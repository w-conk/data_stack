var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _b;
var _c, _QueryStore_query, _QueryStore_values, _QueryStore_exec, _QueryStore_proxied, _QueryStore_originalQuery, _QueryStore_columns, _QueryStore_lengthLoaded, _QueryStore_lengthLoading, _QueryStore_dataLoaded, _QueryStore_dataLoading, _QueryStore_metaLoaded, _QueryStore_metaLoading, _QueryStore_length, _QueryStore_score, _QueryStore_mockResult, _QueryStore_error, _QueryStore_setError, _QueryStore_handleInitialData, _QueryStore_dataFetchPromise, _QueryStore_fetchData, _QueryStore_fetchLength, _QueryStore_fetchMetadata, _QueryStore_calculateScore, _QueryStore_warnHighScore, _QueryStore_subscriptions, _QueryStore_withStoreCache;
import { AbstractStore } from './abstract.store.js';
import { writable } from 'svelte/store';
import { Query, sql, count } from '@uwdata/mosaic-sql';
import { buildId } from './utils/buildId.js';
import { handleMaybePromise } from './utils/handleMaybePromise.js';
import { mutations } from './mutations/index.js';
import { evidenceColumnsToScore, duckdbTypeToEvidenceType
// @ts-expect-error ts can't find the types
 } from '@evidence-dev/universal-sql/calculate-score';
export class QueryStore extends AbstractStore {
    static addActiveQuery(id) {
        _c.activeQueries.update((queries) => queries.add(id));
    }
    static removeActiveQuery(id) {
        _c.activeQueries.update((queries) => (queries.delete(id), queries));
    }
    static isQueryStore(q) {
        if (typeof q === 'object' && q && '__isQueryStore' in q && q.__isQueryStore === true)
            return true;
        return false;
    }
    get proxy() {
        return __classPrivateFieldGet(this, _QueryStore_proxied, "f");
    }
    /** Text of the query represented by this store */
    get text() {
        // TODO: This needs a formatter
        return __classPrivateFieldGet(this, _QueryStore_query, "f").toString();
    }
    get originalText() {
        if (__classPrivateFieldGet(this, _QueryStore_originalQuery, "f") instanceof Query) {
            return __classPrivateFieldGet(this, _QueryStore_originalQuery, "f").toString();
        }
        if (__classPrivateFieldGet(this, _QueryStore_originalQuery, "f") instanceof _c) {
            return __classPrivateFieldGet(this, _QueryStore_originalQuery, "f").text;
        }
        return __classPrivateFieldGet(this, _QueryStore_originalQuery, "f");
    }
    get _evidenceColumnTypes() {
        var _a, _b;
        //@ts-expect-error This implicitly is set on the return value of #exec
        return Array.from((_b = (_a = __classPrivateFieldGet(this, _QueryStore_values, "f")._evidenceColumnTypes) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _QueryStore_columns, "f")) !== null && _b !== void 0 ? _b : []);
    }
    get columns() {
        var _a, _b;
        //@ts-expect-error This implicitly is set on the return value of #exec
        return Array.from((_b = (_a = __classPrivateFieldGet(this, _QueryStore_values, "f")._evidenceColumnTypes) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _QueryStore_columns, "f")) !== null && _b !== void 0 ? _b : []);
    }
    /** Has #fetchData been executed? */
    get loaded() {
        return __classPrivateFieldGet(this, _QueryStore_dataLoaded, "f") && __classPrivateFieldGet(this, _QueryStore_metaLoaded, "f") && __classPrivateFieldGet(this, _QueryStore_lengthLoaded, "f");
    }
    /** Is #fetchData currently running? */
    get loading() {
        return __classPrivateFieldGet(this, _QueryStore_lengthLoading, "f") || __classPrivateFieldGet(this, _QueryStore_dataLoading, "f") || __classPrivateFieldGet(this, _QueryStore_metaLoading, "f");
    }
    get lengthLoaded() {
        return __classPrivateFieldGet(this, _QueryStore_lengthLoaded, "f");
    }
    get lengthLoading() {
        return __classPrivateFieldGet(this, _QueryStore_lengthLoading, "f");
    }
    get dataLoaded() {
        return __classPrivateFieldGet(this, _QueryStore_dataLoaded, "f");
    }
    get dataLoading() {
        return __classPrivateFieldGet(this, _QueryStore_dataLoading, "f");
    }
    get metaLoaded() {
        return __classPrivateFieldGet(this, _QueryStore_metaLoaded, "f");
    }
    get metaLoading() {
        return __classPrivateFieldGet(this, _QueryStore_metaLoading, "f");
    }
    get length() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _QueryStore_length, "f")) !== null && _a !== void 0 ? _a : 0;
    }
    get score() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _QueryStore_score, "f")) !== null && _a !== void 0 ? _a : 0;
    }
    get error() {
        if (__classPrivateFieldGet(this, _QueryStore_error, "f") !== undefined) {
            if (__classPrivateFieldGet(this, _QueryStore_error, "f") instanceof Error)
                return __classPrivateFieldGet(this, _QueryStore_error, "f");
            return new Error('Query encountered an error', { cause: __classPrivateFieldGet(this, _QueryStore_error, "f") });
        }
        return undefined;
    }
    static create(query, exec, id, opts = { disableCache: false }, root) {
        const hash = buildId(query);
        if (!id) {
            id = hash;
        }
        if (!opts.disableCache) {
            const cached = _c.cache.get(hash);
            if (cached)
                return cached;
        }
        const v = new _c(query, exec, id, opts, root);
        _c.cache.set(hash, v);
        return v;
    }
    constructor(query, exec, id, opts = { disableCache: false }, root) {
        super();
        this.opts = opts;
        this.root = root;
        /** Internal Query Builder */
        _QueryStore_query.set(this, new Query());
        /** Currently Held Values */
        _QueryStore_values.set(this, []);
        this.value = () => __classPrivateFieldGet(this, _QueryStore_proxied, "f");
        /** Query Execution Function */
        _QueryStore_exec.set(this, void 0);
        /** Duck Type */
        this.__isQueryStore = true;
        /**
         * A Proxy wrapper around the QueryStore instance.
         * It is used to intercept access to numeric indices and the 'length' property.
         * This Proxy is responsible for triggering data fetching.
         * When any numeric index or the 'length' property is accessed, the Proxy command triggers
         * either the #update() or the #updateLength() function to asynchronously load or update data.
         * Hence, only through this Proxy (i.e., #proxied), can the data fetching and length update
         * process be triggered. Accessing the QueryStore directly does not trigger these functionalities,
         * and hence is not recommended for normal use.
         */
        _QueryStore_proxied.set(this, void 0);
        _QueryStore_originalQuery.set(this, void 0);
        /**
         * Name and Type information about the result columns
         * Note: results._evidenceColumnTypes takes priority
         */
        _QueryStore_columns.set(this, []);
        /** Has #fetchLength been executed? */
        _QueryStore_lengthLoaded.set(this, false);
        /** Is #fetchLength currently running? */
        _QueryStore_lengthLoading.set(this, false);
        /** Has #fetchData been executed? */
        _QueryStore_dataLoaded.set(this, false);
        /** Is #fetchData currently running? */
        _QueryStore_dataLoading.set(this, false);
        /** Has #fetchMetadata been executed? */
        _QueryStore_metaLoaded.set(this, false);
        /** Is #fetchMetadataq currently running? */
        _QueryStore_metaLoading.set(this, false);
        _QueryStore_length.set(this, void 0);
        _QueryStore_score.set(this, void 0);
        /**
         * Svelte bases iteration on the `length` property; so that has to exist before it will try to pass a number
         * However, we don't want to load everything if `length` is accessed - only the data itself.
         * Therefore, there is a tick when the array is full of undefined, because we are still fetching.
         * In that time period, we return this empty object so we don't get `cannot access x of undefined` errors.
         * This may break in instances where the user may have nested arrays / dicts
         */
        _QueryStore_mockResult.set(this, {});
        _QueryStore_error.set(this, void 0);
        _QueryStore_setError.set(this, (e) => {
            var _a;
            if (_c.debug)
                console.debug(`QueryStore ${this.id.substring(0, 6)} | QueryStore encountered a non-fatal error`, e instanceof Error ? (_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e : e);
            __classPrivateFieldSet(this, _QueryStore_error, e, "f");
            if (e) {
                // This needs some testing; might cause a race, but we want to prevent the query from loading anything at this point.
                __classPrivateFieldSet(this, _QueryStore_length, 0, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoaded, false, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoading, false, "f");
            }
            if (this.opts.errorNotifier)
                this.opts.errorNotifier(this.error);
            this.publish();
        });
        _QueryStore_handleInitialData.set(this, () => {
            const { initialData, initialDataDirty, initialError } = this.opts;
            if (initialError) {
                __classPrivateFieldSet(this, _QueryStore_error, initialError, "f");
                return false;
            }
            // Maintain loading state while we wait
            if (initialData && !__classPrivateFieldGet(this, _QueryStore_values, "f").length) {
                __classPrivateFieldSet(this, _QueryStore_dataLoading, true, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoading, true, "f");
                __classPrivateFieldSet(this, _QueryStore_metaLoading, true, "f");
                __classPrivateFieldSet(this, _QueryStore_length, 0, "f");
                this.publish();
                return handleMaybePromise((results) => {
                    if (!results.length) {
                        // if initial data is 0 length; then we should ignore it and go ahead with a fetch
                        __classPrivateFieldSet(this, _QueryStore_lengthLoading, false, "f");
                        __classPrivateFieldSet(this, _QueryStore_dataLoading, false, "f");
                        __classPrivateFieldSet(this, _QueryStore_metaLoading, false, "f");
                        // Don't publish these changes! They should be internal only
                        __classPrivateFieldGet(this, _QueryStore_fetchData, "f").call(this);
                        return false;
                    }
                    __classPrivateFieldSet(this, _QueryStore_values, results, "f");
                    __classPrivateFieldSet(this, _QueryStore_length, results.length, "f");
                    // @ts-expect-error
                    __classPrivateFieldSet(this, _QueryStore_columns, __classPrivateFieldGet(this, _QueryStore_values, "f")._evidenceColumnTypes, "f");
                    __classPrivateFieldSet(this, _QueryStore_dataLoading, false, "f");
                    __classPrivateFieldSet(this, _QueryStore_lengthLoading, false, "f");
                    __classPrivateFieldSet(this, _QueryStore_metaLoading, false, "f");
                    __classPrivateFieldSet(this, _QueryStore_dataLoaded, !initialDataDirty, "f");
                    __classPrivateFieldSet(this, _QueryStore_lengthLoaded, !initialDataDirty, "f");
                    __classPrivateFieldSet(this, _QueryStore_metaLoaded, !initialDataDirty, "f");
                    __classPrivateFieldSet(this, _QueryStore_mockResult, Object.fromEntries(this._evidenceColumnTypes.map((c) => [c.name, null])), "f");
                    __classPrivateFieldGet(this, _QueryStore_calculateScore, "f").call(this);
                    __classPrivateFieldGet(this, _QueryStore_warnHighScore, "f").call(this);
                    this.publish();
                    if (initialDataDirty) {
                        __classPrivateFieldGet(this, _QueryStore_fetchData, "f").call(this);
                        return false;
                    }
                    return true;
                }, () => initialData, (e) => {
                    __classPrivateFieldGet(this, _QueryStore_setError, "f").call(this, e);
                    return false;
                });
            }
            else {
                return false;
            }
        });
        /** Force the QueryStore to fetch data */
        this.fetch = () => __classPrivateFieldGet(this, _QueryStore_fetchData, "f").call(this);
        /**
         * Fetch data in the background,
         * likely meaning `initialData` was provided
         */
        this.backgroundFetch = () => __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(resolve, 0));
            handleMaybePromise(() => { }, () => __classPrivateFieldGet(this, _QueryStore_exec, "f").call(this, `--data\n${__classPrivateFieldGet(this, _QueryStore_query, "f").toString()}`, this.id), () => { });
        });
        /** Keep a copy of the promise so we can wait for loading in multiple places */
        _QueryStore_dataFetchPromise.set(this, void 0);
        _QueryStore_fetchData.set(this, () => {
            if (__classPrivateFieldGet(this, _QueryStore_dataLoading, "f") || __classPrivateFieldGet(this, _QueryStore_dataLoaded, "f")) {
                return __classPrivateFieldGet(this, _QueryStore_dataFetchPromise, "f");
            }
            if (__classPrivateFieldGet(this, _QueryStore_error, "f")) {
                if (_c.debug)
                    console.debug(`QueryStore ${this.id.substring(0, 6)} | Refusing to execute data query; store has an error state.`);
                return __classPrivateFieldGet(this, _QueryStore_dataFetchPromise, "f");
            }
            __classPrivateFieldSet(this, _QueryStore_dataLoading, true, "f");
            this.publish();
            const queryWithComment = `--data\n${__classPrivateFieldGet(this, _QueryStore_query, "f").toString()}`;
            _c.addActiveQuery(this.id);
            __classPrivateFieldSet(this, _QueryStore_dataFetchPromise, handleMaybePromise((result) => {
                __classPrivateFieldSet(this, _QueryStore_values, result, "f");
                __classPrivateFieldSet(this, _QueryStore_dataLoading, false, "f");
                __classPrivateFieldSet(this, _QueryStore_dataLoaded, true, "f");
                _c.removeActiveQuery(this.id);
                return __classPrivateFieldGet(this, _QueryStore_fetchLength, "f").call(this);
            }, () => __classPrivateFieldGet(this, _QueryStore_exec, "f").call(this, queryWithComment, this.id), (err) => {
                __classPrivateFieldGet(this, _QueryStore_setError, "f").call(this, err);
                _c.removeActiveQuery(this.id);
            }), "f");
            return __classPrivateFieldGet(this, _QueryStore_dataFetchPromise, "f");
        });
        _QueryStore_fetchLength.set(this, () => {
            if (__classPrivateFieldGet(this, _QueryStore_lengthLoading, "f") || __classPrivateFieldGet(this, _QueryStore_lengthLoaded, "f")) {
                return;
            }
            if (__classPrivateFieldGet(this, _QueryStore_error, "f")) {
                if (_c.debug)
                    console.debug(`QueryStore ${this.id.substring(0, 6)} | Refusing to execute length query; store has an error state.`);
                return;
            }
            // No need to run the length query if we already have the values available
            if (!__classPrivateFieldGet(this, _QueryStore_values, "f").length && __classPrivateFieldGet(this, _QueryStore_dataLoaded, "f")) {
                __classPrivateFieldSet(this, _QueryStore_length, __classPrivateFieldGet(this, _QueryStore_values, "f").length, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoaded, true, "f");
                __classPrivateFieldGet(this, _QueryStore_calculateScore, "f").call(this);
                __classPrivateFieldGet(this, _QueryStore_warnHighScore, "f").call(this);
                this.publish();
                return;
            }
            __classPrivateFieldSet(this, _QueryStore_lengthLoading, true, "f");
            this.publish();
            const countQuery = new Query()
                .with({ original: __classPrivateFieldGet(this, _QueryStore_query, "f") })
                .select({ length: count('*') })
                .from('original');
            const queryWithComment = `--len\n${countQuery}`;
            return handleMaybePromise((result) => {
                const [row] = result;
                __classPrivateFieldSet(this, _QueryStore_length, row.length, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoaded, true, "f");
                __classPrivateFieldSet(this, _QueryStore_lengthLoading, false, "f");
                __classPrivateFieldGet(this, _QueryStore_calculateScore, "f").call(this);
                __classPrivateFieldGet(this, _QueryStore_warnHighScore, "f").call(this);
                this.publish();
            }, () => __classPrivateFieldGet(this, _QueryStore_exec, "f").call(this, queryWithComment, `${this.id}_length`), __classPrivateFieldGet(this, _QueryStore_setError, "f"));
        });
        _QueryStore_fetchMetadata.set(this, () => {
            if (__classPrivateFieldGet(this, _QueryStore_error, "f")) {
                if (_c.debug)
                    console.debug(`QueryStore ${this.id.substring(0, 6)} | Refusing to execute metadata query; store has an error state.`);
                return;
            }
            if (__classPrivateFieldGet(this, _QueryStore_metaLoaded, "f"))
                return;
            __classPrivateFieldSet(this, _QueryStore_metaLoading, true, "f");
            this.publish();
            return handleMaybePromise((queryResult) => {
                __classPrivateFieldSet(this, _QueryStore_columns, queryResult.map((c) => ({
                    name: c.column_name,
                    evidenceType: duckdbTypeToEvidenceType(c.column_type),
                    typeFidelity: 'precise'
                })), "f");
                __classPrivateFieldSet(this, _QueryStore_mockResult, Object.fromEntries(this._evidenceColumnTypes.map((c) => [c.name, null])), "f");
                if (this._evidenceColumnTypes.length > 0) {
                    __classPrivateFieldSet(this, _QueryStore_metaLoading, false, "f");
                    __classPrivateFieldSet(this, _QueryStore_metaLoaded, true, "f");
                    __classPrivateFieldGet(this, _QueryStore_calculateScore, "f").call(this);
                    __classPrivateFieldGet(this, _QueryStore_warnHighScore, "f").call(this);
                }
                this.publish();
            }, () => __classPrivateFieldGet(this, _QueryStore_exec, "f").call(this, `--col-metadata\nDESCRIBE ${__classPrivateFieldGet(this, _QueryStore_query, "f").toString()}`, `${this.id}_metadata`), __classPrivateFieldGet(this, _QueryStore_setError, "f"));
        });
        _QueryStore_calculateScore.set(this, () => {
            const column_score = evidenceColumnsToScore(this._evidenceColumnTypes);
            __classPrivateFieldSet(this, _QueryStore_score, column_score * this.length, "f");
        });
        _QueryStore_warnHighScore.set(this, () => {
            if (!this.opts.scoreNotifier)
                return;
            if (this.score < 10 * 1024 * 1024)
                return;
            this.opts.scoreNotifier({ id: this.id, query: __classPrivateFieldGet(this, _QueryStore_query, "f").toString(), score: this.score });
        });
        /**
         * Array of child ids that the store is currently subscribed to.
         * @todo: need to clean up subscriptions if/when stores are gc'd
         */
        _QueryStore_subscriptions.set(this, []);
        /**
         * Wraps an derivation function with memoization provided by {@link QueryStore.cache}
         */
        _QueryStore_withStoreCache.set(this, (aggKey, aggFunc, passCurrentAsInitial = false) => {
            return (...args) => {
                var _a, _b;
                // Build a unique ID for the target child store
                const newQuery = aggFunc(__classPrivateFieldGet(this, _QueryStore_query, "f").clone(), ...args);
                const hash = buildId(newQuery.toString());
                // If there is a root; subscription operations will function against that
                // If there isn't; then this is a root
                const subscriber = (_a = this.root) !== null && _a !== void 0 ? _a : this;
                // If caching is enabled and the id exists in the cache
                if (!this.opts.disableCache && _c.cache.has(hash)) {
                    // Use the cache
                    const cachedQuery = _c.cache.get(hash);
                    if (!cachedQuery)
                        throw new Error('Error getting query from cache. This should not occur.');
                    if (!__classPrivateFieldGet(subscriber, _QueryStore_subscriptions, "f").includes(hash)) {
                        cachedQuery.subscribe(subscriber.publish);
                        __classPrivateFieldGet(subscriber, _QueryStore_subscriptions, "f").push(hash);
                    }
                    return __classPrivateFieldGet(cachedQuery, _QueryStore_proxied, "f");
                }
                // Construct a new store, subscribe and cache it
                const newStore = new _c(newQuery, __classPrivateFieldGet(this, _QueryStore_exec, "f"), hash, Object.assign(Object.assign({}, this.opts), { initialData: passCurrentAsInitial ? __classPrivateFieldGet(this, _QueryStore_values, "f") : undefined, initialDataDirty: true }), (_b = this.root) !== null && _b !== void 0 ? _b : this);
                __classPrivateFieldGet(subscriber, _QueryStore_subscriptions, "f").push(hash);
                newStore.subscribe(subscriber.publish);
                _c.cache.set(hash, newStore);
                return __classPrivateFieldGet(newStore, _QueryStore_proxied, "f");
            };
        });
        this.where = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'where', mutations.where.fn, mutations.where.currentAsInitial);
        this.groupBy = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'groupBy', mutations.groupBy.fn, mutations.groupBy.currentAsInitial);
        this.agg = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'agg', mutations.agg.fn, mutations.agg.currentAsInitial);
        this.orderBy = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'orderBy', mutations.orderBy.fn, mutations.orderBy.currentAsInitial);
        this.limit = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'limit', mutations.limit.fn, mutations.limit.currentAsInitial);
        this.offset = __classPrivateFieldGet(this, _QueryStore_withStoreCache, "f").call(this, 'offset', mutations.offset.fn, mutations.offset.currentAsInitial);
        Object.freeze(opts);
        // Ensure an ID Exists
        this.hash = buildId(query);
        this.id = id !== null && id !== void 0 ? id : this.hash;
        // TODO: Strip any trailing ; from queries
        // This is hard because of comments
        // We might want to just error out if the querystring contains a ; for simplicity
        __classPrivateFieldSet(this, _QueryStore_originalQuery, query, "f");
        if (typeof query === 'string') {
            __classPrivateFieldGet(this, _QueryStore_query, "f").from({ __userQuery: sql `(${query})` }).select('*');
        }
        else
            __classPrivateFieldSet(this, _QueryStore_query, query, "f");
        __classPrivateFieldSet(this, _QueryStore_exec, (...args) => exec(args[0], args[1]), "f");
        __classPrivateFieldSet(this, _QueryStore_proxied, new Proxy(this, {
            get: (self, _prop) => {
                // Intercept numeric indices. This implies we're trying to access rows (data) in the store.
                // If the data has not been loaded, initiate the async #update method to fetch the data.
                let prop = _prop;
                if (typeof prop === 'string' && /^[\d.]+$/.exec(prop))
                    prop = parseInt(prop);
                if (typeof prop === 'number') {
                    if (!__classPrivateFieldGet(self, _QueryStore_dataLoaded, "f")) {
                        try {
                            const r = __classPrivateFieldGet(self, _QueryStore_fetchData, "f").call(self);
                            if (r instanceof Promise)
                                r.catch((e) => {
                                    throw new Error('Failed to update query store', { cause: e });
                                });
                        }
                        catch (e) {
                            throw new Error('Failed to update query store', { cause: e });
                        }
                    }
                    if (!__classPrivateFieldGet(self, _QueryStore_values, "f")[prop])
                        return __classPrivateFieldGet(self, _QueryStore_mockResult, "f");
                    return __classPrivateFieldGet(self, _QueryStore_values, "f")[prop];
                }
                if (prop === 'at') {
                    // at is a special case, because it should behave like Store[number]
                    if (!__classPrivateFieldGet(self, _QueryStore_dataLoaded, "f")) {
                        try {
                            const r = __classPrivateFieldGet(self, _QueryStore_fetchData, "f").call(self);
                            if (r instanceof Promise)
                                r.catch((e) => {
                                    throw new Error('Failed to update query store', { cause: e });
                                });
                        }
                        catch (e) {
                            throw new Error('Failed to update query store', { cause: e });
                        }
                    }
                    return (i) => {
                        var _a;
                        if (__classPrivateFieldGet(this, _QueryStore_dataLoaded, "f")) {
                            return __classPrivateFieldGet(this, _QueryStore_values, "f").at(i);
                        }
                        else {
                            return (_a = __classPrivateFieldGet(this, _QueryStore_values, "f").at(i)) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _QueryStore_mockResult, "f"); // We are still mocking
                        }
                    };
                }
                // Intercept 'length' property. This implies we're trying to get the total number of rows (data) in the store.
                // If the length has not been correctly updated, initiate the async #updateLength method to calculate it.
                else if (prop === 'length' && !__classPrivateFieldGet(self, _QueryStore_lengthLoaded, "f")) {
                    try {
                        const r = __classPrivateFieldGet(self, _QueryStore_fetchLength, "f").call(self);
                        if (r instanceof Promise)
                            r.catch((e) => {
                                throw new Error('Failed to update query store length', { cause: e });
                            });
                    }
                    catch (e) {
                        throw new Error('Failed to update query store length', { cause: e });
                    }
                }
                if (prop in self) {
                    // @ts-expect-error Typescript gets mad about this for some reason
                    if (typeof self[prop] === 'function')
                        return self[prop].bind(self);
                    // @ts-expect-error Typescript gets mad about this for some reason
                    return self[prop];
                }
                // TODO: Should we handle things that mutate the data like pop, push, etc
                // @ts-expect-error Typescript gets mad about accessing non-numeric keys of an array dynamically (e.g. pop, push)
                if (typeof __classPrivateFieldGet(self, _QueryStore_values, "f")[prop] === 'function') {
                    // @ts-expect-error Typescript gets mad about accessing non-numeric keys of an array dynamically (e.g. pop, push)
                    return __classPrivateFieldGet(self, _QueryStore_values, "f")[prop].bind(__classPrivateFieldGet(self, _QueryStore_values, "f"));
                }
                // @ts-expect-error Typescript gets mad about accessing non-numeric keys of an array dynamically (e.g. pop, push)
                return __classPrivateFieldGet(self, _QueryStore_values, "f")[prop];
            }
        }), "f");
        if (opts.noResolve && !opts.initialData) {
            __classPrivateFieldSet(this, _QueryStore_dataLoading, true, "f");
            __classPrivateFieldSet(this, _QueryStore_metaLoading, true, "f");
            __classPrivateFieldSet(this, _QueryStore_lengthLoading, true, "f");
            __classPrivateFieldSet(this, _QueryStore_dataLoaded, false, "f");
            __classPrivateFieldSet(this, _QueryStore_metaLoaded, false, "f");
            __classPrivateFieldSet(this, _QueryStore_lengthLoaded, false, "f");
            this.publish();
        }
        else {
            handleMaybePromise((alreadyFetchedMeta) => {
                if (!alreadyFetchedMeta)
                    __classPrivateFieldGet(this, _QueryStore_fetchMetadata, "f").call(this);
            }, () => __classPrivateFieldGet(this, _QueryStore_handleInitialData, "f").call(this), __classPrivateFieldGet(this, _QueryStore_setError, "f"));
            // prerender
            if (typeof window === 'undefined' && !this.loaded)
                __classPrivateFieldGet(this, _QueryStore_fetchData, "f").call(this);
        }
    }
    static emptyCache() {
        _c.cache.clear();
    }
}
_c = QueryStore, _QueryStore_query = new WeakMap(), _QueryStore_values = new WeakMap(), _QueryStore_exec = new WeakMap(), _QueryStore_proxied = new WeakMap(), _QueryStore_originalQuery = new WeakMap(), _QueryStore_columns = new WeakMap(), _QueryStore_lengthLoaded = new WeakMap(), _QueryStore_lengthLoading = new WeakMap(), _QueryStore_dataLoaded = new WeakMap(), _QueryStore_dataLoading = new WeakMap(), _QueryStore_metaLoaded = new WeakMap(), _QueryStore_metaLoading = new WeakMap(), _QueryStore_length = new WeakMap(), _QueryStore_score = new WeakMap(), _QueryStore_mockResult = new WeakMap(), _QueryStore_error = new WeakMap(), _QueryStore_setError = new WeakMap(), _QueryStore_handleInitialData = new WeakMap(), _QueryStore_dataFetchPromise = new WeakMap(), _QueryStore_fetchData = new WeakMap(), _QueryStore_fetchLength = new WeakMap(), _QueryStore_fetchMetadata = new WeakMap(), _QueryStore_calculateScore = new WeakMap(), _QueryStore_warnHighScore = new WeakMap(), _QueryStore_subscriptions = new WeakMap(), _QueryStore_withStoreCache = new WeakMap();
QueryStore.activeQueries = writable(new Set());
QueryStore.debug = Boolean(typeof window === 'undefined'
    ? process.env.VITE_EVIDENCE_DEBUG
    : // @ts-expect-error
        (_b = (_a = import.meta) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.VITE_EVIDENCE_DEBUG);
/////////
// Builder Methods
/////////
/**
 * Shared cache of existing QueryStores to reduce the number of stores initialized
 */
QueryStore.cache = new Map();
//# sourceMappingURL=QueryStore.js.map