import { AbstractStore } from './abstract.store.js';
import type { ColumnMetadata, QueryResult, QueryStoreOpts, QueryStoreValue, Runner } from './types.js';
import { Query } from '@uwdata/mosaic-sql';
export declare class QueryStore extends AbstractStore<QueryStoreValue> {
    #private;
    private readonly opts;
    private readonly root?;
    /** Indicate that QueryStore is readable like an array */
    [index: number]: QueryResult;
    static activeQueries: import("svelte/store").Writable<Set<string>>;
    static addActiveQuery(id: string): void;
    static removeActiveQuery(id: string): void;
    value: () => QueryStoreValue;
    /** Duck Type */
    readonly __isQueryStore = true;
    static isQueryStore(q: unknown): q is QueryStore;
    private static readonly debug;
    get proxy(): QueryStoreValue;
    /** Text of the query represented by this store */
    get text(): string;
    get originalText(): string;
    get _evidenceColumnTypes(): ColumnMetadata[];
    get columns(): ColumnMetadata[];
    /** Has #fetchData been executed? */
    get loaded(): boolean;
    /** Is #fetchData currently running? */
    get loading(): boolean;
    get lengthLoaded(): boolean;
    get lengthLoading(): boolean;
    get dataLoaded(): boolean;
    get dataLoading(): boolean;
    get metaLoaded(): boolean;
    get metaLoading(): boolean;
    get length(): number;
    get score(): number;
    readonly id: string;
    readonly hash: string;
    get error(): Error | undefined;
    static create(query: string | Query, exec: Runner, id?: string, opts?: QueryStoreOpts, root?: QueryStore): QueryStore;
    private constructor();
    /** Force the QueryStore to fetch data */
    fetch: () => unknown;
    /**
     * Fetch data in the background,
     * likely meaning `initialData` was provided
     */
    backgroundFetch: () => Promise<void>;
    /**
     * Shared cache of existing QueryStores to reduce the number of stores initialized
     */
    private static cache;
    static emptyCache(): void;
    where: (...args: unknown[]) => QueryStoreValue;
    groupBy: (...args: unknown[]) => QueryStoreValue;
    agg: (...args: unknown[]) => QueryStoreValue;
    orderBy: (...args: unknown[]) => QueryStoreValue;
    limit: (...args: unknown[]) => QueryStoreValue;
    offset: (...args: unknown[]) => QueryStoreValue;
}
//# sourceMappingURL=QueryStore.d.ts.map