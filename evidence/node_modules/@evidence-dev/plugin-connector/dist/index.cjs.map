{"mappings":"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","sources":["packages/plugin-connector/src/index.js","packages/plugin-connector/src/build-plugins/preprocess.js","packages/plugin-connector/src/component-resolution/get-plugin-components.js","packages/plugin-connector/src/plugin-discovery/index.js","packages/plugin-connector/src/plugin-discovery/get-root-modules.js","packages/plugin-connector/src/plugin-discovery/resolve-evidence-config.js","packages/plugin-connector/src/plugin-discovery/is-valid-package.js","packages/plugin-connector/src/plugin-discovery/schemas/evidence-package.schema.js","packages/plugin-connector/src/lib/clean-zod-errors.js","packages/plugin-connector/src/plugin-discovery/load-config.js","packages/plugin-connector/src/plugin-discovery/schemas/evidence-config.schema.js","packages/plugin-connector/src/component-resolution/get-components-for-package.js","packages/plugin-connector/src/component-resolution/loaders/manifest-loader.js","packages/plugin-connector/src/component-resolution/schemas/component-manifest.schema.js","packages/plugin-connector/src/component-resolution/loaders/file-loader.js","packages/plugin-connector/src/build-plugins/rollup.js","packages/plugin-connector/src/build-plugins/vite.js","packages/plugin-connector/src/build-plugins/query-directory-hmr.js","packages/plugin-connector/src/build-plugins/source-query-hmr.js","packages/plugin-connector/src/data-sources/index.js","packages/plugin-connector/src/data-sources/get-sources.js","packages/plugin-connector/src/data-sources/schemas/datasource-spec.schema.js","packages/plugin-connector/src/data-sources/schemas/query-runner.schema.js","packages/plugin-connector/src/lib/b64-deep.js","packages/plugin-connector/src/data-sources/build-sources.js","packages/plugin-connector/src/data-sources/get-datasource-plugins.js","packages/plugin-connector/src/data-sources/build-connector.js","packages/plugin-connector/src/data-sources/sub-source-vars.js","packages/plugin-connector/src/data-sources/update-datasource-options.js","packages/plugin-connector/src/lib/processing-queue.js"],"sourcesContent":["export * from './build-plugins/preprocess';\nexport * from './build-plugins/rollup';\nexport * from './build-plugins/vite';\nexport * from './data-sources';\nexport * from './lib/clean-zod-errors';\n","import { getPluginComponents } from '../component-resolution/get-plugin-components';\nimport autoImport from 'sveltekit-autoimport';\n\n/**\n * @type {() => import(\"svelte/types/compiler/preprocess\").PreprocessorGroup}\n */\nexport const evidencePlugins = () => {\n\tconst componentPlugins = getPluginComponents();\n\n\tconst packages = componentPlugins\n\t\t.then((components) => {\n\t\t\t/** @type {Record<string,string[]>} */\n\t\t\tconst packages = {};\n\t\t\tfor (const [component, data] of Object.entries(components)) {\n\t\t\t\tif (!packages[data.package]) packages[data.package] = [];\n\t\t\t\tconst import_name = data.aliasOf ? `${data.aliasOf} as ${component}` : component;\n\t\t\t\tpackages[data.package].push(import_name);\n\t\t\t}\n\t\t\treturn packages;\n\t\t})\n\t\t.catch(() => ({}));\n\n\tconst autoImporter = packages.then((packages) =>\n\t\tautoImport({\n\t\t\tinclude: ['**/*.(svelte|md)'],\n\t\t\tmodule: packages,\n\t\t\tcomponents: [{ directory: '../../components', flat: true }]\n\t\t})\n\t);\n\n\treturn {\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").MarkupPreprocessor}} */\n\t\tmarkup: async ({ content, filename }) => {\n\t\t\tconst components = await componentPlugins.catch(() => false);\n\t\t\tif (!components) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { markup: autoimport_process_markup } = await autoImporter;\n\n\t\t\treturn autoimport_process_markup({ content, filename });\n\t\t},\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").Preprocessor}} */\n\t\tstyle: async () => {},\n\t\t/** @type {import(\"svelte/types/compiler/preprocess\").Preprocessor}} */\n\t\tscript: async () => {}\n\t};\n};\n","import { discoverEvidencePlugins } from '../plugin-discovery';\nimport { getComponentsForPackage } from './get-components-for-package';\nimport { loadConfig } from '../plugin-discovery/load-config';\nimport { getRootModules } from '../plugin-discovery/get-root-modules';\nimport chalk from 'chalk';\nimport { findSvelteComponents } from './loaders/file-loader';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * @param {EvidenceConfig} [cfg]\n * @param {PackageDiscoveryResult} [discoveries] Optional: Pass in already discovered plugins\n * @returns {Promise<PluginComponents>}\n */\nexport async function getPluginComponents(cfg, discoveries) {\n\tconst rootDir = await getRootModules();\n\n\tconst config = cfg ?? (await loadConfig(rootDir));\n\n\tconst pluginDiscoveries = discoveries ?? (await discoverEvidencePlugins());\n\n\tObject.values(config.components).reduce(\n\t\t/**\n\t\t * @param {Set<string>} acc\n\t\t * @param {EvidenceComponentConfig} v\n\t\t */\n\t\t(acc, v) => {\n\t\t\tfor (const override of v.overrides) {\n\t\t\t\tif (acc.has(override)) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\tchalk.red(\n\t\t\t\t\t\t\t`[!] ${override} is overriden more than once. Please ensure that a component is overriden only once.`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error('Invalid evidence.plugins.yaml');\n\t\t\t\t}\n\t\t\t\tacc.add(override);\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\tnew Set()\n\t);\n\n\t// Load all the components\n\tconst components = await Promise.all(\n\t\tpluginDiscoveries.components.map(\n\t\t\t/**\n\t\t\t * @param {EvidencePluginPackage<ValidPackage>} pluginPackage\n\t\t\t * @returns {Promise<[string, Set<string>]>}\n\t\t\t */\n\t\t\tasync (pluginPackage) => [\n\t\t\t\tpluginPackage.package.name,\n\t\t\t\tawait getComponentsForPackage(\n\t\t\t\t\trootDir,\n\t\t\t\t\tpluginPackage.path,\n\t\t\t\t\tconfig.components[pluginPackage.package.name]\n\t\t\t\t)\n\t\t\t]\n\t\t)\n\t);\n\n\t// Now we will smush all of this into Record<ComponentName, PackageName>\n\tconst componentMap = components.reduce(\n\t\t/**\n\t\t * @param {PluginComponents} acc\n\t\t * @param {[string, Set<string>]} p\n\t\t */\n\t\t(acc, [packageName, components]) => {\n\t\t\t/** @type {EvidenceComponentConfig} */\n\t\t\tconst packageConfig = config.components[packageName];\n\t\t\tfor (const component of components) {\n\t\t\t\t/** @type {PluginComponent} */\n\t\t\t\tconst componentObj = { package: packageName };\n\n\t\t\t\tconst alias = packageConfig.aliases[component];\n\n\t\t\t\tif (alias) {\n\t\t\t\t\tcomponentObj.aliasOf = component;\n\t\t\t\t}\n\n\t\t\t\tconst componentOutputName = alias ?? component;\n\n\t\t\t\tif (acc[componentOutputName] && !packageConfig.overrides.includes(componentOutputName)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t\t`[!] ${packageName} and ${acc[componentOutputName].package} both provide ${componentOutputName}. ${acc[componentOutputName].package} will be used, to use ${packageName}, specify an alias or explicit override. (https://docs.evidence.dev/plugins#component-aliases)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn acc;\n\t\t\t\t}\n\n\t\t\t\tif (packageConfig.overrides?.includes(componentOutputName)) {\n\t\t\t\t\tif (!acc[componentOutputName]) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t\t\t`[!] ${packageName} cannot override it's own component ${componentOutputName}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponentObj.overriden = {\n\t\t\t\t\t\t\tpackage: acc[componentOutputName].package\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tacc[componentOutputName] = componentObj;\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\t{}\n\t);\n\n\tif (fs.existsSync(`${rootDir}/components`)) {\n\t\tconst user_components = await findSvelteComponents(`${rootDir}/components`);\n\t\tfor (const component_file of user_components) {\n\t\t\tconst component = path.basename(component_file, '.svelte');\n\t\t\tif (componentMap[component]) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\tchalk.yellow(\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t`${chalk.bold(\n\t\t\t\t\t\t\t\t`[!] The components folder and ${componentMap[component].package} both provide ${component}`\n\t\t\t\t\t\t\t)}.`,\n\t\t\t\t\t\t\t'The component from the components folder will be used.',\n\t\t\t\t\t\t\t`To use the component from ${componentMap[component].package}, specify an alias (https://docs.evidence.dev/plugins/using-plugins/#component-aliases) or explicitly import the component.`\n\t\t\t\t\t\t].join('\\n\\t')\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tdelete componentMap[component];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn componentMap;\n}\n","import { getRootModules } from './get-root-modules';\nimport { resolveEvidencePackages } from './resolve-evidence-config';\n\n/**\n * @param {string} [rootDir]\n * @returns {Promise<PackageDiscoveryResult>}\n * @this {void}\n */\nexport async function discoverEvidencePlugins(rootDir) {\n\tif (!rootDir) rootDir = await getRootModules();\n\n\treturn await resolveEvidencePackages(rootDir);\n}\n","import path from 'path';\nimport fs from 'fs/promises';\n\n/**\n * @param {string} p\n * @returns {Promise<boolean>}\n */\nconst hasNodeModules = async (p) => {\n\tconst directoryItems = await fs.readdir(p);\n\treturn directoryItems.includes('node_modules');\n};\n\n/**\n * Attempts to find the highest, project-scoped node_modules filepath.\n * Note that this behavior _should_ remain the same regardless of where this is run from\n * Locally installed (\"linked\") packages and regularly installed packages should return the same value.\n * @param {string | undefined} [startingPoint]\n * @returns {Promise<string>}\n */\nexport const getRootModules = async (startingPoint) => {\n\t// Either use the entry file or a specific startingPoint\n\tconst entryFile = startingPoint ?? process.cwd();\n\t// Split the entryfile path on \"node_modules\", this will help if the main file is nested\n\t// e.g. if sveltekit, main file will be node_modules/@sveltejs/kit/node_modules\n\t// node_modules/.pnpm/vite@4.0.4/node_modules/vite/bin/vite.js\n\tconst parsedPath = path.parse(entryFile.split('/node_modules')[0]);\n\tlet p = `${parsedPath.dir}/${parsedPath.base}`;\n\tconst initP = p;\n\tconst stat = await fs.stat(p);\n\tif (stat.isFile()) p = path.parse(p).dir;\n\n\twhile (!(await hasNodeModules(p))) {\n\t\tif (p === path.parse(p).root) {\n\t\t\tthrow new Error(`Could not locate node_modules! ${JSON.stringify({ startingPoint, initP })}`);\n\t\t}\n\t\tp = path.parse(p).dir;\n\t}\n\n\treturn p;\n};\n","import { isValidPackage } from './is-valid-package';\nimport path from 'path';\nimport { loadConfig } from './load-config';\n/**\n * Wrapper function to create a package validator function\n * @param {string} rootDir\n * @returns {(packageName: string) => Promise<EvidencePluginPackage<ValidPackage> | false>}\n */\nconst validatePlugin =\n\t(rootDir) =>\n\t/**\n\t * Validates that the given package name exists and is a valid plugin package\n\t * @param {string} packageName\n\t * @returns {Promise<EvidencePluginPackage<ValidPackage> | false>}\n\t */\n\tasync (packageName) => {\n\t\tconst packagePath = path.resolve(rootDir, 'node_modules', packageName);\n\t\tconst validPackage = await isValidPackage(packagePath);\n\t\tif (!validPackage) return false;\n\t\treturn {\n\t\t\tpackage: validPackage,\n\t\t\tpath: packagePath\n\t\t};\n\t};\n\n/**\n * Leverages evidence.plugins.yaml to resolve plugins\n * @param {string} rootDir\n * @returns {Promise<PackageDiscoveryResult>}\n */\nexport const resolveEvidencePackages = async (rootDir) => {\n\t/** @type {EvidenceConfig} */\n\tconst configContent = loadConfig(rootDir);\n\n\t/** @type {EvidencePluginPackage<ValidPackage>[]} */\n\tconst componentPackages = await Promise.all(\n\t\tObject.keys(configContent.components).map(validatePlugin(rootDir))\n\t).then((pack) => /** @type {Exclude<typeof pack[number], false>[]} */ (pack.filter(Boolean)));\n\n\t/** @type {EvidencePluginPackage<EvidenceDatasourcePackage>[]} */\n\tconst datasourcePackages = await Promise.all(\n\t\tObject.keys(configContent.datasources).map(validatePlugin(rootDir))\n\t).then(\n\t\t(pack) =>\n\t\t\t/** @type {EvidencePluginPackage<EvidenceDatasourcePackage>[]} */\n\t\t\t(pack.filter((p) => p && Boolean(p.package.evidence?.datasources)))\n\t);\n\n\treturn {\n\t\tcomponents: componentPackages,\n\t\tdatasources: datasourcePackages\n\t};\n};\n","import chalk from 'chalk';\nimport { ValidPackageSchema } from './schemas/evidence-package.schema';\nimport fs from 'fs/promises';\nimport { cleanZodErrors } from '../lib/clean-zod-errors';\n/**\n * Checks a directory to see if it is a package\n * and if it is a package, if it includes\n * the evidence block that marks it as a plugin\n * @param {string} path\n * @returns {Promise<false | ValidPackage>}\n */\nexport const isValidPackage = async (path) => {\n\ttry {\n\t\tconst s = await fs.stat(path);\n\t\tif (!s.isDirectory()) return false;\n\t} catch (e) {\n\t\tif (e instanceof Error && /** @type{NodeJS.ErrnoException} */ (e).code !== 'ENOENT') {\n\t\t\tconsole.warn(\n\t\t\t\tchalk.yellow(\n\t\t\t\t\t`[!] An error occured while loading ${chalk.bold(\n\t\t\t\t\t\t`\"${path.split('node_modules/')[1]}\"`\n\t\t\t\t\t)}: ${e}.`\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\tchalk.yellow(\n\t\t\t\t\t`[!] ${chalk.bold(\n\t\t\t\t\t\t`\"${path.split('node_modules/')[1]}\"`\n\t\t\t\t\t)} could not be found in your node_modules. Check for spelling errors or try running npm install.`\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tconst c = await fs.readdir(path);\n\tif (!c.includes('package.json')) return false;\n\n\tconst packageContent = await fs.readFile(`${path}/package.json`).then(\n\t\t/** @param {Buffer} fileContent */\n\t\t(fileContent) => JSON.parse(fileContent.toString())\n\t);\n\tconst zodResult = ValidPackageSchema.safeParse(packageContent);\n\tif (zodResult.success) return zodResult.data;\n\telse {\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${chalk.bold(`\"${path.split('node_modules/')[1]}\"`)} could not be loaded as a plugin`\n\t\t\t)\n\t\t);\n\t\tconsole.warn(cleanZodErrors(zodResult.error.format()));\n\t\treturn false;\n\t}\n};\n","import { z } from 'zod';\n\nconst PackageExportSchema = z.union([\n\tz.object({ main: z.string() }, { description: 'Use the main field of the package.json' }),\n\tz.object(\n\t\t{ exports: z.object({ '.': z.string() }) },\n\t\t{ description: 'Use the exports field of the package.json' }\n\t),\n\tz\n\t\t.object({ svelte: z.string() }, { description: 'Use the svelte field of the package.json' })\n\t\t.optional()\n]);\n\nconst BasePackageSchema = z.object({\n\tname: z.string(),\n\tevidence: z.undefined()\n});\n\nexport const GenericPackageSchema = z.intersection(BasePackageSchema, PackageExportSchema);\n\nexport const EvidencePackageSchema = z.intersection(\n\tBasePackageSchema.extend({\n\t\tevidence: z.object({\n\t\t\tcomponents: z.boolean().optional(),\n\t\t\tdatasources: z.array(z.union([z.string(), z.array(z.string())])).optional(),\n\t\t\ticon: z.string().optional()\n\t\t})\n\t}),\n\tPackageExportSchema\n);\n\nexport const ValidPackageSchema = z.union([GenericPackageSchema, EvidencePackageSchema]);\n","/**\n * Renames the '_errors' property to 'errors' in the given object and its nested objects recursively.\n * It also removes any empty errors arrays\n *\n * @param {any} obj - The object to rename the '_errors' property in.\n * @return {Object} The object with the renamed property.\n */\nexport function cleanZodErrors(obj) {\n\tfor (const key in obj) {\n\t\tif (typeof obj[key] === 'object') {\n\t\t\tcleanZodErrors(obj[key]); // recursively traverse nested objects\n\t\t}\n\t\tif (key === '_errors') {\n\t\t\tif (obj['_errors'].length) {\n\t\t\t\t// De-duplicate\n\t\t\t\tobj['errors'] = Array.from(new Set(obj['_errors']));\n\t\t\t}\n\t\t\tdelete obj['_errors'];\n\t\t}\n\t}\n\treturn obj;\n}\n","import { cleanZodErrors } from '../lib/clean-zod-errors';\nimport chalk from 'chalk';\nimport fs from 'fs';\nimport yaml from 'yaml';\nimport { EvidenceConfigSchema } from './schemas/evidence-config.schema';\n\n/**\n * @param {string} rootDir\n * @returns {EvidenceConfig}\n */\nexport const loadConfig = (rootDir) => {\n\tconst configPath = `${rootDir}/evidence.plugins.yaml`;\n\ttry {\n\t\tconst configFileContent = fs.readFileSync(configPath, 'utf8').toString();\n\t\t// Surround all YAML key that begin with \"@\" in quotes\n\t\t// Skipping keys that are already quoted (e.g. beginning of line or whitespace)\n\t\tconst rawConfig = yaml.parse(configFileContent.replaceAll(/($|\\s)(@.+):/g, '$1\"$2\":'));\n\n\t\tconst configResult = EvidenceConfigSchema.safeParse(rawConfig);\n\t\tif (!configResult.success) {\n\t\t\tconsole.error(\n\t\t\t\tchalk.bold.red(\n\t\t\t\t\t`[!] evidence.plugins.yaml does not contain a valid configuration. \\n    Plugins will not be loaded. This may lead to unexpected behavior.`\n\t\t\t\t)\n\t\t\t);\n\t\t\tconst formattedError = cleanZodErrors(configResult.error.format());\n\t\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\t\tconst redPipe = chalk.red('|');\n\t\t\tconsole.error(\n\t\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t\t);\n\t\t\tthrow new Error('Invalid evidence.plugins.yaml');\n\t\t}\n\n\t\treturn configResult.data;\n\t} catch (e) {\n\t\tif (!(e instanceof Error)) throw e;\n\t\tif (e.message.startsWith('ENOENT')) {\n\t\t\tthrow new Error(`Could not find evidence plugins file. (Look at ${configPath})`, {\n\t\t\t\tcause: e\n\t\t\t});\n\t\t}\n\t\tthrow e;\n\t}\n};\n","import { z } from 'zod';\n\nexport const EvidenceComponentConfigSchema = z.object({\n\toverrides: z.array(z.string()).default([]),\n\taliases: z\n\t\t.record(\n\t\t\tz.string({ description: 'Component Name' }),\n\t\t\tz.string({ description: 'Alias to apply' })\n\t\t)\n\t\t.default({}),\n\n\tprovides: z.array(z.string()).default([])\n});\n\nexport const EvidenceDatasourceConfigSchema = z.object({\n\toverrides: z.array(z.string()).default([])\n});\n\nexport const EvidenceConfigSchema = z\n\t.object({\n\t\tcomponents: z.record(z.string(), EvidenceComponentConfigSchema),\n\t\tdatasources: z\n\t\t\t.record(z.string({ description: 'Plugin Package Name' }), EvidenceDatasourceConfigSchema)\n\t\t\t.default({})\n\t})\n\t.nonstrict();\n","import fs from 'fs/promises';\nimport chalk from 'chalk';\nimport path from 'path';\nimport { isValidPackage } from '../plugin-discovery/is-valid-package';\nimport { manifestLoader } from './loaders/manifest-loader';\nimport { fileLoader } from './loaders/file-loader';\n\n/**\n * Loads components from a package, given a root directory, package name, and configuration.\n *\n * @param {string} rootDir - The root directory for the package.\n * @param {string} packagePath\n * @param {EvidenceComponentConfig} config\n * @return {Promise<Set<string>>} An array containing the package name and a set of component names.\n */\nexport const getComponentsForPackage = async (rootDir, packagePath, config) => {\n\tconst validEvidencePackage = await isValidPackage(packagePath);\n\n\t/** @type {Set<string>} */\n\tconst providedComponents = new Set();\n\n\t// This doesn't have the required metadata\n\tif (!validEvidencePackage) return providedComponents;\n\n\t// This is a datasource connector, not a component lib\n\tif (validEvidencePackage.evidence && !validEvidencePackage.evidence.components) {\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain components.`\n\t\t\t)\n\t\t);\n\t\treturn providedComponents;\n\t}\n\n\tif (config.provides.length) {\n\t\t// Use this value as the first truth\n\t\tconfig.provides.forEach((c) => providedComponents.add(c));\n\t} else if (!validEvidencePackage.evidence) {\n\t\t// This is probably an external component library that doesn't have any provides statements\n\t\tconsole.warn(\n\t\t\tchalk.yellow(\n\t\t\t\t`[!] ${validEvidencePackage.name} is being used as a component plugin, but does not contain plugins. You may need to add a provides statement to your manifest.`\n\t\t\t)\n\t\t);\n\t\treturn providedComponents;\n\t} else {\n\t\tconst manifestPath = path.resolve(packagePath, 'evidence.manifest.yaml');\n\t\tconst manifestExists = await fs\n\t\t\t.access(manifestPath)\n\t\t\t.then(() => true)\n\t\t\t.catch(() => false);\n\n\t\tif (manifestExists) {\n\t\t\t// Use manifest\n\t\t\tconst manifestComponents = await manifestLoader(packagePath, rootDir);\n\t\t\tmanifestComponents.forEach((c) => providedComponents.add(c));\n\t\t} else {\n\t\t\t// Use file discovery\n\n\t\t\t// Attempt to extract the folder that contains built assets\n\t\t\tconst mainFilePath = path.parse(\n\t\t\t\t'main' in validEvidencePackage\n\t\t\t\t\t? path.resolve(packagePath, validEvidencePackage.main)\n\t\t\t\t\t: 'svelte' in validEvidencePackage\n\t\t\t\t\t? path.resolve(packagePath, validEvidencePackage.svelte)\n\t\t\t\t\t: path.resolve(packagePath, validEvidencePackage.exports['.'])\n\t\t\t).dir;\n\n\t\t\tconst fileComponents = await fileLoader(mainFilePath);\n\t\t\tfileComponents.forEach((c) => providedComponents.add(c));\n\t\t}\n\t}\n\n\treturn providedComponents;\n};\n","import fs from 'fs/promises';\nimport chalk from 'chalk';\nimport path from 'path';\nimport yaml from 'yaml';\nimport { cleanZodErrors } from '../../lib/clean-zod-errors';\nimport { ComponentManifestSchema } from '../schemas/component-manifest.schema';\n\n/**\n * @param {string} packagePath\n * @param {string} rootDir\n *\n * @returns {Promise<string[]>}\n */\nexport async function manifestLoader(packagePath, rootDir) {\n\ttry {\n\t\t// Load Config\n\t\tconst manifestContent = await fs\n\t\t\t.readFile(path.resolve(packagePath, 'evidence.manifest.yaml'))\n\t\t\t.then((r) => r.toString());\n\t\t// Parse YAML, then validate data\n\t\tconst manifest = yaml.parse(manifestContent);\n\t\tconst parsedManifest = ComponentManifestSchema.safeParse(manifest);\n\n\t\tif (!parsedManifest.success) {\n\t\t\t// Shape is wrong\n\t\t\tconsole.error(chalk.bold.red(`[!] evidence.manifest.yaml has errors`));\n\t\t\tconst formattedError = cleanZodErrors(parsedManifest.error.format());\n\t\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\t\tconst redPipe = chalk.red('|');\n\t\t\tconsole.error(\n\t\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t\t);\n\n\t\t\t// TODO: How do we stop here? Do we need to throw here?\n\t\t\tthrow new Error('Unable to load evidence manifest');\n\t\t}\n\n\t\treturn parsedManifest.data.components;\n\t} catch (e) {\n\t\tif (!(e instanceof Error)) throw e;\n\t\tif (e.message === 'ENOENT') {\n\t\t\tconsole.error(\n\t\t\t\tchalk.red.bold(\n\t\t\t\t\t`[!] evidence.manifest.yaml file not found in ${rootDir}.\\n    This is probably a bug in Evidence; please file a report at https://github.com/evidence-dev/evidence/issues/new?assignees=&labels=bug%2C+to-review&projects=&template=bug_report.md`\n\t\t\t\t)\n\t\t\t);\n\t\t\tthrow e;\n\t\t}\n\t\tthrow e;\n\t}\n}\n","import { z } from 'zod';\n\nexport const ComponentManifestSchema = z.object({\n\tcomponents: z.array(z.string())\n});\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { parse as svelteParse } from 'svelte/compiler';\n\n/**\n * Searches recursively within a directory for svelte files\n * Ignores anything beginning with . (hidden) or + (special sveltekit files)\n *\n * @param {string} root\n * @returns {Promise<string[]>}\n */\nexport const findSvelteComponents = async (root) => {\n\t/**\n\t * @type {string[]}\n\t */\n\tconst output = [];\n\t// Scan & iterate directory\n\tconst directoryContents = await fs.readdir(root, { withFileTypes: true });\n\tfor (const item of directoryContents) {\n\t\t// Ignore these cases\n\t\tif (item.name === 'node_modules') continue; // Don't touch any dependencies\n\t\tif (item.name.startsWith('.')) continue; // Don't touch hidden files\n\t\tif (item.name.startsWith('+')) continue; // Don't touch sveltekit files\n\n\t\t// Build path; get item stats\n\t\tconst itemPath = path.resolve(root, item.name);\n\n\t\tif (item.isDirectory()) {\n\t\t\t// Recurse on directories\n\t\t\toutput.push(...(await findSvelteComponents(itemPath)));\n\t\t} else if (item.name.endsWith('.svelte')) {\n\t\t\t// Keep track of svelte components\n\t\t\toutput.push(itemPath);\n\t\t}\n\t}\n\n\t// Return relative filepaths\n\treturn output.map((p) => path.relative('.', p));\n};\n\n/**\n * Reduce function to run on a svelte AST.\n * Searches for the evidenceInclude declaration.\n * @example\n *  <script context=\"module\">\n *      export const evidenceInclude = true\n *  </script>\n *\n * @param {import(\"estree\").Node} currentNode\n * @returns {boolean}\n */\nconst nodeIsEvidenceDeclaration = (currentNode) => {\n\t// If this isn't the right kind of declaration, ignore it\n\tif (currentNode.type !== 'ExportNamedDeclaration') return false;\n\n\tconst rootDeclaration = currentNode.declaration;\n\n\tif (rootDeclaration?.type !== 'VariableDeclaration') return false;\n\n\t// const only, this is somewhat inline with sveltekit's patterns\n\tif (rootDeclaration.kind !== 'const') return false;\n\n\t// This shouldn't be hit, but type safety\n\tif (!rootDeclaration?.declarations) return false;\n\n\t// Iterate through sub-declarations, I've only ever seen 1 here\n\tfor (const declaration of rootDeclaration.declarations) {\n\t\tconst { id, init } = declaration;\n\t\t// Check to see if this is a declaration for evidenceInclude\n\t\tif (id.type !== 'Identifier') continue;\n\t\tif (id.name !== 'evidenceInclude') continue;\n\t\t// Check to see if the value it is declared with is a true constant\n\t\t// We could shorten this; but this reads better\n\t\tif (init?.type !== 'Literal') continue;\n\t\tif (init.value !== true) continue;\n\t\t// We found what we want!\n\t\treturn true;\n\t}\n\t// We never found the right declaration; continue the reduction\n\treturn false;\n};\n\n/**\n * Generates an AST and searches it for the special declaration\n * @param {string} fileContent\n */\nexport const isLibraryComponent = async (fileContent) => {\n\tlet result = false;\n\n\t// remove style tags, postcss can screw this up\n\tfileContent = fileContent.replace(/<style.*>(.|[\\s])*<\\/style>/g, '');\n\t// First parse the passed in file\n\tconst parseResult = svelteParse(fileContent);\n\t// If there is a <script> tag, check there\n\tif (parseResult.instance) {\n\t\tresult = result || Boolean(parseResult.instance.content.body.find(nodeIsEvidenceDeclaration));\n\t}\n\t// If there is a <script context=\"module\"> tag, check there\n\tif (parseResult.module) {\n\t\tresult = result || Boolean(parseResult.module.content.body.find(nodeIsEvidenceDeclaration));\n\t}\n\treturn result;\n};\n\n/**\n * @param {string} rootDir\n *\n * @returns {Promise<string[]>}\n */\nexport async function fileLoader(rootDir) {\n\tconst componentPaths = await findSvelteComponents(rootDir);\n\tconst results = await Promise.all(\n\t\tcomponentPaths.map(async (componentPath) => ({\n\t\t\tinclude: await isLibraryComponent(\n\t\t\t\tawait fs.readFile(componentPath).then((p) => p.toString())\n\t\t\t).catch((e) => {\n\t\t\t\tthrow new Error(`Error while identifying ${componentPath}`, { cause: e });\n\t\t\t}),\n\t\t\t// Get the name of the component, takes the last part of the path and removes the file extension\n\t\t\tcomponentName: path.basename(componentPath, path.extname(componentPath))\n\t\t}))\n\t);\n\n\treturn results.filter((r) => r.include).map((r) => r.componentName);\n}\n","/**\n *\n */\nexport function evidenceRollup() {\n\tthrow new Error('Evidence Rollup Plugin not implemented');\n}\n","import { queryDirectoryHmr } from './query-directory-hmr.js';\nimport { sourceQueryHMR } from './source-query-hmr.js';\n\n/** @type {() => import(\"vite\").UserConfig[\"plugins\"]} */\nexport const evidenceVitePlugin = () => {\n\treturn [sourceQueryHMR(), queryDirectoryHmr];\n};\n","import fs from 'fs/promises';\n/** @type {import(\"vite\").Plugin} */\nexport const queryDirectoryHmr = {\n\tname: 'evidence:query-directory-hmr',\n\n\tconfigureServer(server) {\n\t\tserver.watcher.add('../../queries/**.sql');\n\t\tserver.watcher.addListener(\n\t\t\t'change',\n\t\t\t/**\n\t\t\t *\n\t\t\t * @param {string} filename\n\t\t\t * @returns {Promise<void>}\n\t\t\t */\n\t\t\tasync (filename) => {\n\t\t\t\tif (!(filename.includes('.evidence/template/queries') && filename.endsWith('.sql'))) return;\n\t\t\t\tconst content = await fs.readFile(filename, 'utf-8');\n\t\t\t\tconst queryId = filename\n\t\t\t\t\t.split('.evidence/template/queries/')\n\t\t\t\t\t.pop()\n\t\t\t\t\t?.split('.sql')[0]\n\t\t\t\t\t.replace('/', '_')\n\t\t\t\t\t.replace('\\\\', '_');\n\n\t\t\t\tserver.ws.send('evidence:queryChange', {\n\t\t\t\t\tqueryId,\n\t\t\t\t\tcontent\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t},\n\twatchChange(f, opts) {\n\t\tconsole.log({ f, opts });\n\t}\n};\n","import { watch } from 'chokidar';\nimport EventEmitter from 'events';\nimport { updateDatasourceOutputs } from '../data-sources/index.js';\nimport { getSources } from '../data-sources/get-sources.js';\nimport { readFileSync } from 'fs';\nimport fs from 'fs/promises';\nimport nodePath from 'path';\nimport yaml from 'yaml';\nimport { basename, dirname, resolve, sep as pathSep } from 'path';\n// @ts-expect-error\nimport { setParquetURLs } from '@evidence-dev/universal-sql/client-duckdb';\nimport { ProcessingQueue } from '../lib/processing-queue.js';\n\n/**\n * Extracts source, query, and source_path from a path\n * @param {string} path\n * @returns {{ source: string, query: string, source_path: string }}\n */\nfunction getSourceAndQuery(path) {\n\tconst query = basename(path).split('.')[0];\n\n\twhile (basename(dirname(path)) !== 'sources') {\n\t\tpath = dirname(path);\n\t}\n\n\tconst sourceConnection = readFileSync(nodePath.join(path, 'connection.yaml'), {\n\t\tencoding: 'utf-8'\n\t});\n\n\tconst source = yaml.parse(sourceConnection).name;\n\treturn { source, query, source_path: resolve(path) };\n}\n\n/**\n * This is used to wrap the existing chokidar file watcher\n * It emits an additional `done` event that indicates source queries have finished execution\n */\nconst build_watcher = new EventEmitter();\n\nif (process.env.NODE_ENV === 'development') {\n\tconst queue = ProcessingQueue();\n\n\tconst watcher = watch('../../sources/**');\n\tconst queuedPaths = new Set();\n\twatcher.on(\n\t\t'change',\n\t\t/** @type {(path: string) => Promise<void>} */ async (path) => {\n\t\t\tconst { query, source, source_path } = getSourceAndQuery(path);\n\t\t\tconst isSpecial = query.endsWith('connection') || query.endsWith('connection.options');\n\t\t\tconst title = isSpecial ? source : `${source}.${query}`;\n\n\t\t\tif (queuedPaths.has(title)) return;\n\t\t\tqueuedPaths.add(title);\n\n\t\t\tbuild_watcher.emit('update', path, {}, null, 'Queued to update', 'info');\n\n\t\t\tqueue.add(async () => {\n\t\t\t\tconst datasources = await getSources(resolve('../../sources'));\n\t\t\t\tconst datasource = datasources.find((ds) => ds.sourceDirectory === source_path);\n\t\t\t\tif (!datasource) return;\n\n\t\t\t\t// build_watcher.emit('change', path);\n\t\t\t\tbuild_watcher.emit('update', path, {}, null, 'Updating', 'info');\n\n\t\t\t\tconst reservedFiles = ['connection.yaml', 'connection.options.yaml'];\n\t\t\t\tconst updatedFile = /** @type {string} */ (path.split(pathSep).pop());\n\t\t\t\tconst rerunWholeSource = reservedFiles.includes(updatedFile);\n\t\t\t\tconst queryFilter = rerunWholeSource ? null : new Set([query]);\n\n\t\t\t\t// go in . (aka .evidence/template)\n\t\t\t\ttry {\n\t\t\t\t\tconst manifest = await updateDatasourceOutputs('./static/data', './.evidence-queries', {\n\t\t\t\t\t\tsources: new Set([datasource.name]),\n\t\t\t\t\t\tqueries: queryFilter,\n\t\t\t\t\t\tonly_changed: false\n\t\t\t\t\t});\n\t\t\t\t\tawait setParquetURLs(manifest);\n\t\t\t\t\tawait fs.rm('./.evidence-queries/cache', { recursive: true, force: true });\n\n\t\t\t\t\tbuild_watcher.emit(\n\t\t\t\t\t\t'update',\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tJSON.stringify({ renderedFiles: manifest }),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t'Complete!',\n\t\t\t\t\t\t'success',\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(`Error occured while reloading source: ${error}`);\n\n\t\t\t\t\tif (process.env.VITE_EVIDENCE_DEBUG && error instanceof Error) console.debug(error.stack);\n\t\t\t\t\tbuild_watcher.emit('update', path, {}, error, 'Failed!', 'error');\n\t\t\t\t} finally {\n\t\t\t\t\tqueuedPaths.delete(title);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t);\n}\n\n/** @typedef {(path: string, manifest: object, error: Error | null, message: string, variant: string ) => void} Handler */\n\nconst subscribed_servers = new Map();\n\n/** @type {import(\"vite\").Plugin[\"configureServer\"]} */\nconst configureServer = (server) => {\n\t// handle server restarts\n\tif (subscribed_servers.has(server)) return;\n\tsubscribed_servers.forEach((handlers) => {\n\t\tbuild_watcher.off('update', handlers.handler);\n\t});\n\tsubscribed_servers.clear();\n\n\t/** @type {Handler} */\n\tconst handler = (path, manifest, error, message, variant, done = false) => {\n\t\tconst { source, query } = getSourceAndQuery(path);\n\n\t\tconst isSpecial = query.endsWith('connection') || query.endsWith('connection.options');\n\t\tconst title = isSpecial ? source : `${source}.${query}`;\n\t\t/** @type {*} */\n\t\tconst toast = {\n\t\t\tstatus: variant,\n\t\t\tmessage,\n\t\t\ttitle: title\n\t\t};\n\n\t\tserver.ws.send('evidence:build-status', {\n\t\t\tid: `${source}.${query}`,\n\t\t\tmanifest,\n\t\t\ttoast,\n\t\t\tdone\n\t\t});\n\t};\n\n\tbuild_watcher.on('update', handler);\n\n\tsubscribed_servers.set(server, { handler });\n};\n\n/** @type {() => import(\"vite\").Plugin} */\nexport const sourceQueryHMR = () => {\n\treturn {\n\t\tname: 'evidence:source-query-hmr',\n\t\tconfigureServer\n\t};\n};\n","import { getSources, getSourcesDir } from './get-sources';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { buildSources } from './build-sources';\n\nexport { getDatasourcePlugins } from './get-datasource-plugins';\nexport { updateDatasourceOptions } from './update-datasource-options';\nexport { DatasourceSpecFileSchema, DatasourceSpecSchema } from './schemas/datasource-spec.schema';\n/**\n *\n * @param {Record<string, string[]>} outputFiles\n * @param {string} outDir\n */\nasync function updateManifest(outputFiles, outDir) {\n\tawait fs.mkdir(outDir, { recursive: true });\n\tawait fs.writeFile(\n\t\tpath.join(outDir, 'manifest.json'),\n\t\tJSON.stringify({ renderedFiles: outputFiles })\n\t);\n}\n\n/**\n * @param {string} sourceName - The name of the source.\n * @param {object} sourceConfig - The configuration options for the source.\n * @returns {Record<string,string>} - An object containing environment variables for the source.\n */\nconst generateSourceEnvironmentVariables = (sourceName, sourceConfig) => {\n\t/** @type {Record<string,string>} */\n\tconst sourceEnvVars = {};\n\n\t// Recursively generate environment variables for nested properties\n\t/**\n\t * @param {any} obj\n\t */\n\tconst generateNestedEnvVars = (obj, currentKey = '') => {\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tconst newKey = currentKey ? `${currentKey}__${key}` : key;\n\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tgenerateNestedEnvVars(value, newKey);\n\t\t\t} else {\n\t\t\t\tsourceEnvVars[`EVIDENCE_SOURCE__${sourceName}__${newKey}`] = value.toString();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Start generating environment variables for the source\n\tgenerateNestedEnvVars(sourceConfig);\n\n\treturn sourceEnvVars;\n};\n\n/**\n * Helper function to load configured datasources\n * @param {string} [datasourceDir]\n * @returns {Promise<(DatasourceSpec & { environmentVariables: object })[]>}\n */\nexport async function getDatasourceOptions(datasourceDir) {\n\tdatasourceDir = datasourceDir ?? (await getSourcesDir()) ?? undefined;\n\tif (!datasourceDir) throw new Error('missing sources directory');\n\tconst sources = await getSources(datasourceDir);\n\n\treturn sources.map((s) => ({\n\t\t...s,\n\t\tenvironmentVariables: generateSourceEnvironmentVariables(s.name, s.options)\n\t}));\n}\n\n/**\n * @param {string} dataPath\n * @param {string} metaPath\n * @param {{ sources: Set<string> | null, queries: Set<string> | null, only_changed: boolean }} [filters] `sources` or `queries` being null means no filter\n * @returns {Promise<Record<string, string[]>>}\n */\nexport async function updateDatasourceOutputs(\n\tdataPath,\n\tmetaPath,\n\tfilters = { sources: null, queries: null, only_changed: false }\n) {\n\tconst sourceDir = await getSourcesDir(true);\n\tif (!sourceDir) throw new Error();\n\tconst sources = await getSources(sourceDir);\n\n\tconst manifest = await buildSources(sources, dataPath, metaPath, filters);\n\n\tawait updateManifest(manifest, dataPath);\n\treturn manifest;\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport yaml from 'yaml';\nimport chalk from 'chalk';\nimport merge from 'lodash.merge';\nimport {\n\tDatasourceSpecFileSchema,\n\tDatasourceCacheSchema,\n\tDatasourceManifestSchema\n} from './schemas/datasource-spec.schema';\nimport { cleanZodErrors } from '../lib/clean-zod-errors.js';\nimport { createHash } from 'node:crypto';\nimport { decodeBase64Deep } from '../lib/b64-deep';\n\n/**\n * Returns the path to the sources directory, if it exists in the current directory.\n * If it doesn't exist, it logs a warning message and returns null.\n * @param {boolean} [create] indicates that the directory should be created if it does not exist\n * @returns {Promise<string|null>} The path to the sources directory or null.\n */\nexport const getSourcesDir = async (create) => {\n\t// Get the absolute path to the current working directory\n\tlet pwd = path.resolve('./');\n\n\tif (pwd.includes('.evidence')) pwd = path.resolve('../..');\n\n\t// Get the contents of the current directory\n\tconst contents = await fs.readdir(pwd, { withFileTypes: true });\n\n\t// Find the sources directory in the contents\n\tconst sourcesDir = contents.find((c) => c.name === 'sources' && c.isDirectory());\n\n\tconst sourceDirPath = path.join(pwd, 'sources');\n\n\t// If sources directory doesn't exist, log a warning message\n\tif (!sourcesDir) {\n\t\tif (!create) {\n\t\t\tconsole.warn(chalk.yellow('[!] No Sources Found!'));\n\t\t\treturn null;\n\t\t} else {\n\t\t\tawait fs.mkdir(sourceDirPath, { recursive: true });\n\t\t\tconsole.info(chalk.green(`Created new sources directory; ${sourceDirPath}`));\n\t\t}\n\t}\n\n\t// Return the path to the sources directory\n\treturn path.join(pwd, 'sources');\n};\n\n/**\n * @param {string} sourceName\n * @returns {any}\n */\nexport const loadSourceOptions = (sourceName) => {\n\t/** @type {any} */\n\tconst out = {};\n\tconst keyRegex = /^EVIDENCE_SOURCE__([a-zA-Z0-1_]+)$/;\n\tfor (const [key, value] of Object.entries(process.env)) {\n\t\tconst parts = keyRegex.exec(key);\n\t\tif (!parts) continue;\n\t\tif (parts?.length < 2) continue;\n\t\tif (!parts[1].toLowerCase().startsWith(sourceName.toLowerCase())) continue;\n\t\tconst rawOptKey = parts[1].substring(sourceName.length + 2).split('__');\n\t\tlet t = out;\n\n\t\trawOptKey.forEach((key, i) => {\n\t\t\tif (i < rawOptKey.length - 1) {\n\t\t\t\t// We haven't reached the final key\n\t\t\t\tif (!t[key]) t[key] = {};\n\t\t\t\tt = t[key];\n\t\t\t} else {\n\t\t\t\tt[key] = value;\n\t\t\t}\n\t\t});\n\t}\n\treturn out;\n};\n\n/**\n * Get a list of all sources and their connection info\n * @param {string} sourcesDir The path to the sources directory\n * @returns {Promise<DatasourceSpec[]>} An array of DatasourceSpecs\n */\nexport const getSources = async (sourcesDir) => {\n\tconst sourcesDirectories = await fs.readdir(sourcesDir);\n\t/** @type {DatasourceSpec[]} */\n\treturn await Promise.all(\n\t\tsourcesDirectories.map(async (dirName) => {\n\t\t\tconst sourceDir = path.join(sourcesDir, dirName);\n\t\t\tconst possibleDir = await fs.stat(sourceDir);\n\t\t\tif (!possibleDir.isDirectory()) return false;\n\n\t\t\tconst connParams = await loadConnectionConfiguration(sourceDir);\n\t\t\tif (!connParams) return false;\n\t\t\tif (!connParams.name)\n\t\t\t\tconnParams.name = /** @type {string} */ (sourceDir.split(path.sep).pop());\n\n\t\t\tif (!connParams.name)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unexpected error determining datasource name, please add an explicit name in connection.yaml (${sourceDir})`\n\t\t\t\t);\n\t\t\t// Load Options from connection.options.yaml\n\t\t\tconnParams.options = merge(connParams.options, await loadConnectionOptions(sourceDir));\n\t\t\t// Load Options from Environment\n\t\t\tconnParams.options = merge(connParams.options, loadSourceOptions(connParams.name));\n\n\t\t\t// const queries = await getQueries(sourceDir, contents);\n\t\t\treturn {\n\t\t\t\t...connParams,\n\t\t\t\tsourceDirectory: sourceDir\n\t\t\t\t// queries: queries\n\t\t\t};\n\t\t})\n\t).then((r) => /** @type {Exclude<typeof r[number], false>[]} */ (r.filter(Boolean)));\n};\n\n/**\n *\n * @template {import(\"zod\").ZodType} T\n * @param {T} zod_schema\n * @param {string} file_path\n * @param {import(\"zod\").infer<T>} default_value\n * @param {string} error_message\n * @returns {Promise<import(\"zod\").infer<T>>}\n */\nasync function validateFile(zod_schema, file_path, default_value, error_message) {\n\tconst string_default = JSON.stringify(default_value);\n\n\tconst file_contents = await fs.readFile(file_path, 'utf-8').catch(() => string_default);\n\tconst parsed = JSON.parse(file_contents);\n\tconst validated = zod_schema.safeParse(parsed);\n\n\tif (!validated.success) {\n\t\tconsole.error(chalk.bold.red(error_message));\n\t\tawait fs.writeFile(file_path, string_default);\n\t\treturn default_value;\n\t}\n\n\treturn validated.data;\n}\n\n/**\n *\n * @param {string} outDir\n * @returns {Promise<import(\"zod\").infer<typeof DatasourceManifestSchema>>}\n */\nexport async function getCurrentManifest(outDir) {\n\tconst manifestPath = path.join(outDir, 'manifest.json');\n\treturn validateFile(\n\t\tDatasourceManifestSchema,\n\t\tmanifestPath,\n\t\t{ renderedFiles: {} },\n\t\t'[!] Unable to parse manifest, ignoring'\n\t);\n}\n\nconst hash_location = 'sources/hashes.json';\n\n/**\n * Gets the hashes of all source files, at the time of their last execution.\n * @param {string} baseDir The path to .evidence/template\n * @returns {Promise<import(\"zod\").infer<typeof DatasourceCacheSchema>>}\n */\nexport async function getPastSourceHashes(baseDir) {\n\treturn validateFile(\n\t\tDatasourceCacheSchema,\n\t\tpath.join(baseDir, hash_location),\n\t\t{},\n\t\t'[!] Unable to parse source query hashes, ignoring'\n\t);\n}\n\n/**\n * Saves the supplied source hashes\n * @param {string} baseDir The path to .evidence/template\n * @param {import(\"zod\").infer<typeof DatasourceCacheSchema>} hashes\n */\nexport async function saveSourceHashes(baseDir, hashes) {\n\tconst output = path.join(baseDir, hash_location);\n\tawait fs.mkdir(path.dirname(output), { recursive: true });\n\tawait fs.writeFile(output, JSON.stringify(hashes));\n}\n\n/**\n * Saves the supplied source hashes\n * @param {string} dataDir The path to .evidence/template\n * @param {import(\"zod\").infer<typeof DatasourceCacheSchema>} hashes\n */\nexport async function cleanParquetFiles(dataDir, hashes) {\n\tconst sourceDirectories = (await fs.readdir(dataDir, { withFileTypes: true }))\n\t\t.filter((r) => r.isDirectory())\n\t\t.map((r) => r.name);\n\tconst hashedSources = Object.keys(hashes);\n\n\tfor (const sourceName of sourceDirectories) {\n\t\tconst sourcePath = path.join(dataDir, sourceName);\n\t\t// Clean up sources that have been renamed or removed\n\t\tif (!hashedSources.includes(sourceName)) {\n\t\t\tawait fs.rm(sourcePath, { recursive: true, force: true });\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst queries = await fs.readdir(sourcePath);\n\t\tconst sourceHashes = hashes[sourceName];\n\t\tfor (const queryName of queries) {\n\t\t\tconst queryPath = path.join(sourcePath, queryName);\n\t\t\tconst currentResults = await fs.readdir(queryPath);\n\t\t\tfor (const resultHash of currentResults) {\n\t\t\t\tif (resultHash !== sourceHashes[queryName]) {\n\t\t\t\t\tawait fs.rm(path.join(queryPath, resultHash), { recursive: true, force: true });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!sourceHashes[queryName]) continue;\n\t\t\tconst queryHashPath = path.join(queryPath, /** @type {string} */ (sourceHashes[queryName]));\n\t\t\tconst timestamps = await fs.readdir(queryHashPath);\n\t\t\tconst numbers = timestamps.map((x) => Number(x)).filter((x) => !isNaN(x));\n\n\t\t\tif (!numbers.length) continue;\n\t\t\tconst latest = Math.max(...numbers).toString();\n\t\t\tfor (const timestamp of timestamps) {\n\t\t\t\tif (timestamp !== latest) {\n\t\t\t\t\tawait fs.rm(path.join(queryHashPath, timestamp), {\n\t\t\t\t\t\trecursive: true,\n\t\t\t\t\t\tforce: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reads a YAML file containing connection parameters from the given source directory,\n * parses it, and returns a validated datasource specification.\n *\n * @param {string} sourceDir - The directory containing the connection.yaml file.\n * @return {Promise<DatasourceSpecFile | false>} A Promise that resolves to a validated datasource specification, or false if the directory is not a source.\n */\nasync function loadConnectionConfiguration(sourceDir) {\n\tconst connParamsRaw = await fs\n\t\t.readFile(path.join(sourceDir, 'connection.yaml'))\n\t\t.then((r) => r.toString())\n\t\t.catch(\n\t\t\t/** @returns {false} */\n\t\t\t(e) => {\n\t\t\t\tconsole.warn(chalk.yellow(`[!] ${sourceDir} is not a valid source; skipping`));\n\t\t\t\tconsole.warn(e.message);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t);\n\tif (connParamsRaw === false) return false;\n\n\tlet connParamsUnchecked;\n\ttry {\n\t\tconnParamsUnchecked = yaml.parse(connParamsRaw);\n\t} catch (e) {\n\t\tthrow new Error(`Error parsing connection.yaml file; ${sourceDir}`, { cause: e });\n\t}\n\n\tconst validationResult = DatasourceSpecFileSchema.safeParse(connParamsUnchecked);\n\tif (!validationResult.success) {\n\t\tconsole.error(chalk.bold.red(`[!] connection.yaml has errors (${sourceDir}`));\n\t\tconst formattedError = cleanZodErrors(validationResult.error.format());\n\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\tconst redPipe = chalk.red('|');\n\t\tconsole.error(\n\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t);\n\t\tthrow new Error('Unable to load connection.yaml');\n\t}\n\treturn validationResult.data;\n}\n\n/**\n * @returns {Promise<any>}\n * @param {string} sourceDir\n */\nasync function loadConnectionOptions(sourceDir) {\n\tconst optionsFilePath = path.join(sourceDir, 'connection.options.yaml');\n\tconst optionsFileExists = await fs\n\t\t.stat(optionsFilePath)\n\t\t.then(() => true)\n\t\t.catch(() => false);\n\tif (!optionsFileExists) return {};\n\tconst optionsFile = await fs.readFile(optionsFilePath).then((r) => r.toString());\n\ttry {\n\t\treturn decodeBase64Deep(yaml.parse(optionsFile));\n\t} catch (e) {\n\t\tthrow new Error(`Error parsing connection.options.yaml file; ${sourceDir}`, { cause: e });\n\t}\n}\n\n/**\n * Retrieves the contents of all query files in the source directory,\n * excluding the 'connection.yaml' file, and returns them as an array of\n * objects containing the filepath and content of each query file.\n *\n * @param {string} sourceDir - The path to the source directory.\n * @param {Array<string>} contents - An array of filenames in the source directory.\n * @return {Promise<DatasourceQuery[]>} - A promise that resolves to an array of objects\n * containing the filepath and content of each query file.\n */\nexport async function getQueries(sourceDir, contents) {\n\tconst queryFiles = await Promise.all(\n\t\tcontents\n\t\t\t.filter((s) => s !== 'connection.yaml' && s !== 'connection.options.yaml')\n\t\t\t.flatMap(\n\t\t\t\t/**\n\t\t\t\t * @param {string} s\n\t\t\t\t * @returns {Promise<string[]>}\n\t\t\t\t */\n\n\t\t\t\tasync (s) => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} dirPath\n\t\t\t\t\t * @returns {Promise<boolean>}\n\t\t\t\t\t */\n\t\t\t\t\tasync function isDir(dirPath) {\n\t\t\t\t\t\tconst stats = await fs.lstat(dirPath);\n\t\t\t\t\t\treturn stats.isDirectory();\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} dirPath\n\t\t\t\t\t * @returns {Promise<string[]>}\n\t\t\t\t\t */\n\t\t\t\t\tasync function loadDirRecursive(dirPath) {\n\t\t\t\t\t\tconst content = await fs.readdir(dirPath);\n\t\t\t\t\t\tlet output = [];\n\t\t\t\t\t\tfor (const filePath of content) {\n\t\t\t\t\t\t\tif (await isDir(path.join(dirPath, filePath))) {\n\t\t\t\t\t\t\t\toutput.push(...(await loadDirRecursive(path.join(dirPath, filePath))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toutput.push(path.join(dirPath, filePath));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst fullPath = path.join(sourceDir, s);\n\t\t\t\t\tif (await isDir(fullPath)) {\n\t\t\t\t\t\tconst recursed = await loadDirRecursive(fullPath);\n\t\t\t\t\t\treturn recursed.map((r) => path.relative(sourceDir, r));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t).then(\n\t\t/**\n\t\t * @param {string[][]} r\n\t\t * @returns {string[]}\n\t\t */\n\t\t(r) => r.flat(1)\n\t);\n\n\tconst queries = await Promise.all(\n\t\tqueryFiles.map(async (filename) => {\n\t\t\tconst filepath = path.join(sourceDir, filename);\n\t\t\tconst { size } = await fs.stat(filepath);\n\t\t\tlet content, hash;\n\t\t\tif (size > 100 * 1024 * 1024) {\n\t\t\t\tconsole.warn(`${filename} is over 100MB, skipping`);\n\t\t\t\tcontent = null;\n\t\t\t\thash = null;\n\t\t\t} else {\n\t\t\t\tcontent = await fs.readFile(path.join(sourceDir, filename)).then((r) => r.toString());\n\t\t\t\thash = createHash('md5').update(content).digest('hex');\n\t\t\t}\n\n\t\t\treturn { filepath, content, hash, name: path.basename(filepath).split('.')[0] };\n\t\t})\n\t);\n\n\treturn queries;\n}\n","import { z } from 'zod';\nimport { QueryResultSchema } from './query-runner.schema';\n\nexport const DatasourceQuerySchema = z.object({\n\tfilepath: z.string(),\n\tcontent: z.string().or(z.null()),\n\thash: z.string().or(z.null()),\n\tname: z.string()\n});\n\nexport const DatasourceSpecFileSchema = z.object({\n\ttype: z.string(),\n\tname: z.string().refine((s) => s?.toString().match(/^[a-zA-Z0-9_-]+$/)?.length),\n\toptions: z.any()\n});\n\nexport const DatasourceSpecSchema = DatasourceSpecFileSchema.extend({\n\t// queries: z.array(DatasourceQuerySchema),\n\tsourceDirectory: z.string()\n});\n\nexport const DatasourceQueryResultSchema = z.object({\n\tsource: DatasourceQuerySchema,\n\tresult: QueryResultSchema,\n\tname: z.string({ description: 'Output Table / Store name' })\n});\n\nexport const DatasourceCacheSchema = z.record(z.record(z.string().or(z.null())));\n\nexport const DatasourceManifestSchema = z.object({\n\trenderedFiles: z.record(z.array(z.string()))\n});\n","import { z } from 'zod';\n\n// Note that this only validates that the first item in the array\n// is a record with string keys. If the connector returns some\n// inconsistent array (e.g. [{}, 1]), it will not detect the\n// invalid row.\nconst QueryResultArraySchema = z.any().refine(\n\t(data) => {\n\t\t// result is not an array, fail\n\t\tif (!Array.isArray(data)) return false;\n\t\t// result has no rows, we can't validate this\n\t\t// but this is a correct result set\n\t\tif (data.length === 0) return true;\n\t\treturn z.record(z.string(), z.any()).safeParse(data[0]).success;\n\t},\n\t{ message: 'Data connector returned invalid rows' }\n);\nconst QueryResultGeneratorSchema = z.function();\n\nexport const QueryResultSchema = z\n\t.object({\n\t\t// Note that this only validates that the first item in the array\n\t\t// is a record with string keys. If the connector returns some\n\t\t// inconsistent array (e.g. [{}, 1]), it will not detect the\n\t\t// invalid row.\n\t\trows: QueryResultArraySchema.or(QueryResultGeneratorSchema),\n\t\tcolumnTypes: z.array(\n\t\t\tz.object({\n\t\t\t\tname: z.string(),\n\t\t\t\tevidenceType: z.enum(['boolean', 'number', 'string', 'date']),\n\t\t\t\ttypeFidelity: z.union([z.literal('precise'), z.literal('inferred')])\n\t\t\t})\n\t\t),\n\t\texpectedRowCount: z.number().optional()\n\t})\n\t.refine(\n\t\t(data) => {\n\t\t\t// We can't dig into generator functions\n\t\t\tif (typeof data.rows === 'function') return true;\n\n\t\t\tconst rows = data.rows;\n\n\t\t\t// Validate that all columnTypes appear\n\t\t\tif (rows.length) {\n\t\t\t\t// Filter to column types where name is not in row\n\t\t\t\t// Then map columnTypes to their names to make things easier\n\t\t\t\t// If there are any columns that were not filtered out; provide an error to zod\n\t\t\t\tconst missingColumns = data.columnTypes\n\t\t\t\t\t.filter((ct) => !(ct.name in rows[0]))\n\t\t\t\t\t.map((ct) => ct.name);\n\n\t\t\t\tif (missingColumns.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t(data) => {\n\t\t\t// We can't dig into generator functions\n\t\t\tif (typeof data.rows === 'function')\n\t\t\t\treturn {\n\t\t\t\t\tpath: ['columnTypes']\n\t\t\t\t};\n\t\t\tconst rows = data.rows;\n\n\t\t\tconst missingColumns = data.columnTypes\n\t\t\t\t.filter((ct) => !(ct.name in rows[0]))\n\t\t\t\t.map((ct) => ct.name);\n\t\t\treturn {\n\t\t\t\tpath: ['columnTypes'],\n\t\t\t\tmessage: `Datasource result has columns declared that are missing from results: ${missingColumns.join(\n\t\t\t\t\t', '\n\t\t\t\t)}`\n\t\t\t};\n\t\t}\n\t)\n\t.refine(\n\t\t(data) => {\n\t\t\t// We can't dig into generator functions\n\t\t\tif (typeof data.rows === 'function') return true;\n\n\t\t\t// Validate that all columns in the returned rows have declared column types\n\t\t\tif (data.rows.length) {\n\t\t\t\tconst colNames = data.columnTypes.map((ct) => ct.name);\n\t\t\t\tconst extraColumns = Object.keys(data.rows[0]).filter(\n\t\t\t\t\t(rowKey) => !colNames.includes(rowKey)\n\t\t\t\t);\n\t\t\t\tif (extraColumns.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t(data) => {\n\t\t\t// We can't dig into generator functions\n\t\t\tif (typeof data.rows === 'function')\n\t\t\t\treturn {\n\t\t\t\t\tpath: ['rows']\n\t\t\t\t};\n\n\t\t\tconst colNames = data.columnTypes.map((ct) => ct.name);\n\t\t\tconst extraColumns = Object.keys(data.rows[0]).filter((rowKey) => !colNames.includes(rowKey));\n\t\t\treturn {\n\t\t\t\tpath: ['rows'],\n\t\t\t\tmessage: `First row of results columns not provided in columnTypes: ${extraColumns.join(\n\t\t\t\t\t', '\n\t\t\t\t)}`\n\t\t\t};\n\t\t}\n\t);\n\nexport const QueryRunnerSchema = z\n\t.function()\n\t.args(\n\t\tz.string({ description: 'QueryString' }).or(z.null({ description: 'ExceededSizeQueryString' })),\n\t\tz.string({ description: 'QueryFilepath' }),\n\t\tz.number({ description: 'Batch Size' }).or(z.null())\n\t)\n\t.returns(z.promise(QueryResultSchema.or(z.null())).or(QueryResultSchema));\n\nexport const ConnectionTesterSchema = z\n\t.function()\n\t.args(z.any({ description: 'Connection Options' }))\n\t.returns(z.promise(z.union([z.literal(true), z.object({ reason: z.string() })])));\n\nexport const DatasourceConnectorFactorySchema = z\n\t.function()\n\t.args(\n\t\tz.any({ description: 'Connection Options' }),\n\t\tz.string({ description: 'Datasource directory' })\n\t)\n\t.returns(z.promise(QueryRunnerSchema));\n\n/**\n * @typedef {Object} IDatasourceOptionSpecSchema\n * @property {string} title\n * @property {'string' | 'number' | 'boolean' | 'select' | 'file'} type\n * @property {boolean} [secret]\n * @property {boolean} [shown]\n * @property {string} [description]\n * @property {boolean} [virtual]\n * @property {boolean} [nest]\n * @property {string | number | boolean | undefined} [default]\n * @property {Record<string | number | symbol, Record<string, IDatasourceOptionSpecSchema>> | undefined} [children]\n */\n\nconst primitive = z.union([z.string(), z.number(), z.boolean()]);\n\n/** @type {z.ZodRecord<z.ZodType<string>, z.ZodType<IDatasourceOptionSpecSchema>>} */\nexport const DatasourceOptionSpecSchema = z.record(\n\tz.string(),\n\tz.object({\n\t\ttitle: z.string(),\n\t\ttype: z.enum(['string', 'number', 'boolean', 'select', 'file']),\n\t\tsecret: z.boolean().default(false),\n\t\tshown: z.boolean().optional(),\n\t\t/**\n\t\t * Indicates that the field should not actually be persisted. Should be combined with `references`\n\t\t */\n\t\tvirtual: z.boolean().default(false),\n\t\t/**\n\t\t * Indicates that the field should get its value from another field if it is available\n\t\t */\n\t\treferences: z.string().optional(),\n\t\t/**\n\t\t * Indicates that the field can only get its value from the references\n\t\t */\n\t\tforceReference: z.boolean().default(false),\n\t\tfileFormat: z.enum(['json', 'yaml']).optional(),\n\t\tdescription: z.string().optional(),\n\t\tchildren: z.lazy(() => z.record(z.string(), DatasourceOptionSpecSchema)).optional(),\n\t\trequired: z.boolean().default(false),\n\t\toptions: z\n\t\t\t.union([z.string(), z.object({ value: primitive, label: z.string() })])\n\t\t\t.array()\n\t\t\t.optional(),\n\t\tnest: z.boolean().optional(),\n\t\tdefault: primitive.optional()\n\t})\n);\n\nexport const DatasourceConnectorSchema = z.object({\n\tgetRunner: DatasourceConnectorFactorySchema,\n\tsupports: z.array(z.union([z.string(), z.array(z.string())])),\n\toptions: DatasourceOptionSpecSchema,\n\ttestConnection: ConnectionTesterSchema,\n\tprocessSource: z\n\t\t.function()\n\t\t.returns(\n\t\t\tz.custom((d) => d && typeof d === 'object' && Symbol.asyncIterator in d, {\n\t\t\t\tmessage: 'Expected AsyncIterator result'\n\t\t\t})\n\t\t)\n\t\t.optional()\n});\n","/**\n * Encodes a value or an array of values into Base64 recursively.\n * @param {*} v - The value or array of values to encode.\n * @returns {*} - The encoded value or array of values.\n */\nexport const encodeBase64Deep = (v) => {\n\tif (Array.isArray(v)) {\n\t\tconst mapped = v.map(encodeBase64Deep);\n\t\treturn mapped;\n\t} else if (typeof v === 'string') {\n\t\treturn btoa(v);\n\t} else if (v && v.constructor === Object) {\n\t\t// bare object\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(v).map(\n\t\t\t\t/**\n\t\t\t\t * Maps each key-value pair of the object.\n\t\t\t\t * @param {[string, object]} entry - The key-value pair.\n\t\t\t\t * @returns {[string, object|string]} - The encoded key-value pair.\n\t\t\t\t */\n\t\t\t\t([k, v]) => [k, encodeBase64Deep(v)]\n\t\t\t)\n\t\t);\n\t} else {\n\t\treturn v;\n\t}\n};\n\n/**\n * Dencodes a value or an array of values from Base64 recursively.\n * @param {*} v - The value or array of values to encode.\n * @returns {*} - The encoded value or array of values.\n */\nexport const decodeBase64Deep = (v) => {\n\tif (Array.isArray(v)) {\n\t\tconst mapped = v.map(decodeBase64Deep);\n\t\treturn mapped;\n\t} else if (typeof v === 'string') {\n\t\treturn atob(v);\n\t} else if (v && v.constructor === Object) {\n\t\t// bare object\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(v).map(\n\t\t\t\t/**\n\t\t\t\t * Maps each key-value pair of the object.\n\t\t\t\t * @param {[string, object]} entry - The key-value pair.\n\t\t\t\t * @returns {[string, object|string]} - The encoded key-value pair.\n\t\t\t\t */\n\t\t\t\t([k, v]) => [k, decodeBase64Deep(v)]\n\t\t\t)\n\t\t);\n\t} else {\n\t\treturn v;\n\t}\n};\n","import chalk from 'chalk';\nimport fs from 'fs/promises';\nimport { getDatasourcePlugins } from './get-datasource-plugins';\nimport {\n\tcleanParquetFiles,\n\tgetCurrentManifest,\n\tgetPastSourceHashes,\n\tgetQueries,\n\tsaveSourceHashes\n} from './get-sources';\nimport path from 'path';\nimport { createHash } from 'crypto';\nimport { cleanZodErrors } from '../lib/clean-zod-errors';\nimport { z } from 'zod';\nimport { buildMultipartParquet } from '@evidence-dev/universal-sql';\nimport { logQueryEvent } from '@evidence-dev/telemetry';\n\nimport ora from 'ora';\nimport { subSourceVariables } from './sub-source-vars';\n\n/**\n * @param {string} directory\n * @returns {Promise<SourceDirectory>}\n */\nconst buildSourceDirectory = async (directory) => {\n\t/** @type {SourceDirectory} */\n\tconst output = {};\n\n\tfor (const f of await fs.readdir(directory, { withFileTypes: true })) {\n\t\tif (f.isDirectory()) {\n\t\t\toutput[f.name] = await buildSourceDirectory(path.join(directory, f.name));\n\t\t} else {\n\t\t\t/**\n\t\t\t * @param {boolean} [disableInterpolation = false]\n\t\t\t * @returns {Promise<string>}\n\t\t\t */\n\t\t\toutput[f.name] = async (disableInterpolation) => {\n\t\t\t\tconst content = await fs.readFile(path.join(directory, f.name), { encoding: 'utf-8' });\n\t\t\t\tif (disableInterpolation) return content;\n\t\t\t\telse return subSourceVariables(content);\n\t\t\t};\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * @param {DatasourceSpec[]} sources\n * @param {string} dataPath\n * @param {string} metaPath\n * @param {{ sources: Set<string> | null, queries: Set<string> | null, only_changed: boolean }} [filters] `sources` or `queries` being null means no filter\n * @param {number} [batchSize]\n * @returns {Promise<Record<string, string[]>>}\n */\nexport const buildSources = async (\n\tsources,\n\tdataPath,\n\tmetaPath,\n\tfilters,\n\tbatchSize = 1000 * 1000\n) => {\n\tawait fs.stat(dataPath).catch(async (e) => {\n\t\tif (e.message.startsWith('ENOENT')) {\n\t\t\tawait fs.mkdir(dataPath, { recursive: true });\n\t\t\tif (process.env.VITE_EVIDENCE_DEBUG)\n\t\t\t\tconsole.log('Created data path at ', path.resolve(dataPath));\n\t\t} else throw e;\n\t});\n\tawait fs.stat(metaPath).catch(async (e) => {\n\t\tif (e.message.startsWith('ENOENT')) {\n\t\t\tawait fs.mkdir(metaPath, { recursive: true });\n\t\t\tif (process.env.VITE_EVIDENCE_DEBUG)\n\t\t\t\tconsole.log('Created meta path at ', path.resolve(metaPath));\n\t\t} else throw e;\n\t});\n\n\tconst plugins = await getDatasourcePlugins();\n\tconst existingHashes = await getPastSourceHashes(metaPath);\n\n\t/** @type {Record<string, string[]>} */\n\tconst manifest = {};\n\n\t/** @type {Record<string, string[]>} */\n\tconst existingManifest = await getCurrentManifest(dataPath).then((r) => r.renderedFiles);\n\n\t/** @type {Record<string, Record<string, string | null>>} */\n\tconst hashes = {};\n\n\tfor (const source of sources) {\n\t\tconsole.log(chalk.bold(`Processing ${source.name}`));\n\t\tconst sourceManifest = existingManifest[source.name] ?? [];\n\t\t// For building the manifest\n\t\t/** @type {string[]} */\n\t\tconst outputFilenames = [];\n\t\thashes[source.name] = {};\n\n\t\tif (filters?.sources && !filters.sources.has(source.name)) {\n\t\t\tconsole.log(chalk.yellow(`[!] Skipping filtered source ${source.name}`));\n\t\t\thashes[source.name] = existingHashes[source.name] ?? {}; // passthrough hashes\n\t\t\tmanifest[source.name] = existingManifest[source.name] ?? [];\n\t\t\tcontinue;\n\t\t}\n\t\tconst targetPlugin = plugins[source.type];\n\t\tif (!targetPlugin) {\n\t\t\tconsole.log(\n\t\t\t\tchalk.yellow(\n\t\t\t\t\t`[!] Unable to process source ${source.name}; no source connector found for ${source.type}`\n\t\t\t\t)\n\t\t\t);\n\t\t\tlogQueryEvent('source-connector-not-found', source.type, source.name);\n\t\t\thashes[source.name] = existingHashes[source.name];\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst connectionValid = await targetPlugin.testConnection(\n\t\t\tsource.options,\n\t\t\tsource.sourceDirectory\n\t\t);\n\t\tif (connectionValid !== true) {\n\t\t\tlogQueryEvent('db-connection-error', source.type, source.name);\n\t\t\tthrow new Error(\n\t\t\t\tchalk.red(`[!] ${chalk.bold(source.name)} failed to connect; ${connectionValid.reason}`)\n\t\t\t);\n\t\t}\n\t\t//TODO evidence-1344 and db-connection-error didn't have an equivalent for event in legacy\n\t\tlogQueryEvent('db-connection-success', source.type, source.name);\n\n\t\tconst utils = {\n\t\t\t/**\n\t\t\t * @param {string} name\n\t\t\t * @param {string} content\n\t\t\t */\n\t\t\tisCached: (name, content) => {\n\t\t\t\tconst hash = createHash('md5').update(content).digest('hex');\n\t\t\t\treturn existingHashes[source.name]?.[name] === hash;\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {string} name\n\t\t\t * @returns {boolean} true if query is included in filters\n\t\t\t */\n\t\t\tisFiltered: (name) =>\n\t\t\t\tBoolean(filters?.queries?.has(name) || filters?.queries?.has(`${source.name}.${name}`)) ||\n\t\t\t\t!filters?.queries,\n\t\t\t/**\n\t\t\t * @param {string} name\n\t\t\t * @param {string} content\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tshouldRun: (name, content) =>\n\t\t\t\t!utils.isFiltered(name) && Boolean(filters?.only_changed) && !utils.isCached(name, content),\n\t\t\t/**\n\t\t\t * @param {string} name\n\t\t\t * @param {string} content\n\t\t\t */\n\t\t\taddToCache: (name, content) =>\n\t\t\t\t(hashes[source.name][name] = createHash('md5').update(content).digest('hex'))\n\t\t};\n\n\t\tif (targetPlugin.processSource) {\n\t\t\t// Advanced Source\n\t\t\tconst sourceIterator = targetPlugin.processSource(\n\t\t\t\tsource.options,\n\t\t\t\tawait buildSourceDirectory(source.sourceDirectory),\n\t\t\t\tutils\n\t\t\t);\n\n\t\t\tfor await (const table of sourceIterator) {\n\t\t\t\t// Flush this source\n\t\t\t\tconst spinner = ora({\n\t\t\t\t\tprefixText: `  ${table.name}`,\n\t\t\t\t\tspinner: 'triangle',\n\t\t\t\t\tdiscardStdin: false,\n\t\t\t\t\tinterval: 250\n\t\t\t\t});\n\n\t\t\t\ttry {\n\t\t\t\t\tspinner.start('Processing...');\n\n\t\t\t\t\tif (!utils.isFiltered(table.name)) {\n\t\t\t\t\t\tspinner.warn('Skipping: Filtered');\n\t\t\t\t\t\thashes[source.name][table.name] = existingHashes[source.name]?.[table.name]; // passthrough hashes\n\t\t\t\t\t\tconst existingManifestUrl = sourceManifest.find(\n\t\t\t\t\t\t\t(existingPath) => path.basename(existingPath, '.parquet') === table.name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (existingManifestUrl) {\n\t\t\t\t\t\t\toutputFilenames.push(existingManifestUrl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspinner.warn('Skipping: Filtered (table does not exist yet)');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filters?.only_changed && utils.isCached(table.name, table.content)) {\n\t\t\t\t\t\tspinner.warn('Skipping: Cached');\n\t\t\t\t\t\thashes[source.name][table.name] = existingHashes[source.name]?.[table.name]; // passthrough hashes\n\t\t\t\t\t\tconst existingManifestUrl = sourceManifest.find(\n\t\t\t\t\t\t\t(existingPath) => path.basename(existingPath, '.parquet') === table.name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (existingManifestUrl) {\n\t\t\t\t\t\t\toutputFilenames.push(existingManifestUrl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspinner.warn('Skipping: Filtered (cache may be broken)');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogQueryEvent('cache-query', source.type, source.name);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thashes[source.name][table.name] = createHash('md5')\n\t\t\t\t\t\t.update(table.content ?? '')\n\t\t\t\t\t\t.digest('hex');\n\n\t\t\t\t\tconst filename = await flushSource(\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: table.name,\n\t\t\t\t\t\t\tfilepath: path.join(source.sourceDirectory, table.name),\n\t\t\t\t\t\t\tcontent: table.content,\n\t\t\t\t\t\t\thash: hashes[source.name][table.name]\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttable,\n\t\t\t\t\t\tdataPath,\n\t\t\t\t\t\tmetaPath,\n\t\t\t\t\t\tbatchSize,\n\t\t\t\t\t\tspinner\n\t\t\t\t\t);\n\t\t\t\t\tif (filename) outputFilenames.push(filename);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlet message = 'Unknown error occurred';\n\t\t\t\t\tif (typeof e === 'string') message = e;\n\t\t\t\t\telse if (e instanceof Error) message = e.message.toString();\n\t\t\t\t\tspinner.fail(chalk.bold.red(message));\n\t\t\t\t\tif (process.env.VITE_EVIDENCE_DEBUG && e instanceof Error) console.log(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Simple Source\n\t\t\t// Load and iterate through query files\n\t\t\tconst queries = await getQueries(\n\t\t\t\tsource.sourceDirectory,\n\t\t\t\tawait fs.readdir(source.sourceDirectory)\n\t\t\t);\n\t\t\tconst runner = await targetPlugin.factory(source.options, source.sourceDirectory);\n\n\t\t\tfor (const query of queries) {\n\t\t\t\tconst spinner = ora({\n\t\t\t\t\tprefixText: `  ${query.name}`,\n\t\t\t\t\tspinner: 'triangle',\n\t\t\t\t\tdiscardStdin: false,\n\t\t\t\t\tinterval: 250\n\t\t\t\t});\n\n\t\t\t\ttry {\n\t\t\t\t\tspinner.start('Processing...');\n\n\t\t\t\t\tif (!utils.isFiltered(query.name)) {\n\t\t\t\t\t\tspinner.warn('Skipping: Filtered');\n\t\t\t\t\t\thashes[source.name][query.name] = existingHashes[source.name]?.[query.name]; // passthrough hashes\n\t\t\t\t\t\tconst existingManifestUrl = sourceManifest.find(\n\t\t\t\t\t\t\t(existingPath) => path.basename(existingPath, '.parquet') === query.name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (existingManifestUrl) {\n\t\t\t\t\t\t\toutputFilenames.push(existingManifestUrl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspinner.warn('Skipping: Filtered (table does not exist yet)');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filters?.only_changed && utils.isCached(query.name, query.content ?? '')) {\n\t\t\t\t\t\tspinner.warn('Skipping: Cached');\n\t\t\t\t\t\tlogQueryEvent('cache-query', source.type, source.name, query.name);\n\t\t\t\t\t\thashes[source.name][query.name] = existingHashes[source.name]?.[query.name]; // passthrough hashes\n\t\t\t\t\t\tconst existingManifestUrl = sourceManifest.find(\n\t\t\t\t\t\t\t(existingPath) => path.basename(existingPath, '.parquet') === query.name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (existingManifestUrl) {\n\t\t\t\t\t\t\toutputFilenames.push(existingManifestUrl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspinner.warn('Skipping: Filtered (cache may be broken)');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\thashes[source.name][query.name] = createHash('md5')\n\t\t\t\t\t\t.update(query.content ?? '')\n\t\t\t\t\t\t.digest('hex');\n\t\t\t\t\t/** @type {QueryResult | null} */\n\t\t\t\t\tlet result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst interpolatedContent = query.content\n\t\t\t\t\t\t\t? subSourceVariables(query.content)\n\t\t\t\t\t\t\t: query.content;\n\t\t\t\t\t\tconst _r = runner(interpolatedContent, query.filepath, batchSize);\n\t\t\t\t\t\tif (_r instanceof Promise) {\n\t\t\t\t\t\t\tresult = await _r.catch((e) => {\n\t\t\t\t\t\t\t\tif (e instanceof z.ZodError) {\n\t\t\t\t\t\t\t\t\tlogQueryEvent('db-error', source.type, source.name, query.name);\n\t\t\t\t\t\t\t\t\tconsole.log(e.format());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\tlogQueryEvent('db-query', source.type, source.name, query.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = _r;\n\t\t\t\t\t\t\tlogQueryEvent('db-query', source.type, source.name, query.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlogQueryEvent('db-error', source.type, source.name, query.name);\n\t\t\t\t\t\tif (e instanceof z.ZodError) console.log(cleanZodErrors(e.format()));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === null) {\n\t\t\t\t\t\tspinner.warn(`Finished. Returned no results!`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst filename = await flushSource(\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tquery,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\tdataPath,\n\t\t\t\t\t\tmetaPath,\n\t\t\t\t\t\tbatchSize,\n\t\t\t\t\t\tspinner\n\t\t\t\t\t);\n\n\t\t\t\t\tif (filename) outputFilenames.push(filename);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlet message = 'Unknown error occurred';\n\t\t\t\t\tif (typeof e === 'string') message = e;\n\t\t\t\t\telse if (e instanceof Error) message = e.message.toString();\n\t\t\t\t\tspinner.fail(chalk.bold.red(message));\n\t\t\t\t\tif (process.env.VITE_EVIDENCE_DEBUG && e instanceof Error) console.log(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmanifest[source.name] = outputFilenames;\n\t}\n\n\tawait saveSourceHashes(metaPath, hashes);\n\tawait cleanParquetFiles(dataPath, hashes);\n\treturn manifest;\n};\n\n/**\n *\n * @param {DatasourceSpec} source\n * @param {DatasourceQuery} query\n * @param {QueryResult} result\n * @param {string} dataPath\n * @param {string} metaPath\n * @param {number} batchSize\n * @param {import(\"ora\").Ora} [spinner]\n * @returns {Promise<null | string>}\n */\nconst flushSource = async (source, query, result, dataPath, metaPath, batchSize, spinner) => {\n\tconst logOut = /** @param {string} t **/ (t) => (spinner ? (spinner.text = t) : console.log(t));\n\n\t// use `Date.now()` to ensure data is updated\n\tconst dataOutDir = path.join(\n\t\tdataPath,\n\t\tsource.name,\n\t\tquery.name,\n\t\tquery.hash ?? '',\n\t\tDate.now().toString()\n\t);\n\n\tconst parquetFilename = path.join(dataOutDir, query.name + '.parquet');\n\tconst schemaFilename = path.join(dataOutDir, query.name + '.schema.json');\n\n\tconst tmpDir = path.join(metaPath, 'intermediate-parquet', source.name, query.name);\n\n\t// Make sure the directories exist\n\tawait fs.mkdir(dataOutDir, { recursive: true });\n\tawait fs.mkdir(tmpDir, { recursive: true });\n\n\tconst rows = /** @type {any[] | Generator<any[]>} */ (result.rows);\n\n\tif ((result.expectedRowCount ?? -1) > 1000000)\n\t\tlogOut(chalk.yellow(`Expected row count is ~${result.expectedRowCount?.toLocaleString()}`));\n\telse if (result.expectedRowCount)\n\t\tlogOut(`Expected row count is ~${result.expectedRowCount?.toLocaleString()}`);\n\n\t// Spinner start\n\t// Disable the console for a moment, stack up and then print everything after?\n\tconst writtenRows = await buildMultipartParquet(\n\t\tresult.columnTypes,\n\t\trows,\n\t\ttmpDir,\n\t\tdataOutDir,\n\t\tquery.name + '.parquet',\n\t\tresult.expectedRowCount,\n\t\tbatchSize\n\t);\n\n\t// Spinner stop?\n\tif (!writtenRows) {\n\t\t(spinner?.warn.bind(spinner) ?? console.warn)(\n\t\t\tchalk.yellow(`Finished. 0 rows, did not create table`)\n\t\t);\n\t\treturn null;\n\t} else {\n\t\t(spinner?.succeed.bind(spinner) ?? console.log)(`Finished. ${writtenRows} rows`);\n\t}\n\n\tawait fs.writeFile(schemaFilename, JSON.stringify(result.columnTypes));\n\n\treturn parquetFilename;\n};\n","import { discoverEvidencePlugins } from '../plugin-discovery';\nimport { buildConnector } from './build-connector';\nimport chalk from 'chalk';\nimport path from 'path';\n/**\n * @param {EvidenceConfig} [cfg]\n * @param {PackageDiscoveryResult} [discoveries] Optional: Pass in already discovered plugins\n * @returns {Promise<PluginDatasources>}\n */\nexport async function getDatasourcePlugins(cfg, discoveries) {\n\tconst pluginDiscoveries = discoveries ?? (await discoverEvidencePlugins());\n\n\treturn await pluginDiscoveries.datasources.reduce(\n\t\t/**\n\t\t * Adds a plugin to a map of EvidencePluginPackages with a corresponding DatasourceConnectorFactory,\n\t\t * ensuring that no duplicate datasources are added.\n\t\t * @param {Promise<Record<string, PluginDatasources[string]>>} _acc - A promise representing the current state of the package map\n\t\t * @param {EvidencePluginPackage<EvidenceDatasourcePackage>} v - The plugin package to be added to the map\n\t\t * @returns {Promise<Record<string, PluginDatasources[string]>>} - A promise representing the updated package map\n\t\t */\n\t\tasync (_acc, v) => {\n\t\t\t// TODO: Handle Overrides\n\n\t\t\t// Wait for the current state of the package map to resolve\n\t\t\tconst acc = await _acc;\n\t\t\t// Build a DatasourceConnectorFactory for the plugin package's datasourcess\n\t\t\tconst factory = await buildConnector(\n\t\t\t\tpath.join(v.path, v.package.main),\n\t\t\t\tv.package.evidence?.datasources ?? [],\n\t\t\t\tv.package.name\n\t\t\t);\n\t\t\t// For each datasource in the plugin package...\n\t\t\tv.package.evidence.datasources?.flat().forEach((d) => {\n\t\t\t\t// If a plugin with the same datasource already exists in the map, throw an error\n\t\t\t\tif (d in acc) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\tchalk.red(\n\t\t\t\t\t\t\t`[!] Multiple datasource connectors found for ${d}. Please ensure that only one is used.`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error('Datasource plugin conflict found!');\n\t\t\t\t}\n\t\t\t\t// Otherwise, add the plugin package and its DatasourceConnectorFactory to the map\n\t\t\t\tacc[d] = {\n\t\t\t\t\tpackage: v,\n\t\t\t\t\tfactory: factory.getRunner,\n\t\t\t\t\toptions: factory.options,\n\t\t\t\t\ttestConnection: factory.testConnection,\n\t\t\t\t\tprocessSource: /** @type {*} **/ (factory.processSource) // We can't really validate AsyncIterator output\n\t\t\t\t};\n\t\t\t});\n\t\t\t// Return the updated package map as a promise\n\t\t\treturn acc;\n\t\t},\n\t\tPromise.resolve({})\n\t);\n}\n","import chalk from 'chalk';\nimport yaml from 'yaml';\nimport { cleanZodErrors } from '../lib/clean-zod-errors';\nimport { DatasourceConnectorSchema } from './schemas/query-runner.schema';\n/**\n * Builds a datasource connector with the given package main and support types.\n *\n * @param {string} packageMain - The main file of the package to import.\n * @param {(string | string[])[]} supports - An array of support types.\n * @param {string} packageName - Name of the connector package; used for error outputs\n * @return {Promise<DatasourceConnector>} A promise that resolves to the built datasource connector.\n */\nexport const buildConnector = async (packageMain, supports, packageName) => {\n\t// https://github.com/nodejs/node/issues/31710 thanks windows\n\tconst crossPlatformPackage = new URL(`file:///${packageMain}`).href;\n\tconst connectorPackage = await import(crossPlatformPackage /* @vite-ignore */);\n\tconst connector = DatasourceConnectorSchema.safeParse({ ...connectorPackage, supports });\n\n\tif (!connector.success) {\n\t\tconsole.error(chalk.bold.red(`[!] Datasource connector \"${packageName}\" is invalid`));\n\t\tconst formattedError = cleanZodErrors(connector.error.format());\n\t\tconsole.error(chalk.red('|   Discovered Errors:'));\n\t\tconst redPipe = chalk.red('|');\n\t\tconsole.error(\n\t\t\t`${redPipe}   ${yaml.stringify(formattedError).replace(/\\n/g, `\\n${redPipe}   `)}`\n\t\t);\n\t\tprocess.exit(1);\n\t} else {\n\t\treturn connector.data;\n\t}\n};\n","/**\n * Replaces all ${var} patterns in a string with the matching EVIDENCE_VAR__[var] environment variables\n * @param {string} queryString\n * @returns {string}\n */\nexport const subSourceVariables = (queryString) => {\n\tconst envPrefix = 'EVIDENCE_VAR__';\n\n\tif (queryString.length > 1024 * 1024) {\n\t\tif (process.env.VITE_EVIDENCE_DEBUG) {\n\t\t\tconsole.log(\n\t\t\t\t`Skipping variable interpolation for file; has more than ${1024 * 1024} characters`\n\t\t\t);\n\t\t}\n\t\treturn queryString;\n\t}\n\n\tconst validVars = Object.fromEntries(\n\t\tObject.entries(process.env)\n\t\t\t.filter(([k]) => k.startsWith(envPrefix))\n\t\t\t.map(([k, v]) => {\n\t\t\t\tconst name = k.substring(envPrefix.length);\n\t\t\t\tconst value = v?.toString();\n\t\t\t\treturn [name, value];\n\t\t\t})\n\t);\n\tlet output = queryString;\n\t// This regex is prefixed with a negative lookbehind to disqualify $${var} patterns\n\tconst regex = RegExp(/(?<!\\$)\\$\\{(.+?)\\}/, 'g');\n\n\tlet match;\n\twhile ((match = regex.exec(queryString)) !== null) {\n\t\tconst fullMatch = match[0]; // e.g. ${variable}\n\t\tconst varName = match[1]; // e.g. variable\n\t\tconst start = match.index;\n\t\tconst end = match[0].length + start;\n\n\t\tif (varName in validVars && validVars[varName]) {\n\t\t\tconst value = validVars[varName];\n\t\t\tif (!value) throw new Error('Value somehow became undefined');\n\t\t\tconst before = output.substring(0, start);\n\t\t\tconst after = output.substring(end);\n\t\t\toutput = `${before}${value}${after}`;\n\t\t} else\n\t\t\tconsole.warn(\n\t\t\t\t`Missed substition for ${fullMatch}, do you need to set EVIDENCE_VAR__${varName}?`\n\t\t\t);\n\t}\n\n\toutput = output.replaceAll('$${', '${');\n\n\treturn output;\n};\n","import path from 'path';\nimport yaml from 'yaml';\nimport merge from 'lodash.merge';\nimport fs from 'fs/promises';\nimport { getSourcesDir } from './get-sources';\nimport { getDatasourceOptions } from '.';\nimport { encodeBase64Deep } from '../lib/b64-deep';\n\n/**\n * @typedef {Record<string, string | number | boolean | *>} OptsObject\n */\n\nexport const sepSecrets = (\n\t/** @type {OptsObject} */ opts,\n\t/** @type {DatasourceOptionsSpec} */ spec\n) => {\n\t/** @type {*} */\n\tlet secretOut = {};\n\t/** @type {*} */\n\tlet varOut = {};\n\n\tif (typeof opts !== 'object' || !opts) {\n\t\tconsole.warn(`Error processing options`);\n\t\treturn { secret: {}, _var: {} };\n\t}\n\tfor (const [key, value] of Object.entries(spec)) {\n\t\tif (value.virtual) continue;\n\t\tconst metakey = `_${key}`;\n\t\t/** @type {string | number | boolean | symbol } */\n\t\tconst valuekey = value.children && value.nest ? metakey : key;\n\t\tif (value.children) {\n\t\t\t/** @type {string | number | boolean | object} */\n\t\t\tconst optsValueKey = opts[valuekey];\n\t\t\tif (typeof optsValueKey === 'object') {\n\t\t\t\t/* TODO: Something is wrong? */ continue;\n\t\t\t}\n\t\t\t// We don't have any spec for this child value\n\t\t\tif (optsValueKey === undefined) continue;\n\n\t\t\tconst targetSpec = value.children[optsValueKey.toString()];\n\t\t\tif (targetSpec) {\n\t\t\t\t// The current value for this field has children\n\t\t\t\tif (value.nest) {\n\t\t\t\t\tconst optKey = opts[key];\n\t\t\t\t\tif (typeof optKey !== 'object') {\n\t\t\t\t\t\t/* TODO: Something is wrong? */ continue;\n\t\t\t\t\t}\n\t\t\t\t\t// Recurse, looking at the nested options object\n\t\t\t\t\tconst { secret, _var } = sepSecrets(optKey, targetSpec);\n\t\t\t\t\tvarOut[key] = _var;\n\t\t\t\t\tsecretOut[key] = secret;\n\t\t\t\t} else {\n\t\t\t\t\t// Recurse, applying the child schema to the same options object\n\t\t\t\t\tconst { secret, _var } = sepSecrets(opts, targetSpec);\n\t\t\t\t\tvarOut = merge(varOut, _var);\n\t\t\t\t\tsecretOut = merge(secretOut, secret);\n\t\t\t\t\tif (value.secret) {\n\t\t\t\t\t\tsecretOut[key] = opts[key];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvarOut[key] = opts[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (value.secret) {\n\t\t\t\t\tsecretOut[key] = opts[key];\n\t\t\t\t} else {\n\t\t\t\t\tvarOut[key] = opts[key];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (value.secret) {\n\t\t\t\tsecretOut[key] = opts[key];\n\t\t\t} else {\n\t\t\t\tvarOut[key] = opts[key];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { secret: secretOut, _var: varOut };\n};\n\n/**\n *\n * @param {*} newOptions\n * @param {string} sourceDir\n * @returns\n */\nexport async function bootstrapSourceDirectory(newOptions, sourceDir) {\n\tconst sourcePath = newOptions.sourceDirectory ?? path.join(sourceDir, newOptions.name);\n\tconst sourceDirectories = await fs.readdir(sourceDir);\n\n\tif (\n\t\t!sourceDirectories.includes(newOptions.name) &&\n\t\t!sourceDirectories.includes(sourcePath.split(path.sep).pop())\n\t) {\n\t\tawait fs.mkdir(sourcePath);\n\t}\n\n\tconst sourceDirContent = await fs.readdir(sourcePath);\n\n\tconst connYamlPath = path.join(sourcePath, 'connection.yaml');\n\tconst optsYamlPath = path.join(sourcePath, 'connection.options.yaml');\n\n\tif (!sourceDirContent.includes('connection.yaml')) {\n\t\tawait fs.writeFile(\n\t\t\tconnYamlPath,\n\t\t\t`# This file was automatically generated\nname: ${newOptions.name}\ntype: ${newOptions.type}`\n\t\t);\n\t}\n\tif (!sourceDirContent.includes('connection.options.yaml')) {\n\t\tawait fs.writeFile(optsYamlPath, '');\n\t}\n\n\treturn { connYamlPath, optsYamlPath };\n}\n\n/**\n * @param {Partial<DatasourceSpec> & { type: string, name: string, initialName?: string }} newOptions\n * @param {Omit<PluginDatasources, \"factory\">} plugins\n * @returns {Promise<DatasourceSpec>}\n */\nexport async function updateDatasourceOptions(newOptions, plugins) {\n\t/** @param {*} o */\n\tconst denull = (o) =>\n\t\tObject.fromEntries(Object.entries(o).filter(([, v]) => v !== null && v !== undefined));\n\n\t// First; we need to divy this up into secret, and non secret values\n\tconst usedPlugin = plugins[newOptions.type];\n\n\tconst { secret, _var: vars } = sepSecrets(denull(newOptions.options), usedPlugin.options);\n\n\t// Then; we need to check if the folder already exists; and if it does, load the existing\n\t// connection.yaml and connection.options.yaml\n\n\tconst sourceDir = await getSourcesDir();\n\n\tif (!sourceDir) throw new Error('Unable to locate sources directory');\n\n\tconst { optsYamlPath, connYamlPath } = await bootstrapSourceDirectory(newOptions, sourceDir);\n\n\tconst connYamlContent = await fs\n\t\t.readFile(connYamlPath, { encoding: 'utf8' })\n\t\t.then((r) => yaml.parse(r));\n\n\tconst mergedConnYaml = merge(\n\t\t{ ...connYamlContent, options: undefined },\n\t\t{ options: vars, name: newOptions.name }\n\t);\n\n\tconst mergedOptsYaml = secret;\n\n\tawait fs.writeFile(\n\t\tconnYamlPath,\n\t\t`# This file was automatically generated\\n${yaml.stringify(denull(mergedConnYaml))}`\n\t);\n\n\tconst optsYamlContent = yaml.stringify(encodeBase64Deep(denull(mergedOptsYaml)));\n\n\tawait fs.writeFile(\n\t\toptsYamlPath,\n\t\t`# This file was automatically generated\\n# It should *not* be source controlled, as it likely contain credentials or other sensitive configuration values.\\n# Values in this file are base64 encoded; https://it-tools.tech/base64-string-converter has an excellent encoder / decoder tool.\\n# Base64 is NOT encryption, and should not be treated as secure\\n${optsYamlContent}`\n\t);\n\n\tconst updatedSource = (await getDatasourceOptions(sourceDir)).find(\n\t\t(r) => r.name === newOptions.name\n\t);\n\n\tif (!updatedSource) throw new Error(`Failed to locate datasource after update`);\n\n\treturn updatedSource;\n}\n","import EventEmitter from 'events';\n\n/** @typedef {\"done\" | \"err\"} ProcessingQueueEvent */\n\n/**\n * @typedef {Object} ProcessingQueueOpts\n * @property {boolean} [stopOnError]\n */\n\n/**\n *\n * @param {ProcessingQueueOpts} param0\n */\nexport const ProcessingQueue = ({ stopOnError } = {}) => {\n\t/** @type {(() => unknown)[]} */\n\tconst queue = [];\n\t/** @type {boolean} */\n\tlet running = false;\n\n\t/** @type {boolean} */\n\tlet frozen = false;\n\n\tconst emitter = new EventEmitter();\n\tif (stopOnError) emitter.addListener('err', () => (frozen = true));\n\n\t/**\n\t * @returns {Promise<void>}\n\t */\n\tconst next = async () => {\n\t\tif (frozen) {\n\t\t\trunning = false;\n\t\t\treturn;\n\t\t}\n\t\trunning = true;\n\t\tif (queue.length) {\n\t\t\ttry {\n\t\t\t\tconst fn = queue.pop();\n\t\t\t\tif (fn === undefined) {\n\t\t\t\t\tconsole.error('Something has gone awry!'); // TODO: This error message sucks\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst result = fn();\n\t\t\t\tif (result instanceof Promise) await result;\n\t\t\t} catch (e) {\n\t\t\t\temitter.emit('err', e);\n\t\t\t}\n\n\t\t\tawait next();\n\t\t} else {\n\t\t\temitter.emit('done');\n\t\t\trunning = false;\n\t\t}\n\t};\n\n\treturn {\n\t\t/**\n\t\t *  @param {Array<() => unknown>}  fn\n\t\t *  @returns {Promise<void>} Promise resolves when the queue has emptied; will throw if an error is encountered\n\t\t */\n\t\tadd(...fn) {\n\t\t\tqueue.push(...fn);\n\t\t\tif (!running) {\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\treturn Promise.resolve();\n\t\t},\n\t\tget frozen() {\n\t\t\treturn frozen;\n\t\t},\n\t\t/**\n\t\t * @param {ProcessingQueueEvent} event\n\t\t * @param {Parameters<EventEmitter[\"addListener\"]>[1]} handler\n\t\t */\n\t\taddListener: (event, handler) => {\n\t\t\temitter.addListener(event, handler);\n\t\t},\n\t\t/**\n\t\t * @param {ProcessingQueueEvent} event\n\t\t * @param {Parameters<EventEmitter[\"removeListener\"]>[1]} handler\n\t\t */\n\t\tremoveListener: (event, handler) => {\n\t\t\temitter.removeListener(event, handler);\n\t\t},\n\t\tremoveAllListeners: emitter.removeAllListeners.bind(emitter),\n\t\tfinish: async () => {\n\t\t\treturn /** @type {Promise<void>} */ (\n\t\t\t\tnew Promise((res, rej) => {\n\t\t\t\t\tif (running) {\n\t\t\t\t\t\temitter.addListener('done', res);\n\t\t\t\t\t\temitter.addListener('err', rej);\n\t\t\t\t\t} else res();\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t};\n};\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../../../"}