import $4S4dR$path1, * as $4S4dR$path from "path";
import $4S4dR$fs, {readFileSync as $4S4dR$readFileSync} from "fs";
import $4S4dR$util from "util";
import {URL as $4S4dR$URL} from "url";
import {release as $4S4dR$release} from "os";
import {isatty as $4S4dR$isatty} from "tty";


      var $parcel$global = globalThis;
    
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire94c2"];

if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire94c2"] = parcelRequire;
}

var parcelRegister = parcelRequire.register;
parcelRegister("4bc8D", function(module, exports) {
module.exports = JSON.parse('{"core":{"meta":{"path":"components/prism-core.js","option":"mandatory"},"core":"Core"},"themes":{"meta":{"path":"themes/{id}.css","link":"index.html?theme={id}","exclusive":true},"prism":{"title":"Default","option":"default"},"prism-dark":"Dark","prism-funky":"Funky","prism-okaidia":{"title":"Okaidia","owner":"ocodia"},"prism-twilight":{"title":"Twilight","owner":"remybach"},"prism-coy":{"title":"Coy","owner":"tshedor"},"prism-solarizedlight":{"title":"Solarized Light","owner":"hectormatos2011 "},"prism-tomorrow":{"title":"Tomorrow Night","owner":"Rosey"}},"languages":{"meta":{"path":"components/prism-{id}","noCSS":true,"examplesPath":"examples/prism-{id}","addCheckAll":true},"markup":{"title":"Markup","alias":["html","xml","svg","mathml","ssml","atom","rss"],"aliasTitles":{"html":"HTML","xml":"XML","svg":"SVG","mathml":"MathML","ssml":"SSML","atom":"Atom","rss":"RSS"},"option":"default"},"css":{"title":"CSS","option":"default","modify":"markup"},"clike":{"title":"C-like","option":"default"},"javascript":{"title":"JavaScript","require":"clike","modify":"markup","optional":"regex","alias":"js","option":"default"},"abap":{"title":"ABAP","owner":"dellagustin"},"abnf":{"title":"ABNF","owner":"RunDevelopment"},"actionscript":{"title":"ActionScript","require":"javascript","modify":"markup","owner":"Golmote"},"ada":{"title":"Ada","owner":"Lucretia"},"agda":{"title":"Agda","owner":"xy-ren"},"al":{"title":"AL","owner":"RunDevelopment"},"antlr4":{"title":"ANTLR4","alias":"g4","owner":"RunDevelopment"},"apacheconf":{"title":"Apache Configuration","owner":"GuiTeK"},"apex":{"title":"Apex","require":["clike","sql"],"owner":"RunDevelopment"},"apl":{"title":"APL","owner":"ngn"},"applescript":{"title":"AppleScript","owner":"Golmote"},"aql":{"title":"AQL","owner":"RunDevelopment"},"arduino":{"title":"Arduino","require":"cpp","alias":"ino","owner":"dkern"},"arff":{"title":"ARFF","owner":"Golmote"},"armasm":{"title":"ARM Assembly","alias":"arm-asm","owner":"RunDevelopment"},"arturo":{"title":"Arturo","alias":"art","optional":["bash","css","javascript","markup","markdown","sql"],"owner":"drkameleon"},"asciidoc":{"alias":"adoc","title":"AsciiDoc","owner":"Golmote"},"aspnet":{"title":"ASP.NET (C#)","require":["markup","csharp"],"owner":"nauzilus"},"asm6502":{"title":"6502 Assembly","owner":"kzurawel"},"asmatmel":{"title":"Atmel AVR Assembly","owner":"cerkit"},"autohotkey":{"title":"AutoHotkey","owner":"aviaryan"},"autoit":{"title":"AutoIt","owner":"Golmote"},"avisynth":{"title":"AviSynth","alias":"avs","owner":"Zinfidel"},"avro-idl":{"title":"Avro IDL","alias":"avdl","owner":"RunDevelopment"},"awk":{"title":"AWK","alias":"gawk","aliasTitles":{"gawk":"GAWK"},"owner":"RunDevelopment"},"bash":{"title":"Bash","alias":["sh","shell"],"aliasTitles":{"sh":"Shell","shell":"Shell"},"owner":"zeitgeist87"},"basic":{"title":"BASIC","owner":"Golmote"},"batch":{"title":"Batch","owner":"Golmote"},"bbcode":{"title":"BBcode","alias":"shortcode","aliasTitles":{"shortcode":"Shortcode"},"owner":"RunDevelopment"},"bbj":{"title":"BBj","owner":"hyyan"},"bicep":{"title":"Bicep","owner":"johnnyreilly"},"birb":{"title":"Birb","require":"clike","owner":"Calamity210"},"bison":{"title":"Bison","require":"c","owner":"Golmote"},"bnf":{"title":"BNF","alias":"rbnf","aliasTitles":{"rbnf":"RBNF"},"owner":"RunDevelopment"},"bqn":{"title":"BQN","owner":"yewscion"},"brainfuck":{"title":"Brainfuck","owner":"Golmote"},"brightscript":{"title":"BrightScript","owner":"RunDevelopment"},"bro":{"title":"Bro","owner":"wayward710"},"bsl":{"title":"BSL (1C:Enterprise)","alias":"oscript","aliasTitles":{"oscript":"OneScript"},"owner":"Diversus23"},"c":{"title":"C","require":"clike","owner":"zeitgeist87"},"csharp":{"title":"C#","require":"clike","alias":["cs","dotnet"],"owner":"mvalipour"},"cpp":{"title":"C++","require":"c","owner":"zeitgeist87"},"cfscript":{"title":"CFScript","require":"clike","alias":"cfc","owner":"mjclemente"},"chaiscript":{"title":"ChaiScript","require":["clike","cpp"],"owner":"RunDevelopment"},"cil":{"title":"CIL","owner":"sbrl"},"cilkc":{"title":"Cilk/C","require":"c","alias":"cilk-c","owner":"OpenCilk"},"cilkcpp":{"title":"Cilk/C++","require":"cpp","alias":["cilk-cpp","cilk"],"owner":"OpenCilk"},"clojure":{"title":"Clojure","owner":"troglotit"},"cmake":{"title":"CMake","owner":"mjrogozinski"},"cobol":{"title":"COBOL","owner":"RunDevelopment"},"coffeescript":{"title":"CoffeeScript","require":"javascript","alias":"coffee","owner":"R-osey"},"concurnas":{"title":"Concurnas","alias":"conc","owner":"jasontatton"},"csp":{"title":"Content-Security-Policy","owner":"ScottHelme"},"cooklang":{"title":"Cooklang","owner":"ahue"},"coq":{"title":"Coq","owner":"RunDevelopment"},"crystal":{"title":"Crystal","require":"ruby","owner":"MakeNowJust"},"css-extras":{"title":"CSS Extras","require":"css","modify":"css","owner":"milesj"},"csv":{"title":"CSV","owner":"RunDevelopment"},"cue":{"title":"CUE","owner":"RunDevelopment"},"cypher":{"title":"Cypher","owner":"RunDevelopment"},"d":{"title":"D","require":"clike","owner":"Golmote"},"dart":{"title":"Dart","require":"clike","owner":"Golmote"},"dataweave":{"title":"DataWeave","owner":"machaval"},"dax":{"title":"DAX","owner":"peterbud"},"dhall":{"title":"Dhall","owner":"RunDevelopment"},"diff":{"title":"Diff","owner":"uranusjr"},"django":{"title":"Django/Jinja2","require":"markup-templating","alias":"jinja2","owner":"romanvm"},"dns-zone-file":{"title":"DNS zone file","owner":"RunDevelopment","alias":"dns-zone"},"docker":{"title":"Docker","alias":"dockerfile","owner":"JustinBeckwith"},"dot":{"title":"DOT (Graphviz)","alias":"gv","optional":"markup","owner":"RunDevelopment"},"ebnf":{"title":"EBNF","owner":"RunDevelopment"},"editorconfig":{"title":"EditorConfig","owner":"osipxd"},"eiffel":{"title":"Eiffel","owner":"Conaclos"},"ejs":{"title":"EJS","require":["javascript","markup-templating"],"owner":"RunDevelopment","alias":"eta","aliasTitles":{"eta":"Eta"}},"elixir":{"title":"Elixir","owner":"Golmote"},"elm":{"title":"Elm","owner":"zwilias"},"etlua":{"title":"Embedded Lua templating","require":["lua","markup-templating"],"owner":"RunDevelopment"},"erb":{"title":"ERB","require":["ruby","markup-templating"],"owner":"Golmote"},"erlang":{"title":"Erlang","owner":"Golmote"},"excel-formula":{"title":"Excel Formula","alias":["xlsx","xls"],"owner":"RunDevelopment"},"fsharp":{"title":"F#","require":"clike","owner":"simonreynolds7"},"factor":{"title":"Factor","owner":"catb0t"},"false":{"title":"False","owner":"edukisto"},"firestore-security-rules":{"title":"Firestore security rules","require":"clike","owner":"RunDevelopment"},"flow":{"title":"Flow","require":"javascript","owner":"Golmote"},"fortran":{"title":"Fortran","owner":"Golmote"},"ftl":{"title":"FreeMarker Template Language","require":"markup-templating","owner":"RunDevelopment"},"gml":{"title":"GameMaker Language","alias":"gamemakerlanguage","require":"clike","owner":"LiarOnce"},"gap":{"title":"GAP (CAS)","owner":"RunDevelopment"},"gcode":{"title":"G-code","owner":"RunDevelopment"},"gdscript":{"title":"GDScript","owner":"RunDevelopment"},"gedcom":{"title":"GEDCOM","owner":"Golmote"},"gettext":{"title":"gettext","alias":"po","owner":"RunDevelopment"},"gherkin":{"title":"Gherkin","owner":"hason"},"git":{"title":"Git","owner":"lgiraudel"},"glsl":{"title":"GLSL","require":"c","owner":"Golmote"},"gn":{"title":"GN","alias":"gni","owner":"RunDevelopment"},"linker-script":{"title":"GNU Linker Script","alias":"ld","owner":"RunDevelopment"},"go":{"title":"Go","require":"clike","owner":"arnehormann"},"go-module":{"title":"Go module","alias":"go-mod","owner":"RunDevelopment"},"gradle":{"title":"Gradle","require":"clike","owner":"zeabdelkhalek-badido18"},"graphql":{"title":"GraphQL","optional":"markdown","owner":"Golmote"},"groovy":{"title":"Groovy","require":"clike","owner":"robfletcher"},"haml":{"title":"Haml","require":"ruby","optional":["css","css-extras","coffeescript","erb","javascript","less","markdown","scss","textile"],"owner":"Golmote"},"handlebars":{"title":"Handlebars","require":"markup-templating","alias":["hbs","mustache"],"aliasTitles":{"mustache":"Mustache"},"owner":"Golmote"},"haskell":{"title":"Haskell","alias":"hs","owner":"bholst"},"haxe":{"title":"Haxe","require":"clike","optional":"regex","owner":"Golmote"},"hcl":{"title":"HCL","owner":"outsideris"},"hlsl":{"title":"HLSL","require":"c","owner":"RunDevelopment"},"hoon":{"title":"Hoon","owner":"matildepark"},"http":{"title":"HTTP","optional":["csp","css","hpkp","hsts","javascript","json","markup","uri"],"owner":"danielgtaylor"},"hpkp":{"title":"HTTP Public-Key-Pins","owner":"ScottHelme"},"hsts":{"title":"HTTP Strict-Transport-Security","owner":"ScottHelme"},"ichigojam":{"title":"IchigoJam","owner":"BlueCocoa"},"icon":{"title":"Icon","owner":"Golmote"},"icu-message-format":{"title":"ICU Message Format","owner":"RunDevelopment"},"idris":{"title":"Idris","alias":"idr","owner":"KeenS","require":"haskell"},"ignore":{"title":".ignore","owner":"osipxd","alias":["gitignore","hgignore","npmignore"],"aliasTitles":{"gitignore":".gitignore","hgignore":".hgignore","npmignore":".npmignore"}},"inform7":{"title":"Inform 7","owner":"Golmote"},"ini":{"title":"Ini","owner":"aviaryan"},"io":{"title":"Io","owner":"AlesTsurko"},"j":{"title":"J","owner":"Golmote"},"java":{"title":"Java","require":"clike","owner":"sherblot"},"javadoc":{"title":"JavaDoc","require":["markup","java","javadoclike"],"modify":"java","optional":"scala","owner":"RunDevelopment"},"javadoclike":{"title":"JavaDoc-like","modify":["java","javascript","php"],"owner":"RunDevelopment"},"javastacktrace":{"title":"Java stack trace","owner":"RunDevelopment"},"jexl":{"title":"Jexl","owner":"czosel"},"jolie":{"title":"Jolie","require":"clike","owner":"thesave"},"jq":{"title":"JQ","owner":"RunDevelopment"},"jsdoc":{"title":"JSDoc","require":["javascript","javadoclike","typescript"],"modify":"javascript","optional":["actionscript","coffeescript"],"owner":"RunDevelopment"},"js-extras":{"title":"JS Extras","require":"javascript","modify":"javascript","optional":["actionscript","coffeescript","flow","n4js","typescript"],"owner":"RunDevelopment"},"json":{"title":"JSON","alias":"webmanifest","aliasTitles":{"webmanifest":"Web App Manifest"},"owner":"CupOfTea696"},"json5":{"title":"JSON5","require":"json","owner":"RunDevelopment"},"jsonp":{"title":"JSONP","require":"json","owner":"RunDevelopment"},"jsstacktrace":{"title":"JS stack trace","owner":"sbrl"},"js-templates":{"title":"JS Templates","require":"javascript","modify":"javascript","optional":["css","css-extras","graphql","markdown","markup","sql"],"owner":"RunDevelopment"},"julia":{"title":"Julia","owner":"cdagnino"},"keepalived":{"title":"Keepalived Configure","owner":"dev-itsheng"},"keyman":{"title":"Keyman","owner":"mcdurdin"},"kotlin":{"title":"Kotlin","alias":["kt","kts"],"aliasTitles":{"kts":"Kotlin Script"},"require":"clike","owner":"Golmote"},"kumir":{"title":"KuMir (\u041A\u0443\u041C\u0438\u0440)","alias":"kum","owner":"edukisto"},"kusto":{"title":"Kusto","owner":"RunDevelopment"},"latex":{"title":"LaTeX","alias":["tex","context"],"aliasTitles":{"tex":"TeX","context":"ConTeXt"},"owner":"japborst"},"latte":{"title":"Latte","require":["clike","markup-templating","php"],"owner":"nette"},"less":{"title":"Less","require":"css","optional":"css-extras","owner":"Golmote"},"lilypond":{"title":"LilyPond","require":"scheme","alias":"ly","owner":"RunDevelopment"},"liquid":{"title":"Liquid","require":"markup-templating","owner":"cinhtau"},"lisp":{"title":"Lisp","alias":["emacs","elisp","emacs-lisp"],"owner":"JuanCaicedo"},"livescript":{"title":"LiveScript","owner":"Golmote"},"llvm":{"title":"LLVM IR","owner":"porglezomp"},"log":{"title":"Log file","optional":"javastacktrace","owner":"RunDevelopment"},"lolcode":{"title":"LOLCODE","owner":"Golmote"},"lua":{"title":"Lua","owner":"Golmote"},"magma":{"title":"Magma (CAS)","owner":"RunDevelopment"},"makefile":{"title":"Makefile","owner":"Golmote"},"markdown":{"title":"Markdown","require":"markup","optional":"yaml","alias":"md","owner":"Golmote"},"markup-templating":{"title":"Markup templating","require":"markup","owner":"Golmote"},"mata":{"title":"Mata","owner":"RunDevelopment"},"matlab":{"title":"MATLAB","owner":"Golmote"},"maxscript":{"title":"MAXScript","owner":"RunDevelopment"},"mel":{"title":"MEL","owner":"Golmote"},"mermaid":{"title":"Mermaid","owner":"RunDevelopment"},"metafont":{"title":"METAFONT","owner":"LaeriExNihilo"},"mizar":{"title":"Mizar","owner":"Golmote"},"mongodb":{"title":"MongoDB","owner":"airs0urce","require":"javascript"},"monkey":{"title":"Monkey","owner":"Golmote"},"moonscript":{"title":"MoonScript","alias":"moon","owner":"RunDevelopment"},"n1ql":{"title":"N1QL","owner":"TMWilds"},"n4js":{"title":"N4JS","require":"javascript","optional":"jsdoc","alias":"n4jsd","owner":"bsmith-n4"},"nand2tetris-hdl":{"title":"Nand To Tetris HDL","owner":"stephanmax"},"naniscript":{"title":"Naninovel Script","owner":"Elringus","alias":"nani"},"nasm":{"title":"NASM","owner":"rbmj"},"neon":{"title":"NEON","owner":"nette"},"nevod":{"title":"Nevod","owner":"nezaboodka"},"nginx":{"title":"nginx","owner":"volado"},"nim":{"title":"Nim","owner":"Golmote"},"nix":{"title":"Nix","owner":"Golmote"},"nsis":{"title":"NSIS","owner":"idleberg"},"objectivec":{"title":"Objective-C","require":"c","alias":"objc","owner":"uranusjr"},"ocaml":{"title":"OCaml","owner":"Golmote"},"odin":{"title":"Odin","owner":"edukisto"},"opencl":{"title":"OpenCL","require":"c","modify":["c","cpp"],"owner":"Milania1"},"openqasm":{"title":"OpenQasm","alias":"qasm","owner":"RunDevelopment"},"oz":{"title":"Oz","owner":"Golmote"},"parigp":{"title":"PARI/GP","owner":"Golmote"},"parser":{"title":"Parser","require":"markup","owner":"Golmote"},"pascal":{"title":"Pascal","alias":"objectpascal","aliasTitles":{"objectpascal":"Object Pascal"},"owner":"Golmote"},"pascaligo":{"title":"Pascaligo","owner":"DefinitelyNotAGoat"},"psl":{"title":"PATROL Scripting Language","owner":"bertysentry"},"pcaxis":{"title":"PC-Axis","alias":"px","owner":"RunDevelopment"},"peoplecode":{"title":"PeopleCode","alias":"pcode","owner":"RunDevelopment"},"perl":{"title":"Perl","owner":"Golmote"},"php":{"title":"PHP","require":"markup-templating","owner":"milesj"},"phpdoc":{"title":"PHPDoc","require":["php","javadoclike"],"modify":"php","owner":"RunDevelopment"},"php-extras":{"title":"PHP Extras","require":"php","modify":"php","owner":"milesj"},"plant-uml":{"title":"PlantUML","alias":"plantuml","owner":"RunDevelopment"},"plsql":{"title":"PL/SQL","require":"sql","owner":"Golmote"},"powerquery":{"title":"PowerQuery","alias":["pq","mscript"],"owner":"peterbud"},"powershell":{"title":"PowerShell","owner":"nauzilus"},"processing":{"title":"Processing","require":"clike","owner":"Golmote"},"prolog":{"title":"Prolog","owner":"Golmote"},"promql":{"title":"PromQL","owner":"arendjr"},"properties":{"title":".properties","owner":"Golmote"},"protobuf":{"title":"Protocol Buffers","require":"clike","owner":"just-boris"},"pug":{"title":"Pug","require":["markup","javascript"],"optional":["coffeescript","ejs","handlebars","less","livescript","markdown","scss","stylus","twig"],"owner":"Golmote"},"puppet":{"title":"Puppet","owner":"Golmote"},"pure":{"title":"Pure","optional":["c","cpp","fortran"],"owner":"Golmote"},"purebasic":{"title":"PureBasic","require":"clike","alias":"pbfasm","owner":"HeX0R101"},"purescript":{"title":"PureScript","require":"haskell","alias":"purs","owner":"sriharshachilakapati"},"python":{"title":"Python","alias":"py","owner":"multipetros"},"qsharp":{"title":"Q#","require":"clike","alias":"qs","owner":"fedonman"},"q":{"title":"Q (kdb+ database)","owner":"Golmote"},"qml":{"title":"QML","require":"javascript","owner":"RunDevelopment"},"qore":{"title":"Qore","require":"clike","owner":"temnroegg"},"r":{"title":"R","owner":"Golmote"},"racket":{"title":"Racket","require":"scheme","alias":"rkt","owner":"RunDevelopment"},"cshtml":{"title":"Razor C#","alias":"razor","require":["markup","csharp"],"optional":["css","css-extras","javascript","js-extras"],"owner":"RunDevelopment"},"jsx":{"title":"React JSX","require":["markup","javascript"],"optional":["jsdoc","js-extras","js-templates"],"owner":"vkbansal"},"tsx":{"title":"React TSX","require":["jsx","typescript"]},"reason":{"title":"Reason","require":"clike","owner":"Golmote"},"regex":{"title":"Regex","owner":"RunDevelopment"},"rego":{"title":"Rego","owner":"JordanSh"},"renpy":{"title":"Ren\'py","alias":"rpy","owner":"HyuchiaDiego"},"rescript":{"title":"ReScript","alias":"res","owner":"vmarcosp"},"rest":{"title":"reST (reStructuredText)","owner":"Golmote"},"rip":{"title":"Rip","owner":"ravinggenius"},"roboconf":{"title":"Roboconf","owner":"Golmote"},"robotframework":{"title":"Robot Framework","alias":"robot","owner":"RunDevelopment"},"ruby":{"title":"Ruby","require":"clike","alias":"rb","owner":"samflores"},"rust":{"title":"Rust","owner":"Golmote"},"sas":{"title":"SAS","optional":["groovy","lua","sql"],"owner":"Golmote"},"sass":{"title":"Sass (Sass)","require":"css","optional":"css-extras","owner":"Golmote"},"scss":{"title":"Sass (SCSS)","require":"css","optional":"css-extras","owner":"MoOx"},"scala":{"title":"Scala","require":"java","owner":"jozic"},"scheme":{"title":"Scheme","owner":"bacchus123"},"shell-session":{"title":"Shell session","require":"bash","alias":["sh-session","shellsession"],"owner":"RunDevelopment"},"smali":{"title":"Smali","owner":"RunDevelopment"},"smalltalk":{"title":"Smalltalk","owner":"Golmote"},"smarty":{"title":"Smarty","require":"markup-templating","optional":"php","owner":"Golmote"},"sml":{"title":"SML","alias":"smlnj","aliasTitles":{"smlnj":"SML/NJ"},"owner":"RunDevelopment"},"solidity":{"title":"Solidity (Ethereum)","alias":"sol","require":"clike","owner":"glachaud"},"solution-file":{"title":"Solution file","alias":"sln","owner":"RunDevelopment"},"soy":{"title":"Soy (Closure Template)","require":"markup-templating","owner":"Golmote"},"sparql":{"title":"SPARQL","require":"turtle","owner":"Triply-Dev","alias":"rq"},"splunk-spl":{"title":"Splunk SPL","owner":"RunDevelopment"},"sqf":{"title":"SQF: Status Quo Function (Arma 3)","require":"clike","owner":"RunDevelopment"},"sql":{"title":"SQL","owner":"multipetros"},"squirrel":{"title":"Squirrel","require":"clike","owner":"RunDevelopment"},"stan":{"title":"Stan","owner":"RunDevelopment"},"stata":{"title":"Stata Ado","require":["mata","java","python"],"owner":"RunDevelopment"},"iecst":{"title":"Structured Text (IEC 61131-3)","owner":"serhioromano"},"stylus":{"title":"Stylus","owner":"vkbansal"},"supercollider":{"title":"SuperCollider","alias":"sclang","owner":"RunDevelopment"},"swift":{"title":"Swift","owner":"chrischares"},"systemd":{"title":"Systemd configuration file","owner":"RunDevelopment"},"t4-templating":{"title":"T4 templating","owner":"RunDevelopment"},"t4-cs":{"title":"T4 Text Templates (C#)","require":["t4-templating","csharp"],"alias":"t4","owner":"RunDevelopment"},"t4-vb":{"title":"T4 Text Templates (VB)","require":["t4-templating","vbnet"],"owner":"RunDevelopment"},"tap":{"title":"TAP","owner":"isaacs","require":"yaml"},"tcl":{"title":"Tcl","owner":"PeterChaplin"},"tt2":{"title":"Template Toolkit 2","require":["clike","markup-templating"],"owner":"gflohr"},"textile":{"title":"Textile","require":"markup","optional":"css","owner":"Golmote"},"toml":{"title":"TOML","owner":"RunDevelopment"},"tremor":{"title":"Tremor","alias":["trickle","troy"],"owner":"darach","aliasTitles":{"trickle":"trickle","troy":"troy"}},"turtle":{"title":"Turtle","alias":"trig","aliasTitles":{"trig":"TriG"},"owner":"jakubklimek"},"twig":{"title":"Twig","require":"markup-templating","owner":"brandonkelly"},"typescript":{"title":"TypeScript","require":"javascript","optional":"js-templates","alias":"ts","owner":"vkbansal"},"typoscript":{"title":"TypoScript","alias":"tsconfig","aliasTitles":{"tsconfig":"TSConfig"},"owner":"dkern"},"unrealscript":{"title":"UnrealScript","alias":["uscript","uc"],"owner":"RunDevelopment"},"uorazor":{"title":"UO Razor Script","owner":"jaseowns"},"uri":{"title":"URI","alias":"url","aliasTitles":{"url":"URL"},"owner":"RunDevelopment"},"v":{"title":"V","require":"clike","owner":"taggon"},"vala":{"title":"Vala","require":"clike","optional":"regex","owner":"TemplarVolk"},"vbnet":{"title":"VB.Net","require":"basic","owner":"Bigsby"},"velocity":{"title":"Velocity","require":"markup","owner":"Golmote"},"verilog":{"title":"Verilog","owner":"a-rey"},"vhdl":{"title":"VHDL","owner":"a-rey"},"vim":{"title":"vim","owner":"westonganger"},"visual-basic":{"title":"Visual Basic","alias":["vb","vba"],"aliasTitles":{"vba":"VBA"},"owner":"Golmote"},"warpscript":{"title":"WarpScript","owner":"RunDevelopment"},"wasm":{"title":"WebAssembly","owner":"Golmote"},"web-idl":{"title":"Web IDL","alias":"webidl","owner":"RunDevelopment"},"wgsl":{"title":"WGSL","owner":"Dr4gonthree"},"wiki":{"title":"Wiki markup","require":"markup","owner":"Golmote"},"wolfram":{"title":"Wolfram language","alias":["mathematica","nb","wl"],"aliasTitles":{"mathematica":"Mathematica","nb":"Mathematica Notebook"},"owner":"msollami"},"wren":{"title":"Wren","owner":"clsource"},"xeora":{"title":"Xeora","require":"markup","alias":"xeoracube","aliasTitles":{"xeoracube":"XeoraCube"},"owner":"freakmaxi"},"xml-doc":{"title":"XML doc (.net)","require":"markup","modify":["csharp","fsharp","vbnet"],"owner":"RunDevelopment"},"xojo":{"title":"Xojo (REALbasic)","owner":"Golmote"},"xquery":{"title":"XQuery","require":"markup","owner":"Golmote"},"yaml":{"title":"YAML","alias":"yml","owner":"hason"},"yang":{"title":"YANG","owner":"RunDevelopment"},"zig":{"title":"Zig","owner":"RunDevelopment"}},"plugins":{"meta":{"path":"plugins/{id}/prism-{id}","link":"plugins/{id}/"},"line-highlight":{"title":"Line Highlight","description":"Highlights specific lines and/or line ranges."},"line-numbers":{"title":"Line Numbers","description":"Line number at the beginning of code lines.","owner":"kuba-kubula"},"show-invisibles":{"title":"Show Invisibles","description":"Show hidden characters such as tabs and line breaks.","optional":["autolinker","data-uri-highlight"]},"autolinker":{"title":"Autolinker","description":"Converts URLs and emails in code to clickable links. Parses Markdown links in comments."},"wpd":{"title":"WebPlatform Docs","description":"Makes tokens link to <a href=\\"https://webplatform.github.io/docs/\\">WebPlatform.org documentation</a>. The links open in a new tab."},"custom-class":{"title":"Custom Class","description":"This plugin allows you to prefix Prism\'s default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.","owner":"dvkndn","noCSS":true},"file-highlight":{"title":"File Highlight","description":"Fetch external files and highlight them with Prism. Used on the Prism website itself.","noCSS":true},"show-language":{"title":"Show Language","description":"Display the highlighted language in code blocks (inline code does not show the label).","owner":"nauzilus","noCSS":true,"require":"toolbar"},"jsonp-highlight":{"title":"JSONP Highlight","description":"Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).","noCSS":true,"owner":"nauzilus"},"highlight-keywords":{"title":"Highlight Keywords","description":"Adds special CSS classes for each keyword for fine-grained highlighting.","owner":"vkbansal","noCSS":true},"remove-initial-line-feed":{"title":"Remove initial line feed","description":"Removes the initial line feed in code blocks.","owner":"Golmote","noCSS":true},"inline-color":{"title":"Inline color","description":"Adds a small inline preview for colors in style sheets.","require":"css-extras","owner":"RunDevelopment"},"previewers":{"title":"Previewers","description":"Previewers for angles, colors, gradients, easing and time.","require":"css-extras","owner":"Golmote"},"autoloader":{"title":"Autoloader","description":"Automatically loads the needed languages to highlight the code blocks.","owner":"Golmote","noCSS":true},"keep-markup":{"title":"Keep Markup","description":"Prevents custom markup from being dropped out during highlighting.","owner":"Golmote","optional":"normalize-whitespace","noCSS":true},"command-line":{"title":"Command Line","description":"Display a command line with a prompt and, optionally, the output/response from the commands.","owner":"chriswells0"},"unescaped-markup":{"title":"Unescaped Markup","description":"Write markup without having to escape anything."},"normalize-whitespace":{"title":"Normalize Whitespace","description":"Supports multiple operations to normalize whitespace in code blocks.","owner":"zeitgeist87","optional":"unescaped-markup","noCSS":true},"data-uri-highlight":{"title":"Data-URI Highlight","description":"Highlights data-URI contents.","owner":"Golmote","noCSS":true},"toolbar":{"title":"Toolbar","description":"Attach a toolbar for plugins to easily register buttons on the top of a code block.","owner":"mAAdhaTTah"},"copy-to-clipboard":{"title":"Copy to Clipboard Button","description":"Add a button that copies the code block to the clipboard when clicked.","owner":"mAAdhaTTah","require":"toolbar","noCSS":true},"download-button":{"title":"Download Button","description":"A button in the toolbar of a code block adding a convenient way to download a code file.","owner":"Golmote","require":"toolbar","noCSS":true},"match-braces":{"title":"Match braces","description":"Highlights matching braces.","owner":"RunDevelopment"},"diff-highlight":{"title":"Diff Highlight","description":"Highlights the code inside diff blocks.","owner":"RunDevelopment","require":"diff"},"filter-highlight-all":{"title":"Filter highlightAll","description":"Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.","owner":"RunDevelopment","noCSS":true},"treeview":{"title":"Treeview","description":"A language with special styles to highlight file system tree structures.","owner":"Golmote"}}}');

});

parcelRegister("4wAom", function(module, exports) {
/* **********************************************
     Begin prism-core.js
********************************************** */ /// <reference lib="WebWorker"/>
var $34b6613fd50afc6a$var$_self = typeof window !== "undefined" ? window // if in browser
 : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self // if in worker
 : {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var $34b6613fd50afc6a$var$Prism = function(_self) {
    // Private helper vars
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    // The grammar object for plaintext
    var plainTextGrammar = {};
    var _ = {
        /**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ manual: _self.Prism && _self.Prism.manual,
        /**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        /**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */ util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) return new Token(tokens.type, encode(tokens.content), tokens.alias);
                else if (Array.isArray(tokens)) return tokens.map(encode);
                else return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            /**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */ type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */ objId: function(obj) {
                if (!obj["__id"]) Object.defineProperty(obj, "__id", {
                    value: ++uniqueId
                });
                return obj["__id"];
            },
            /**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */ clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone;
                var id;
                switch(_.util.type(o)){
                    case "Object":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = /** @type {Record<string, any>} */ {};
                        visited[id] = clone;
                        for(var key in o)if (o.hasOwnProperty(key)) clone[key] = deepClone(o[key], visited);
                        return /** @type {any} */ clone;
                    case "Array":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = [];
                        visited[id] = clone;
                        /** @type {any} */ o.forEach(function(v, i) {
                            clone[i] = deepClone(v, visited);
                        });
                        return /** @type {any} */ clone;
                    default:
                        return o;
                }
            },
            /**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */ getLanguage: function(element) {
                while(element){
                    var m = lang.exec(element.className);
                    if (m) return m[1].toLowerCase();
                    element = element.parentElement;
                }
                return "none";
            },
            /**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */ setLanguage: function(element, language) {
                // remove all `language-xxxx` classes
                // (this might leave behind a leading space)
                element.className = element.className.replace(RegExp(lang, "gi"), "");
                // add the new `language-xxxx` class
                // (using `classList` will automatically clean up spaces for us)
                element.classList.add("language-" + language);
            },
            /**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */ currentScript: function() {
                if (typeof document === "undefined") return null;
                if ("currentScript" in document && true /* hack to trip TS' flow analysis */ ) return /** @type {any} */ document.currentScript;
                // IE11 workaround
                // we'll get the src of the current script by parsing IE11's error stack trace
                // this will not work for inline scripts
                try {
                    throw new Error();
                } catch (err) {
                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                    // A stack will look like this:
                    //
                    // Error
                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for(var i in scripts){
                            if (scripts[i].src == src) return scripts[i];
                        }
                    }
                    return null;
                }
            },
            /**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */ isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while(element){
                    var classList = element.classList;
                    if (classList.contains(className)) return true;
                    if (classList.contains(no)) return false;
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        /**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ languages: {
            /**
			 * The grammar for plain, unformatted text.
			 */ plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */ extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for(var key in redef)lang[key] = redef[key];
                return lang;
            },
            /**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */ insertBefore: function(inside, before, insert, root) {
                root = root || /** @type {any} */ _.languages;
                var grammar = root[inside];
                /** @type {Grammar} */ var ret = {};
                for(var token in grammar)if (grammar.hasOwnProperty(token)) {
                    if (token == before) {
                        for(var newToken in insert)if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];
                    }
                    // Do not insert token which also occur in insert. See #1525
                    if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];
                }
                var old = root[inside];
                root[inside] = ret;
                // Update references in other language definitions
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) this[key] = ret;
                });
                return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for(var i in o)if (o.hasOwnProperty(i)) {
                    callback.call(o, i, o[i], type || i);
                    var property = o[i];
                    var propertyType = _.util.type(property);
                    if (propertyType === "Object" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, null, visited);
                    } else if (propertyType === "Array" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, i, visited);
                    }
                }
            }
        },
        plugins: {},
        /**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */ highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        /**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */ highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for(var i = 0, element; element = env.elements[i++];)_.highlightElement(element, async === true, env.callback);
        },
        /**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */ highlightElement: function(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            // Set language on the element, if not present
            _.util.setLanguage(element, language);
            // Set language on the parent, for styling
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") _.util.setLanguage(parent, language);
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            // plugins may change/add the parent/element
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) parent.setAttribute("tabindex", "0");
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        },
        /**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */ highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) throw new Error('The language "' + env.language + '" has no grammar.');
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */ tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for(var token in rest)grammar[token] = rest[token];
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        /**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ hooks: {
            all: {},
            /**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */ add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            /**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */ run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) return;
                for(var i = 0, callback; callback = callbacks[i++];)callback(env);
            }
        },
        Token: Token
    };
    _self.Prism = _;
    // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
    /**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */ function Token(type, content, alias, matchedStr) {
        /**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */ this.type = type;
        /**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */ this.content = content;
        /**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */ this.alias = alias;
        // Copy of the full string this token was created from
        this.length = (matchedStr || "").length | 0;
    }
    /**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */ /**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */ Token.stringify = function stringify(o, language) {
        if (typeof o == "string") return o;
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [
                "token",
                o.type
            ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) Array.prototype.push.apply(env.classes, aliases);
            else env.classes.push(aliases);
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for(var name in env.attributes)attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    /**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */ function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    /**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for(var token in grammar){
            if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [
                patterns
            ];
            for(var j = 0; j < patterns.length; ++j){
                if (rematch && rematch.cause == token + "," + j) return;
                var patternObj = patterns[j];
                var inside = patternObj.inside;
                var lookbehind = !!patternObj.lookbehind;
                var greedy = !!patternObj.greedy;
                var alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    // Without the global flag, lastIndex won't work
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;
                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){
                    if (rematch && pos >= rematch.reach) break;
                    var str = currentNode.value;
                    if (tokenList.length > text.length) // Something went terribly wrong, ABORT, ABORT!
                    return;
                    if (str instanceof Token) continue;
                    var removeCount = 1; // this is the to parameter of removeBetween
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match || match.index >= text.length) break;
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        // find the node that contains the match
                        p += currentNode.value.length;
                        while(from >= p){
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        // adjust pos (and p)
                        p -= currentNode.value.length;
                        pos = p;
                        // the current node is a Token, then the match starts inside another Token, which is invalid
                        if (currentNode.value instanceof Token) continue;
                        // find the last node which is affected by this match
                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next){
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        // replace with the new match
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) continue;
                    }
                    // eslint-disable-next-line no-redeclare
                    var from = match.index;
                    var matchStr = match[0];
                    var before = str.slice(0, from);
                    var after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) rematch.reach = reach;
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) addAfter(tokenList, currentNode, after);
                    if (removeCount > 1) {
                        // at least one Token object was removed, so we have to do some rematching
                        // this can only happen if the current pattern is greedy
                        /** @type {RematchOptions} */ var nestedRematch = {
                            cause: token + "," + j,
                            reach: reach
                        };
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                        // the reach might have been extended because of the rematching
                        if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;
                    }
                }
            }
        }
    }
    /**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */ /**
	 * @template T
	 * @private
	 */ function LinkedList() {
        /** @type {LinkedListNode<T>} */ var head = {
            value: null,
            prev: null,
            next: null
        };
        /** @type {LinkedListNode<T>} */ var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        /** @type {LinkedListNode<T>} */ this.head = head;
        /** @type {LinkedListNode<T>} */ this.tail = tail;
        this.length = 0;
    }
    /**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */ function addAfter(list, node, value) {
        // assumes that node != list.tail && values.length >= 0
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    /**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */ function removeRange(list, node, count) {
        var next = node.next;
        for(var i = 0; i < count && next !== list.tail; i++)next = next.next;
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    /**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */ function toArray(list) {
        var array = [];
        var node = list.head.next;
        while(node !== list.tail){
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self.document) {
        if (!_self.addEventListener) // in Node.js
        return _;
        if (!_.disableWorkerMessageHandler) // In worker
        _self.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self.postMessage(_.highlight(code, _.languages[lang], lang));
            if (immediateClose) _self.close();
        }, false);
        return _;
    }
    // Get current script and highlight
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) _.manual = true;
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) _.highlightAll();
    }
    if (!_.manual) {
        // If the document state is "loading", then we'll use DOMContentLoaded.
        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
        // might take longer one animation frame to execute which can create a race condition where only some plugins have
        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
        // See https://github.com/PrismJS/prism/issues/2102
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        else if (window.requestAnimationFrame) window.requestAnimationFrame(highlightAutomaticallyCallback);
        else window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
}($34b6613fd50afc6a$var$_self);
if (0, module.exports) module.exports = $34b6613fd50afc6a$var$Prism;
// hack for components to work correctly in node.js
if (typeof $parcel$global !== "undefined") $parcel$global.Prism = $34b6613fd50afc6a$var$Prism;
// some additional documentation/types
/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */ /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */ /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */ /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */ /* **********************************************
     Begin prism-markup.js
********************************************** */ $34b6613fd50afc6a$var$Prism.languages.markup = {
    "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
    },
    "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
    },
    "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: true,
                greedy: true,
                inside: null // see below
            },
            "string": {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
        }
    },
    "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
    },
    "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
            "tag": {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    "punctuation": /^<\/?/,
                    "namespace": /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    "punctuation": [
                        {
                            pattern: /^=/,
                            alias: "attr-equals"
                        },
                        {
                            pattern: /^(\s*)["']|["']$/,
                            lookbehind: true
                        }
                    ]
                }
            },
            "punctuation": /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    "namespace": /^[^\s>\/:]+:/
                }
            }
        }
    },
    "entity": [
        {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
    ]
};
$34b6613fd50afc6a$var$Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = $34b6613fd50afc6a$var$Prism.languages.markup["entity"];
$34b6613fd50afc6a$var$Prism.languages.markup["doctype"].inside["internal-subset"].inside = $34b6613fd50afc6a$var$Prism.languages.markup;
// Plugin to make entity title show the real entity, idea by Roman Komarov
$34b6613fd50afc6a$var$Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") env.attributes["title"] = env.content.replace(/&amp;/, "&");
});
Object.defineProperty($34b6613fd50afc6a$var$Prism.languages.markup.tag, "addInlined", {
    /**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */ value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: $34b6613fd50afc6a$var$Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: $34b6613fd50afc6a$var$Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside: inside
        };
        $34b6613fd50afc6a$var$Prism.languages.insertBefore("markup", "cdata", def);
    }
});
Object.defineProperty($34b6613fd50afc6a$var$Prism.languages.markup.tag, "addAttribute", {
    /**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */ value: function(attrName, lang) {
        $34b6613fd50afc6a$var$Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
            lookbehind: true,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        "value": {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: true,
                            alias: [
                                lang,
                                "language-" + lang
                            ],
                            inside: $34b6613fd50afc6a$var$Prism.languages[lang]
                        },
                        "punctuation": [
                            {
                                pattern: /^=/,
                                alias: "attr-equals"
                            },
                            /"|'/
                        ]
                    }
                }
            }
        });
    }
});
$34b6613fd50afc6a$var$Prism.languages.html = $34b6613fd50afc6a$var$Prism.languages.markup;
$34b6613fd50afc6a$var$Prism.languages.mathml = $34b6613fd50afc6a$var$Prism.languages.markup;
$34b6613fd50afc6a$var$Prism.languages.svg = $34b6613fd50afc6a$var$Prism.languages.markup;
$34b6613fd50afc6a$var$Prism.languages.xml = $34b6613fd50afc6a$var$Prism.languages.extend("markup", {});
$34b6613fd50afc6a$var$Prism.languages.ssml = $34b6613fd50afc6a$var$Prism.languages.xml;
$34b6613fd50afc6a$var$Prism.languages.atom = $34b6613fd50afc6a$var$Prism.languages.xml;
$34b6613fd50afc6a$var$Prism.languages.rss = $34b6613fd50afc6a$var$Prism.languages.xml;
/* **********************************************
     Begin prism-css.js
********************************************** */ (function(Prism) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
                "rule": /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                    lookbehind: true,
                    alias: "selector"
                },
                "keyword": {
                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                    lookbehind: true
                }
            }
        },
        "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
                "function": /^url/i,
                "punctuation": /^\(|\)$/,
                "string": {
                    pattern: RegExp("^" + string.source + "$"),
                    alias: "url"
                }
            }
        },
        "selector": {
            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
        },
        "string": {
            pattern: string,
            greedy: true
        },
        "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
        },
        "punctuation": /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
    }
})($34b6613fd50afc6a$var$Prism);
/* **********************************************
     Begin prism-clike.js
********************************************** */ $34b6613fd50afc6a$var$Prism.languages.clike = {
    "comment": [
        {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
        },
        {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
        }
    ],
    "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
            "punctuation": /[.\\]/
        }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
};
/* **********************************************
     Begin prism-javascript.js
********************************************** */ $34b6613fd50afc6a$var$Prism.languages.javascript = $34b6613fd50afc6a$var$Prism.languages.extend("clike", {
    "class-name": [
        $34b6613fd50afc6a$var$Prism.languages.clike["class-name"],
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
        }
    ],
    "keyword": [
        {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
        },
        {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
        }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
        lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
$34b6613fd50afc6a$var$Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
$34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
        pattern: RegExp(// lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
        lookbehind: true,
        greedy: true,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: $34b6613fd50afc6a$var$Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    "parameter": [
        {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: $34b6613fd50afc6a$var$Prism.languages.javascript
        },
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: $34b6613fd50afc6a$var$Prism.languages.javascript
        },
        {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: $34b6613fd50afc6a$var$Prism.languages.javascript
        },
        {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: $34b6613fd50afc6a$var$Prism.languages.javascript
        }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
$34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            "interpolation": {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: $34b6613fd50afc6a$var$Prism.languages.javascript
                }
            },
            "string": /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
    }
});
$34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
    }
});
if ($34b6613fd50afc6a$var$Prism.languages.markup) {
    $34b6613fd50afc6a$var$Prism.languages.markup.tag.addInlined("script", "javascript");
    // add attribute support for all DOM events.
    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    $34b6613fd50afc6a$var$Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
$34b6613fd50afc6a$var$Prism.languages.js = $34b6613fd50afc6a$var$Prism.languages.javascript;
/* **********************************************
     Begin prism-file-highlight.js
********************************************** */ (function() {
    if (typeof $34b6613fd50afc6a$var$Prism === "undefined" || typeof document === "undefined") return;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var LOADING_MESSAGE = "Loading\u2026";
    var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
    var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ":not([" + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    /**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */ function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status < 400 && xhr.responseText) success(xhr.responseText);
                else if (xhr.status >= 400) error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                else error(FAILURE_EMPTY_MESSAGE);
            }
        };
        xhr.send(null);
    }
    /**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */ function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
            var start = Number(m[1]);
            var comma = m[2];
            var end = m[3];
            if (!comma) return [
                start,
                start
            ];
            if (!end) return [
                start,
                undefined
            ];
            return [
                start,
                Number(end)
            ];
        }
        return undefined;
    }
    $34b6613fd50afc6a$var$Prism.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
    });
    $34b6613fd50afc6a$var$Prism.hooks.add("before-sanity-check", function(env) {
        var pre = /** @type {HTMLPreElement} */ env.element;
        if (pre.matches(SELECTOR)) {
            env.code = ""; // fast-path the whole thing and go to complete
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
            // add code element with loading message
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env.language;
            if (language === "none") {
                // the language might be 'none' because there is no language set;
                // in this case, we want to use the extension as the language
                var extension = (/\.(\w+)$/.exec(src) || [
                    ,
                    "none"
                ])[1];
                language = EXTENSIONS[extension] || extension;
            }
            // set language classes
            $34b6613fd50afc6a$var$Prism.util.setLanguage(code, language);
            $34b6613fd50afc6a$var$Prism.util.setLanguage(pre, language);
            // preload the language
            var autoloader = $34b6613fd50afc6a$var$Prism.plugins.autoloader;
            if (autoloader) autoloader.loadLanguages(language);
            // load file
            loadFile(src, function(text) {
                // mark as loaded
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                // handle data-range
                var range = parseRange(pre.getAttribute("data-range"));
                if (range) {
                    var lines = text.split(/\r\n?|\n/g);
                    // the range is one-based and inclusive on both ends
                    var start = range[0];
                    var end = range[1] == null ? lines.length : range[1];
                    if (start < 0) start += lines.length;
                    start = Math.max(0, Math.min(start - 1, lines.length));
                    if (end < 0) end += lines.length;
                    end = Math.max(0, Math.min(end, lines.length));
                    text = lines.slice(start, end).join("\n");
                    // add data-start for line numbers
                    if (!pre.hasAttribute("data-start")) pre.setAttribute("data-start", String(start + 1));
                }
                // highlight code
                code.textContent = text;
                $34b6613fd50afc6a$var$Prism.highlightElement(code);
            }, function(error) {
                // mark as failed
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error;
            });
        }
    });
    $34b6613fd50afc6a$var$Prism.plugins.fileHighlight = {
        /**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */ highlight: function highlight(container) {
            var elements = (container || document).querySelectorAll(SELECTOR);
            for(var i = 0, element; element = elements[i++];)$34b6613fd50afc6a$var$Prism.highlightElement(element);
        }
    };
    var logged = false;
    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */ $34b6613fd50afc6a$var$Prism.fileHighlight = function() {
        if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
        }
        $34b6613fd50afc6a$var$Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    };
})();

});

parcelRegister("i3bOO", function(module, exports) {
"use strict";

var $7KTOy = parcelRequire("7KTOy");

var $hVG8h = parcelRequire("hVG8h");
module.exports = $hVG8h;
$hVG8h.prototype.message = $d241acb5acf024fe$var$message;
$hVG8h.prototype.info = $d241acb5acf024fe$var$info;
$hVG8h.prototype.fail = $d241acb5acf024fe$var$fail;
// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function $d241acb5acf024fe$var$message(reason, position, origin) {
    var message = new $7KTOy(reason, position, origin);
    if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
}
// Fail: creates a vmessage, associates it with the file, and throws it.
function $d241acb5acf024fe$var$fail() {
    var message = this.message.apply(this, arguments);
    message.fatal = true;
    throw message;
}
// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function $d241acb5acf024fe$var$info() {
    var message = this.message.apply(this, arguments);
    message.fatal = null;
    return message;
}

});
parcelRegister("7KTOy", function(module, exports) {
"use strict";

var $h6R6u = parcelRequire("h6R6u");
module.exports = $017508c5821aacc0$var$VMessage;
// Inherit from `Error#`.
function $017508c5821aacc0$var$VMessagePrototype() {}
$017508c5821aacc0$var$VMessagePrototype.prototype = Error.prototype;
$017508c5821aacc0$var$VMessage.prototype = new $017508c5821aacc0$var$VMessagePrototype();
// Message properties.
var $017508c5821aacc0$var$proto = $017508c5821aacc0$var$VMessage.prototype;
$017508c5821aacc0$var$proto.file = "";
$017508c5821aacc0$var$proto.name = "";
$017508c5821aacc0$var$proto.reason = "";
$017508c5821aacc0$var$proto.message = "";
$017508c5821aacc0$var$proto.stack = "";
$017508c5821aacc0$var$proto.fatal = null;
$017508c5821aacc0$var$proto.column = null;
$017508c5821aacc0$var$proto.line = null;
// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function $017508c5821aacc0$var$VMessage(reason, position, origin) {
    var parts;
    var range;
    var location;
    if (typeof position === "string") {
        origin = position;
        position = null;
    }
    parts = $017508c5821aacc0$var$parseOrigin(origin);
    range = $h6R6u(position) || "1:1";
    location = {
        start: {
            line: null,
            column: null
        },
        end: {
            line: null,
            column: null
        }
    };
    // Node.
    if (position && position.position) position = position.position;
    if (position) {
        // Position.
        if (position.start) {
            location = position;
            position = position.start;
        } else // Point.
        location.start = position;
    }
    if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location;
    this.source = parts[0];
    this.ruleId = parts[1];
}
function $017508c5821aacc0$var$parseOrigin(origin) {
    var result = [
        null,
        null
    ];
    var index;
    if (typeof origin === "string") {
        index = origin.indexOf(":");
        if (index === -1) result[1] = origin;
        else {
            result[0] = origin.slice(0, index);
            result[1] = origin.slice(index + 1);
        }
    }
    return result;
}

});
parcelRegister("h6R6u", function(module, exports) {
"use strict";
var $c74c307ec7a099f3$var$own = {}.hasOwnProperty;
module.exports = $c74c307ec7a099f3$var$stringify;
function $c74c307ec7a099f3$var$stringify(value) {
    // Nothing.
    if (!value || typeof value !== "object") return "";
    // Node.
    if ($c74c307ec7a099f3$var$own.call(value, "position") || $c74c307ec7a099f3$var$own.call(value, "type")) return $c74c307ec7a099f3$var$position(value.position);
    // Position.
    if ($c74c307ec7a099f3$var$own.call(value, "start") || $c74c307ec7a099f3$var$own.call(value, "end")) return $c74c307ec7a099f3$var$position(value);
    // Point.
    if ($c74c307ec7a099f3$var$own.call(value, "line") || $c74c307ec7a099f3$var$own.call(value, "column")) return $c74c307ec7a099f3$var$point(value);
    // ?
    return "";
}
function $c74c307ec7a099f3$var$point(point) {
    if (!point || typeof point !== "object") point = {};
    return $c74c307ec7a099f3$var$index(point.line) + ":" + $c74c307ec7a099f3$var$index(point.column);
}
function $c74c307ec7a099f3$var$position(pos) {
    if (!pos || typeof pos !== "object") pos = {};
    return $c74c307ec7a099f3$var$point(pos.start) + "-" + $c74c307ec7a099f3$var$point(pos.end);
}
function $c74c307ec7a099f3$var$index(value) {
    return value && typeof value === "number" ? value : 1;
}

});


parcelRegister("hVG8h", function(module, exports) {
"use strict";

var $dxIWx = parcelRequire("dxIWx");

var $4FYWM = parcelRequire("4FYWM");

var $9POxA = parcelRequire("9POxA");
module.exports = $d0d871292c0df40d$var$VFile;
var $d0d871292c0df40d$var$own = {}.hasOwnProperty;
// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var $d0d871292c0df40d$var$order = [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
];
$d0d871292c0df40d$var$VFile.prototype.toString = $d0d871292c0df40d$var$toString;
// Access full path (`~/index.min.js`).
Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "path", {
    get: $d0d871292c0df40d$var$getPath,
    set: $d0d871292c0df40d$var$setPath
});
// Access parent path (`~`).
Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "dirname", {
    get: $d0d871292c0df40d$var$getDirname,
    set: $d0d871292c0df40d$var$setDirname
});
// Access basename (`index.min.js`).
Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "basename", {
    get: $d0d871292c0df40d$var$getBasename,
    set: $d0d871292c0df40d$var$setBasename
});
// Access extname (`.js`).
Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "extname", {
    get: $d0d871292c0df40d$var$getExtname,
    set: $d0d871292c0df40d$var$setExtname
});
// Access stem (`index.min`).
Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "stem", {
    get: $d0d871292c0df40d$var$getStem,
    set: $d0d871292c0df40d$var$setStem
});
// Construct a new file.
function $d0d871292c0df40d$var$VFile(options) {
    var prop;
    var index;
    if (!options) options = {};
    else if (typeof options === "string" || $9POxA(options)) options = {
        contents: options
    };
    else if ("message" in options && "messages" in options) return options;
    if (!(this instanceof $d0d871292c0df40d$var$VFile)) return new $d0d871292c0df40d$var$VFile(options);
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = $4FYWM.cwd();
    // Set path related properties in the correct order.
    index = -1;
    while(++index < $d0d871292c0df40d$var$order.length){
        prop = $d0d871292c0df40d$var$order[index];
        if ($d0d871292c0df40d$var$own.call(options, prop)) this[prop] = options[prop];
    }
    // Set non-path related properties.
    for(prop in options)if ($d0d871292c0df40d$var$order.indexOf(prop) < 0) this[prop] = options[prop];
}
function $d0d871292c0df40d$var$getPath() {
    return this.history[this.history.length - 1];
}
function $d0d871292c0df40d$var$setPath(path) {
    $d0d871292c0df40d$var$assertNonEmpty(path, "path");
    if (this.path !== path) this.history.push(path);
}
function $d0d871292c0df40d$var$getDirname() {
    return typeof this.path === "string" ? $dxIWx.dirname(this.path) : undefined;
}
function $d0d871292c0df40d$var$setDirname(dirname) {
    $d0d871292c0df40d$var$assertPath(this.path, "dirname");
    this.path = $dxIWx.join(dirname || "", this.basename);
}
function $d0d871292c0df40d$var$getBasename() {
    return typeof this.path === "string" ? $dxIWx.basename(this.path) : undefined;
}
function $d0d871292c0df40d$var$setBasename(basename) {
    $d0d871292c0df40d$var$assertNonEmpty(basename, "basename");
    $d0d871292c0df40d$var$assertPart(basename, "basename");
    this.path = $dxIWx.join(this.dirname || "", basename);
}
function $d0d871292c0df40d$var$getExtname() {
    return typeof this.path === "string" ? $dxIWx.extname(this.path) : undefined;
}
function $d0d871292c0df40d$var$setExtname(extname) {
    $d0d871292c0df40d$var$assertPart(extname, "extname");
    $d0d871292c0df40d$var$assertPath(this.path, "extname");
    if (extname) {
        if (extname.charCodeAt(0) !== 46 /* `.` */ ) throw new Error("`extname` must start with `.`");
        if (extname.indexOf(".", 1) > -1) throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $dxIWx.join(this.dirname, this.stem + (extname || ""));
}
function $d0d871292c0df40d$var$getStem() {
    return typeof this.path === "string" ? $dxIWx.basename(this.path, this.extname) : undefined;
}
function $d0d871292c0df40d$var$setStem(stem) {
    $d0d871292c0df40d$var$assertNonEmpty(stem, "stem");
    $d0d871292c0df40d$var$assertPart(stem, "stem");
    this.path = $dxIWx.join(this.dirname || "", stem + (this.extname || ""));
}
// Get the value of the file.
function $d0d871292c0df40d$var$toString(encoding) {
    return (this.contents || "").toString(encoding);
}
// Assert that `part` is not a path (i.e., does not contain `p.sep`).
function $d0d871292c0df40d$var$assertPart(part, name) {
    if (part && part.indexOf($dxIWx.sep) > -1) throw new Error("`" + name + "` cannot be a path: did not expect `" + $dxIWx.sep + "`");
}
// Assert that `part` is not empty.
function $d0d871292c0df40d$var$assertNonEmpty(part, name) {
    if (!part) throw new Error("`" + name + "` cannot be empty");
}
// Assert `path` exists.
function $d0d871292c0df40d$var$assertPath(path, name) {
    if (!path) throw new Error("Setting `" + name + "` requires `path` to be set too");
}

});
parcelRegister("dxIWx", function(module, exports) {
"use strict";

module.exports = $4S4dR$path;

});

parcelRegister("4FYWM", function(module, exports) {
"use strict";
module.exports = process;

});

parcelRegister("9POxA", function(module, exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ module.exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};

});



parcelRegister("cSDDS", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});

parcelRegister("fh61I", function(module, exports) {
"use strict";

var $gqx3p = parcelRequire("gqx3p");

var $62RH5 = parcelRequire("62RH5");

var $c0y3C = parcelRequire("c0y3C");
module.exports = $b1ed1e5730f8b37a$var$setOptions;
function $b1ed1e5730f8b37a$var$setOptions(options) {
    var self = this;
    var current = self.options;
    var key;
    var value;
    if (options == null) options = {};
    else if (typeof options === "object") options = $gqx3p(options);
    else throw new Error("Invalid value `" + options + "` for setting `options`");
    for(key in $c0y3C){
        value = options[key];
        if (value == null) value = current[key];
        if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
        options[key] = value;
    }
    self.options = options;
    self.escape = $62RH5(options);
    return self;
}

});
parcelRegister("gqx3p", function(module, exports) {
module.exports = $bf58b6e1a1bad1ce$var$extend;
var $bf58b6e1a1bad1ce$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $bf58b6e1a1bad1ce$var$extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($bf58b6e1a1bad1ce$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

});

parcelRegister("62RH5", function(module, exports) {
"use strict";
module.exports = $466c9474c0358230$var$escapes;
var $466c9474c0358230$var$defaults = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
];
var $466c9474c0358230$var$gfm = $466c9474c0358230$var$defaults.concat([
    "~",
    "|"
]);
var $466c9474c0358230$var$commonmark = $466c9474c0358230$var$gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
]);
$466c9474c0358230$var$escapes.default = $466c9474c0358230$var$defaults;
$466c9474c0358230$var$escapes.gfm = $466c9474c0358230$var$gfm;
$466c9474c0358230$var$escapes.commonmark = $466c9474c0358230$var$commonmark;
// Get markdown escapes.
function $466c9474c0358230$var$escapes(options) {
    var settings = options || {};
    if (settings.commonmark) return $466c9474c0358230$var$commonmark;
    return settings.gfm ? $466c9474c0358230$var$gfm : $466c9474c0358230$var$defaults;
}

});

parcelRegister("c0y3C", function(module, exports) {
"use strict";

module.exports = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: (parcelRequire("4Xmw9"))
};

});
parcelRegister("4Xmw9", function(module, exports) {
"use strict";
module.exports = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
];

});



parcelRegister("jPzk9", function(module, exports) {
"use strict";

var $gqx3p = parcelRequire("gqx3p");

var $55478 = parcelRequire("55478");
module.exports = $e6fe2e5def165bbb$var$parse;
var $e6fe2e5def165bbb$var$lineFeed = "\n";
var $e6fe2e5def165bbb$var$lineBreaksExpression = /\r\n|\r/g;
// Parse the bound file.
function $e6fe2e5def165bbb$var$parse() {
    var self = this;
    var value = String(self.file);
    var start = {
        line: 1,
        column: 1,
        offset: 0
    };
    var content = $gqx3p(start);
    var node;
    // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
    // This should not affect positional information.
    value = value.replace($e6fe2e5def165bbb$var$lineBreaksExpression, $e6fe2e5def165bbb$var$lineFeed);
    // BOM.
    if (value.charCodeAt(0) === 0xfeff) {
        value = value.slice(1);
        content.column++;
        content.offset++;
    }
    node = {
        type: "root",
        children: self.tokenizeBlock(value, content),
        position: {
            start: start,
            end: self.eof || $gqx3p(start)
        }
    };
    if (!self.options.position) $55478(node, true);
    return node;
}

});
parcelRegister("55478", function(module, exports) {
"use strict";

var $5cnuX = parcelRequire("5cnuX");
module.exports = $3b309c60545c5649$var$removePosition;
function $3b309c60545c5649$var$removePosition(node, force) {
    $5cnuX(node, force ? $3b309c60545c5649$var$hard : $3b309c60545c5649$var$soft);
    return node;
}
function $3b309c60545c5649$var$hard(node) {
    delete node.position;
}
function $3b309c60545c5649$var$soft(node) {
    node.position = undefined;
}

});
parcelRegister("5cnuX", function(module, exports) {
"use strict";
module.exports = $3c904d00d8fa4e41$var$visit;

var $hvmII = parcelRequire("hvmII");
var $3c904d00d8fa4e41$var$CONTINUE = $hvmII.CONTINUE;
var $3c904d00d8fa4e41$var$SKIP = $hvmII.SKIP;
var $3c904d00d8fa4e41$var$EXIT = $hvmII.EXIT;
$3c904d00d8fa4e41$var$visit.CONTINUE = $3c904d00d8fa4e41$var$CONTINUE;
$3c904d00d8fa4e41$var$visit.SKIP = $3c904d00d8fa4e41$var$SKIP;
$3c904d00d8fa4e41$var$visit.EXIT = $3c904d00d8fa4e41$var$EXIT;
function $3c904d00d8fa4e41$var$visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    $hvmII(tree, test, overload, reverse);
    function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index, parent);
    }
}

});
parcelRegister("hvmII", function(module, exports) {
"use strict";
module.exports = $cbe6f4b3cca59231$var$visitParents;

var $5MHnZ = parcelRequire("5MHnZ");

var $lMJbn = parcelRequire("lMJbn");
var $cbe6f4b3cca59231$var$CONTINUE = true;
var $cbe6f4b3cca59231$var$SKIP = "skip";
var $cbe6f4b3cca59231$var$EXIT = false;
$cbe6f4b3cca59231$var$visitParents.CONTINUE = $cbe6f4b3cca59231$var$CONTINUE;
$cbe6f4b3cca59231$var$visitParents.SKIP = $cbe6f4b3cca59231$var$SKIP;
$cbe6f4b3cca59231$var$visitParents.EXIT = $cbe6f4b3cca59231$var$EXIT;
function $cbe6f4b3cca59231$var$visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    is = $5MHnZ(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name;
        if (typeof value.type === "string") {
            name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            visit.displayName = "node (" + $lMJbn(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
            var grandparents = parents.concat(node);
            var result = [];
            var subresult;
            var offset;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $cbe6f4b3cca59231$var$toResult(visitor(node, parents));
                if (result[0] === $cbe6f4b3cca59231$var$EXIT) return result;
            }
            if (node.children && result[0] !== $cbe6f4b3cca59231$var$SKIP) {
                offset = (reverse ? node.children.length : -1) + step;
                while(offset > -1 && offset < node.children.length){
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $cbe6f4b3cca59231$var$EXIT) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
}
function $cbe6f4b3cca59231$var$toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) return value;
    if (typeof value === "number") return [
        $cbe6f4b3cca59231$var$CONTINUE,
        value
    ];
    return [
        value
    ];
}

});
parcelRegister("5MHnZ", function(module, exports) {
"use strict";
module.exports = $436316f9d154723a$var$convert;
function $436316f9d154723a$var$convert(test) {
    if (test == null) return $436316f9d154723a$var$ok;
    if (typeof test === "string") return $436316f9d154723a$var$typeFactory(test);
    if (typeof test === "object") return "length" in test ? $436316f9d154723a$var$anyFactory(test) : $436316f9d154723a$var$allFactory(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $436316f9d154723a$var$allFactory(test) {
    return all;
    function all(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $436316f9d154723a$var$anyFactory(tests) {
    var checks = [];
    var index = -1;
    while(++index < tests.length)checks[index] = $436316f9d154723a$var$convert(tests[index]);
    return any;
    function any() {
        var index = -1;
        while(++index < checks.length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $436316f9d154723a$var$typeFactory(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $436316f9d154723a$var$ok() {
    return true;
}

});

parcelRegister("lMJbn", function(module, exports) {
module.exports = $fdc120fed48dcdfd$var$color;
function $fdc120fed48dcdfd$var$color(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}

});





parcelRegister("6MCKT", function(module, exports) {
"use strict";
// A line containing no characters, or a line containing only spaces (U+0020) or
// tabs (U+0009), is called a blank line.
// See <https://spec.commonmark.org/0.29/#blank-line>.
var $4f0549c3e762a5f7$var$reBlankLine = /^[ \t]*(\n|$)/;
// Note that though blank lines play a special role in lists to determine
// whether the list is tight or loose
// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
// tokenizer and this blank line tokenizer does not have to be responsible for
// that.
// Therefore, configs such as `blankLine.notInList` do not have to be set here.
module.exports = $4f0549c3e762a5f7$var$blankLine;
function $4f0549c3e762a5f7$var$blankLine(eat, value, silent) {
    var match;
    var subvalue = "";
    var index = 0;
    var length = value.length;
    while(index < length){
        match = $4f0549c3e762a5f7$var$reBlankLine.exec(value.slice(index));
        if (match == null) break;
        index += match[0].length;
        subvalue += match[0];
    }
    if (subvalue === "") return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    eat(subvalue);
}

});

parcelRegister("eRBEg", function(module, exports) {
"use strict";

var $iolzW = parcelRequire("iolzW");

var $dM9W3 = parcelRequire("dM9W3");
module.exports = $ad23382468445acd$var$indentedCode;
var $ad23382468445acd$var$lineFeed = "\n";
var $ad23382468445acd$var$tab = "	";
var $ad23382468445acd$var$space = " ";
var $ad23382468445acd$var$tabSize = 4;
var $ad23382468445acd$var$codeIndent = $iolzW($ad23382468445acd$var$space, $ad23382468445acd$var$tabSize);
function $ad23382468445acd$var$indentedCode(eat, value, silent) {
    var index = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent;
    while(++index < length){
        character = value.charAt(index);
        if (indent) {
            indent = false;
            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = "";
            contentQueue = "";
            if (character === $ad23382468445acd$var$lineFeed) {
                subvalueQueue = character;
                contentQueue = character;
            } else {
                subvalue += character;
                content += character;
                while(++index < length){
                    character = value.charAt(index);
                    if (!character || character === $ad23382468445acd$var$lineFeed) {
                        contentQueue = character;
                        subvalueQueue = character;
                        break;
                    }
                    subvalue += character;
                    content += character;
                }
            }
        } else if (character === $ad23382468445acd$var$space && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
            subvalueQueue += $ad23382468445acd$var$codeIndent;
            index += 3;
            indent = true;
        } else if (character === $ad23382468445acd$var$tab) {
            subvalueQueue += character;
            indent = true;
        } else {
            blankQueue = "";
            while(character === $ad23382468445acd$var$tab || character === $ad23382468445acd$var$space){
                blankQueue += character;
                character = value.charAt(++index);
            }
            if (character !== $ad23382468445acd$var$lineFeed) break;
            subvalueQueue += blankQueue + character;
            contentQueue += character;
        }
    }
    if (content) {
        if (silent) return true;
        return eat(subvalue)({
            type: "code",
            lang: null,
            meta: null,
            value: $dM9W3(content)
        });
    }
}

});
parcelRegister("iolzW", function(module, exports) {
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ "use strict";
/**
 * Results cache
 */ var $d63b34f53feb40f2$var$res = "";
var $d63b34f53feb40f2$var$cache;
/**
 * Expose `repeat`
 */ module.exports = $d63b34f53feb40f2$var$repeat;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */ function $d63b34f53feb40f2$var$repeat(str, num) {
    if (typeof str !== "string") throw new TypeError("expected a string");
    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;
    var max = str.length * num;
    if ($d63b34f53feb40f2$var$cache !== str || typeof $d63b34f53feb40f2$var$cache === "undefined") {
        $d63b34f53feb40f2$var$cache = str;
        $d63b34f53feb40f2$var$res = "";
    } else if ($d63b34f53feb40f2$var$res.length >= max) return $d63b34f53feb40f2$var$res.substr(0, max);
    while(max > $d63b34f53feb40f2$var$res.length && num > 1){
        if (num & 1) $d63b34f53feb40f2$var$res += str;
        num >>= 1;
        str += str;
    }
    $d63b34f53feb40f2$var$res += str;
    $d63b34f53feb40f2$var$res = $d63b34f53feb40f2$var$res.substr(0, max);
    return $d63b34f53feb40f2$var$res;
}

});

parcelRegister("dM9W3", function(module, exports) {
"use strict";
module.exports = $a0777706fddb1f22$var$trimTrailingLines;
// Remove final newline characters from `value`.
function $a0777706fddb1f22$var$trimTrailingLines(value) {
    return String(value).replace(/\n+$/, "");
}

});


parcelRegister("1dZOZ", function(module, exports) {
"use strict";
module.exports = $0e46f5cf904b3e03$var$fencedCode;
var $0e46f5cf904b3e03$var$lineFeed = "\n";
var $0e46f5cf904b3e03$var$tab = "	";
var $0e46f5cf904b3e03$var$space = " ";
var $0e46f5cf904b3e03$var$tilde = "~";
var $0e46f5cf904b3e03$var$graveAccent = "`";
var $0e46f5cf904b3e03$var$minFenceCount = 3;
var $0e46f5cf904b3e03$var$tabSize = 4;
function $0e46f5cf904b3e03$var$fencedCode(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var length = value.length + 1;
    var index = 0;
    var subvalue = "";
    var fenceCount;
    var marker;
    var character;
    var flag;
    var lang;
    var meta;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;
    if (!gfm) return;
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab) break;
        subvalue += character;
        index++;
    }
    indent = index;
    // Eat the fence.
    character = value.charAt(index);
    if (character !== $0e46f5cf904b3e03$var$tilde && character !== $0e46f5cf904b3e03$var$graveAccent) return;
    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;
    while(index < length){
        character = value.charAt(index);
        if (character !== marker) break;
        subvalue += character;
        fenceCount++;
        index++;
    }
    if (fenceCount < $0e46f5cf904b3e03$var$minFenceCount) return;
    // Eat spacing before flag.
    while(index < length){
        character = value.charAt(index);
        if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab) break;
        subvalue += character;
        index++;
    }
    // Eat flag.
    flag = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $0e46f5cf904b3e03$var$lineFeed || marker === $0e46f5cf904b3e03$var$graveAccent && character === marker) break;
        if (character === $0e46f5cf904b3e03$var$space || character === $0e46f5cf904b3e03$var$tab) queue += character;
        else {
            flag += queue + character;
            queue = "";
        }
        index++;
    }
    character = value.charAt(index);
    if (character && character !== $0e46f5cf904b3e03$var$lineFeed) return;
    if (silent) return true;
    now = eat.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self.decode.raw(self.unescape(flag), now);
    if (queue) subvalue += queue;
    queue = "";
    closing = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    // Eat content.
    while(index < length){
        character = value.charAt(index);
        content += closing;
        exdentedContent += exdentedClosing;
        closing = "";
        exdentedClosing = "";
        if (character !== $0e46f5cf904b3e03$var$lineFeed) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
        }
        // The first line feed is ignored. Others aren’t.
        if (skip) {
            subvalue += character;
            skip = false;
        } else {
            closing += character;
            exdentedClosing += character;
        }
        queue = "";
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character !== $0e46f5cf904b3e03$var$space) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue.slice(indent);
        if (queue.length >= $0e46f5cf904b3e03$var$tabSize) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== marker) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue;
        if (queue.length < fenceCount) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab) break;
            closing += character;
            exdentedClosing += character;
            index++;
        }
        if (!character || character === $0e46f5cf904b3e03$var$lineFeed) break;
    }
    subvalue += content + closing;
    // Get lang and meta from the flag.
    index = -1;
    length = flag.length;
    while(++index < length){
        character = flag.charAt(index);
        if (character === $0e46f5cf904b3e03$var$space || character === $0e46f5cf904b3e03$var$tab) {
            if (!lang) lang = flag.slice(0, index);
        } else if (lang) {
            meta = flag.slice(index);
            break;
        }
    }
    return eat(subvalue)({
        type: "code",
        lang: lang || flag || null,
        meta: meta || null,
        value: exdentedContent
    });
}

});

parcelRegister("1lYit", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $ibWU2 = parcelRequire("ibWU2");
module.exports = $0fc68654454540bd$var$blockquote;
var $0fc68654454540bd$var$lineFeed = "\n";
var $0fc68654454540bd$var$tab = "	";
var $0fc68654454540bd$var$space = " ";
var $0fc68654454540bd$var$greaterThan = ">";
function $0fc68654454540bd$var$blockquote(eat, value, silent) {
    var self = this;
    var offsets = self.offset;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptBlockquote;
    var now = eat.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while(index < length){
        character = value.charAt(index);
        if (character !== $0fc68654454540bd$var$space && character !== $0fc68654454540bd$var$tab) break;
        index++;
    }
    if (value.charAt(index) !== $0fc68654454540bd$var$greaterThan) return;
    if (silent) return true;
    index = 0;
    while(index < length){
        nextIndex = value.indexOf($0fc68654454540bd$var$lineFeed, index);
        startIndex = index;
        prefixed = false;
        if (nextIndex === -1) nextIndex = length;
        while(index < length){
            character = value.charAt(index);
            if (character !== $0fc68654454540bd$var$space && character !== $0fc68654454540bd$var$tab) break;
            index++;
        }
        if (value.charAt(index) === $0fc68654454540bd$var$greaterThan) {
            index++;
            prefixed = true;
            if (value.charAt(index) === $0fc68654454540bd$var$space) index++;
        } else index = startIndex;
        content = value.slice(index, nextIndex);
        if (!prefixed && !$lSPH2(content)) {
            index = startIndex;
            break;
        }
        if (!prefixed) {
            rest = value.slice(index);
            // Check if the following code contains a possible block.
            if ($ibWU2(interruptors, tokenizers, self, [
                eat,
                rest,
                true
            ])) break;
        }
        line = startIndex === index ? content : value.slice(startIndex, nextIndex);
        indents.push(index - startIndex);
        values.push(line);
        contents.push(content);
        index = nextIndex + 1;
    }
    index = -1;
    length = indents.length;
    add = eat(values.join($0fc68654454540bd$var$lineFeed));
    while(++index < length){
        offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
        currentLine++;
    }
    exit = self.enterBlock();
    contents = self.tokenizeBlock(contents.join($0fc68654454540bd$var$lineFeed), now);
    exit();
    return add({
        type: "blockquote",
        children: contents
    });
}

});
parcelRegister("lSPH2", function(module, exports) {
exports = module.exports = trim;
function trim(str) {
    if (str.trim) return str.trim();
    return exports.right(exports.left(str));
}
exports.left = function(str) {
    if (str.trimLeft) return str.trimLeft();
    return str.replace(/^\s\s*/, "");
};
exports.right = function(str) {
    if (str.trimRight) return str.trimRight();
    var whitespace_pattern = /\s/, i = str.length;
    while(whitespace_pattern.test(str.charAt(--i)));
    return str.slice(0, i + 1);
};

});

parcelRegister("ibWU2", function(module, exports) {
"use strict";
module.exports = $d3e6f1f8c40cdcc3$var$interrupt;
function $d3e6f1f8c40cdcc3$var$interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index = -1;
    var interruptor;
    var config;
    while(++index < length){
        interruptor = interruptors[index];
        config = interruptor[1] || {};
        if (config.pedantic !== undefined && config.pedantic !== ctx.options.pedantic) continue;
        if (config.commonmark !== undefined && config.commonmark !== ctx.options.commonmark) continue;
        if (tokenizers[interruptor[0]].apply(ctx, parameters)) return true;
    }
    return false;
}

});


parcelRegister("dbuo7", function(module, exports) {
"use strict";
module.exports = $9993dfe192d1f70f$var$atxHeading;
var $9993dfe192d1f70f$var$lineFeed = "\n";
var $9993dfe192d1f70f$var$tab = "	";
var $9993dfe192d1f70f$var$space = " ";
var $9993dfe192d1f70f$var$numberSign = "#";
var $9993dfe192d1f70f$var$maxFenceCount = 6;
function $9993dfe192d1f70f$var$atxHeading(eat, value, silent) {
    var self = this;
    var pedantic = self.options.pedantic;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    // Eat initial spacing.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat hashes.
    depth = 0;
    while(++index <= length){
        character = value.charAt(index);
        if (character !== $9993dfe192d1f70f$var$numberSign) {
            index--;
            break;
        }
        subvalue += character;
        depth++;
    }
    if (depth > $9993dfe192d1f70f$var$maxFenceCount) return;
    if (!depth || !pedantic && value.charAt(index + 1) === $9993dfe192d1f70f$var$numberSign) return;
    length = value.length + 1;
    // Eat intermediate white-space.
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab) {
            index--;
            break;
        }
        queue += character;
    }
    // Exit when not in pedantic mode without spacing.
    if (!pedantic && queue.length === 0 && character && character !== $9993dfe192d1f70f$var$lineFeed) return;
    if (silent) return true;
    // Eat content.
    subvalue += queue;
    queue = "";
    content = "";
    while(++index < length){
        character = value.charAt(index);
        if (!character || character === $9993dfe192d1f70f$var$lineFeed) break;
        if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab && character !== $9993dfe192d1f70f$var$numberSign) {
            content += queue + character;
            queue = "";
            continue;
        }
        while(character === $9993dfe192d1f70f$var$space || character === $9993dfe192d1f70f$var$tab){
            queue += character;
            character = value.charAt(++index);
        }
        // `#` without a queue is part of the content.
        if (!pedantic && content && !queue && character === $9993dfe192d1f70f$var$numberSign) {
            content += character;
            continue;
        }
        while(character === $9993dfe192d1f70f$var$numberSign){
            queue += character;
            character = value.charAt(++index);
        }
        while(character === $9993dfe192d1f70f$var$space || character === $9993dfe192d1f70f$var$tab){
            queue += character;
            character = value.charAt(++index);
        }
        index--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat(subvalue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}

});

parcelRegister("etWp6", function(module, exports) {
"use strict";
module.exports = $a8b113e4bd1e7a93$var$thematicBreak;
var $a8b113e4bd1e7a93$var$tab = "	";
var $a8b113e4bd1e7a93$var$lineFeed = "\n";
var $a8b113e4bd1e7a93$var$space = " ";
var $a8b113e4bd1e7a93$var$asterisk = "*";
var $a8b113e4bd1e7a93$var$dash = "-";
var $a8b113e4bd1e7a93$var$underscore = "_";
var $a8b113e4bd1e7a93$var$maxCount = 3;
function $a8b113e4bd1e7a93$var$thematicBreak(eat, value, silent) {
    var index = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker;
    var markerCount;
    var queue;
    while(++index < length){
        character = value.charAt(index);
        if (character !== $a8b113e4bd1e7a93$var$tab && character !== $a8b113e4bd1e7a93$var$space) break;
        subvalue += character;
    }
    if (character !== $a8b113e4bd1e7a93$var$asterisk && character !== $a8b113e4bd1e7a93$var$dash && character !== $a8b113e4bd1e7a93$var$underscore) return;
    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = "";
        } else if (character === $a8b113e4bd1e7a93$var$space) queue += character;
        else if (markerCount >= $a8b113e4bd1e7a93$var$maxCount && (!character || character === $a8b113e4bd1e7a93$var$lineFeed)) {
            subvalue += queue;
            if (silent) return true;
            return eat(subvalue)({
                type: "thematicBreak"
            });
        } else return;
    }
}

});

parcelRegister("2nv9J", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $iolzW = parcelRequire("iolzW");

var $9cn3E = parcelRequire("9cn3E");

var $6I3kJ = parcelRequire("6I3kJ");

var $2ARjj = parcelRequire("2ARjj");

var $ibWU2 = parcelRequire("ibWU2");
module.exports = $1bb5e5b3cce06068$var$list;
var $1bb5e5b3cce06068$var$asterisk = "*";
var $1bb5e5b3cce06068$var$underscore = "_";
var $1bb5e5b3cce06068$var$plusSign = "+";
var $1bb5e5b3cce06068$var$dash = "-";
var $1bb5e5b3cce06068$var$dot = ".";
var $1bb5e5b3cce06068$var$space = " ";
var $1bb5e5b3cce06068$var$lineFeed = "\n";
var $1bb5e5b3cce06068$var$tab = "	";
var $1bb5e5b3cce06068$var$rightParenthesis = ")";
var $1bb5e5b3cce06068$var$lowercaseX = "x";
var $1bb5e5b3cce06068$var$tabSize = 4;
var $1bb5e5b3cce06068$var$looseListItemExpression = /\n\n(?!\s*$)/;
var $1bb5e5b3cce06068$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
var $1bb5e5b3cce06068$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var $1bb5e5b3cce06068$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var $1bb5e5b3cce06068$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
function $1bb5e5b3cce06068$var$list(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var pedantic = self.options.pedantic;
    var tokenizers = self.blockTokenizers;
    var interuptors = self.interruptList;
    var index = 0;
    var length = value.length;
    var start = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread = false;
    var node;
    var now;
    var end;
    var indented;
    while(index < length){
        character = value.charAt(index);
        if (character !== $1bb5e5b3cce06068$var$tab && character !== $1bb5e5b3cce06068$var$space) break;
        index++;
    }
    character = value.charAt(index);
    if (character === $1bb5e5b3cce06068$var$asterisk || character === $1bb5e5b3cce06068$var$plusSign || character === $1bb5e5b3cce06068$var$dash) {
        marker = character;
        ordered = false;
    } else {
        ordered = true;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (!$9cn3E(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (!queue || !(character === $1bb5e5b3cce06068$var$dot || commonmark && character === $1bb5e5b3cce06068$var$rightParenthesis)) return;
        /* Slightly abusing `silent` mode, whose goal is to make interrupting
     * paragraphs work.
     * Well, that’s exactly what we want to do here: don’t interrupt:
     * 2. here, because the “list” doesn’t start with `1`. */ if (silent && queue !== "1") return;
        start = parseInt(queue, 10);
        marker = character;
    }
    character = value.charAt(++index);
    if (character !== $1bb5e5b3cce06068$var$space && character !== $1bb5e5b3cce06068$var$tab && (pedantic || character !== $1bb5e5b3cce06068$var$lineFeed && character !== "")) return;
    if (silent) return true;
    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while(index < length){
        nextIndex = value.indexOf($1bb5e5b3cce06068$var$lineFeed, index);
        startIndex = index;
        prefixed = false;
        indented = false;
        if (nextIndex === -1) nextIndex = length;
        size = 0;
        while(index < length){
            character = value.charAt(index);
            if (character === $1bb5e5b3cce06068$var$tab) size += $1bb5e5b3cce06068$var$tabSize - size % $1bb5e5b3cce06068$var$tabSize;
            else if (character === $1bb5e5b3cce06068$var$space) size++;
            else break;
            index++;
        }
        if (item && size >= item.indent) indented = true;
        character = value.charAt(index);
        currentMarker = null;
        if (!indented) {
            if (character === $1bb5e5b3cce06068$var$asterisk || character === $1bb5e5b3cce06068$var$plusSign || character === $1bb5e5b3cce06068$var$dash) {
                currentMarker = character;
                index++;
                size++;
            } else {
                queue = "";
                while(index < length){
                    character = value.charAt(index);
                    if (!$9cn3E(character)) break;
                    queue += character;
                    index++;
                }
                character = value.charAt(index);
                index++;
                if (queue && (character === $1bb5e5b3cce06068$var$dot || commonmark && character === $1bb5e5b3cce06068$var$rightParenthesis)) {
                    currentMarker = character;
                    size += queue.length + 1;
                }
            }
            if (currentMarker) {
                character = value.charAt(index);
                if (character === $1bb5e5b3cce06068$var$tab) {
                    size += $1bb5e5b3cce06068$var$tabSize - size % $1bb5e5b3cce06068$var$tabSize;
                    index++;
                } else if (character === $1bb5e5b3cce06068$var$space) {
                    end = index + $1bb5e5b3cce06068$var$tabSize;
                    while(index < end){
                        if (value.charAt(index) !== $1bb5e5b3cce06068$var$space) break;
                        index++;
                        size++;
                    }
                    if (index === end && value.charAt(index) === $1bb5e5b3cce06068$var$space) {
                        index -= $1bb5e5b3cce06068$var$tabSize - 1;
                        size -= $1bb5e5b3cce06068$var$tabSize - 1;
                    }
                } else if (character !== $1bb5e5b3cce06068$var$lineFeed && character !== "") currentMarker = null;
            }
        }
        if (currentMarker) {
            if (!pedantic && marker !== currentMarker) break;
            prefixed = true;
        } else {
            if (!commonmark && !indented && value.charAt(startIndex) === $1bb5e5b3cce06068$var$space) indented = true;
            else if (commonmark && item) indented = size >= item.indent || size > $1bb5e5b3cce06068$var$tabSize;
            prefixed = false;
            index = startIndex;
        }
        line = value.slice(startIndex, nextIndex);
        content = startIndex === index ? line : value.slice(index, nextIndex);
        if (currentMarker === $1bb5e5b3cce06068$var$asterisk || currentMarker === $1bb5e5b3cce06068$var$underscore || currentMarker === $1bb5e5b3cce06068$var$dash) {
            if (tokenizers.thematicBreak.call(self, eat, line, true)) break;
        }
        previousEmpty = empty;
        empty = !prefixed && !$lSPH2(content).length;
        if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (prefixed) {
            if (emptyLines.length !== 0) {
                spread = true;
                item.value.push("");
                item.trail = emptyLines.concat();
            }
            item = {
                value: [
                    line
                ],
                indent: size,
                trail: []
            };
            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (empty) {
            if (previousEmpty && !commonmark) break;
            emptyLines.push(line);
        } else {
            if (previousEmpty) break;
            if ($ibWU2(interuptors, tokenizers, self, [
                eat,
                line,
                true
            ])) break;
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        }
        index = nextIndex + 1;
    }
    node = eat(allLines.join($1bb5e5b3cce06068$var$lineFeed)).reset({
        type: "list",
        ordered: ordered,
        start: start,
        spread: spread,
        children: []
    });
    enterTop = self.enterList();
    exitBlockquote = self.enterBlock();
    index = -1;
    length = items.length;
    while(++index < length){
        item = items[index].value.join($1bb5e5b3cce06068$var$lineFeed);
        now = eat.now();
        eat(item)($1bb5e5b3cce06068$var$listItem(self, item, now), node);
        item = items[index].trail.join($1bb5e5b3cce06068$var$lineFeed);
        if (index !== length - 1) item += $1bb5e5b3cce06068$var$lineFeed;
        eat(item);
    }
    enterTop();
    exitBlockquote();
    return node;
}
function $1bb5e5b3cce06068$var$listItem(ctx, value, position) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? $1bb5e5b3cce06068$var$pedanticListItem : $1bb5e5b3cce06068$var$normalListItem;
    var checked = null;
    var task;
    var indent;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
        task = value.match($1bb5e5b3cce06068$var$taskItemExpression);
        if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === $1bb5e5b3cce06068$var$lowercaseX;
            offsets[position.line] += indent;
            value = value.slice(indent);
        }
    }
    return {
        type: "listItem",
        spread: $1bb5e5b3cce06068$var$looseListItemExpression.test(value),
        checked: checked,
        children: ctx.tokenizeBlock(value, position)
    };
}
// Create a list-item using overly simple mechanics.
function $1bb5e5b3cce06068$var$pedanticListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    // Remove the list-item’s bullet.
    value = value.replace($1bb5e5b3cce06068$var$pedanticBulletExpression, replacer);
    // The initial line was also matched by the below, so we reset the `line`.
    line = position.line;
    return value.replace($1bb5e5b3cce06068$var$initialIndentExpression, replacer);
    // A simple replacer which removed all matches, and adds their length to
    // `offset`.
    function replacer($0) {
        offsets[line] = (offsets[line] || 0) + $0.length;
        line++;
        return "";
    }
}
// Create a list-item using sane mechanics.
function $1bb5e5b3cce06068$var$normalListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;
    // Remove the list-item’s bullet.
    value = value.replace($1bb5e5b3cce06068$var$bulletExpression, replacer);
    lines = value.split($1bb5e5b3cce06068$var$lineFeed);
    trimmedLines = $2ARjj(value, $6I3kJ(max).indent).split($1bb5e5b3cce06068$var$lineFeed);
    // We replaced the initial bullet with something else above, which was used
    // to trick `removeIndentation` into removing some more characters when
    // possible.  However, that could result in the initial line to be stripped
    // more than it should be.
    trimmedLines[0] = rest;
    offsets[line] = (offsets[line] || 0) + bullet.length;
    line++;
    index = 0;
    length = lines.length;
    while(++index < length){
        offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
        line++;
    }
    return trimmedLines.join($1bb5e5b3cce06068$var$lineFeed);
    /* eslint-disable-next-line max-params */ function replacer($0, $1, $2, $3, $4) {
        bullet = $1 + $2 + $3;
        rest = $4;
        // Make sure that the first nine numbered list items can indent with an
        // extra space.  That is, when the bullet did not receive an extra final
        // space.
        if (Number($2) < 10 && bullet.length % 2 === 1) $2 = $1bb5e5b3cce06068$var$space + $2;
        max = $1 + $iolzW($1bb5e5b3cce06068$var$space, $2.length) + $3;
        return max + rest;
    }
}

});
parcelRegister("9cn3E", function(module, exports) {
"use strict";
module.exports = $6b271edc473bdd9b$var$decimal;
// Check if the given character code, or the character code at the first
// character, is decimal.
function $6b271edc473bdd9b$var$decimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57 /* 0-9 */ ;
}

});

parcelRegister("6I3kJ", function(module, exports) {
"use strict";
module.exports = $4e297013b392cffd$var$indentation;
var $4e297013b392cffd$var$tab = "	";
var $4e297013b392cffd$var$space = " ";
var $4e297013b392cffd$var$spaceSize = 1;
var $4e297013b392cffd$var$tabSize = 4;
// Gets indentation information for a line.
function $4e297013b392cffd$var$indentation(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;
    var lastIndent = 0;
    while(character === $4e297013b392cffd$var$tab || character === $4e297013b392cffd$var$space){
        size = character === $4e297013b392cffd$var$tab ? $4e297013b392cffd$var$tabSize : $4e297013b392cffd$var$spaceSize;
        indent += size;
        if (size > 1) indent = Math.floor(indent / size) * size;
        while(lastIndent < indent)stops[++lastIndent] = index;
        character = value.charAt(++index);
    }
    return {
        indent: indent,
        stops: stops
    };
}

});

parcelRegister("2ARjj", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $iolzW = parcelRequire("iolzW");

var $6I3kJ = parcelRequire("6I3kJ");
module.exports = $1e384bea36573dc1$var$indentation;
var $1e384bea36573dc1$var$lineFeed = "\n";
var $1e384bea36573dc1$var$space = " ";
var $1e384bea36573dc1$var$exclamationMark = "!";
// Remove the minimum indent from every line in `value`.  Supports both tab,
// spaced, and mixed indentation (as well as possible).
function $1e384bea36573dc1$var$indentation(value, maximum) {
    var values = value.split($1e384bea36573dc1$var$lineFeed);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    values.unshift($iolzW($1e384bea36573dc1$var$space, maximum) + $1e384bea36573dc1$var$exclamationMark);
    while(position--){
        indentation = $6I3kJ(values[position]);
        matrix[position] = indentation.stops;
        if ($lSPH2(values[position]).length === 0) continue;
        if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) minIndent = indentation.indent;
        } else {
            minIndent = Infinity;
            break;
        }
    }
    if (minIndent !== Infinity) {
        position = values.length;
        while(position--){
            stops = matrix[position];
            index = minIndent;
            while(index && !(index in stops))index--;
            values[position] = values[position].slice(stops[index] + 1);
        }
    }
    values.shift();
    return values.join($1e384bea36573dc1$var$lineFeed);
}

});


parcelRegister("igoS1", function(module, exports) {
"use strict";
module.exports = $d4bd0357c1035059$var$setextHeading;
var $d4bd0357c1035059$var$lineFeed = "\n";
var $d4bd0357c1035059$var$tab = "	";
var $d4bd0357c1035059$var$space = " ";
var $d4bd0357c1035059$var$equalsTo = "=";
var $d4bd0357c1035059$var$dash = "-";
var $d4bd0357c1035059$var$maxIndent = 3;
var $d4bd0357c1035059$var$equalsToDepth = 1;
var $d4bd0357c1035059$var$dashDepth = 2;
function $d4bd0357c1035059$var$setextHeading(eat, value, silent) {
    var self = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker;
    var depth;
    // Eat initial indentation.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $d4bd0357c1035059$var$space || index >= $d4bd0357c1035059$var$maxIndent) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat content.
    content = "";
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === $d4bd0357c1035059$var$lineFeed) {
            index--;
            break;
        }
        if (character === $d4bd0357c1035059$var$space || character === $d4bd0357c1035059$var$tab) queue += character;
        else {
            content += queue + character;
            queue = "";
        }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    // Ensure the content is followed by a newline and a valid marker.
    character = value.charAt(++index);
    marker = value.charAt(++index);
    if (character !== $d4bd0357c1035059$var$lineFeed || marker !== $d4bd0357c1035059$var$equalsTo && marker !== $d4bd0357c1035059$var$dash) return;
    subvalue += character;
    // Eat Setext-line.
    queue = marker;
    depth = marker === $d4bd0357c1035059$var$equalsTo ? $d4bd0357c1035059$var$equalsToDepth : $d4bd0357c1035059$var$dashDepth;
    while(++index < length){
        character = value.charAt(index);
        if (character !== marker) {
            if (character !== $d4bd0357c1035059$var$lineFeed) return;
            index--;
            break;
        }
        queue += character;
    }
    if (silent) return true;
    return eat(subvalue + queue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}

});

parcelRegister("5mJ60", function(module, exports) {
"use strict";

var $fjSMD = parcelRequire("fjSMD");
var $3e81fceca342c5e2$require$openCloseTag = $fjSMD.openCloseTag;
module.exports = $3e81fceca342c5e2$var$blockHtml;
var $3e81fceca342c5e2$var$tab = "	";
var $3e81fceca342c5e2$var$space = " ";
var $3e81fceca342c5e2$var$lineFeed = "\n";
var $3e81fceca342c5e2$var$lessThan = "<";
var $3e81fceca342c5e2$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
var $3e81fceca342c5e2$var$rawCloseExpression = /<\/(script|pre|style)>/i;
var $3e81fceca342c5e2$var$commentOpenExpression = /^<!--/;
var $3e81fceca342c5e2$var$commentCloseExpression = /-->/;
var $3e81fceca342c5e2$var$instructionOpenExpression = /^<\?/;
var $3e81fceca342c5e2$var$instructionCloseExpression = /\?>/;
var $3e81fceca342c5e2$var$directiveOpenExpression = /^<![A-Za-z]/;
var $3e81fceca342c5e2$var$directiveCloseExpression = />/;
var $3e81fceca342c5e2$var$cdataOpenExpression = /^<!\[CDATA\[/;
var $3e81fceca342c5e2$var$cdataCloseExpression = /]]>/;
var $3e81fceca342c5e2$var$elementCloseExpression = /^$/;
var $3e81fceca342c5e2$var$otherElementOpenExpression = new RegExp($3e81fceca342c5e2$require$openCloseTag.source + "\\s*$");
function $3e81fceca342c5e2$var$blockHtml(eat, value, silent) {
    var self = this;
    var blocks = self.options.blocks.join("|");
    var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    var length = value.length;
    var index = 0;
    var next;
    var line;
    var offset;
    var character;
    var count;
    var sequence;
    var subvalue;
    var sequences = [
        [
            $3e81fceca342c5e2$var$rawOpenExpression,
            $3e81fceca342c5e2$var$rawCloseExpression,
            true
        ],
        [
            $3e81fceca342c5e2$var$commentOpenExpression,
            $3e81fceca342c5e2$var$commentCloseExpression,
            true
        ],
        [
            $3e81fceca342c5e2$var$instructionOpenExpression,
            $3e81fceca342c5e2$var$instructionCloseExpression,
            true
        ],
        [
            $3e81fceca342c5e2$var$directiveOpenExpression,
            $3e81fceca342c5e2$var$directiveCloseExpression,
            true
        ],
        [
            $3e81fceca342c5e2$var$cdataOpenExpression,
            $3e81fceca342c5e2$var$cdataCloseExpression,
            true
        ],
        [
            elementOpenExpression,
            $3e81fceca342c5e2$var$elementCloseExpression,
            true
        ],
        [
            $3e81fceca342c5e2$var$otherElementOpenExpression,
            $3e81fceca342c5e2$var$elementCloseExpression,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $3e81fceca342c5e2$var$tab && character !== $3e81fceca342c5e2$var$space) break;
        index++;
    }
    if (value.charAt(index) !== $3e81fceca342c5e2$var$lessThan) return;
    next = value.indexOf($3e81fceca342c5e2$var$lineFeed, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($3e81fceca342c5e2$var$lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}

});
parcelRegister("fjSMD", function(module, exports) {

$parcel$export(module.exports, "openCloseTag", () => $b273203b5dbc1f7d$export$a33a5d2984e0051b, (v) => $b273203b5dbc1f7d$export$a33a5d2984e0051b = v);
$parcel$export(module.exports, "tag", () => $b273203b5dbc1f7d$export$2b067c6666111485, (v) => $b273203b5dbc1f7d$export$2b067c6666111485 = v);
var $b273203b5dbc1f7d$export$a33a5d2984e0051b;
var $b273203b5dbc1f7d$export$2b067c6666111485;
"use strict";
var $b273203b5dbc1f7d$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var $b273203b5dbc1f7d$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
var $b273203b5dbc1f7d$var$singleQuoted = "'[^']*'";
var $b273203b5dbc1f7d$var$doubleQuoted = '"[^"]*"';
var $b273203b5dbc1f7d$var$attributeValue = "(?:" + $b273203b5dbc1f7d$var$unquoted + "|" + $b273203b5dbc1f7d$var$singleQuoted + "|" + $b273203b5dbc1f7d$var$doubleQuoted + ")";
var $b273203b5dbc1f7d$var$attribute = "(?:\\s+" + $b273203b5dbc1f7d$var$attributeName + "(?:\\s*=\\s*" + $b273203b5dbc1f7d$var$attributeValue + ")?)";
var $b273203b5dbc1f7d$var$openTag = "<[A-Za-z][A-Za-z0-9\\-]*" + $b273203b5dbc1f7d$var$attribute + "*\\s*\\/?>";
var $b273203b5dbc1f7d$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var $b273203b5dbc1f7d$var$comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var $b273203b5dbc1f7d$var$processing = "<[?].*?[?]>";
var $b273203b5dbc1f7d$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
var $b273203b5dbc1f7d$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
$b273203b5dbc1f7d$export$a33a5d2984e0051b = new RegExp("^(?:" + $b273203b5dbc1f7d$var$openTag + "|" + $b273203b5dbc1f7d$var$closeTag + ")");
$b273203b5dbc1f7d$export$2b067c6666111485 = new RegExp("^(?:" + $b273203b5dbc1f7d$var$openTag + "|" + $b273203b5dbc1f7d$var$closeTag + "|" + $b273203b5dbc1f7d$var$comment + "|" + $b273203b5dbc1f7d$var$processing + "|" + $b273203b5dbc1f7d$var$declaration + "|" + $b273203b5dbc1f7d$var$cdata + ")");

});


parcelRegister("iUyeb", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");

var $4Zypr = parcelRequire("4Zypr");
module.exports = $dc4801de94817cd5$var$definition;
var $dc4801de94817cd5$var$quotationMark = '"';
var $dc4801de94817cd5$var$apostrophe = "'";
var $dc4801de94817cd5$var$backslash = "\\";
var $dc4801de94817cd5$var$lineFeed = "\n";
var $dc4801de94817cd5$var$tab = "	";
var $dc4801de94817cd5$var$space = " ";
var $dc4801de94817cd5$var$leftSquareBracket = "[";
var $dc4801de94817cd5$var$rightSquareBracket = "]";
var $dc4801de94817cd5$var$leftParenthesis = "(";
var $dc4801de94817cd5$var$rightParenthesis = ")";
var $dc4801de94817cd5$var$colon = ":";
var $dc4801de94817cd5$var$lessThan = "<";
var $dc4801de94817cd5$var$greaterThan = ">";
function $dc4801de94817cd5$var$definition(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;
    while(index < length){
        character = value.charAt(index);
        if (character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$tab) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (character !== $dc4801de94817cd5$var$leftSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $dc4801de94817cd5$var$rightSquareBracket) break;
        else if (character === $dc4801de94817cd5$var$backslash) {
            queue += character;
            index++;
            character = value.charAt(index);
        }
        queue += character;
        index++;
    }
    if (!queue || value.charAt(index) !== $dc4801de94817cd5$var$rightSquareBracket || value.charAt(index + 1) !== $dc4801de94817cd5$var$colon) return;
    identifier = queue;
    subvalue += queue + $dc4801de94817cd5$var$rightSquareBracket + $dc4801de94817cd5$var$colon;
    index = subvalue.length;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$lineFeed) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $dc4801de94817cd5$var$lessThan) {
        index++;
        while(index < length){
            character = value.charAt(index);
            if (!$dc4801de94817cd5$var$isEnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $dc4801de94817cd5$var$isEnclosedURLCharacter.delimiter) {
            subvalue += $dc4801de94817cd5$var$lessThan + queue + character;
            index++;
        } else {
            if (commonmark) return;
            index -= queue.length + 1;
            queue = "";
        }
    }
    if (!queue) {
        while(index < length){
            character = value.charAt(index);
            if (!$dc4801de94817cd5$var$isUnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        subvalue += queue;
    }
    if (!queue) return;
    url = queue;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$lineFeed) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    test = null;
    if (character === $dc4801de94817cd5$var$quotationMark) test = $dc4801de94817cd5$var$quotationMark;
    else if (character === $dc4801de94817cd5$var$apostrophe) test = $dc4801de94817cd5$var$apostrophe;
    else if (character === $dc4801de94817cd5$var$leftParenthesis) test = $dc4801de94817cd5$var$rightParenthesis;
    if (!test) {
        queue = "";
        index = subvalue.length;
    } else if (queue) {
        subvalue += queue + character;
        index = subvalue.length;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character === test) break;
            if (character === $dc4801de94817cd5$var$lineFeed) {
                index++;
                character = value.charAt(index);
                if (character === $dc4801de94817cd5$var$lineFeed || character === test) return;
                queue += $dc4801de94817cd5$var$lineFeed;
            }
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character !== test) return;
        beforeTitle = subvalue;
        subvalue += queue + character;
        index++;
        title = queue;
        queue = "";
    } else return;
    while(index < length){
        character = value.charAt(index);
        if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (!character || character === $dc4801de94817cd5$var$lineFeed) {
        if (silent) return true;
        beforeURL = eat(beforeURL).test().end;
        url = self.decode.raw(self.unescape(url), beforeURL, {
            nonTerminated: false
        });
        if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.unescape(title), beforeTitle);
        }
        return eat(subvalue)({
            type: "definition",
            identifier: $4Zypr(identifier),
            label: identifier,
            title: title || null,
            url: url
        });
    }
}
// Check if `character` can be inside an enclosed URI.
function $dc4801de94817cd5$var$isEnclosedURLCharacter(character) {
    return character !== $dc4801de94817cd5$var$greaterThan && character !== $dc4801de94817cd5$var$leftSquareBracket && character !== $dc4801de94817cd5$var$rightSquareBracket;
}
$dc4801de94817cd5$var$isEnclosedURLCharacter.delimiter = $dc4801de94817cd5$var$greaterThan;
// Check if `character` can be inside an unclosed URI.
function $dc4801de94817cd5$var$isUnclosedURLCharacter(character) {
    return character !== $dc4801de94817cd5$var$leftSquareBracket && character !== $dc4801de94817cd5$var$rightSquareBracket && !$6qoLm(character);
}

});
parcelRegister("6qoLm", function(module, exports) {
"use strict";
module.exports = $4ad8612833b06372$var$whitespace;
var $4ad8612833b06372$var$fromCode = String.fromCharCode;
var $4ad8612833b06372$var$re = /\s/;
// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function $4ad8612833b06372$var$whitespace(character) {
    return $4ad8612833b06372$var$re.test(typeof character === "number" ? $4ad8612833b06372$var$fromCode(character) : character.charAt(0));
}

});

parcelRegister("4Zypr", function(module, exports) {
"use strict";

var $jmMQ2 = parcelRequire("jmMQ2");
module.exports = $3a278ce95e904ed3$var$normalize;
// Normalize an identifier.  Collapses multiple white space characters into a
// single space, and removes casing.
function $3a278ce95e904ed3$var$normalize(value) {
    return $jmMQ2(value).toLowerCase();
}

});
parcelRegister("jmMQ2", function(module, exports) {
"use strict";
module.exports = $e195f4a9fe2fbe26$var$collapse;
// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function $e195f4a9fe2fbe26$var$collapse(value) {
    return String(value).replace(/\s+/g, " ");
}

});



parcelRegister("jvhub", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");
module.exports = $e32e79e1c4c5fc3b$var$table;
var $e32e79e1c4c5fc3b$var$tab = "	";
var $e32e79e1c4c5fc3b$var$lineFeed = "\n";
var $e32e79e1c4c5fc3b$var$space = " ";
var $e32e79e1c4c5fc3b$var$dash = "-";
var $e32e79e1c4c5fc3b$var$colon = ":";
var $e32e79e1c4c5fc3b$var$backslash = "\\";
var $e32e79e1c4c5fc3b$var$verticalBar = "|";
var $e32e79e1c4c5fc3b$var$minColumns = 1;
var $e32e79e1c4c5fc3b$var$minRows = 2;
var $e32e79e1c4c5fc3b$var$left = "left";
var $e32e79e1c4c5fc3b$var$center = "center";
var $e32e79e1c4c5fc3b$var$right = "right";
function $e32e79e1c4c5fc3b$var$table(eat, value, silent) {
    var self = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;
    // Exit when not in gfm-mode.
    if (!self.options.gfm) return;
    // Get the rows.
    // Detecting tables soon is hard, so there are some checks for performance
    // here, such as the minimum number of rows, and allowed characters in the
    // alignment row.
    index = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while(index < length){
        lineIndex = value.indexOf($e32e79e1c4c5fc3b$var$lineFeed, index);
        pipeIndex = value.indexOf($e32e79e1c4c5fc3b$var$verticalBar, index + 1);
        if (lineIndex === -1) lineIndex = value.length;
        if (pipeIndex === -1 || pipeIndex > lineIndex) {
            if (lineCount < $e32e79e1c4c5fc3b$var$minRows) return;
            break;
        }
        lines.push(value.slice(index, lineIndex));
        lineCount++;
        index = lineIndex + 1;
    }
    // Parse the alignment row.
    subvalue = lines.join($e32e79e1c4c5fc3b$var$lineFeed);
    alignments = lines.splice(1, 1)[0] || [];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while(index < length){
        character = alignments.charAt(index);
        if (character === $e32e79e1c4c5fc3b$var$verticalBar) {
            hasDash = null;
            if (alignment === false) {
                if (first === false) return;
            } else {
                align.push(alignment);
                alignment = false;
            }
            first = false;
        } else if (character === $e32e79e1c4c5fc3b$var$dash) {
            hasDash = true;
            alignment = alignment || null;
        } else if (character === $e32e79e1c4c5fc3b$var$colon) {
            if (alignment === $e32e79e1c4c5fc3b$var$left) alignment = $e32e79e1c4c5fc3b$var$center;
            else if (hasDash && alignment === null) alignment = $e32e79e1c4c5fc3b$var$right;
            else alignment = $e32e79e1c4c5fc3b$var$left;
        } else if (!$6qoLm(character)) return;
        index++;
    }
    if (alignment !== false) align.push(alignment);
    // Exit when without enough columns.
    if (align.length < $e32e79e1c4c5fc3b$var$minColumns) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Parse the rows.
    position = -1;
    rows = [];
    table = eat(subvalue).reset({
        type: "table",
        align: align,
        children: rows
    });
    while(++position < lineCount){
        line = lines[position];
        row = {
            type: "tableRow",
            children: []
        };
        // Eat a newline character when this is not the first row.
        if (position) eat($e32e79e1c4c5fc3b$var$lineFeed);
        // Eat the row.
        eat(line).reset(row, table);
        length = line.length + 1;
        index = 0;
        queue = "";
        cell = "";
        preamble = true;
        while(index < length){
            character = line.charAt(index);
            if (character === $e32e79e1c4c5fc3b$var$tab || character === $e32e79e1c4c5fc3b$var$space) {
                if (cell) queue += character;
                else eat(character);
                index++;
                continue;
            }
            if (character === "" || character === $e32e79e1c4c5fc3b$var$verticalBar) {
                if (preamble) eat(character);
                else {
                    if ((cell || character) && !preamble) {
                        subvalue = cell;
                        if (queue.length > 1) {
                            if (character) {
                                subvalue += queue.slice(0, -1);
                                queue = queue.charAt(queue.length - 1);
                            } else {
                                subvalue += queue;
                                queue = "";
                            }
                        }
                        now = eat.now();
                        eat(subvalue)({
                            type: "tableCell",
                            children: self.tokenizeInline(cell, now)
                        }, row);
                    }
                    eat(queue + character);
                    queue = "";
                    cell = "";
                }
            } else {
                if (queue) {
                    cell += queue;
                    queue = "";
                }
                cell += character;
                if (character === $e32e79e1c4c5fc3b$var$backslash && index !== length - 2) {
                    cell += line.charAt(index + 1);
                    index++;
                }
            }
            preamble = false;
            index++;
        }
        // Eat the alignment row.
        if (!position) eat($e32e79e1c4c5fc3b$var$lineFeed + alignments);
    }
    return table;
}

});

parcelRegister("fkexf", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $dM9W3 = parcelRequire("dM9W3");

var $ibWU2 = parcelRequire("ibWU2");
module.exports = $b283ffa679ad5953$var$paragraph;
var $b283ffa679ad5953$var$tab = "	";
var $b283ffa679ad5953$var$lineFeed = "\n";
var $b283ffa679ad5953$var$space = " ";
var $b283ffa679ad5953$var$tabSize = 4;
// Tokenise paragraph.
function $b283ffa679ad5953$var$paragraph(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var commonmark = settings.commonmark;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptParagraph;
    var index = value.indexOf($b283ffa679ad5953$var$lineFeed);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;
    while(index < length){
        // Eat everything if there’s no following newline.
        if (index === -1) {
            index = length;
            break;
        }
        // Stop if the next character is NEWLINE.
        if (value.charAt(index + 1) === $b283ffa679ad5953$var$lineFeed) break;
        // In commonmark-mode, following indented lines are part of the paragraph.
        if (commonmark) {
            size = 0;
            position = index + 1;
            while(position < length){
                character = value.charAt(position);
                if (character === $b283ffa679ad5953$var$tab) {
                    size = $b283ffa679ad5953$var$tabSize;
                    break;
                } else if (character === $b283ffa679ad5953$var$space) size++;
                else break;
                position++;
            }
            if (size >= $b283ffa679ad5953$var$tabSize && character !== $b283ffa679ad5953$var$lineFeed) {
                index = value.indexOf($b283ffa679ad5953$var$lineFeed, index + 1);
                continue;
            }
        }
        subvalue = value.slice(index + 1);
        // Check if the following code contains a possible block.
        if ($ibWU2(interruptors, tokenizers, self, [
            eat,
            subvalue,
            true
        ])) break;
        position = index;
        index = value.indexOf($b283ffa679ad5953$var$lineFeed, index + 1);
        if (index !== -1 && $lSPH2(value.slice(position, index)) === "") {
            index = position;
            break;
        }
    }
    subvalue = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    subvalue = $dM9W3(subvalue);
    return eat(subvalue)({
        type: "paragraph",
        children: self.tokenizeInline(subvalue, now)
    });
}

});

parcelRegister("jGxnv", function(module, exports) {
"use strict";

var $4DogI = parcelRequire("4DogI");
module.exports = $e54bd4c139e2be15$var$escape;
$e54bd4c139e2be15$var$escape.locator = $4DogI;
var $e54bd4c139e2be15$var$lineFeed = "\n";
var $e54bd4c139e2be15$var$backslash = "\\";
function $e54bd4c139e2be15$var$escape(eat, value, silent) {
    var self = this;
    var character;
    var node;
    if (value.charAt(0) === $e54bd4c139e2be15$var$backslash) {
        character = value.charAt(1);
        if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            if (character === $e54bd4c139e2be15$var$lineFeed) node = {
                type: "break"
            };
            else node = {
                type: "text",
                value: character
            };
            return eat($e54bd4c139e2be15$var$backslash + character)(node);
        }
    }
}

});
parcelRegister("4DogI", function(module, exports) {
"use strict";
module.exports = $35fda13454910b20$var$locate;
function $35fda13454910b20$var$locate(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
}

});


parcelRegister("aoJGq", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");

var $3qZkh = parcelRequire("3qZkh");

var $gQ52E = parcelRequire("gQ52E");
module.exports = $791f950ae947bccc$var$autoLink;
$791f950ae947bccc$var$autoLink.locator = $gQ52E;
$791f950ae947bccc$var$autoLink.notInLink = true;
var $791f950ae947bccc$var$lessThan = "<";
var $791f950ae947bccc$var$greaterThan = ">";
var $791f950ae947bccc$var$atSign = "@";
var $791f950ae947bccc$var$slash = "/";
var $791f950ae947bccc$var$mailto = "mailto:";
var $791f950ae947bccc$var$mailtoLength = $791f950ae947bccc$var$mailto.length;
function $791f950ae947bccc$var$autoLink(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var length = value.length;
    var index = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== $791f950ae947bccc$var$lessThan) return;
    index++;
    subvalue = $791f950ae947bccc$var$lessThan;
    while(index < length){
        character = value.charAt(index);
        if ($6qoLm(character) || character === $791f950ae947bccc$var$greaterThan || character === $791f950ae947bccc$var$atSign || character === ":" && value.charAt(index + 1) === $791f950ae947bccc$var$slash) break;
        queue += character;
        index++;
    }
    if (!queue) return;
    link += queue;
    queue = "";
    character = value.charAt(index);
    link += character;
    index++;
    if (character === $791f950ae947bccc$var$atSign) hasAtCharacter = true;
    else {
        if (character !== ":" || value.charAt(index + 1) !== $791f950ae947bccc$var$slash) return;
        link += $791f950ae947bccc$var$slash;
        index++;
    }
    while(index < length){
        character = value.charAt(index);
        if ($6qoLm(character) || character === $791f950ae947bccc$var$greaterThan) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (!queue || character !== $791f950ae947bccc$var$greaterThan) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
        if (link.slice(0, $791f950ae947bccc$var$mailtoLength).toLowerCase() === $791f950ae947bccc$var$mailto) {
            content = content.slice($791f950ae947bccc$var$mailtoLength);
            now.column += $791f950ae947bccc$var$mailtoLength;
            now.offset += $791f950ae947bccc$var$mailtoLength;
        } else link = $791f950ae947bccc$var$mailto + link;
    }
    // Temporarily remove all tokenizers except text in autolinks.
    tokenizers = self.inlineTokenizers;
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    exit = self.enterLink();
    content = self.tokenizeInline(content, now);
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(subvalue)({
        type: "link",
        title: null,
        url: $3qZkh(link, {
            nonTerminated: false
        }),
        children: content
    });
}

});
parcelRegister("3qZkh", function(module, exports) {
"use strict";

var $1qIcT = parcelRequire("1qIcT");

var $17Ogq = parcelRequire("17Ogq");

var $9cn3E = parcelRequire("9cn3E");

var $lGwCQ = parcelRequire("lGwCQ");

var $435e3 = parcelRequire("435e3");

var $Cj6UP = parcelRequire("Cj6UP");
module.exports = $28035edfc2d3de7e$var$parseEntities;
var $28035edfc2d3de7e$var$own = {}.hasOwnProperty;
var $28035edfc2d3de7e$var$fromCharCode = String.fromCharCode;
var $28035edfc2d3de7e$var$noop = Function.prototype;
// Default settings.
var $28035edfc2d3de7e$var$defaults = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
};
// Characters.
var $28035edfc2d3de7e$var$tab = 9 // '\t'
;
var $28035edfc2d3de7e$var$lineFeed = 10 // '\n'
;
var $28035edfc2d3de7e$var$formFeed = 12 // '\f'
;
var $28035edfc2d3de7e$var$space = 32 // ' '
;
var $28035edfc2d3de7e$var$ampersand = 38 // '&'
;
var $28035edfc2d3de7e$var$semicolon = 59 // ';'
;
var $28035edfc2d3de7e$var$lessThan = 60 // '<'
;
var $28035edfc2d3de7e$var$equalsTo = 61 // '='
;
var $28035edfc2d3de7e$var$numberSign = 35 // '#'
;
var $28035edfc2d3de7e$var$uppercaseX = 88 // 'X'
;
var $28035edfc2d3de7e$var$lowercaseX = 120 // 'x'
;
var $28035edfc2d3de7e$var$replacementCharacter = 65533 // '�'
;
// Reference types.
var $28035edfc2d3de7e$var$name = "named";
var $28035edfc2d3de7e$var$hexa = "hexadecimal";
var $28035edfc2d3de7e$var$deci = "decimal";
// Map of bases.
var $28035edfc2d3de7e$var$bases = {};
$28035edfc2d3de7e$var$bases[$28035edfc2d3de7e$var$hexa] = 16;
$28035edfc2d3de7e$var$bases[$28035edfc2d3de7e$var$deci] = 10;
// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var $28035edfc2d3de7e$var$tests = {};
$28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$name] = $435e3;
$28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$deci] = $9cn3E;
$28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$hexa] = $lGwCQ;
// Warning types.
var $28035edfc2d3de7e$var$namedNotTerminated = 1;
var $28035edfc2d3de7e$var$numericNotTerminated = 2;
var $28035edfc2d3de7e$var$namedEmpty = 3;
var $28035edfc2d3de7e$var$numericEmpty = 4;
var $28035edfc2d3de7e$var$namedUnknown = 5;
var $28035edfc2d3de7e$var$numericDisallowed = 6;
var $28035edfc2d3de7e$var$numericProhibited = 7;
// Warning messages.
var $28035edfc2d3de7e$var$messages = {};
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedEmpty] = "Named character references cannot be empty";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericEmpty] = "Numeric character references cannot be empty";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedUnknown] = "Named character references must be known";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
// Wrap to ensure clean parameters are given to `parse`.
function $28035edfc2d3de7e$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) options = {};
    for(key in $28035edfc2d3de7e$var$defaults){
        option = options[key];
        settings[key] = option === null || option === undefined ? $28035edfc2d3de7e$var$defaults[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }
    return $28035edfc2d3de7e$var$parse(value, settings);
}
// Parse entities.
// eslint-disable-next-line complexity
function $28035edfc2d3de7e$var$parse(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") additional = additional.charCodeAt(0);
    // Cache the current point.
    prev = now();
    // Wrap `handleWarning`.
    warning = handleWarning ? parseError : $28035edfc2d3de7e$var$noop;
    // Ensure the algorithm walks over the first character and the end
    // (inclusive).
    index--;
    length++;
    while(++index < length){
        // If the previous character was a newline.
        if (character === $28035edfc2d3de7e$var$lineFeed) column = indent[lines] || 1;
        character = value.charCodeAt(index);
        if (character === $28035edfc2d3de7e$var$ampersand) {
            following = value.charCodeAt(index + 1);
            // The behaviour depends on the identity of the next character.
            if (following === $28035edfc2d3de7e$var$tab || following === $28035edfc2d3de7e$var$lineFeed || following === $28035edfc2d3de7e$var$formFeed || following === $28035edfc2d3de7e$var$space || following === $28035edfc2d3de7e$var$ampersand || following === $28035edfc2d3de7e$var$lessThan || following !== following || additional && following === additional) {
                // Not a character reference.
                // No characters are consumed, and nothing is returned.
                // This is not an error, either.
                queue += $28035edfc2d3de7e$var$fromCharCode(character);
                column++;
                continue;
            }
            start = index + 1;
            begin = start;
            end = start;
            if (following === $28035edfc2d3de7e$var$numberSign) {
                // Numerical entity.
                end = ++begin;
                // The behaviour further depends on the next character.
                following = value.charCodeAt(end);
                if (following === $28035edfc2d3de7e$var$uppercaseX || following === $28035edfc2d3de7e$var$lowercaseX) {
                    // ASCII hex digits.
                    type = $28035edfc2d3de7e$var$hexa;
                    end = ++begin;
                } else // ASCII digits.
                type = $28035edfc2d3de7e$var$deci;
            } else // Named entity.
            type = $28035edfc2d3de7e$var$name;
            entityCharacters = "";
            entity = "";
            characters = "";
            test = $28035edfc2d3de7e$var$tests[type];
            end--;
            while(++end < length){
                following = value.charCodeAt(end);
                if (!test(following)) break;
                characters += $28035edfc2d3de7e$var$fromCharCode(following);
                // Check if we can match a legacy named reference.
                // If so, we cache that as the last viable named reference.
                // This ensures we do not need to walk backwards later.
                if (type === $28035edfc2d3de7e$var$name && $28035edfc2d3de7e$var$own.call($1qIcT, characters)) {
                    entityCharacters = characters;
                    entity = $1qIcT[characters];
                }
            }
            terminated = value.charCodeAt(end) === $28035edfc2d3de7e$var$semicolon;
            if (terminated) {
                end++;
                namedEntity = type === $28035edfc2d3de7e$var$name ? $Cj6UP(characters) : false;
                if (namedEntity) {
                    entityCharacters = characters;
                    entity = namedEntity;
                }
            }
            diff = 1 + end - start;
            if (!terminated && !nonTerminated) ;
            else if (!characters) // An empty (possible) entity is valid, unless it’s numeric (thus an
            // ampersand followed by an octothorp).
            {
                if (type !== $28035edfc2d3de7e$var$name) warning($28035edfc2d3de7e$var$numericEmpty, diff);
            } else if (type === $28035edfc2d3de7e$var$name) {
                // An ampersand followed by anything unknown, and not terminated, is
                // invalid.
                if (terminated && !entity) warning($28035edfc2d3de7e$var$namedUnknown, 1);
                else {
                    // If theres something after an entity name which is not known, cap
                    // the reference.
                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }
                    // If the reference is not terminated, warn.
                    if (!terminated) {
                        reason = entityCharacters ? $28035edfc2d3de7e$var$namedNotTerminated : $28035edfc2d3de7e$var$namedEmpty;
                        if (settings.attribute) {
                            following = value.charCodeAt(end);
                            if (following === $28035edfc2d3de7e$var$equalsTo) {
                                warning(reason, diff);
                                entity = null;
                            } else if ($435e3(following)) entity = null;
                            else warning(reason, diff);
                        } else warning(reason, diff);
                    }
                }
                reference = entity;
            } else {
                if (!terminated) // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning($28035edfc2d3de7e$var$numericNotTerminated, diff);
                // When terminated and number, parse as either hexadecimal or decimal.
                reference = parseInt(characters, $28035edfc2d3de7e$var$bases[type]);
                // Trigger a warning when the parsed number is prohibited, and replace
                // with replacement character.
                if ($28035edfc2d3de7e$var$prohibited(reference)) {
                    warning($28035edfc2d3de7e$var$numericProhibited, diff);
                    reference = $28035edfc2d3de7e$var$fromCharCode($28035edfc2d3de7e$var$replacementCharacter);
                } else if (reference in $17Ogq) {
                    // Trigger a warning when the parsed number is disallowed, and replace
                    // by an alternative.
                    warning($28035edfc2d3de7e$var$numericDisallowed, diff);
                    reference = $17Ogq[reference];
                } else {
                    // Parse the number.
                    output = "";
                    // Trigger a warning when the parsed number should not be used.
                    if ($28035edfc2d3de7e$var$disallowed(reference)) warning($28035edfc2d3de7e$var$numericDisallowed, diff);
                    // Stringify the number.
                    if (reference > 0xffff) {
                        reference -= 0x10000;
                        output += $28035edfc2d3de7e$var$fromCharCode(reference >>> 10 | 0xd800);
                        reference = 0xdc00 | reference & 0x3ff;
                    }
                    reference = output + $28035edfc2d3de7e$var$fromCharCode(reference);
                }
            }
            // Found it!
            // First eat the queued characters as normal text, then eat an entity.
            if (reference) {
                flush();
                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;
                if (handleReference) handleReference.call(referenceContext, reference, {
                    start: prev,
                    end: next
                }, value.slice(start - 1, end));
                prev = next;
            } else {
                // If we could not find a reference, queue the checked characters (as
                // normal characters), and move the pointer to their end.
                // This is possible because we can be certain neither newlines nor
                // ampersands are included.
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            }
        } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
            }
            if (character === character) {
                queue += $28035edfc2d3de7e$var$fromCharCode(character);
                column++;
            } else flush();
        }
    }
    // Return the reduced nodes.
    return result.join("");
    // Get current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
        };
    }
    // “Throw” a parse-error: a warning.
    function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, $28035edfc2d3de7e$var$messages[code], position, code);
    }
    // Flush `queue` (normal text).
    // Macro invoked before each entity and at the end of `value`.
    // Does nothing when `queue` is empty.
    function flush() {
        if (queue) {
            result.push(queue);
            if (handleText) handleText.call(textContext, queue, {
                start: prev,
                end: now()
            });
            queue = "";
        }
    }
}
// Check if `character` is outside the permissible unicode range.
function $28035edfc2d3de7e$var$prohibited(code) {
    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
}
// Check if `character` is disallowed.
function $28035edfc2d3de7e$var$disallowed(code) {
    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
}

});
parcelRegister("1qIcT", function(module, exports) {
module.exports = JSON.parse('{"AElig":"\xc6","AMP":"&","Aacute":"\xc1","Acirc":"\xc2","Agrave":"\xc0","Aring":"\xc5","Atilde":"\xc3","Auml":"\xc4","COPY":"\xa9","Ccedil":"\xc7","ETH":"\xd0","Eacute":"\xc9","Ecirc":"\xca","Egrave":"\xc8","Euml":"\xcb","GT":">","Iacute":"\xcd","Icirc":"\xce","Igrave":"\xcc","Iuml":"\xcf","LT":"<","Ntilde":"\xd1","Oacute":"\xd3","Ocirc":"\xd4","Ograve":"\xd2","Oslash":"\xd8","Otilde":"\xd5","Ouml":"\xd6","QUOT":"\\"","REG":"\xae","THORN":"\xde","Uacute":"\xda","Ucirc":"\xdb","Ugrave":"\xd9","Uuml":"\xdc","Yacute":"\xdd","aacute":"\xe1","acirc":"\xe2","acute":"\xb4","aelig":"\xe6","agrave":"\xe0","amp":"&","aring":"\xe5","atilde":"\xe3","auml":"\xe4","brvbar":"\xa6","ccedil":"\xe7","cedil":"\xb8","cent":"\xa2","copy":"\xa9","curren":"\xa4","deg":"\xb0","divide":"\xf7","eacute":"\xe9","ecirc":"\xea","egrave":"\xe8","eth":"\xf0","euml":"\xeb","frac12":"\xbd","frac14":"\xbc","frac34":"\xbe","gt":">","iacute":"\xed","icirc":"\xee","iexcl":"\xa1","igrave":"\xec","iquest":"\xbf","iuml":"\xef","laquo":"\xab","lt":"<","macr":"\xaf","micro":"\xb5","middot":"\xb7","nbsp":"\xa0","not":"\xac","ntilde":"\xf1","oacute":"\xf3","ocirc":"\xf4","ograve":"\xf2","ordf":"\xaa","ordm":"\xba","oslash":"\xf8","otilde":"\xf5","ouml":"\xf6","para":"\xb6","plusmn":"\xb1","pound":"\xa3","quot":"\\"","raquo":"\xbb","reg":"\xae","sect":"\xa7","shy":"\xad","sup1":"\xb9","sup2":"\xb2","sup3":"\xb3","szlig":"\xdf","thorn":"\xfe","times":"\xd7","uacute":"\xfa","ucirc":"\xfb","ugrave":"\xf9","uml":"\xa8","uuml":"\xfc","yacute":"\xfd","yen":"\xa5","yuml":"\xff"}');

});

parcelRegister("17Ogq", function(module, exports) {
module.exports = JSON.parse('{"0":"\uFFFD","128":"\u20AC","130":"\u201A","131":"\u0192","132":"\u201E","133":"\u2026","134":"\u2020","135":"\u2021","136":"\u02C6","137":"\u2030","138":"\u0160","139":"\u2039","140":"\u0152","142":"\u017D","145":"\u2018","146":"\u2019","147":"\u201C","148":"\u201D","149":"\u2022","150":"\u2013","151":"\u2014","152":"\u02DC","153":"\u2122","154":"\u0161","155":"\u203A","156":"\u0153","158":"\u017E","159":"\u0178"}');

});

parcelRegister("lGwCQ", function(module, exports) {
"use strict";
module.exports = $fc96d3f76b074740$var$hexadecimal;
// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function $fc96d3f76b074740$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 /* a */  && code <= 102 || code >= 65 /* A */  && code <= 70 || code >= 48 /* A */  && code <= 57;
}

});

parcelRegister("435e3", function(module, exports) {
"use strict";

var $jQpNp = parcelRequire("jQpNp");

var $9cn3E = parcelRequire("9cn3E");
module.exports = $2f2b7eeef6f58bd4$var$alphanumerical;
// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function $2f2b7eeef6f58bd4$var$alphanumerical(character) {
    return $jQpNp(character) || $9cn3E(character);
}

});
parcelRegister("jQpNp", function(module, exports) {
"use strict";
module.exports = $e726e2348600cb26$var$alphabetical;
// Check if the given character code, or the character code at the first
// character, is alphabetical.
function $e726e2348600cb26$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

});


parcelRegister("Cj6UP", function(module, exports) {
"use strict";

var $5jBAm = parcelRequire("5jBAm");
module.exports = $07325fae06a93008$var$decodeEntity;
var $07325fae06a93008$var$own = {}.hasOwnProperty;
function $07325fae06a93008$var$decodeEntity(characters) {
    return $07325fae06a93008$var$own.call($5jBAm, characters) ? $5jBAm[characters] : false;
}

});
parcelRegister("5jBAm", function(module, exports) {
module.exports = JSON.parse('{"AEli":"\xc6","AElig":"\xc6","AM":"&","AMP":"&","Aacut":"\xc1","Aacute":"\xc1","Abreve":"\u0102","Acir":"\xc2","Acirc":"\xc2","Acy":"\u0410","Afr":"\uD835\uDD04","Agrav":"\xc0","Agrave":"\xc0","Alpha":"\u0391","Amacr":"\u0100","And":"\u2A53","Aogon":"\u0104","Aopf":"\uD835\uDD38","ApplyFunction":"\u2061","Arin":"\xc5","Aring":"\xc5","Ascr":"\uD835\uDC9C","Assign":"\u2254","Atild":"\xc3","Atilde":"\xc3","Aum":"\xc4","Auml":"\xc4","Backslash":"\u2216","Barv":"\u2AE7","Barwed":"\u2306","Bcy":"\u0411","Because":"\u2235","Bernoullis":"\u212C","Beta":"\u0392","Bfr":"\uD835\uDD05","Bopf":"\uD835\uDD39","Breve":"\u02D8","Bscr":"\u212C","Bumpeq":"\u224E","CHcy":"\u0427","COP":"\xa9","COPY":"\xa9","Cacute":"\u0106","Cap":"\u22D2","CapitalDifferentialD":"\u2145","Cayleys":"\u212D","Ccaron":"\u010C","Ccedi":"\xc7","Ccedil":"\xc7","Ccirc":"\u0108","Cconint":"\u2230","Cdot":"\u010A","Cedilla":"\xb8","CenterDot":"\xb7","Cfr":"\u212D","Chi":"\u03A7","CircleDot":"\u2299","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","Colon":"\u2237","Colone":"\u2A74","Congruent":"\u2261","Conint":"\u222F","ContourIntegral":"\u222E","Copf":"\u2102","Coproduct":"\u2210","CounterClockwiseContourIntegral":"\u2233","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","Cup":"\u22D3","CupCap":"\u224D","DD":"\u2145","DDotrahd":"\u2911","DJcy":"\u0402","DScy":"\u0405","DZcy":"\u040F","Dagger":"\u2021","Darr":"\u21A1","Dashv":"\u2AE4","Dcaron":"\u010E","Dcy":"\u0414","Del":"\u2207","Delta":"\u0394","Dfr":"\uD835\uDD07","DiacriticalAcute":"\xb4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","Diamond":"\u22C4","DifferentialD":"\u2146","Dopf":"\uD835\uDD3B","Dot":"\xa8","DotDot":"\u20DC","DotEqual":"\u2250","DoubleContourIntegral":"\u222F","DoubleDot":"\xa8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrow":"\u2193","DownArrowBar":"\u2913","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVector":"\u21BD","DownLeftVectorBar":"\u2956","DownRightTeeVector":"\u295F","DownRightVector":"\u21C1","DownRightVectorBar":"\u2957","DownTee":"\u22A4","DownTeeArrow":"\u21A7","Downarrow":"\u21D3","Dscr":"\uD835\uDC9F","Dstrok":"\u0110","ENG":"\u014A","ET":"\xd0","ETH":"\xd0","Eacut":"\xc9","Eacute":"\xc9","Ecaron":"\u011A","Ecir":"\xca","Ecirc":"\xca","Ecy":"\u042D","Edot":"\u0116","Efr":"\uD835\uDD08","Egrav":"\xc8","Egrave":"\xc8","Element":"\u2208","Emacr":"\u0112","EmptySmallSquare":"\u25FB","EmptyVerySmallSquare":"\u25AB","Eogon":"\u0118","Eopf":"\uD835\uDD3C","Epsilon":"\u0395","Equal":"\u2A75","EqualTilde":"\u2242","Equilibrium":"\u21CC","Escr":"\u2130","Esim":"\u2A73","Eta":"\u0397","Eum":"\xcb","Euml":"\xcb","Exists":"\u2203","ExponentialE":"\u2147","Fcy":"\u0424","Ffr":"\uD835\uDD09","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","Fopf":"\uD835\uDD3D","ForAll":"\u2200","Fouriertrf":"\u2131","Fscr":"\u2131","GJcy":"\u0403","G":">","GT":">","Gamma":"\u0393","Gammad":"\u03DC","Gbreve":"\u011E","Gcedil":"\u0122","Gcirc":"\u011C","Gcy":"\u0413","Gdot":"\u0120","Gfr":"\uD835\uDD0A","Gg":"\u22D9","Gopf":"\uD835\uDD3E","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","Gt":"\u226B","HARDcy":"\u042A","Hacek":"\u02C7","Hat":"^","Hcirc":"\u0124","Hfr":"\u210C","HilbertSpace":"\u210B","Hopf":"\u210D","HorizontalLine":"\u2500","Hscr":"\u210B","Hstrok":"\u0126","HumpDownHump":"\u224E","HumpEqual":"\u224F","IEcy":"\u0415","IJlig":"\u0132","IOcy":"\u0401","Iacut":"\xcd","Iacute":"\xcd","Icir":"\xce","Icirc":"\xce","Icy":"\u0418","Idot":"\u0130","Ifr":"\u2111","Igrav":"\xcc","Igrave":"\xcc","Im":"\u2111","Imacr":"\u012A","ImaginaryI":"\u2148","Implies":"\u21D2","Int":"\u222C","Integral":"\u222B","Intersection":"\u22C2","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","Iogon":"\u012E","Iopf":"\uD835\uDD40","Iota":"\u0399","Iscr":"\u2110","Itilde":"\u0128","Iukcy":"\u0406","Ium":"\xcf","Iuml":"\xcf","Jcirc":"\u0134","Jcy":"\u0419","Jfr":"\uD835\uDD0D","Jopf":"\uD835\uDD41","Jscr":"\uD835\uDCA5","Jsercy":"\u0408","Jukcy":"\u0404","KHcy":"\u0425","KJcy":"\u040C","Kappa":"\u039A","Kcedil":"\u0136","Kcy":"\u041A","Kfr":"\uD835\uDD0E","Kopf":"\uD835\uDD42","Kscr":"\uD835\uDCA6","LJcy":"\u0409","L":"<","LT":"<","Lacute":"\u0139","Lambda":"\u039B","Lang":"\u27EA","Laplacetrf":"\u2112","Larr":"\u219E","Lcaron":"\u013D","Lcedil":"\u013B","Lcy":"\u041B","LeftAngleBracket":"\u27E8","LeftArrow":"\u2190","LeftArrowBar":"\u21E4","LeftArrowRightArrow":"\u21C6","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVector":"\u21C3","LeftDownVectorBar":"\u2959","LeftFloor":"\u230A","LeftRightArrow":"\u2194","LeftRightVector":"\u294E","LeftTee":"\u22A3","LeftTeeArrow":"\u21A4","LeftTeeVector":"\u295A","LeftTriangle":"\u22B2","LeftTriangleBar":"\u29CF","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVector":"\u21BF","LeftUpVectorBar":"\u2958","LeftVector":"\u21BC","LeftVectorBar":"\u2952","Leftarrow":"\u21D0","Leftrightarrow":"\u21D4","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","LessLess":"\u2AA1","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","Lfr":"\uD835\uDD0F","Ll":"\u22D8","Lleftarrow":"\u21DA","Lmidot":"\u013F","LongLeftArrow":"\u27F5","LongLeftRightArrow":"\u27F7","LongRightArrow":"\u27F6","Longleftarrow":"\u27F8","Longleftrightarrow":"\u27FA","Longrightarrow":"\u27F9","Lopf":"\uD835\uDD43","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","Lscr":"\u2112","Lsh":"\u21B0","Lstrok":"\u0141","Lt":"\u226A","Map":"\u2905","Mcy":"\u041C","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","MinusPlus":"\u2213","Mopf":"\uD835\uDD44","Mscr":"\u2133","Mu":"\u039C","NJcy":"\u040A","Nacute":"\u0143","Ncaron":"\u0147","Ncedil":"\u0145","Ncy":"\u041D","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\\n","Nfr":"\uD835\uDD11","NoBreak":"\u2060","NonBreakingSpace":"\xa0","Nopf":"\u2115","Not":"\u2AEC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangle":"\u22EB","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","Nscr":"\uD835\uDCA9","Ntild":"\xd1","Ntilde":"\xd1","Nu":"\u039D","OElig":"\u0152","Oacut":"\xd3","Oacute":"\xd3","Ocir":"\xd4","Ocirc":"\xd4","Ocy":"\u041E","Odblac":"\u0150","Ofr":"\uD835\uDD12","Ograv":"\xd2","Ograve":"\xd2","Omacr":"\u014C","Omega":"\u03A9","Omicron":"\u039F","Oopf":"\uD835\uDD46","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","Or":"\u2A54","Oscr":"\uD835\uDCAA","Oslas":"\xd8","Oslash":"\xd8","Otild":"\xd5","Otilde":"\xd5","Otimes":"\u2A37","Oum":"\xd6","Ouml":"\xd6","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","PartialD":"\u2202","Pcy":"\u041F","Pfr":"\uD835\uDD13","Phi":"\u03A6","Pi":"\u03A0","PlusMinus":"\xb1","Poincareplane":"\u210C","Popf":"\u2119","Pr":"\u2ABB","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","Prime":"\u2033","Product":"\u220F","Proportion":"\u2237","Proportional":"\u221D","Pscr":"\uD835\uDCAB","Psi":"\u03A8","QUO":"\\"","QUOT":"\\"","Qfr":"\uD835\uDD14","Qopf":"\u211A","Qscr":"\uD835\uDCAC","RBarr":"\u2910","RE":"\xae","REG":"\xae","Racute":"\u0154","Rang":"\u27EB","Rarr":"\u21A0","Rarrtl":"\u2916","Rcaron":"\u0158","Rcedil":"\u0156","Rcy":"\u0420","Re":"\u211C","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","Rfr":"\u211C","Rho":"\u03A1","RightAngleBracket":"\u27E9","RightArrow":"\u2192","RightArrowBar":"\u21E5","RightArrowLeftArrow":"\u21C4","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVector":"\u21C2","RightDownVectorBar":"\u2955","RightFloor":"\u230B","RightTee":"\u22A2","RightTeeArrow":"\u21A6","RightTeeVector":"\u295B","RightTriangle":"\u22B3","RightTriangleBar":"\u29D0","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVector":"\u21BE","RightUpVectorBar":"\u2954","RightVector":"\u21C0","RightVectorBar":"\u2953","Rightarrow":"\u21D2","Ropf":"\u211D","RoundImplies":"\u2970","Rrightarrow":"\u21DB","Rscr":"\u211B","Rsh":"\u21B1","RuleDelayed":"\u29F4","SHCHcy":"\u0429","SHcy":"\u0428","SOFTcy":"\u042C","Sacute":"\u015A","Sc":"\u2ABC","Scaron":"\u0160","Scedil":"\u015E","Scirc":"\u015C","Scy":"\u0421","Sfr":"\uD835\uDD16","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","Sigma":"\u03A3","SmallCircle":"\u2218","Sopf":"\uD835\uDD4A","Sqrt":"\u221A","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","Sscr":"\uD835\uDCAE","Star":"\u22C6","Sub":"\u22D0","Subset":"\u22D0","SubsetEqual":"\u2286","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","SuchThat":"\u220B","Sum":"\u2211","Sup":"\u22D1","Superset":"\u2283","SupersetEqual":"\u2287","Supset":"\u22D1","THOR":"\xde","THORN":"\xde","TRADE":"\u2122","TSHcy":"\u040B","TScy":"\u0426","Tab":"\\t","Tau":"\u03A4","Tcaron":"\u0164","Tcedil":"\u0162","Tcy":"\u0422","Tfr":"\uD835\uDD17","Therefore":"\u2234","Theta":"\u0398","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","Topf":"\uD835\uDD4B","TripleDot":"\u20DB","Tscr":"\uD835\uDCAF","Tstrok":"\u0166","Uacut":"\xda","Uacute":"\xda","Uarr":"\u219F","Uarrocir":"\u2949","Ubrcy":"\u040E","Ubreve":"\u016C","Ucir":"\xdb","Ucirc":"\xdb","Ucy":"\u0423","Udblac":"\u0170","Ufr":"\uD835\uDD18","Ugrav":"\xd9","Ugrave":"\xd9","Umacr":"\u016A","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","Uopf":"\uD835\uDD4C","UpArrow":"\u2191","UpArrowBar":"\u2912","UpArrowDownArrow":"\u21C5","UpDownArrow":"\u2195","UpEquilibrium":"\u296E","UpTee":"\u22A5","UpTeeArrow":"\u21A5","Uparrow":"\u21D1","Updownarrow":"\u21D5","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","Upsi":"\u03D2","Upsilon":"\u03A5","Uring":"\u016E","Uscr":"\uD835\uDCB0","Utilde":"\u0168","Uum":"\xdc","Uuml":"\xdc","VDash":"\u22AB","Vbar":"\u2AEB","Vcy":"\u0412","Vdash":"\u22A9","Vdashl":"\u2AE6","Vee":"\u22C1","Verbar":"\u2016","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","Vopf":"\uD835\uDD4D","Vscr":"\uD835\uDCB1","Vvdash":"\u22AA","Wcirc":"\u0174","Wedge":"\u22C0","Wfr":"\uD835\uDD1A","Wopf":"\uD835\uDD4E","Wscr":"\uD835\uDCB2","Xfr":"\uD835\uDD1B","Xi":"\u039E","Xopf":"\uD835\uDD4F","Xscr":"\uD835\uDCB3","YAcy":"\u042F","YIcy":"\u0407","YUcy":"\u042E","Yacut":"\xdd","Yacute":"\xdd","Ycirc":"\u0176","Ycy":"\u042B","Yfr":"\uD835\uDD1C","Yopf":"\uD835\uDD50","Yscr":"\uD835\uDCB4","Yuml":"\u0178","ZHcy":"\u0416","Zacute":"\u0179","Zcaron":"\u017D","Zcy":"\u0417","Zdot":"\u017B","ZeroWidthSpace":"\u200B","Zeta":"\u0396","Zfr":"\u2128","Zopf":"\u2124","Zscr":"\uD835\uDCB5","aacut":"\xe1","aacute":"\xe1","abreve":"\u0103","ac":"\u223E","acE":"\u223E\u0333","acd":"\u223F","acir":"\xe2","acirc":"\xe2","acut":"\xb4","acute":"\xb4","acy":"\u0430","aeli":"\xe6","aelig":"\xe6","af":"\u2061","afr":"\uD835\uDD1E","agrav":"\xe0","agrave":"\xe0","alefsym":"\u2135","aleph":"\u2135","alpha":"\u03B1","amacr":"\u0101","amalg":"\u2A3F","am":"&","amp":"&","and":"\u2227","andand":"\u2A55","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsd":"\u2221","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\xc5","angzarr":"\u237C","aogon":"\u0105","aopf":"\uD835\uDD52","ap":"\u2248","apE":"\u2A70","apacir":"\u2A6F","ape":"\u224A","apid":"\u224B","apos":"\'","approx":"\u2248","approxeq":"\u224A","arin":"\xe5","aring":"\xe5","ascr":"\uD835\uDCB6","ast":"*","asymp":"\u2248","asympeq":"\u224D","atild":"\xe3","atilde":"\xe3","aum":"\xe4","auml":"\xe4","awconint":"\u2233","awint":"\u2A11","bNot":"\u2AED","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","barvee":"\u22BD","barwed":"\u2305","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","beta":"\u03B2","beth":"\u2136","between":"\u226C","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bnot":"\u2310","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxDL":"\u2557","boxDR":"\u2554","boxDl":"\u2556","boxDr":"\u2553","boxH":"\u2550","boxHD":"\u2566","boxHU":"\u2569","boxHd":"\u2564","boxHu":"\u2567","boxUL":"\u255D","boxUR":"\u255A","boxUl":"\u255C","boxUr":"\u2559","boxV":"\u2551","boxVH":"\u256C","boxVL":"\u2563","boxVR":"\u2560","boxVh":"\u256B","boxVl":"\u2562","boxVr":"\u255F","boxbox":"\u29C9","boxdL":"\u2555","boxdR":"\u2552","boxdl":"\u2510","boxdr":"\u250C","boxh":"\u2500","boxhD":"\u2565","boxhU":"\u2568","boxhd":"\u252C","boxhu":"\u2534","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxuL":"\u255B","boxuR":"\u2558","boxul":"\u2518","boxur":"\u2514","boxv":"\u2502","boxvH":"\u256A","boxvL":"\u2561","boxvR":"\u255E","boxvh":"\u253C","boxvl":"\u2524","boxvr":"\u251C","bprime":"\u2035","breve":"\u02D8","brvba":"\xa6","brvbar":"\xa6","bscr":"\uD835\uDCB7","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsol":"\\\\","bsolb":"\u29C5","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","bumpeq":"\u224F","cacute":"\u0107","cap":"\u2229","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","capcup":"\u2A47","capdot":"\u2A40","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","ccaps":"\u2A4D","ccaron":"\u010D","ccedi":"\xe7","ccedil":"\xe7","ccirc":"\u0109","ccups":"\u2A4C","ccupssm":"\u2A50","cdot":"\u010B","cedi":"\xb8","cedil":"\xb8","cemptyv":"\u29B2","cen":"\xa2","cent":"\xa2","centerdot":"\xb7","cfr":"\uD835\uDD20","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","chi":"\u03C7","cir":"\u25CB","cirE":"\u29C3","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledR":"\xae","circledS":"\u24C8","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","clubs":"\u2663","clubsuit":"\u2663","colon":":","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","conint":"\u222E","copf":"\uD835\uDD54","coprod":"\u2210","cop":"\xa9","copy":"\xa9","copysr":"\u2117","crarr":"\u21B5","cross":"\u2717","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cup":"\u222A","cupbrcap":"\u2A48","cupcap":"\u2A46","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curre":"\xa4","curren":"\xa4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dArr":"\u21D3","dHar":"\u2965","dagger":"\u2020","daleth":"\u2138","darr":"\u2193","dash":"\u2010","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","dcaron":"\u010F","dcy":"\u0434","dd":"\u2146","ddagger":"\u2021","ddarr":"\u21CA","ddotseq":"\u2A77","de":"\xb0","deg":"\xb0","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","dfr":"\uD835\uDD21","dharl":"\u21C3","dharr":"\u21C2","diam":"\u22C4","diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\xa8","digamma":"\u03DD","disin":"\u22F2","div":"\xf7","divid":"\xf7","divide":"\xf7","divideontimes":"\u22C7","divonx":"\u22C7","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","dopf":"\uD835\uDD55","dot":"\u02D9","doteq":"\u2250","doteqdot":"\u2251","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","downarrow":"\u2193","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","dscr":"\uD835\uDCB9","dscy":"\u0455","dsol":"\u29F6","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","dzcy":"\u045F","dzigrarr":"\u27FF","eDDot":"\u2A77","eDot":"\u2251","eacut":"\xe9","eacute":"\xe9","easter":"\u2A6E","ecaron":"\u011B","ecir":"\xea","ecirc":"\xea","ecolon":"\u2255","ecy":"\u044D","edot":"\u0117","ee":"\u2147","efDot":"\u2252","efr":"\uD835\uDD22","eg":"\u2A9A","egrav":"\xe8","egrave":"\xe8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","emptyv":"\u2205","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","eng":"\u014B","ensp":"\u2002","eogon":"\u0119","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","equals":"=","equest":"\u225F","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erDot":"\u2253","erarr":"\u2971","escr":"\u212F","esdot":"\u2250","esim":"\u2242","eta":"\u03B7","et":"\xf0","eth":"\xf0","eum":"\xeb","euml":"\xeb","euro":"\u20AC","excl":"!","exist":"\u2203","expectation":"\u2130","exponentiale":"\u2147","fallingdotseq":"\u2252","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","ffr":"\uD835\uDD23","filig":"\uFB01","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","fopf":"\uD835\uDD57","forall":"\u2200","fork":"\u22D4","forkv":"\u2AD9","fpartint":"\u2A0D","frac1":"\xbc","frac12":"\xbd","frac13":"\u2153","frac14":"\xbc","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac3":"\xbe","frac34":"\xbe","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","gE":"\u2267","gEl":"\u2A8C","gacute":"\u01F5","gamma":"\u03B3","gammad":"\u03DD","gap":"\u2A86","gbreve":"\u011F","gcirc":"\u011D","gcy":"\u0433","gdot":"\u0121","ge":"\u2265","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","ges":"\u2A7E","gescc":"\u2AA9","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","gfr":"\uD835\uDD24","gg":"\u226B","ggg":"\u22D9","gimel":"\u2137","gjcy":"\u0453","gl":"\u2277","glE":"\u2A92","gla":"\u2AA5","glj":"\u2AA4","gnE":"\u2269","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","gopf":"\uD835\uDD58","grave":"`","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","g":">","gt":">","gtcc":"\u2AA7","gtcir":"\u2A7A","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","hArr":"\u21D4","hairsp":"\u200A","half":"\xbd","hamilt":"\u210B","hardcy":"\u044A","harr":"\u2194","harrcir":"\u2948","harrw":"\u21AD","hbar":"\u210F","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","horbar":"\u2015","hscr":"\uD835\uDCBD","hslash":"\u210F","hstrok":"\u0127","hybull":"\u2043","hyphen":"\u2010","iacut":"\xed","iacute":"\xed","ic":"\u2063","icir":"\xee","icirc":"\xee","icy":"\u0438","iecy":"\u0435","iexc":"\xa1","iexcl":"\xa1","iff":"\u21D4","ifr":"\uD835\uDD26","igrav":"\xec","igrave":"\xec","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","ijlig":"\u0133","imacr":"\u012B","image":"\u2111","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","imof":"\u22B7","imped":"\u01B5","in":"\u2208","incare":"\u2105","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","int":"\u222B","intcal":"\u22BA","integers":"\u2124","intercal":"\u22BA","intlarhk":"\u2A17","intprod":"\u2A3C","iocy":"\u0451","iogon":"\u012F","iopf":"\uD835\uDD5A","iota":"\u03B9","iprod":"\u2A3C","iques":"\xbf","iquest":"\xbf","iscr":"\uD835\uDCBE","isin":"\u2208","isinE":"\u22F9","isindot":"\u22F5","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","itilde":"\u0129","iukcy":"\u0456","ium":"\xef","iuml":"\xef","jcirc":"\u0135","jcy":"\u0439","jfr":"\uD835\uDD27","jmath":"\u0237","jopf":"\uD835\uDD5B","jscr":"\uD835\uDCBF","jsercy":"\u0458","jukcy":"\u0454","kappa":"\u03BA","kappav":"\u03F0","kcedil":"\u0137","kcy":"\u043A","kfr":"\uD835\uDD28","kgreen":"\u0138","khcy":"\u0445","kjcy":"\u045C","kopf":"\uD835\uDD5C","kscr":"\uD835\uDCC0","lAarr":"\u21DA","lArr":"\u21D0","lAtail":"\u291B","lBarr":"\u290E","lE":"\u2266","lEg":"\u2A8B","lHar":"\u2962","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","lambda":"\u03BB","lang":"\u27E8","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","laqu":"\xab","laquo":"\xab","larr":"\u2190","larrb":"\u21E4","larrbfs":"\u291F","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","lat":"\u2AAB","latail":"\u2919","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","lcaron":"\u013E","lcedil":"\u013C","lceil":"\u2308","lcub":"{","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","leftarrow":"\u2190","leftarrowtail":"\u21A2","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","leftthreetimes":"\u22CB","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","les":"\u2A7D","lescc":"\u2AA8","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","lessgtr":"\u2276","lesssim":"\u2272","lfisht":"\u297C","lfloor":"\u230A","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","ljcy":"\u0459","ll":"\u226A","llarr":"\u21C7","llcorner":"\u231E","llhard":"\u296B","lltri":"\u25FA","lmidot":"\u0140","lmoust":"\u23B0","lmoustache":"\u23B0","lnE":"\u2268","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","longleftrightarrow":"\u27F7","longmapsto":"\u27FC","longrightarrow":"\u27F6","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","lstrok":"\u0142","l":"<","lt":"<","ltcc":"\u2AA6","ltcir":"\u2A79","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltrPar":"\u2996","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","mDDot":"\u223A","mac":"\xaf","macr":"\xaf","male":"\u2642","malt":"\u2720","maltese":"\u2720","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","mcy":"\u043C","mdash":"\u2014","measuredangle":"\u2221","mfr":"\uD835\uDD2A","mho":"\u2127","micr":"\xb5","micro":"\xb5","mid":"\u2223","midast":"*","midcir":"\u2AF0","middo":"\xb7","middot":"\xb7","minus":"\u2212","minusb":"\u229F","minusd":"\u2238","minusdu":"\u2A2A","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","mstpos":"\u223E","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nGg":"\u22D9\u0338","nGt":"\u226B\u20D2","nGtv":"\u226B\u0338","nLeftarrow":"\u21CD","nLeftrightarrow":"\u21CE","nLl":"\u22D8\u0338","nLt":"\u226A\u20D2","nLtv":"\u226A\u0338","nRightarrow":"\u21CF","nVDash":"\u22AF","nVdash":"\u22AE","nabla":"\u2207","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natur":"\u266E","natural":"\u266E","naturals":"\u2115","nbs":"\xa0","nbsp":"\xa0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","ncaron":"\u0148","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","ncy":"\u043D","ndash":"\u2013","ne":"\u2260","neArr":"\u21D7","nearhk":"\u2924","nearr":"\u2197","nearrow":"\u2197","nedot":"\u2250\u0338","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","nexist":"\u2204","nexists":"\u2204","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","ngsim":"\u2275","ngt":"\u226F","ngtr":"\u226F","nhArr":"\u21CE","nharr":"\u21AE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","njcy":"\u045A","nlArr":"\u21CD","nlE":"\u2266\u0338","nlarr":"\u219A","nldr":"\u2025","nle":"\u2270","nleftarrow":"\u219A","nleftrightarrow":"\u21AE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nlsim":"\u2274","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nmid":"\u2224","nopf":"\uD835\uDD5F","no":"\xac","not":"\xac","notin":"\u2209","notinE":"\u22F9\u0338","notindot":"\u22F5\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","npar":"\u2226","nparallel":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","npre":"\u2AAF\u0338","nprec":"\u2280","npreceq":"\u2AAF\u0338","nrArr":"\u21CF","nrarr":"\u219B","nrarrc":"\u2933\u0338","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","ntild":"\xf1","ntilde":"\xf1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvDash":"\u22AD","nvHarr":"\u2904","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwArr":"\u21D6","nwarhk":"\u2923","nwarr":"\u2196","nwarrow":"\u2196","nwnear":"\u2927","oS":"\u24C8","oacut":"\xf3","oacute":"\xf3","oast":"\u229B","ocir":"\xf4","ocirc":"\xf4","ocy":"\u043E","odash":"\u229D","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","oelig":"\u0153","ofcir":"\u29BF","ofr":"\uD835\uDD2C","ogon":"\u02DB","ograv":"\xf2","ograve":"\xf2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","omacr":"\u014D","omega":"\u03C9","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","oopf":"\uD835\uDD60","opar":"\u29B7","operp":"\u29B9","oplus":"\u2295","or":"\u2228","orarr":"\u21BB","ord":"\xba","order":"\u2134","orderof":"\u2134","ordf":"\xaa","ordm":"\xba","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oscr":"\u2134","oslas":"\xf8","oslash":"\xf8","osol":"\u2298","otild":"\xf5","otilde":"\xf5","otimes":"\u2297","otimesas":"\u2A36","oum":"\xf6","ouml":"\xf6","ovbar":"\u233D","par":"\xb6","para":"\xb6","parallel":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","pfr":"\uD835\uDD2D","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plus":"+","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","plusm":"\xb1","plusmn":"\xb1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\xb1","pointint":"\u2A15","popf":"\uD835\uDD61","poun":"\xa3","pound":"\xa3","pr":"\u227A","prE":"\u2AB3","prap":"\u2AB7","prcue":"\u227C","pre":"\u2AAF","prec":"\u227A","precapprox":"\u2AB7","preccurlyeq":"\u227C","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","precsim":"\u227E","prime":"\u2032","primes":"\u2119","prnE":"\u2AB5","prnap":"\u2AB9","prnsim":"\u22E8","prod":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","pscr":"\uD835\uDCC5","psi":"\u03C8","puncsp":"\u2008","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","qprime":"\u2057","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quo":"\\"","quot":"\\"","rAarr":"\u21DB","rArr":"\u21D2","rAtail":"\u291C","rBarr":"\u290F","rHar":"\u2964","race":"\u223D\u0331","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raqu":"\xbb","raquo":"\xbb","rarr":"\u2192","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","rcaron":"\u0159","rcedil":"\u0157","rceil":"\u2309","rcub":"}","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","rect":"\u25AD","re":"\xae","reg":"\xae","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","rho":"\u03C1","rhov":"\u03F1","rightarrow":"\u2192","rightarrowtail":"\u21A3","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","rightthreetimes":"\u22CC","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoust":"\u23B1","rmoustache":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","roplus":"\u2A2E","rotimes":"\u2A35","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","rsaquo":"\u203A","rscr":"\uD835\uDCC7","rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","ruluhar":"\u2968","rx":"\u211E","sacute":"\u015B","sbquo":"\u201A","sc":"\u227B","scE":"\u2AB4","scap":"\u2AB8","scaron":"\u0161","sccue":"\u227D","sce":"\u2AB0","scedil":"\u015F","scirc":"\u015D","scnE":"\u2AB6","scnap":"\u2ABA","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","scy":"\u0441","sdot":"\u22C5","sdotb":"\u22A1","sdote":"\u2A66","seArr":"\u21D8","searhk":"\u2925","searr":"\u2198","searrow":"\u2198","sec":"\xa7","sect":"\xa7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","shchcy":"\u0449","shcy":"\u0448","shortmid":"\u2223","shortparallel":"\u2225","sh":"\xad","shy":"\xad","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","softcy":"\u044C","sol":"/","solb":"\u29C4","solbar":"\u233F","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","squ":"\u25A1","square":"\u25A1","squarf":"\u25AA","squf":"\u25AA","srarr":"\u2192","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\xaf","sub":"\u2282","subE":"\u2AC5","subdot":"\u2ABD","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","subseteq":"\u2286","subseteqq":"\u2AC5","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succ":"\u227B","succapprox":"\u2AB8","succcurlyeq":"\u227D","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","sum":"\u2211","sung":"\u266A","sup":"\u2283","sup1":"\xb9","sup2":"\xb2","sup3":"\xb3","supE":"\u2AC6","supdot":"\u2ABE","supdsub":"\u2AD8","supe":"\u2287","supedot":"\u2AC4","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swArr":"\u21D9","swarhk":"\u2926","swarr":"\u2199","swarrow":"\u2199","swnwar":"\u292A","szli":"\xdf","szlig":"\xdf","target":"\u2316","tau":"\u03C4","tbrk":"\u23B4","tcaron":"\u0165","tcedil":"\u0163","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","thor":"\xfe","thorn":"\xfe","tilde":"\u02DC","time":"\xd7","times":"\xd7","timesb":"\u22A0","timesbar":"\u2A31","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","top":"\u22A4","topbot":"\u2336","topcir":"\u2AF1","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","tscr":"\uD835\uDCC9","tscy":"\u0446","tshcy":"\u045B","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","uArr":"\u21D1","uHar":"\u2963","uacut":"\xfa","uacute":"\xfa","uarr":"\u2191","ubrcy":"\u045E","ubreve":"\u016D","ucir":"\xfb","ucirc":"\xfb","ucy":"\u0443","udarr":"\u21C5","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","ufr":"\uD835\uDD32","ugrav":"\xf9","ugrave":"\xf9","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","umacr":"\u016B","um":"\xa8","uml":"\xa8","uogon":"\u0173","uopf":"\uD835\uDD66","uparrow":"\u2191","updownarrow":"\u2195","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","upsi":"\u03C5","upsih":"\u03D2","upsilon":"\u03C5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","uring":"\u016F","urtri":"\u25F9","uscr":"\uD835\uDCCA","utdot":"\u22F0","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","uum":"\xfc","uuml":"\xfc","uwangle":"\u29A7","vArr":"\u21D5","vBar":"\u2AE8","vBarv":"\u2AE9","vDash":"\u22A8","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vcy":"\u0432","vdash":"\u22A2","vee":"\u2228","veebar":"\u22BB","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","vert":"|","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","vzigzag":"\u299A","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","wedgeq":"\u2259","weierp":"\u2118","wfr":"\uD835\uDD34","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","xfr":"\uD835\uDD35","xhArr":"\u27FA","xharr":"\u27F7","xi":"\u03BE","xlArr":"\u27F8","xlarr":"\u27F5","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrArr":"\u27F9","xrarr":"\u27F6","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","yacut":"\xfd","yacute":"\xfd","yacy":"\u044F","ycirc":"\u0177","ycy":"\u044B","ye":"\xa5","yen":"\xa5","yfr":"\uD835\uDD36","yicy":"\u0457","yopf":"\uD835\uDD6A","yscr":"\uD835\uDCCE","yucy":"\u044E","yum":"\xff","yuml":"\xff","zacute":"\u017A","zcaron":"\u017E","zcy":"\u0437","zdot":"\u017C","zeetrf":"\u2128","zeta":"\u03B6","zfr":"\uD835\uDD37","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}');

});



parcelRegister("gQ52E", function(module, exports) {
"use strict";
module.exports = $c42569dd8f388be7$var$locate;
function $c42569dd8f388be7$var$locate(value, fromIndex) {
    return value.indexOf("<", fromIndex);
}

});


parcelRegister("9HIzs", function(module, exports) {
"use strict";

var $a597o = parcelRequire("a597o");

var $3qZkh = parcelRequire("3qZkh");

var $9cn3E = parcelRequire("9cn3E");

var $jQpNp = parcelRequire("jQpNp");

var $6qoLm = parcelRequire("6qoLm");

var $eOUs6 = parcelRequire("eOUs6");
module.exports = $710ab415b4e45c8e$var$url;
$710ab415b4e45c8e$var$url.locator = $eOUs6;
$710ab415b4e45c8e$var$url.notInLink = true;
var $710ab415b4e45c8e$var$exclamationMark = 33 // '!'
;
var $710ab415b4e45c8e$var$ampersand = 38 // '&'
;
var $710ab415b4e45c8e$var$rightParenthesis = 41 // ')'
;
var $710ab415b4e45c8e$var$asterisk = 42 // '*'
;
var $710ab415b4e45c8e$var$comma = 44 // ','
;
var $710ab415b4e45c8e$var$dash = 45 // '-'
;
var $710ab415b4e45c8e$var$dot = 46 // '.'
;
var $710ab415b4e45c8e$var$colon = 58 // ':'
;
var $710ab415b4e45c8e$var$semicolon = 59 // ';'
;
var $710ab415b4e45c8e$var$questionMark = 63 // '?'
;
var $710ab415b4e45c8e$var$lessThan = 60 // '<'
;
var $710ab415b4e45c8e$var$underscore = 95 // '_'
;
var $710ab415b4e45c8e$var$tilde = 126 // '~'
;
var $710ab415b4e45c8e$var$leftParenthesisCharacter = "(";
var $710ab415b4e45c8e$var$rightParenthesisCharacter = ")";
function $710ab415b4e45c8e$var$url(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start;
    var index;
    var pathStart;
    var path;
    var code;
    var end;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url;
    var exit;
    if (!gfm) return;
    // `WWW.` doesn’t work.
    if (value.slice(0, 4) === "www.") {
        protocolless = true;
        index = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://") index = 7;
    else if (value.slice(0, 8).toLowerCase() === "https://") index = 8;
    else return;
    // Act as if the starting boundary is a dot.
    previousDot = index - 1;
    // Parse a valid domain.
    start = index;
    dots = [];
    while(index < length){
        code = value.charCodeAt(index);
        if (code === $710ab415b4e45c8e$var$dot) {
            // Dots may not appear after each other.
            if (previousDot === index - 1) break;
            dots.push(index);
            previousDot = index;
            index++;
            continue;
        }
        if ($9cn3E(code) || $jQpNp(code) || code === $710ab415b4e45c8e$var$dash || code === $710ab415b4e45c8e$var$underscore) {
            index++;
            continue;
        }
        break;
    }
    // Ignore a final dot:
    if (code === $710ab415b4e45c8e$var$dot) {
        dots.pop();
        index--;
    }
    // If there are not dots, exit.
    if (dots[0] === undefined) return;
    // If there is an underscore in the last two domain parts, exit:
    // `www.example.c_m` and `www.ex_ample.com` are not OK, but
    // `www.sub_domain.example.com` is.
    lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    end = index;
    pathStart = index;
    // Parse a path.
    while(index < length){
        code = value.charCodeAt(index);
        if ($6qoLm(code) || code === $710ab415b4e45c8e$var$lessThan) break;
        index++;
        if (code === $710ab415b4e45c8e$var$exclamationMark || code === $710ab415b4e45c8e$var$asterisk || code === $710ab415b4e45c8e$var$comma || code === $710ab415b4e45c8e$var$dot || code === $710ab415b4e45c8e$var$colon || code === $710ab415b4e45c8e$var$questionMark || code === $710ab415b4e45c8e$var$underscore || code === $710ab415b4e45c8e$var$tilde) ;
        else end = index;
    }
    index = end;
    // If the path ends in a closing paren, and the count of closing parens is
    // higher than the opening count, then remove the supefluous closing parens.
    if (value.charCodeAt(index - 1) === $710ab415b4e45c8e$var$rightParenthesis) {
        path = value.slice(pathStart, index);
        leftCount = $a597o(path, $710ab415b4e45c8e$var$leftParenthesisCharacter);
        rightCount = $a597o(path, $710ab415b4e45c8e$var$rightParenthesisCharacter);
        while(rightCount > leftCount){
            index = pathStart + path.lastIndexOf($710ab415b4e45c8e$var$rightParenthesisCharacter);
            path = value.slice(pathStart, index);
            rightCount--;
        }
    }
    if (value.charCodeAt(index - 1) === $710ab415b4e45c8e$var$semicolon) {
        // GitHub doesn’t document this, but final semicolons aren’t paret of the
        // URL either.
        index--;
        // // If the path ends in what looks like an entity, it’s not part of the path.
        if ($jQpNp(value.charCodeAt(index - 1))) {
            end = index - 2;
            while($jQpNp(value.charCodeAt(end)))end--;
            if (value.charCodeAt(end) === $710ab415b4e45c8e$var$ampersand) index = end;
        }
    }
    content = value.slice(0, index);
    url = $3qZkh(content, {
        nonTerminated: false
    });
    if (protocolless) url = "http://" + url;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: url,
        children: children
    });
}

});
parcelRegister("a597o", function(module, exports) {
"use strict";
module.exports = $757171bb1de82ed0$var$ccount;
function $757171bb1de82ed0$var$ccount(source, character) {
    var value = String(source);
    var count = 0;
    var index;
    if (typeof character !== "string") throw new Error("Expected character");
    index = value.indexOf(character);
    while(index !== -1){
        count++;
        index = value.indexOf(character, index + character.length);
    }
    return count;
}

});

parcelRegister("eOUs6", function(module, exports) {
"use strict";
module.exports = $aca186734f4231e7$var$locate;
var $aca186734f4231e7$var$values = [
    "www.",
    "http://",
    "https://"
];
function $aca186734f4231e7$var$locate(value, fromIndex) {
    var min = -1;
    var index;
    var length;
    var position;
    if (!this.options.gfm) return min;
    length = $aca186734f4231e7$var$values.length;
    index = -1;
    while(++index < length){
        position = value.indexOf($aca186734f4231e7$var$values[index], fromIndex);
        if (position !== -1 && (min === -1 || position < min)) min = position;
    }
    return min;
}

});


parcelRegister("dps5A", function(module, exports) {
"use strict";

var $3qZkh = parcelRequire("3qZkh");

var $9cn3E = parcelRequire("9cn3E");

var $jQpNp = parcelRequire("jQpNp");

var $e0hp6 = parcelRequire("e0hp6");
module.exports = $9c336615c9ac9564$var$email;
$9c336615c9ac9564$var$email.locator = $e0hp6;
$9c336615c9ac9564$var$email.notInLink = true;
var $9c336615c9ac9564$var$plusSign = 43 // '+'
;
var $9c336615c9ac9564$var$dash = 45 // '-'
;
var $9c336615c9ac9564$var$dot = 46 // '.'
;
var $9c336615c9ac9564$var$atSign = 64 // '@'
;
var $9c336615c9ac9564$var$underscore = 95 // '_'
;
function $9c336615c9ac9564$var$email(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var index = 0;
    var length = value.length;
    var firstDot = -1;
    var code;
    var content;
    var children;
    var exit;
    if (!gfm) return;
    code = value.charCodeAt(index);
    while($9cn3E(code) || $jQpNp(code) || code === $9c336615c9ac9564$var$plusSign || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$dot || code === $9c336615c9ac9564$var$underscore)code = value.charCodeAt(++index);
    if (index === 0) return;
    if (code !== $9c336615c9ac9564$var$atSign) return;
    index++;
    while(index < length){
        code = value.charCodeAt(index);
        if ($9cn3E(code) || $jQpNp(code) || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$dot || code === $9c336615c9ac9564$var$underscore) {
            index++;
            if (firstDot === -1 && code === $9c336615c9ac9564$var$dot) firstDot = index;
            continue;
        }
        break;
    }
    if (firstDot === -1 || firstDot === index || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$underscore) return;
    if (code === $9c336615c9ac9564$var$dot) index--;
    content = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: "mailto:" + $3qZkh(content, {
            nonTerminated: false
        }),
        children: children
    });
}

});
parcelRegister("e0hp6", function(module, exports) {
"use strict";

var $9cn3E = parcelRequire("9cn3E");

var $jQpNp = parcelRequire("jQpNp");
var $a31e90cc896b73f2$var$plusSign = 43 // '+'
;
var $a31e90cc896b73f2$var$dash = 45 // '-'
;
var $a31e90cc896b73f2$var$dot = 46 // '.'
;
var $a31e90cc896b73f2$var$underscore = 95 // '_'
;
module.exports = $a31e90cc896b73f2$var$locate;
// See: <https://github.github.com/gfm/#extended-email-autolink>
function $a31e90cc896b73f2$var$locate(value, fromIndex) {
    var self = this;
    var at;
    var position;
    if (!this.options.gfm) return -1;
    at = value.indexOf("@", fromIndex);
    if (at === -1) return -1;
    position = at;
    if (position === fromIndex || !$a31e90cc896b73f2$var$isGfmAtext(value.charCodeAt(position - 1))) return $a31e90cc896b73f2$var$locate.call(self, value, at + 1);
    while(position > fromIndex && $a31e90cc896b73f2$var$isGfmAtext(value.charCodeAt(position - 1)))position--;
    return position;
}
function $a31e90cc896b73f2$var$isGfmAtext(code) {
    return $9cn3E(code) || $jQpNp(code) || code === $a31e90cc896b73f2$var$plusSign || code === $a31e90cc896b73f2$var$dash || code === $a31e90cc896b73f2$var$dot || code === $a31e90cc896b73f2$var$underscore;
}

});


parcelRegister("6NCFJ", function(module, exports) {
"use strict";

var $jQpNp = parcelRequire("jQpNp");

var $gQ52E = parcelRequire("gQ52E");

var $fjSMD = parcelRequire("fjSMD");
var $4f3551226f982ae4$require$tag = $fjSMD.tag;
module.exports = $4f3551226f982ae4$var$inlineHTML;
$4f3551226f982ae4$var$inlineHTML.locator = $gQ52E;
var $4f3551226f982ae4$var$lessThan = "<";
var $4f3551226f982ae4$var$questionMark = "?";
var $4f3551226f982ae4$var$exclamationMark = "!";
var $4f3551226f982ae4$var$slash = "/";
var $4f3551226f982ae4$var$htmlLinkOpenExpression = /^<a /i;
var $4f3551226f982ae4$var$htmlLinkCloseExpression = /^<\/a>/i;
function $4f3551226f982ae4$var$inlineHTML(eat, value, silent) {
    var self = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== $4f3551226f982ae4$var$lessThan || length < 3) return;
    character = value.charAt(1);
    if (!$jQpNp(character) && character !== $4f3551226f982ae4$var$questionMark && character !== $4f3551226f982ae4$var$exclamationMark && character !== $4f3551226f982ae4$var$slash) return;
    subvalue = value.match($4f3551226f982ae4$require$tag);
    if (!subvalue) return;
    /* istanbul ignore if - not used yet. */ if (silent) return true;
    subvalue = subvalue[0];
    if (!self.inLink && $4f3551226f982ae4$var$htmlLinkOpenExpression.test(subvalue)) self.inLink = true;
    else if (self.inLink && $4f3551226f982ae4$var$htmlLinkCloseExpression.test(subvalue)) self.inLink = false;
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}

});

parcelRegister("8jyKl", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");

var $56k0G = parcelRequire("56k0G");
module.exports = $60db0d060832584b$var$link;
$60db0d060832584b$var$link.locator = $56k0G;
var $60db0d060832584b$var$lineFeed = "\n";
var $60db0d060832584b$var$exclamationMark = "!";
var $60db0d060832584b$var$quotationMark = '"';
var $60db0d060832584b$var$apostrophe = "'";
var $60db0d060832584b$var$leftParenthesis = "(";
var $60db0d060832584b$var$rightParenthesis = ")";
var $60db0d060832584b$var$lessThan = "<";
var $60db0d060832584b$var$greaterThan = ">";
var $60db0d060832584b$var$leftSquareBracket = "[";
var $60db0d060832584b$var$backslash = "\\";
var $60db0d060832584b$var$rightSquareBracket = "]";
var $60db0d060832584b$var$graveAccent = "`";
function $60db0d060832584b$var$link(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var index = 0;
    var character = value.charAt(0);
    var pedantic = self.options.pedantic;
    var commonmark = self.options.commonmark;
    var gfm = self.options.gfm;
    var closed;
    var count;
    var opening;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;
    var exit;
    var node;
    // Detect whether this is an image.
    if (character === $60db0d060832584b$var$exclamationMark) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }
    // Eat the opening.
    if (character !== $60db0d060832584b$var$leftSquareBracket) return;
    // Exit when this is a link and we’re already inside a link.
    if (!isImage && self.inLink) return;
    subvalue += character;
    queue = "";
    index++;
    // Eat the content.
    length = value.length;
    now = eat.now();
    depth = 0;
    now.column += index;
    now.offset += index;
    while(index < length){
        character = value.charAt(index);
        subqueue = character;
        if (character === $60db0d060832584b$var$graveAccent) {
            // Inline-code in link content.
            count = 1;
            while(value.charAt(index + 1) === $60db0d060832584b$var$graveAccent){
                subqueue += character;
                index++;
                count++;
            }
            if (!opening) opening = count;
            else if (count >= opening) opening = 0;
        } else if (character === $60db0d060832584b$var$backslash) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
        } else if ((!opening || gfm) && character === $60db0d060832584b$var$leftSquareBracket) // In GFM mode, brackets in code still count.  In all other modes,
        // they don’t.
        depth++;
        else if ((!opening || gfm) && character === $60db0d060832584b$var$rightSquareBracket) {
            if (depth) depth--;
            else {
                if (value.charAt(index + 1) !== $60db0d060832584b$var$leftParenthesis) return;
                subqueue += $60db0d060832584b$var$leftParenthesis;
                closed = true;
                index++;
                break;
            }
        }
        queue += subqueue;
        subqueue = "";
        index++;
    }
    // Eat the content closing.
    if (!closed) return;
    content = queue;
    subvalue += queue + subqueue;
    index++;
    // Eat white-space.
    while(index < length){
        character = value.charAt(index);
        if (!$6qoLm(character)) break;
        subvalue += character;
        index++;
    }
    // Eat the URL.
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $60db0d060832584b$var$lessThan) {
        index++;
        beforeURL += $60db0d060832584b$var$lessThan;
        while(index < length){
            character = value.charAt(index);
            if (character === $60db0d060832584b$var$greaterThan) break;
            if (commonmark && character === $60db0d060832584b$var$lineFeed) return;
            queue += character;
            index++;
        }
        if (value.charAt(index) !== $60db0d060832584b$var$greaterThan) return;
        subvalue += $60db0d060832584b$var$lessThan + queue + $60db0d060832584b$var$greaterThan;
        url = queue;
        index++;
    } else {
        character = null;
        subqueue = "";
        while(index < length){
            character = value.charAt(index);
            if (subqueue && (character === $60db0d060832584b$var$quotationMark || character === $60db0d060832584b$var$apostrophe || commonmark && character === $60db0d060832584b$var$leftParenthesis)) break;
            if ($6qoLm(character)) {
                if (!pedantic) break;
                subqueue += character;
            } else {
                if (character === $60db0d060832584b$var$leftParenthesis) depth++;
                else if (character === $60db0d060832584b$var$rightParenthesis) {
                    if (depth === 0) break;
                    depth--;
                }
                queue += subqueue;
                subqueue = "";
                if (character === $60db0d060832584b$var$backslash) {
                    queue += $60db0d060832584b$var$backslash;
                    character = value.charAt(++index);
                }
                queue += character;
            }
            index++;
        }
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }
    // Eat white-space.
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (!$6qoLm(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    subvalue += queue;
    // Eat the title.
    if (queue && (character === $60db0d060832584b$var$quotationMark || character === $60db0d060832584b$var$apostrophe || commonmark && character === $60db0d060832584b$var$leftParenthesis)) {
        index++;
        subvalue += character;
        queue = "";
        marker = character === $60db0d060832584b$var$leftParenthesis ? $60db0d060832584b$var$rightParenthesis : character;
        beforeTitle = subvalue;
        // In commonmark-mode, things are pretty easy: the marker cannot occur
        // inside the title.  Non-commonmark does, however, support nested
        // delimiters.
        if (commonmark) {
            while(index < length){
                character = value.charAt(index);
                if (character === marker) break;
                if (character === $60db0d060832584b$var$backslash) {
                    queue += $60db0d060832584b$var$backslash;
                    character = value.charAt(++index);
                }
                index++;
                queue += character;
            }
            character = value.charAt(index);
            if (character !== marker) return;
            title = queue;
            subvalue += queue + character;
            index++;
            while(index < length){
                character = value.charAt(index);
                if (!$6qoLm(character)) break;
                subvalue += character;
                index++;
            }
        } else {
            subqueue = "";
            while(index < length){
                character = value.charAt(index);
                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + subqueue;
                        subqueue = "";
                    }
                    hasMarker = true;
                } else if (!hasMarker) queue += character;
                else if (character === $60db0d060832584b$var$rightParenthesis) {
                    subvalue += queue + marker + subqueue;
                    title = queue;
                    break;
                } else if ($6qoLm(character)) subqueue += character;
                else {
                    queue += marker + subqueue + character;
                    subqueue = "";
                    hasMarker = false;
                }
                index++;
            }
        }
    }
    if (value.charAt(index) !== $60db0d060832584b$var$rightParenthesis) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    subvalue += $60db0d060832584b$var$rightParenthesis;
    url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
        nonTerminated: false
    });
    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self.decode.raw(self.unescape(title), beforeTitle);
    }
    node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url
    };
    if (isImage) node.alt = self.decode.raw(self.unescape(content), now) || null;
    else {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    }
    return eat(subvalue)(node);
}

});
parcelRegister("56k0G", function(module, exports) {
"use strict";
module.exports = $3b6d08e06ccc3714$var$locate;
function $3b6d08e06ccc3714$var$locate(value, fromIndex) {
    var link = value.indexOf("[", fromIndex);
    var image = value.indexOf("![", fromIndex);
    if (image === -1) return link;
    // Link can never be `-1` if an image is found, so we don’t need to check
    // for that :)
    return link < image ? link : image;
}

});


parcelRegister("4wSVw", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");

var $56k0G = parcelRequire("56k0G");

var $4Zypr = parcelRequire("4Zypr");
module.exports = $34c4c1e1c6f87b77$var$reference;
$34c4c1e1c6f87b77$var$reference.locator = $56k0G;
var $34c4c1e1c6f87b77$var$link = "link";
var $34c4c1e1c6f87b77$var$image = "image";
var $34c4c1e1c6f87b77$var$shortcut = "shortcut";
var $34c4c1e1c6f87b77$var$collapsed = "collapsed";
var $34c4c1e1c6f87b77$var$full = "full";
var $34c4c1e1c6f87b77$var$exclamationMark = "!";
var $34c4c1e1c6f87b77$var$leftSquareBracket = "[";
var $34c4c1e1c6f87b77$var$backslash = "\\";
var $34c4c1e1c6f87b77$var$rightSquareBracket = "]";
function $34c4c1e1c6f87b77$var$reference(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type = $34c4c1e1c6f87b77$var$link;
    var referenceType = $34c4c1e1c6f87b77$var$shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    // Check whether we’re eating an image.
    if (character === $34c4c1e1c6f87b77$var$exclamationMark) {
        type = $34c4c1e1c6f87b77$var$image;
        intro = character;
        character = value.charAt(++index);
    }
    if (character !== $34c4c1e1c6f87b77$var$leftSquareBracket) return;
    index++;
    intro += character;
    queue = "";
    // Eat the text.
    depth = 0;
    while(index < length){
        character = value.charAt(index);
        if (character === $34c4c1e1c6f87b77$var$leftSquareBracket) {
            bracketed = true;
            depth++;
        } else if (character === $34c4c1e1c6f87b77$var$rightSquareBracket) {
            if (!depth) break;
            depth--;
        }
        if (character === $34c4c1e1c6f87b77$var$backslash) {
            queue += $34c4c1e1c6f87b77$var$backslash;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index);
    if (character !== $34c4c1e1c6f87b77$var$rightSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    if (!commonmark) // The original markdown syntax definition explicitly allows for whitespace
    // between the link text and link label; commonmark departs from this, in
    // part to improve support for shortcut reference links
    while(index < length){
        character = value.charAt(index);
        if (!$6qoLm(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (character === $34c4c1e1c6f87b77$var$leftSquareBracket) {
        identifier = "";
        queue += character;
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character === $34c4c1e1c6f87b77$var$leftSquareBracket || character === $34c4c1e1c6f87b77$var$rightSquareBracket) break;
            if (character === $34c4c1e1c6f87b77$var$backslash) {
                identifier += $34c4c1e1c6f87b77$var$backslash;
                character = value.charAt(++index);
            }
            identifier += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $34c4c1e1c6f87b77$var$rightSquareBracket) {
            referenceType = identifier ? $34c4c1e1c6f87b77$var$full : $34c4c1e1c6f87b77$var$collapsed;
            queue += identifier + character;
            index++;
        } else identifier = "";
        subvalue += queue;
        queue = "";
    } else {
        if (!content) return;
        identifier = content;
    }
    // Brackets cannot be inside the identifier.
    if (referenceType !== $34c4c1e1c6f87b77$var$full && bracketed) return;
    subvalue = intro + subvalue;
    if (type === $34c4c1e1c6f87b77$var$link && self.inLink) return null;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === $34c4c1e1c6f87b77$var$full ? identifier : content;
    node = {
        type: type + "Reference",
        identifier: $4Zypr(identifier),
        label: identifier,
        referenceType: referenceType
    };
    if (type === $34c4c1e1c6f87b77$var$link) {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    } else node.alt = self.decode.raw(self.unescape(content), now) || null;
    return eat(subvalue)(node);
}

});

parcelRegister("icpkQ", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $6qoLm = parcelRequire("6qoLm");

var $hXbwz = parcelRequire("hXbwz");
module.exports = $d3fd0006fe9bff75$var$strong;
$d3fd0006fe9bff75$var$strong.locator = $hXbwz;
var $d3fd0006fe9bff75$var$backslash = "\\";
var $d3fd0006fe9bff75$var$asterisk = "*";
var $d3fd0006fe9bff75$var$underscore = "_";
function $d3fd0006fe9bff75$var$strong(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $d3fd0006fe9bff75$var$asterisk && character !== $d3fd0006fe9bff75$var$underscore || value.charAt(++index) !== character) return;
    pedantic = self.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $6qoLm(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$6qoLm(previous))) {
            character = value.charAt(index + 2);
            if (character !== marker) {
                if (!$lSPH2(queue)) return;
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column += 2;
                now.offset += 2;
                return eat(subvalue + queue + subvalue)({
                    type: "strong",
                    children: self.tokenizeInline(queue, now)
                });
            }
        }
        if (!pedantic && character === $d3fd0006fe9bff75$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}

});
parcelRegister("hXbwz", function(module, exports) {
"use strict";
module.exports = $d120e2dedcddea7d$var$locate;
function $d120e2dedcddea7d$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}

});


parcelRegister("3P2AS", function(module, exports) {
"use strict";

var $lSPH2 = parcelRequire("lSPH2");

var $escbs = parcelRequire("escbs");

var $6qoLm = parcelRequire("6qoLm");

var $dLzgd = parcelRequire("dLzgd");
module.exports = $2c882591cf327a57$var$emphasis;
$2c882591cf327a57$var$emphasis.locator = $dLzgd;
var $2c882591cf327a57$var$asterisk = "*";
var $2c882591cf327a57$var$underscore = "_";
var $2c882591cf327a57$var$backslash = "\\";
function $2c882591cf327a57$var$emphasis(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $2c882591cf327a57$var$asterisk && character !== $2c882591cf327a57$var$underscore) return;
    pedantic = self.options.pedantic;
    subvalue = character;
    marker = character;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $6qoLm(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && (!pedantic || !$6qoLm(previous))) {
            character = value.charAt(++index);
            if (character !== marker) {
                if (!$lSPH2(queue) || previous === marker) return;
                if (!pedantic && marker === $2c882591cf327a57$var$underscore && $escbs(character)) {
                    queue += marker;
                    continue;
                }
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column++;
                now.offset++;
                return eat(subvalue + queue + marker)({
                    type: "emphasis",
                    children: self.tokenizeInline(queue, now)
                });
            }
            queue += marker;
        }
        if (!pedantic && character === $2c882591cf327a57$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}

});
parcelRegister("escbs", function(module, exports) {
"use strict";
module.exports = $a85d21ab5f43d069$var$wordCharacter;
var $a85d21ab5f43d069$var$fromCode = String.fromCharCode;
var $a85d21ab5f43d069$var$re = /\w/;
// Check if the given character code, or the character code at the first
// character, is a word character.
function $a85d21ab5f43d069$var$wordCharacter(character) {
    return $a85d21ab5f43d069$var$re.test(typeof character === "number" ? $a85d21ab5f43d069$var$fromCode(character) : character.charAt(0));
}

});

parcelRegister("dLzgd", function(module, exports) {
"use strict";
module.exports = $a05b0423a51622b7$var$locate;
function $a05b0423a51622b7$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}

});


parcelRegister("jUYRO", function(module, exports) {
"use strict";

var $6qoLm = parcelRequire("6qoLm");

var $9mumw = parcelRequire("9mumw");
module.exports = $e80276304304c5e0$var$strikethrough;
$e80276304304c5e0$var$strikethrough.locator = $9mumw;
var $e80276304304c5e0$var$tilde = "~";
var $e80276304304c5e0$var$fence = "~~";
function $e80276304304c5e0$var$strikethrough(eat, value, silent) {
    var self = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index;
    var length;
    var now;
    if (!self.options.gfm || value.charAt(0) !== $e80276304304c5e0$var$tilde || value.charAt(1) !== $e80276304304c5e0$var$tilde || $6qoLm(value.charAt(2))) return;
    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;
    now.offset += 2;
    while(++index < length){
        character = value.charAt(index);
        if (character === $e80276304304c5e0$var$tilde && previous === $e80276304304c5e0$var$tilde && (!preceding || !$6qoLm(preceding))) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat($e80276304304c5e0$var$fence + subvalue + $e80276304304c5e0$var$fence)({
                type: "delete",
                children: self.tokenizeInline(subvalue, now)
            });
        }
        subvalue += previous;
        preceding = previous;
        previous = character;
    }
}

});
parcelRegister("9mumw", function(module, exports) {
"use strict";
module.exports = $6d0db875ed18fe9e$var$locate;
function $6d0db875ed18fe9e$var$locate(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
}

});


parcelRegister("ahmx7", function(module, exports) {
"use strict";

var $fzlur = parcelRequire("fzlur");
module.exports = $77bcf88b867a48b1$var$inlineCode;
$77bcf88b867a48b1$var$inlineCode.locator = $fzlur;
var $77bcf88b867a48b1$var$lineFeed = 10 //  '\n'
;
var $77bcf88b867a48b1$var$space = 32 // ' '
;
var $77bcf88b867a48b1$var$graveAccent = 96 //  '`'
;
function $77bcf88b867a48b1$var$inlineCode(eat, value, silent) {
    var length = value.length;
    var index = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code;
    var next;
    var found;
    while(index < length){
        if (value.charCodeAt(index) !== $77bcf88b867a48b1$var$graveAccent) break;
        index++;
    }
    if (index === 0 || index === length) return;
    openingFenceEnd = index;
    next = value.charCodeAt(index);
    while(index < length){
        code = next;
        next = value.charCodeAt(index + 1);
        if (code === $77bcf88b867a48b1$var$graveAccent) {
            if (closingFenceStart === undefined) closingFenceStart = index;
            closingFenceEnd = index + 1;
            if (next !== $77bcf88b867a48b1$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
                found = true;
                break;
            }
        } else if (closingFenceStart !== undefined) {
            closingFenceStart = undefined;
            closingFenceEnd = undefined;
        }
        index++;
    }
    if (!found) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Remove the initial and final space (or line feed), iff they exist and there
    // are non-space characters in the content.
    index = openingFenceEnd;
    length = closingFenceStart;
    code = value.charCodeAt(index);
    next = value.charCodeAt(length - 1);
    found = false;
    if (length - index > 2 && (code === $77bcf88b867a48b1$var$space || code === $77bcf88b867a48b1$var$lineFeed) && (next === $77bcf88b867a48b1$var$space || next === $77bcf88b867a48b1$var$lineFeed)) {
        index++;
        length--;
        while(index < length){
            code = value.charCodeAt(index);
            if (code !== $77bcf88b867a48b1$var$space && code !== $77bcf88b867a48b1$var$lineFeed) {
                found = true;
                break;
            }
            index++;
        }
        if (found === true) {
            openingFenceEnd++;
            closingFenceStart--;
        }
    }
    return eat(value.slice(0, closingFenceEnd))({
        type: "inlineCode",
        value: value.slice(openingFenceEnd, closingFenceStart)
    });
}

});
parcelRegister("fzlur", function(module, exports) {
"use strict";
module.exports = $b55acb5d79e00b8e$var$locate;
function $b55acb5d79e00b8e$var$locate(value, fromIndex) {
    return value.indexOf("`", fromIndex);
}

});


parcelRegister("9AmxP", function(module, exports) {
"use strict";

var $bLzz2 = parcelRequire("bLzz2");
module.exports = $6fa8f6ba047a1858$var$hardBreak;
$6fa8f6ba047a1858$var$hardBreak.locator = $bLzz2;
var $6fa8f6ba047a1858$var$space = " ";
var $6fa8f6ba047a1858$var$lineFeed = "\n";
var $6fa8f6ba047a1858$var$minBreakLength = 2;
function $6fa8f6ba047a1858$var$hardBreak(eat, value, silent) {
    var length = value.length;
    var index = -1;
    var queue = "";
    var character;
    while(++index < length){
        character = value.charAt(index);
        if (character === $6fa8f6ba047a1858$var$lineFeed) {
            if (index < $6fa8f6ba047a1858$var$minBreakLength) return;
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            queue += character;
            return eat(queue)({
                type: "break"
            });
        }
        if (character !== $6fa8f6ba047a1858$var$space) return;
        queue += character;
    }
}

});
parcelRegister("bLzz2", function(module, exports) {
"use strict";
module.exports = $890fabcb91c3fbd5$var$locate;
function $890fabcb91c3fbd5$var$locate(value, fromIndex) {
    var index = value.indexOf("\n", fromIndex);
    while(index > fromIndex){
        if (value.charAt(index - 1) !== " ") break;
        index--;
    }
    return index;
}

});


parcelRegister("I2hrQ", function(module, exports) {
"use strict";
module.exports = $0845e104fe9855d1$var$text;
function $0845e104fe9855d1$var$text(eat, value, silent) {
    var self = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    methods = self.inlineMethods;
    length = methods.length;
    tokenizers = self.inlineTokenizers;
    index = -1;
    min = value.length;
    while(++index < length){
        name = methods[index];
        if (name === "text" || !tokenizers[name]) continue;
        tokenizer = tokenizers[name].locator;
        if (!tokenizer) eat.file.fail("Missing locator: `" + name + "`");
        position = tokenizer.call(self, value, 1);
        if (position !== -1 && position < min) min = position;
    }
    subvalue = value.slice(0, min);
    now = eat.now();
    self.decode(subvalue, now, handler);
    function handler(content, position, source) {
        eat(source || content)({
            type: "text",
            value: content
        });
    }
}

});

parcelRegister("ljm8s", function(module, exports) {

var $dTQAV = parcelRequire("dTQAV");

var $5xH1P = parcelRequire("5xH1P");
var $87a9ab9859246ada$require$containsFrontmatter = $5xH1P.containsFrontmatter;
/**
 * @param {string} content File Content
 * @returns {any}
 */ const $87a9ab9859246ada$var$parseFrontmatter = (content)=>{
    // Run against regex
    const frontmatter = $87a9ab9859246ada$require$containsFrontmatter(content);
    if (frontmatter) return $dTQAV.parse(frontmatter) ?? {};
    // No match for frontmatter
    return undefined;
};
module.exports = {
    parseFrontmatter: $87a9ab9859246ada$var$parseFrontmatter
};

});
parcelRegister("dTQAV", function(module, exports) {

$parcel$export(module.exports, "parse", () => $a1e9359aa6e39471$export$98e6a39c04603d36, (v) => $a1e9359aa6e39471$export$98e6a39c04603d36 = v);
var $a1e9359aa6e39471$export$57ed0bcea28f97a2;
var $a1e9359aa6e39471$export$b34a105447964f9f;
var $a1e9359aa6e39471$export$19342e026b58ebb7;
var $a1e9359aa6e39471$export$699cd54d617b337f;
var $a1e9359aa6e39471$export$c1188aaa49090a5c;
var $a1e9359aa6e39471$export$856b463bac79f971;
var $a1e9359aa6e39471$export$17b520249a85fe16;
var $a1e9359aa6e39471$export$c6275352883a2b3e;
var $a1e9359aa6e39471$export$cea7aa84e978eba5;
var $a1e9359aa6e39471$export$62858bae88b53fd0;
var $a1e9359aa6e39471$export$5c90113a285f2241;
var $a1e9359aa6e39471$export$8ee0fc9ee280b4ee;
var $a1e9359aa6e39471$export$7c8d445944656308;
var $a1e9359aa6e39471$export$8f3495e22775e76c;
var $a1e9359aa6e39471$export$342ac1d101ffe14b;
var $a1e9359aa6e39471$export$d63d7cff08fe4dc9;
var $a1e9359aa6e39471$export$595dbf49c602a1f;
var $a1e9359aa6e39471$export$eb1691c4b19bb5eb;
var $a1e9359aa6e39471$export$47adc25f769055b2;
var $a1e9359aa6e39471$export$dd3c50b1c80c78ef;
var $a1e9359aa6e39471$export$6168dc8908a6c652;
var $a1e9359aa6e39471$export$c8a6f24ae2865e59;
var $a1e9359aa6e39471$export$7acfa6ed01010e37;
var $a1e9359aa6e39471$export$98e6a39c04603d36;
var $a1e9359aa6e39471$export$643da2570c3b3d01;
var $a1e9359aa6e39471$export$b6a9369736b19f4d;
var $a1e9359aa6e39471$export$fac44ee5b035f737;
var $a1e9359aa6e39471$export$bf638b60ea8b89b7;
var $a1e9359aa6e39471$export$3c4f5d970a5e6a3b;
"use strict";

var $9Ds0b = parcelRequire("9Ds0b");

var $e3GNt = parcelRequire("e3GNt");

var $lz3js = parcelRequire("lz3js");

var $1MTYj = parcelRequire("1MTYj");

var $2QkGt = parcelRequire("2QkGt");

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $k84gT = parcelRequire("k84gT");

var $k3oDt = parcelRequire("k3oDt");

var $dsY7M = parcelRequire("dsY7M");

var $dlJmx = parcelRequire("dlJmx");

var $2pbWl = parcelRequire("2pbWl");

var $93t4w = parcelRequire("93t4w");

var $6nt1D = parcelRequire("6nt1D");

var $f2kIs = parcelRequire("f2kIs");

var $dh9VJ = parcelRequire("dh9VJ");
$a1e9359aa6e39471$export$57ed0bcea28f97a2 = $9Ds0b.Composer;
$a1e9359aa6e39471$export$b34a105447964f9f = $e3GNt.Document;
$a1e9359aa6e39471$export$19342e026b58ebb7 = $lz3js.Schema;
$a1e9359aa6e39471$export$699cd54d617b337f = $1MTYj.YAMLError;
$a1e9359aa6e39471$export$c1188aaa49090a5c = $1MTYj.YAMLParseError;
$a1e9359aa6e39471$export$856b463bac79f971 = $1MTYj.YAMLWarning;
$a1e9359aa6e39471$export$17b520249a85fe16 = $2QkGt.Alias;
$a1e9359aa6e39471$export$c6275352883a2b3e = $8XpWs.isAlias;
$a1e9359aa6e39471$export$cea7aa84e978eba5 = $8XpWs.isCollection;
$a1e9359aa6e39471$export$62858bae88b53fd0 = $8XpWs.isDocument;
$a1e9359aa6e39471$export$5c90113a285f2241 = $8XpWs.isMap;
$a1e9359aa6e39471$export$8ee0fc9ee280b4ee = $8XpWs.isNode;
$a1e9359aa6e39471$export$7c8d445944656308 = $8XpWs.isPair;
$a1e9359aa6e39471$export$8f3495e22775e76c = $8XpWs.isScalar;
$a1e9359aa6e39471$export$342ac1d101ffe14b = $8XpWs.isSeq;
$a1e9359aa6e39471$export$d63d7cff08fe4dc9 = $3difO.Pair;
$a1e9359aa6e39471$export$595dbf49c602a1f = $k84gT.Scalar;
$a1e9359aa6e39471$export$eb1691c4b19bb5eb = $k3oDt.YAMLMap;
$a1e9359aa6e39471$export$47adc25f769055b2 = $dsY7M.YAMLSeq;
$a1e9359aa6e39471$export$dd3c50b1c80c78ef = $dlJmx;
$a1e9359aa6e39471$export$6168dc8908a6c652 = $2pbWl.Lexer;
$a1e9359aa6e39471$export$c8a6f24ae2865e59 = $93t4w.LineCounter;
$a1e9359aa6e39471$export$7acfa6ed01010e37 = $6nt1D.Parser;
$a1e9359aa6e39471$export$98e6a39c04603d36 = $f2kIs.parse;
$a1e9359aa6e39471$export$643da2570c3b3d01 = $f2kIs.parseAllDocuments;
$a1e9359aa6e39471$export$b6a9369736b19f4d = $f2kIs.parseDocument;
$a1e9359aa6e39471$export$fac44ee5b035f737 = $f2kIs.stringify;
$a1e9359aa6e39471$export$bf638b60ea8b89b7 = $dh9VJ.visit;
$a1e9359aa6e39471$export$3c4f5d970a5e6a3b = $dh9VJ.visitAsync;

});
parcelRegister("9Ds0b", function(module, exports) {

$parcel$export(module.exports, "Composer", () => $703d7a2a25afcd1e$export$57ed0bcea28f97a2, (v) => $703d7a2a25afcd1e$export$57ed0bcea28f97a2 = v);
var $703d7a2a25afcd1e$export$57ed0bcea28f97a2;
"use strict";

var $7Vhyk = parcelRequire("7Vhyk");

var $e3GNt = parcelRequire("e3GNt");

var $1MTYj = parcelRequire("1MTYj");

var $8XpWs = parcelRequire("8XpWs");

var $aHTfY = parcelRequire("aHTfY");

var $3YAog = parcelRequire("3YAog");
function $703d7a2a25afcd1e$var$getErrorPos(src) {
    if (typeof src === "number") return [
        src,
        src + 1
    ];
    if (Array.isArray(src)) return src.length === 2 ? src : [
        src[0],
        src[1]
    ];
    const { offset: offset, source: source } = src;
    return [
        offset,
        offset + (typeof source === "string" ? source.length : 1)
    ];
}
function $703d7a2a25afcd1e$var$parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for(let i = 0; i < prelude.length; ++i){
        const source = prelude[i];
        switch(source[0]){
            case "#":
                comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
                atComment = true;
                afterEmptyLine = false;
                break;
            case "%":
                if (prelude[i + 1]?.[0] !== "#") i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment) afterEmptyLine = true;
                atComment = false;
        }
    }
    return {
        comment: comment,
        afterEmptyLine: afterEmptyLine
    };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */ class $703d7a2a25afcd1e$var$Composer {
    constructor(options = {}){
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning)=>{
            const pos = $703d7a2a25afcd1e$var$getErrorPos(source);
            if (warning) this.warnings.push(new $1MTYj.YAMLWarning(pos, code, message));
            else this.errors.push(new $1MTYj.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new $7Vhyk.Directives({
            version: options.version || "1.2"
        });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment: comment, afterEmptyLine: afterEmptyLine } = $703d7a2a25afcd1e$var$parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment;
            else if ($8XpWs.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if ($8XpWs.isPair(it)) it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            } else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */ streamInfo() {
        return {
            comment: $703d7a2a25afcd1e$var$parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */ *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */ *next(token) {
        if (process.env.LOG_STREAM) console.dir(token, {
            depth: null
        });
        switch(token.type){
            case "directive":
                this.directives.add(token.source, (offset, message, warning)=>{
                    const pos = $703d7a2a25afcd1e$var$getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, "BAD_DIRECTIVE", message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case "document":
                {
                    const doc = $aHTfY.composeDoc(this.options, this.directives, token, this.onError);
                    if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
                    this.decorate(doc, false);
                    if (this.doc) yield this.doc;
                    this.doc = doc;
                    this.atDirectives = false;
                    break;
                }
            case "byte-order-mark":
            case "space":
                break;
            case "comment":
            case "newline":
                this.prelude.push(token.source);
                break;
            case "error":
                {
                    const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
                    const error = new $1MTYj.YAMLParseError($703d7a2a25afcd1e$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg);
                    if (this.atDirectives || !this.doc) this.errors.push(error);
                    else this.doc.errors.push(error);
                    break;
                }
            case "doc-end":
                {
                    if (!this.doc) {
                        const msg = "Unexpected doc-end without preceding document";
                        this.errors.push(new $1MTYj.YAMLParseError($703d7a2a25afcd1e$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                        break;
                    }
                    this.doc.directives.docEnd = true;
                    const end = $3YAog.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                    this.decorate(this.doc, true);
                    if (end.comment) {
                        const dc = this.doc.comment;
                        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                    }
                    this.doc.range[2] = end.offset;
                    break;
                }
            default:
                this.errors.push(new $1MTYj.YAMLParseError($703d7a2a25afcd1e$var$getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */ *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        } else if (forceDoc) {
            const opts = Object.assign({
                _directives: this.directives
            }, this.options);
            const doc = new $e3GNt.Document(undefined, opts);
            if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
            doc.range = [
                0,
                endOffset,
                endOffset
            ];
            this.decorate(doc, false);
            yield doc;
        }
    }
}
$703d7a2a25afcd1e$export$57ed0bcea28f97a2 = $703d7a2a25afcd1e$var$Composer;

});
parcelRegister("7Vhyk", function(module, exports) {

$parcel$export(module.exports, "Directives", () => $5c4b78e346aac244$export$129646a0e1af8d85, (v) => $5c4b78e346aac244$export$129646a0e1af8d85 = v);
var $5c4b78e346aac244$export$129646a0e1af8d85;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $dh9VJ = parcelRequire("dh9VJ");
const $5c4b78e346aac244$var$escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
};
const $5c4b78e346aac244$var$escapeTagName = (tn)=>tn.replace(/[!,[\]{}]/g, (ch)=>$5c4b78e346aac244$var$escapeChars[ch]);
class $5c4b78e346aac244$var$Directives {
    constructor(yaml, tags){
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */ this.docStart = null;
        /** The doc-end marker `...`.  */ this.docEnd = false;
        this.yaml = Object.assign({}, $5c4b78e346aac244$var$Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, $5c4b78e346aac244$var$Directives.defaultTags, tags);
    }
    clone() {
        const copy = new $5c4b78e346aac244$var$Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */ atDocument() {
        const res = new $5c4b78e346aac244$var$Directives(this.yaml, this.tags);
        switch(this.yaml.version){
            case "1.1":
                this.atNextDocument = true;
                break;
            case "1.2":
                this.atNextDocument = false;
                this.yaml = {
                    explicit: $5c4b78e346aac244$var$Directives.defaultYaml.explicit,
                    version: "1.2"
                };
                this.tags = Object.assign({}, $5c4b78e346aac244$var$Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */ add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = {
                explicit: $5c4b78e346aac244$var$Directives.defaultYaml.explicit,
                version: "1.1"
            };
            this.tags = Object.assign({}, $5c4b78e346aac244$var$Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch(name){
            case "%TAG":
                {
                    if (parts.length !== 2) {
                        onError(0, "%TAG directive should contain exactly two parts");
                        if (parts.length < 2) return false;
                    }
                    const [handle, prefix] = parts;
                    this.tags[handle] = prefix;
                    return true;
                }
            case "%YAML":
                {
                    this.yaml.explicit = true;
                    if (parts.length !== 1) {
                        onError(0, "%YAML directive should contain exactly one part");
                        return false;
                    }
                    const [version] = parts;
                    if (version === "1.1" || version === "1.2") {
                        this.yaml.version = version;
                        return true;
                    } else {
                        const isValid = /^\d+\.\d+$/.test(version);
                        onError(6, `Unsupported YAML version ${version}`, isValid);
                        return false;
                    }
                }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */ tagName(source, onError) {
        if (source === "!") return "!"; // non-specific tag
        if (source[0] !== "!") {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === "<") {
            const verbatim = source.slice(2, -1);
            if (verbatim === "!" || verbatim === "!!") {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix) onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) try {
            return prefix + decodeURIComponent(suffix);
        } catch (error) {
            onError(String(error));
            return null;
        }
        if (handle === "!") return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */ tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)){
            if (tag.startsWith(prefix)) return handle + $5c4b78e346aac244$var$escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit ? [
            `%YAML ${this.yaml.version || "1.2"}`
        ] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && $8XpWs.isNode(doc.contents)) {
            const tags = {};
            $dh9VJ.visit(doc.contents, (_key, node)=>{
                if ($8XpWs.isNode(node) && node.tag) tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        } else tagNames = [];
        for (const [handle, prefix] of tagEntries){
            if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
            if (!doc || tagNames.some((tn)=>tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
    }
}
$5c4b78e346aac244$var$Directives.defaultYaml = {
    explicit: false,
    version: "1.2"
};
$5c4b78e346aac244$var$Directives.defaultTags = {
    "!!": "tag:yaml.org,2002:"
};
$5c4b78e346aac244$export$129646a0e1af8d85 = $5c4b78e346aac244$var$Directives;

});
parcelRegister("8XpWs", function(module, exports) {

$parcel$export(module.exports, "ALIAS", () => $6857f4f1cda3188c$export$6e16f50e77e6cb4d, (v) => $6857f4f1cda3188c$export$6e16f50e77e6cb4d = v);
$parcel$export(module.exports, "DOC", () => $6857f4f1cda3188c$export$c41a48f61a15d775, (v) => $6857f4f1cda3188c$export$c41a48f61a15d775 = v);
$parcel$export(module.exports, "MAP", () => $6857f4f1cda3188c$export$ce970371e0e850bc, (v) => $6857f4f1cda3188c$export$ce970371e0e850bc = v);
$parcel$export(module.exports, "NODE_TYPE", () => $6857f4f1cda3188c$export$accaa52ddae3fe58, (v) => $6857f4f1cda3188c$export$accaa52ddae3fe58 = v);
$parcel$export(module.exports, "PAIR", () => $6857f4f1cda3188c$export$c4eb1412cef9eb18, (v) => $6857f4f1cda3188c$export$c4eb1412cef9eb18 = v);
$parcel$export(module.exports, "SCALAR", () => $6857f4f1cda3188c$export$8dde1211cb7c9d16, (v) => $6857f4f1cda3188c$export$8dde1211cb7c9d16 = v);
$parcel$export(module.exports, "SEQ", () => $6857f4f1cda3188c$export$200ef2dcd45611c9, (v) => $6857f4f1cda3188c$export$200ef2dcd45611c9 = v);
$parcel$export(module.exports, "hasAnchor", () => $6857f4f1cda3188c$export$67947a995b37b771, (v) => $6857f4f1cda3188c$export$67947a995b37b771 = v);
$parcel$export(module.exports, "isAlias", () => $6857f4f1cda3188c$export$c6275352883a2b3e, (v) => $6857f4f1cda3188c$export$c6275352883a2b3e = v);
$parcel$export(module.exports, "isCollection", () => $6857f4f1cda3188c$export$cea7aa84e978eba5, (v) => $6857f4f1cda3188c$export$cea7aa84e978eba5 = v);
$parcel$export(module.exports, "isDocument", () => $6857f4f1cda3188c$export$62858bae88b53fd0, (v) => $6857f4f1cda3188c$export$62858bae88b53fd0 = v);
$parcel$export(module.exports, "isMap", () => $6857f4f1cda3188c$export$5c90113a285f2241, (v) => $6857f4f1cda3188c$export$5c90113a285f2241 = v);
$parcel$export(module.exports, "isNode", () => $6857f4f1cda3188c$export$8ee0fc9ee280b4ee, (v) => $6857f4f1cda3188c$export$8ee0fc9ee280b4ee = v);
$parcel$export(module.exports, "isPair", () => $6857f4f1cda3188c$export$7c8d445944656308, (v) => $6857f4f1cda3188c$export$7c8d445944656308 = v);
$parcel$export(module.exports, "isScalar", () => $6857f4f1cda3188c$export$8f3495e22775e76c, (v) => $6857f4f1cda3188c$export$8f3495e22775e76c = v);
$parcel$export(module.exports, "isSeq", () => $6857f4f1cda3188c$export$342ac1d101ffe14b, (v) => $6857f4f1cda3188c$export$342ac1d101ffe14b = v);
var $6857f4f1cda3188c$export$6e16f50e77e6cb4d;
var $6857f4f1cda3188c$export$c41a48f61a15d775;
var $6857f4f1cda3188c$export$ce970371e0e850bc;
var $6857f4f1cda3188c$export$accaa52ddae3fe58;
var $6857f4f1cda3188c$export$c4eb1412cef9eb18;
var $6857f4f1cda3188c$export$8dde1211cb7c9d16;
var $6857f4f1cda3188c$export$200ef2dcd45611c9;
var $6857f4f1cda3188c$export$67947a995b37b771;
var $6857f4f1cda3188c$export$c6275352883a2b3e;
var $6857f4f1cda3188c$export$cea7aa84e978eba5;
var $6857f4f1cda3188c$export$62858bae88b53fd0;
var $6857f4f1cda3188c$export$5c90113a285f2241;
var $6857f4f1cda3188c$export$8ee0fc9ee280b4ee;
var $6857f4f1cda3188c$export$7c8d445944656308;
var $6857f4f1cda3188c$export$8f3495e22775e76c;
var $6857f4f1cda3188c$export$342ac1d101ffe14b;
"use strict";
const $6857f4f1cda3188c$var$ALIAS = Symbol.for("yaml.alias");
const $6857f4f1cda3188c$var$DOC = Symbol.for("yaml.document");
const $6857f4f1cda3188c$var$MAP = Symbol.for("yaml.map");
const $6857f4f1cda3188c$var$PAIR = Symbol.for("yaml.pair");
const $6857f4f1cda3188c$var$SCALAR = Symbol.for("yaml.scalar");
const $6857f4f1cda3188c$var$SEQ = Symbol.for("yaml.seq");
const $6857f4f1cda3188c$var$NODE_TYPE = Symbol.for("yaml.node.type");
const $6857f4f1cda3188c$var$isAlias = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$ALIAS;
const $6857f4f1cda3188c$var$isDocument = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$DOC;
const $6857f4f1cda3188c$var$isMap = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$MAP;
const $6857f4f1cda3188c$var$isPair = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$PAIR;
const $6857f4f1cda3188c$var$isScalar = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$SCALAR;
const $6857f4f1cda3188c$var$isSeq = (node)=>!!node && typeof node === "object" && node[$6857f4f1cda3188c$var$NODE_TYPE] === $6857f4f1cda3188c$var$SEQ;
function $6857f4f1cda3188c$var$isCollection(node) {
    if (node && typeof node === "object") switch(node[$6857f4f1cda3188c$var$NODE_TYPE]){
        case $6857f4f1cda3188c$var$MAP:
        case $6857f4f1cda3188c$var$SEQ:
            return true;
    }
    return false;
}
function $6857f4f1cda3188c$var$isNode(node) {
    if (node && typeof node === "object") switch(node[$6857f4f1cda3188c$var$NODE_TYPE]){
        case $6857f4f1cda3188c$var$ALIAS:
        case $6857f4f1cda3188c$var$MAP:
        case $6857f4f1cda3188c$var$SCALAR:
        case $6857f4f1cda3188c$var$SEQ:
            return true;
    }
    return false;
}
const $6857f4f1cda3188c$var$hasAnchor = (node)=>($6857f4f1cda3188c$var$isScalar(node) || $6857f4f1cda3188c$var$isCollection(node)) && !!node.anchor;
$6857f4f1cda3188c$export$6e16f50e77e6cb4d = $6857f4f1cda3188c$var$ALIAS;
$6857f4f1cda3188c$export$c41a48f61a15d775 = $6857f4f1cda3188c$var$DOC;
$6857f4f1cda3188c$export$ce970371e0e850bc = $6857f4f1cda3188c$var$MAP;
$6857f4f1cda3188c$export$accaa52ddae3fe58 = $6857f4f1cda3188c$var$NODE_TYPE;
$6857f4f1cda3188c$export$c4eb1412cef9eb18 = $6857f4f1cda3188c$var$PAIR;
$6857f4f1cda3188c$export$8dde1211cb7c9d16 = $6857f4f1cda3188c$var$SCALAR;
$6857f4f1cda3188c$export$200ef2dcd45611c9 = $6857f4f1cda3188c$var$SEQ;
$6857f4f1cda3188c$export$67947a995b37b771 = $6857f4f1cda3188c$var$hasAnchor;
$6857f4f1cda3188c$export$c6275352883a2b3e = $6857f4f1cda3188c$var$isAlias;
$6857f4f1cda3188c$export$cea7aa84e978eba5 = $6857f4f1cda3188c$var$isCollection;
$6857f4f1cda3188c$export$62858bae88b53fd0 = $6857f4f1cda3188c$var$isDocument;
$6857f4f1cda3188c$export$5c90113a285f2241 = $6857f4f1cda3188c$var$isMap;
$6857f4f1cda3188c$export$8ee0fc9ee280b4ee = $6857f4f1cda3188c$var$isNode;
$6857f4f1cda3188c$export$7c8d445944656308 = $6857f4f1cda3188c$var$isPair;
$6857f4f1cda3188c$export$8f3495e22775e76c = $6857f4f1cda3188c$var$isScalar;
$6857f4f1cda3188c$export$342ac1d101ffe14b = $6857f4f1cda3188c$var$isSeq;

});

parcelRegister("dh9VJ", function(module, exports) {

$parcel$export(module.exports, "visit", () => $9aa490cf7ab432bf$export$bf638b60ea8b89b7, (v) => $9aa490cf7ab432bf$export$bf638b60ea8b89b7 = v);
$parcel$export(module.exports, "visitAsync", () => $9aa490cf7ab432bf$export$3c4f5d970a5e6a3b, (v) => $9aa490cf7ab432bf$export$3c4f5d970a5e6a3b = v);
var $9aa490cf7ab432bf$export$bf638b60ea8b89b7;
var $9aa490cf7ab432bf$export$3c4f5d970a5e6a3b;
"use strict";

var $8XpWs = parcelRequire("8XpWs");
const $9aa490cf7ab432bf$var$BREAK = Symbol("break visit");
const $9aa490cf7ab432bf$var$SKIP = Symbol("skip children");
const $9aa490cf7ab432bf$var$REMOVE = Symbol("remove node");
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */ function $9aa490cf7ab432bf$var$visit(node, visitor) {
    const visitor_ = $9aa490cf7ab432bf$var$initVisitor(visitor);
    if ($8XpWs.isDocument(node)) {
        const cd = $9aa490cf7ab432bf$var$visit_(null, node.contents, visitor_, Object.freeze([
            node
        ]));
        if (cd === $9aa490cf7ab432bf$var$REMOVE) node.contents = null;
    } else $9aa490cf7ab432bf$var$visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $9aa490cf7ab432bf$var$visit.BREAK = $9aa490cf7ab432bf$var$BREAK;
/** Do not visit the children of the current node */ $9aa490cf7ab432bf$var$visit.SKIP = $9aa490cf7ab432bf$var$SKIP;
/** Remove the current node */ $9aa490cf7ab432bf$var$visit.REMOVE = $9aa490cf7ab432bf$var$REMOVE;
function $9aa490cf7ab432bf$var$visit_(key, node, visitor, path) {
    const ctrl = $9aa490cf7ab432bf$var$callVisitor(key, node, visitor, path);
    if ($8XpWs.isNode(ctrl) || $8XpWs.isPair(ctrl)) {
        $9aa490cf7ab432bf$var$replaceNode(key, path, ctrl);
        return $9aa490cf7ab432bf$var$visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
        if ($8XpWs.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for(let i = 0; i < node.items.length; ++i){
                const ci = $9aa490cf7ab432bf$var$visit_(i, node.items[i], visitor, path);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
                else if (ci === $9aa490cf7ab432bf$var$REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        } else if ($8XpWs.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = $9aa490cf7ab432bf$var$visit_("key", node.key, visitor, path);
            if (ck === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
            else if (ck === $9aa490cf7ab432bf$var$REMOVE) node.key = null;
            const cv = $9aa490cf7ab432bf$var$visit_("value", node.value, visitor, path);
            if (cv === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
            else if (cv === $9aa490cf7ab432bf$var$REMOVE) node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */ async function $9aa490cf7ab432bf$var$visitAsync(node, visitor) {
    const visitor_ = $9aa490cf7ab432bf$var$initVisitor(visitor);
    if ($8XpWs.isDocument(node)) {
        const cd = await $9aa490cf7ab432bf$var$visitAsync_(null, node.contents, visitor_, Object.freeze([
            node
        ]));
        if (cd === $9aa490cf7ab432bf$var$REMOVE) node.contents = null;
    } else await $9aa490cf7ab432bf$var$visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $9aa490cf7ab432bf$var$visitAsync.BREAK = $9aa490cf7ab432bf$var$BREAK;
/** Do not visit the children of the current node */ $9aa490cf7ab432bf$var$visitAsync.SKIP = $9aa490cf7ab432bf$var$SKIP;
/** Remove the current node */ $9aa490cf7ab432bf$var$visitAsync.REMOVE = $9aa490cf7ab432bf$var$REMOVE;
async function $9aa490cf7ab432bf$var$visitAsync_(key, node, visitor, path) {
    const ctrl = await $9aa490cf7ab432bf$var$callVisitor(key, node, visitor, path);
    if ($8XpWs.isNode(ctrl) || $8XpWs.isPair(ctrl)) {
        $9aa490cf7ab432bf$var$replaceNode(key, path, ctrl);
        return $9aa490cf7ab432bf$var$visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
        if ($8XpWs.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for(let i = 0; i < node.items.length; ++i){
                const ci = await $9aa490cf7ab432bf$var$visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
                else if (ci === $9aa490cf7ab432bf$var$REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        } else if ($8XpWs.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await $9aa490cf7ab432bf$var$visitAsync_("key", node.key, visitor, path);
            if (ck === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
            else if (ck === $9aa490cf7ab432bf$var$REMOVE) node.key = null;
            const cv = await $9aa490cf7ab432bf$var$visitAsync_("value", node.value, visitor, path);
            if (cv === $9aa490cf7ab432bf$var$BREAK) return $9aa490cf7ab432bf$var$BREAK;
            else if (cv === $9aa490cf7ab432bf$var$REMOVE) node.value = null;
        }
    }
    return ctrl;
}
function $9aa490cf7ab432bf$var$initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
    }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
    }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
    }, visitor);
    return visitor;
}
function $9aa490cf7ab432bf$var$callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function") return visitor(key, node, path);
    if ($8XpWs.isMap(node)) return visitor.Map?.(key, node, path);
    if ($8XpWs.isSeq(node)) return visitor.Seq?.(key, node, path);
    if ($8XpWs.isPair(node)) return visitor.Pair?.(key, node, path);
    if ($8XpWs.isScalar(node)) return visitor.Scalar?.(key, node, path);
    if ($8XpWs.isAlias(node)) return visitor.Alias?.(key, node, path);
    return undefined;
}
function $9aa490cf7ab432bf$var$replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if ($8XpWs.isCollection(parent)) parent.items[key] = node;
    else if ($8XpWs.isPair(parent)) {
        if (key === "key") parent.key = node;
        else parent.value = node;
    } else if ($8XpWs.isDocument(parent)) parent.contents = node;
    else {
        const pt = $8XpWs.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}
$9aa490cf7ab432bf$export$bf638b60ea8b89b7 = $9aa490cf7ab432bf$var$visit;
$9aa490cf7ab432bf$export$3c4f5d970a5e6a3b = $9aa490cf7ab432bf$var$visitAsync;

});


parcelRegister("e3GNt", function(module, exports) {

$parcel$export(module.exports, "Document", () => $a3c28b164a041264$export$b34a105447964f9f, (v) => $a3c28b164a041264$export$b34a105447964f9f = v);
var $a3c28b164a041264$export$b34a105447964f9f;
"use strict";

var $2QkGt = parcelRequire("2QkGt");

var $lgfhz = parcelRequire("lgfhz");

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $iCaaN = parcelRequire("iCaaN");

var $lz3js = parcelRequire("lz3js");

var $jHLhT = parcelRequire("jHLhT");

var $dZtwv = parcelRequire("dZtwv");

var $jiToa = parcelRequire("jiToa");

var $3G4bN = parcelRequire("3G4bN");

var $7Vhyk = parcelRequire("7Vhyk");
class $a3c28b164a041264$var$Document {
    constructor(value, replacer, options){
        /** A comment before this Document */ this.commentBefore = null;
        /** A comment immediately after this Document */ this.comment = null;
        /** Errors encountered during parsing. */ this.errors = [];
        /** Warnings encountered during parsing. */ this.warnings = [];
        Object.defineProperty(this, $8XpWs.NODE_TYPE, {
            value: $8XpWs.DOC
        });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: "warn",
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: "1.2"
        }, options);
        this.options = opt;
        let { version: version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit) version = this.directives.yaml.version;
        } else this.directives = new $7Vhyk.Directives({
            version: version
        });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */ clone() {
        const copy = Object.create($a3c28b164a041264$var$Document.prototype, {
            [$8XpWs.NODE_TYPE]: {
                value: $8XpWs.DOC
            }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives) copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = $8XpWs.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */ add(value) {
        if ($a3c28b164a041264$var$assertCollection(this.contents)) this.contents.add(value);
    }
    /** Adds a value to the document. */ addIn(path, value) {
        if ($a3c28b164a041264$var$assertCollection(this.contents)) this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */ createAlias(node, name) {
        if (!node.anchor) {
            const prev = $dZtwv.anchorNames(this);
            node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            !name || prev.has(name) ? $dZtwv.findNewAnchor(name || "a", prev) : name;
        }
        return new $2QkGt.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === "function") {
            value = replacer.call({
                "": value
            }, "", value);
            _replacer = replacer;
        } else if (Array.isArray(replacer)) {
            const keyToStr = (v)=>typeof v === "number" || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0) replacer = replacer.concat(asStr);
            _replacer = replacer;
        } else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects: aliasDuplicateObjects, anchorPrefix: anchorPrefix, flow: flow, keepUndefined: keepUndefined, onTagObj: onTagObj, tag: tag } = options ?? {};
        const { onAnchor: onAnchor, setAnchors: setAnchors, sourceObjects: sourceObjects } = $dZtwv.createNodeAnchors(this, // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || "a");
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor: onAnchor,
            onTagObj: onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects: sourceObjects
        };
        const node = $3G4bN.createNode(value, tag, ctx);
        if (flow && $8XpWs.isCollection(node)) node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */ createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new $3difO.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */ delete(key) {
        return $a3c28b164a041264$var$assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */ deleteIn(path) {
        if ($lgfhz.isEmptyPath(path)) {
            if (this.contents == null) return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return $a3c28b164a041264$var$assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ get(key, keepScalar) {
        return $8XpWs.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ getIn(path, keepScalar) {
        if ($lgfhz.isEmptyPath(path)) return !keepScalar && $8XpWs.isScalar(this.contents) ? this.contents.value : this.contents;
        return $8XpWs.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */ has(key) {
        return $8XpWs.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */ hasIn(path) {
        if ($lgfhz.isEmptyPath(path)) return this.contents !== undefined;
        return $8XpWs.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ set(key, value) {
        if (this.contents == null) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = $lgfhz.collectionFromPath(this.schema, [
            key
        ], value);
        else if ($a3c28b164a041264$var$assertCollection(this.contents)) this.contents.set(key, value);
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ setIn(path, value) {
        if ($lgfhz.isEmptyPath(path)) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = value;
        else if (this.contents == null) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = $lgfhz.collectionFromPath(this.schema, Array.from(path), value);
        else if ($a3c28b164a041264$var$assertCollection(this.contents)) this.contents.setIn(path, value);
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */ setSchema(version, options = {}) {
        if (typeof version === "number") version = String(version);
        let opt;
        switch(version){
            case "1.1":
                if (this.directives) this.directives.yaml.version = "1.1";
                else this.directives = new $7Vhyk.Directives({
                    version: "1.1"
                });
                opt = {
                    merge: true,
                    resolveKnownTags: false,
                    schema: "yaml-1.1"
                };
                break;
            case "1.2":
            case "next":
                if (this.directives) this.directives.yaml.version = version;
                else this.directives = new $7Vhyk.Directives({
                    version: version
                });
                opt = {
                    merge: false,
                    resolveKnownTags: true,
                    schema: "core"
                };
                break;
            case null:
                if (this.directives) delete this.directives;
                opt = null;
                break;
            default:
                {
                    const sv = JSON.stringify(version);
                    throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
                }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object) this.schema = options.schema;
        else if (opt) this.schema = new $lz3js.Schema(Object.assign(opt, options));
        else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json: json, jsonArg: jsonArg, mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = $iCaaN.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function") for (const { count: count, res: res } of ctx.anchors.values())onAnchor(res, count);
        return typeof reviver === "function" ? $jiToa.applyReviver(reviver, {
            "": res
        }, "", res) : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */ toJSON(jsonArg, onAnchor) {
        return this.toJS({
            json: true,
            jsonArg: jsonArg,
            mapAsMap: false,
            onAnchor: onAnchor
        });
    }
    /** A YAML representation of the document. */ toString(options = {}) {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return $jHLhT.stringifyDocument(this, options);
    }
}
function $a3c28b164a041264$var$assertCollection(contents) {
    if ($8XpWs.isCollection(contents)) return true;
    throw new Error("Expected a YAML collection as document contents");
}
$a3c28b164a041264$export$b34a105447964f9f = $a3c28b164a041264$var$Document;

});
parcelRegister("2QkGt", function(module, exports) {

$parcel$export(module.exports, "Alias", () => $21207b86477620b6$export$17b520249a85fe16, (v) => $21207b86477620b6$export$17b520249a85fe16 = v);
var $21207b86477620b6$export$17b520249a85fe16;
"use strict";

var $dZtwv = parcelRequire("dZtwv");

var $dh9VJ = parcelRequire("dh9VJ");

var $8XpWs = parcelRequire("8XpWs");

var $deCwS = parcelRequire("deCwS");

var $iCaaN = parcelRequire("iCaaN");
class $21207b86477620b6$var$Alias extends $deCwS.NodeBase {
    constructor(source){
        super($8XpWs.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
            set () {
                throw new Error("Alias nodes cannot have tags");
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */ resolve(doc) {
        let found = undefined;
        $dh9VJ.visit(doc, {
            Node: (_key, node)=>{
                if (node === this) return $dh9VJ.visit.BREAK;
                if (node.anchor === this.source) found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx) return {
            source: this.source
        };
        const { anchors: anchors, doc: doc, maxAliasCount: maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            $iCaaN.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */ if (!data || data.res === undefined) {
            const msg = "This should not happen: Alias anchor was not resolved?";
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0) data.aliasCount = $21207b86477620b6$var$getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = "Excessive alias count indicates a resource exhaustion attack";
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            $dZtwv.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey) return `${src} `;
        }
        return src;
    }
}
function $21207b86477620b6$var$getAliasCount(doc, node, anchors) {
    if ($8XpWs.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if ($8XpWs.isCollection(node)) {
        let count = 0;
        for (const item of node.items){
            const c = $21207b86477620b6$var$getAliasCount(doc, item, anchors);
            if (c > count) count = c;
        }
        return count;
    } else if ($8XpWs.isPair(node)) {
        const kc = $21207b86477620b6$var$getAliasCount(doc, node.key, anchors);
        const vc = $21207b86477620b6$var$getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}
$21207b86477620b6$export$17b520249a85fe16 = $21207b86477620b6$var$Alias;

});
parcelRegister("dZtwv", function(module, exports) {

$parcel$export(module.exports, "anchorIsValid", () => $a2f7df9511007c2d$export$67b774d238e24409, (v) => $a2f7df9511007c2d$export$67b774d238e24409 = v);
$parcel$export(module.exports, "anchorNames", () => $a2f7df9511007c2d$export$402f230d710ffb75, (v) => $a2f7df9511007c2d$export$402f230d710ffb75 = v);
$parcel$export(module.exports, "createNodeAnchors", () => $a2f7df9511007c2d$export$5498887d1e6c340c, (v) => $a2f7df9511007c2d$export$5498887d1e6c340c = v);
$parcel$export(module.exports, "findNewAnchor", () => $a2f7df9511007c2d$export$1a7f8f45ec43f9e4, (v) => $a2f7df9511007c2d$export$1a7f8f45ec43f9e4 = v);
var $a2f7df9511007c2d$export$67b774d238e24409;
var $a2f7df9511007c2d$export$402f230d710ffb75;
var $a2f7df9511007c2d$export$5498887d1e6c340c;
var $a2f7df9511007c2d$export$1a7f8f45ec43f9e4;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $dh9VJ = parcelRequire("dh9VJ");
/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */ function $a2f7df9511007c2d$var$anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function $a2f7df9511007c2d$var$anchorNames(root) {
    const anchors = new Set();
    $dh9VJ.visit(root, {
        Value (_key, node) {
            if (node.anchor) anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */ function $a2f7df9511007c2d$var$findNewAnchor(prefix, exclude) {
    for(let i = 1;; ++i){
        const name = `${prefix}${i}`;
        if (!exclude.has(name)) return name;
    }
}
function $a2f7df9511007c2d$var$createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source)=>{
            aliasObjects.push(source);
            if (!prevAnchors) prevAnchors = $a2f7df9511007c2d$var$anchorNames(doc);
            const anchor = $a2f7df9511007c2d$var$findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */ setAnchors: ()=>{
            for (const source of aliasObjects){
                const ref = sourceObjects.get(source);
                if (typeof ref === "object" && ref.anchor && ($8XpWs.isScalar(ref.node) || $8XpWs.isCollection(ref.node))) ref.node.anchor = ref.anchor;
                else {
                    const error = new Error("Failed to resolve repeated object (this should not happen)");
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects: sourceObjects
    };
}
$a2f7df9511007c2d$export$67b774d238e24409 = $a2f7df9511007c2d$var$anchorIsValid;
$a2f7df9511007c2d$export$402f230d710ffb75 = $a2f7df9511007c2d$var$anchorNames;
$a2f7df9511007c2d$export$5498887d1e6c340c = $a2f7df9511007c2d$var$createNodeAnchors;
$a2f7df9511007c2d$export$1a7f8f45ec43f9e4 = $a2f7df9511007c2d$var$findNewAnchor;

});

parcelRegister("deCwS", function(module, exports) {

$parcel$export(module.exports, "NodeBase", () => $9a2a784b38fc5660$export$7cc40ad5cb33f2dc, (v) => $9a2a784b38fc5660$export$7cc40ad5cb33f2dc = v);
var $9a2a784b38fc5660$export$7cc40ad5cb33f2dc;
"use strict";

var $jiToa = parcelRequire("jiToa");

var $8XpWs = parcelRequire("8XpWs");

var $iCaaN = parcelRequire("iCaaN");
class $9a2a784b38fc5660$var$NodeBase {
    constructor(type){
        Object.defineProperty(this, $8XpWs.NODE_TYPE, {
            value: type
        });
    }
    /** Create a copy of this node.  */ clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */ toJS(doc, { mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver } = {}) {
        if (!$8XpWs.isDocument(doc)) throw new TypeError("A document argument is required");
        const ctx = {
            anchors: new Map(),
            doc: doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = $iCaaN.toJS(this, "", ctx);
        if (typeof onAnchor === "function") for (const { count: count, res: res } of ctx.anchors.values())onAnchor(res, count);
        return typeof reviver === "function" ? $jiToa.applyReviver(reviver, {
            "": res
        }, "", res) : res;
    }
}
$9a2a784b38fc5660$export$7cc40ad5cb33f2dc = $9a2a784b38fc5660$var$NodeBase;

});
parcelRegister("jiToa", function(module, exports) {

$parcel$export(module.exports, "applyReviver", () => $e0daa9cebe0917de$export$abc04374ac0ef535, (v) => $e0daa9cebe0917de$export$abc04374ac0ef535 = v);
var $e0daa9cebe0917de$export$abc04374ac0ef535;
"use strict";
/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */ function $e0daa9cebe0917de$var$applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
        if (Array.isArray(val)) for(let i = 0, len = val.length; i < len; ++i){
            const v0 = val[i];
            const v1 = $e0daa9cebe0917de$var$applyReviver(reviver, val, String(i), v0);
            if (v1 === undefined) delete val[i];
            else if (v1 !== v0) val[i] = v1;
        }
        else if (val instanceof Map) for (const k of Array.from(val.keys())){
            const v0 = val.get(k);
            const v1 = $e0daa9cebe0917de$var$applyReviver(reviver, val, k, v0);
            if (v1 === undefined) val.delete(k);
            else if (v1 !== v0) val.set(k, v1);
        }
        else if (val instanceof Set) for (const v0 of Array.from(val)){
            const v1 = $e0daa9cebe0917de$var$applyReviver(reviver, val, v0, v0);
            if (v1 === undefined) val.delete(v0);
            else if (v1 !== v0) {
                val.delete(v0);
                val.add(v1);
            }
        }
        else for (const [k, v0] of Object.entries(val)){
            const v1 = $e0daa9cebe0917de$var$applyReviver(reviver, val, k, v0);
            if (v1 === undefined) delete val[k];
            else if (v1 !== v0) val[k] = v1;
        }
    }
    return reviver.call(obj, key, val);
}
$e0daa9cebe0917de$export$abc04374ac0ef535 = $e0daa9cebe0917de$var$applyReviver;

});

parcelRegister("iCaaN", function(module, exports) {

$parcel$export(module.exports, "toJS", () => $d8d3aac839527417$export$f08965dd1304d490, (v) => $d8d3aac839527417$export$f08965dd1304d490 = v);
var $d8d3aac839527417$export$f08965dd1304d490;
"use strict";

var $8XpWs = parcelRequire("8XpWs");
/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */ function $d8d3aac839527417$var$toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value)) return value.map((v, i)=>$d8d3aac839527417$var$toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !$8XpWs.hasAnchor(value)) return value.toJSON(arg, ctx);
        const data = {
            aliasCount: 0,
            count: 1,
            res: undefined
        };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res)=>{
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate) ctx.onCreate(res);
        return res;
    }
    if (typeof value === "bigint" && !ctx?.keep) return Number(value);
    return value;
}
$d8d3aac839527417$export$f08965dd1304d490 = $d8d3aac839527417$var$toJS;

});



parcelRegister("lgfhz", function(module, exports) {

$parcel$export(module.exports, "Collection", () => $f7a6f259ad28faa5$export$fb8073518f34e6ec, (v) => $f7a6f259ad28faa5$export$fb8073518f34e6ec = v);
$parcel$export(module.exports, "collectionFromPath", () => $f7a6f259ad28faa5$export$f5ac8bc6072340dd, (v) => $f7a6f259ad28faa5$export$f5ac8bc6072340dd = v);
$parcel$export(module.exports, "isEmptyPath", () => $f7a6f259ad28faa5$export$e3bfca790bd8f9da, (v) => $f7a6f259ad28faa5$export$e3bfca790bd8f9da = v);
var $f7a6f259ad28faa5$export$fb8073518f34e6ec;
var $f7a6f259ad28faa5$export$f5ac8bc6072340dd;
var $f7a6f259ad28faa5$export$e3bfca790bd8f9da;
"use strict";

var $3G4bN = parcelRequire("3G4bN");

var $8XpWs = parcelRequire("8XpWs");

var $deCwS = parcelRequire("deCwS");
function $f7a6f259ad28faa5$var$collectionFromPath(schema, path, value) {
    let v = value;
    for(let i = path.length - 1; i >= 0; --i){
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        } else v = new Map([
            [
                k,
                v
            ]
        ]);
    }
    return $3G4bN.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: ()=>{
            throw new Error("This should not happen, please report a bug.");
        },
        schema: schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const $f7a6f259ad28faa5$var$isEmptyPath = (path)=>path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
class $f7a6f259ad28faa5$var$Collection extends $deCwS.NodeBase {
    constructor(type, schema){
        super(type);
        Object.defineProperty(this, "schema", {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */ clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema) copy.schema = schema;
        copy.items = copy.items.map((it)=>$8XpWs.isNode(it) || $8XpWs.isPair(it) ? it.clone(schema) : it);
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */ addIn(path, value) {
        if ($f7a6f259ad28faa5$var$isEmptyPath(path)) this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if ($8XpWs.isCollection(node)) node.addIn(rest, value);
            else if (node === undefined && this.schema) this.set(key, $f7a6f259ad28faa5$var$collectionFromPath(this.schema, rest, value));
            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */ deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.delete(key);
        const node = this.get(key, true);
        if ($8XpWs.isCollection(node)) return node.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0) return !keepScalar && $8XpWs.isScalar(node) ? node.value : node;
        else return $8XpWs.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every((node)=>{
            if (!$8XpWs.isPair(node)) return false;
            const n = node.value;
            return n == null || allowScalar && $8XpWs.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */ hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.has(key);
        const node = this.get(key, true);
        return $8XpWs.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) this.set(key, value);
        else {
            const node = this.get(key, true);
            if ($8XpWs.isCollection(node)) node.setIn(rest, value);
            else if (node === undefined && this.schema) this.set(key, $f7a6f259ad28faa5$var$collectionFromPath(this.schema, rest, value));
            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
$f7a6f259ad28faa5$var$Collection.maxFlowStringSingleLineLength = 60;
$f7a6f259ad28faa5$export$fb8073518f34e6ec = $f7a6f259ad28faa5$var$Collection;
$f7a6f259ad28faa5$export$f5ac8bc6072340dd = $f7a6f259ad28faa5$var$collectionFromPath;
$f7a6f259ad28faa5$export$e3bfca790bd8f9da = $f7a6f259ad28faa5$var$isEmptyPath;

});
parcelRegister("3G4bN", function(module, exports) {

$parcel$export(module.exports, "createNode", () => $2ad88b3cff84e727$export$270e7ba5936d3c48, (v) => $2ad88b3cff84e727$export$270e7ba5936d3c48 = v);
var $2ad88b3cff84e727$export$270e7ba5936d3c48;
"use strict";

var $2QkGt = parcelRequire("2QkGt");

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");
const $2ad88b3cff84e727$var$defaultTagPrefix = "tag:yaml.org,2002:";
function $2ad88b3cff84e727$var$findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter((t)=>t.tag === tagName);
        const tagObj = match.find((t)=>!t.format) ?? match[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find((t)=>t.identify?.(value) && !t.format);
}
function $2ad88b3cff84e727$var$createNode(value, tagName, ctx) {
    if ($8XpWs.isDocument(value)) value = value.contents;
    if ($8XpWs.isNode(value)) return value;
    if ($8XpWs.isPair(value)) {
        const map = ctx.schema[$8XpWs.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt // not supported everywhere
    ) // https://tc39.es/ecma262/#sec-serializejsonproperty
    value = value.valueOf();
    const { aliasDuplicateObjects: aliasDuplicateObjects, onAnchor: onAnchor, onTagObj: onTagObj, schema: schema, sourceObjects: sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor) ref.anchor = onAnchor(value);
            return new $2QkGt.Alias(ref.anchor);
        } else {
            ref = {
                anchor: null,
                node: null
            };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith("!!")) tagName = $2ad88b3cff84e727$var$defaultTagPrefix + tagName.slice(2);
    let tagObj = $2ad88b3cff84e727$var$findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === "function") // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        value = value.toJSON();
        if (!value || typeof value !== "object") {
            const node = new $k84gT.Scalar(value);
            if (ref) ref.node = node;
            return node;
        }
        tagObj = value instanceof Map ? schema[$8XpWs.MAP] : Symbol.iterator in Object(value) ? schema[$8XpWs.SEQ] : schema[$8XpWs.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new $k84gT.Scalar(value);
    if (tagName) node.tag = tagName;
    else if (!tagObj.default) node.tag = tagObj.tag;
    if (ref) ref.node = node;
    return node;
}
$2ad88b3cff84e727$export$270e7ba5936d3c48 = $2ad88b3cff84e727$var$createNode;

});
parcelRegister("k84gT", function(module, exports) {

$parcel$export(module.exports, "Scalar", () => $ea77de39afc2fe37$export$595dbf49c602a1f, (v) => $ea77de39afc2fe37$export$595dbf49c602a1f = v);
$parcel$export(module.exports, "isScalarValue", () => $ea77de39afc2fe37$export$dc071f102752d0eb, (v) => $ea77de39afc2fe37$export$dc071f102752d0eb = v);
var $ea77de39afc2fe37$export$595dbf49c602a1f;
var $ea77de39afc2fe37$export$dc071f102752d0eb;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $deCwS = parcelRequire("deCwS");

var $iCaaN = parcelRequire("iCaaN");
const $ea77de39afc2fe37$var$isScalarValue = (value)=>!value || typeof value !== "function" && typeof value !== "object";
class $ea77de39afc2fe37$var$Scalar extends $deCwS.NodeBase {
    constructor(value){
        super($8XpWs.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : $iCaaN.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
$ea77de39afc2fe37$var$Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
$ea77de39afc2fe37$var$Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
$ea77de39afc2fe37$var$Scalar.PLAIN = "PLAIN";
$ea77de39afc2fe37$var$Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
$ea77de39afc2fe37$var$Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
$ea77de39afc2fe37$export$595dbf49c602a1f = $ea77de39afc2fe37$var$Scalar;
$ea77de39afc2fe37$export$dc071f102752d0eb = $ea77de39afc2fe37$var$isScalarValue;

});



parcelRegister("3difO", function(module, exports) {

$parcel$export(module.exports, "Pair", () => $2570bee19d83aa88$export$d63d7cff08fe4dc9, (v) => $2570bee19d83aa88$export$d63d7cff08fe4dc9 = v);
$parcel$export(module.exports, "createPair", () => $2570bee19d83aa88$export$afe19f123272774, (v) => $2570bee19d83aa88$export$afe19f123272774 = v);
var $2570bee19d83aa88$export$d63d7cff08fe4dc9;
var $2570bee19d83aa88$export$afe19f123272774;
"use strict";

var $3G4bN = parcelRequire("3G4bN");

var $gRs2Y = parcelRequire("gRs2Y");

var $jSZqD = parcelRequire("jSZqD");

var $8XpWs = parcelRequire("8XpWs");
function $2570bee19d83aa88$var$createPair(key, value, ctx) {
    const k = $3G4bN.createNode(key, undefined, ctx);
    const v = $3G4bN.createNode(value, undefined, ctx);
    return new $2570bee19d83aa88$var$Pair(k, v);
}
class $2570bee19d83aa88$var$Pair {
    constructor(key, value = null){
        Object.defineProperty(this, $8XpWs.NODE_TYPE, {
            value: $8XpWs.PAIR
        });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key: key, value: value } = this;
        if ($8XpWs.isNode(key)) key = key.clone(schema);
        if ($8XpWs.isNode(value)) value = value.clone(schema);
        return new $2570bee19d83aa88$var$Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return $jSZqD.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? $gRs2Y.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
}
$2570bee19d83aa88$export$d63d7cff08fe4dc9 = $2570bee19d83aa88$var$Pair;
$2570bee19d83aa88$export$afe19f123272774 = $2570bee19d83aa88$var$createPair;

});
parcelRegister("gRs2Y", function(module, exports) {

$parcel$export(module.exports, "stringifyPair", () => $c4675a18a15a6543$export$fffacbb893c76683, (v) => $c4675a18a15a6543$export$fffacbb893c76683 = v);
var $c4675a18a15a6543$export$fffacbb893c76683;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");

var $dq9bU = parcelRequire("dq9bU");

var $7ZOXt = parcelRequire("7ZOXt");
function $c4675a18a15a6543$var$stringifyPair({ key: key, value: value }, ctx, onComment, onChompKeep) {
    const { allNullValues: allNullValues, doc: doc, indent: indent, indentStep: indentStep, options: { commentString: commentString, indentSeq: indentSeq, simpleKeys: simpleKeys } } = ctx;
    let keyComment = $8XpWs.isNode(key) && key.comment || null;
    if (simpleKeys) {
        if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
        if ($8XpWs.isCollection(key)) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || $8XpWs.isCollection(key) || ($8XpWs.isScalar(key) ? key.type === $k84gT.Scalar.BLOCK_FOLDED || key.type === $k84gT.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = $dq9bU.stringify(key, ctx, ()=>keyCommentDone = true, ()=>chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment) onComment();
            return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) str += $7ZOXt.lineComment(str, ctx.indent, commentString(keyComment));
        else if (chompKeep && onChompKeep) onChompKeep();
        return str;
    }
    if (keyCommentDone) keyComment = null;
    if (explicitKey) {
        if (keyComment) str += $7ZOXt.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    } else {
        str = `${str}:`;
        if (keyComment) str += $7ZOXt.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if ($8XpWs.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object") value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && $8XpWs.isScalar(value)) ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && $8XpWs.isSeq(value) && !value.flow && !value.tag && !value.anchor) // If indentSeq === false, consider '- ' as part of indentation where possible
    ctx.indent = ctx.indent.substring(2);
    let valueCommentDone = false;
    const valueStr = $dq9bU.stringify(value, ctx, ()=>valueCommentDone = true, ()=>chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${$7ZOXt.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
            if (ws === "\n") ws = "\n\n";
        } else ws += `\n${ctx.indent}`;
    } else if (!explicitKey && $8XpWs.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === "&" || vs0 === "!")) {
                let sp0 = valueStr.indexOf(" ");
                if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
                if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
            }
            if (!hasPropsLine) ws = `\n${ctx.indent}`;
        }
    } else if (valueStr === "" || valueStr[0] === "\n") ws = "";
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment) onComment();
    } else if (valueComment && !valueCommentDone) str += $7ZOXt.lineComment(str, ctx.indent, commentString(valueComment));
    else if (chompKeep && onChompKeep) onChompKeep();
    return str;
}
$c4675a18a15a6543$export$fffacbb893c76683 = $c4675a18a15a6543$var$stringifyPair;

});
parcelRegister("dq9bU", function(module, exports) {

$parcel$export(module.exports, "createStringifyContext", () => $9c54d536e33538ba$export$829faaf53c257c4d, (v) => $9c54d536e33538ba$export$829faaf53c257c4d = v);
$parcel$export(module.exports, "stringify", () => $9c54d536e33538ba$export$fac44ee5b035f737, (v) => $9c54d536e33538ba$export$fac44ee5b035f737 = v);
var $9c54d536e33538ba$export$829faaf53c257c4d;
var $9c54d536e33538ba$export$fac44ee5b035f737;
"use strict";

var $dZtwv = parcelRequire("dZtwv");

var $8XpWs = parcelRequire("8XpWs");

var $7ZOXt = parcelRequire("7ZOXt");

var $bkIH8 = parcelRequire("bkIH8");
function $9c54d536e33538ba$var$createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: $7ZOXt.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch(opt.collectionStyle){
        case "block":
            inFlow = false;
            break;
        case "flow":
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc: doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow: inFlow,
        options: opt
    };
}
function $9c54d536e33538ba$var$getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter((t)=>t.tag === item.tag);
        if (match.length > 0) return match.find((t)=>t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if ($8XpWs.isScalar(item)) {
        obj = item.value;
        const match = tags.filter((t)=>t.identify?.(obj));
        tagObj = match.find((t)=>t.format === item.format) ?? match.find((t)=>!t.format);
    } else {
        obj = item;
        tagObj = tags.find((t)=>t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function $9c54d536e33538ba$var$stringifyProps(node, tagObj, { anchors: anchors$1, doc: doc }) {
    if (!doc.directives) return "";
    const props = [];
    const anchor = ($8XpWs.isScalar(node) || $8XpWs.isCollection(node)) && node.anchor;
    if (anchor && $dZtwv.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag) props.push(doc.directives.tagString(tag));
    return props.join(" ");
}
function $9c54d536e33538ba$var$stringify(item, ctx, onComment, onChompKeep) {
    if ($8XpWs.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
    if ($8XpWs.isAlias(item)) {
        if (ctx.doc.directives) return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        else {
            if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
            else ctx.resolvedAliases = new Set([
                item
            ]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = $8XpWs.isNode(item) ? item : ctx.doc.createNode(item, {
        onTagObj: (o)=>tagObj = o
    });
    if (!tagObj) tagObj = $9c54d536e33538ba$var$getTagObject(ctx.doc.schema.tags, node);
    const props = $9c54d536e33538ba$var$stringifyProps(node, tagObj, ctx);
    if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : $8XpWs.isScalar(node) ? $bkIH8.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props) return str;
    return $8XpWs.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}
$9c54d536e33538ba$export$829faaf53c257c4d = $9c54d536e33538ba$var$createStringifyContext;
$9c54d536e33538ba$export$fac44ee5b035f737 = $9c54d536e33538ba$var$stringify;

});
parcelRegister("7ZOXt", function(module, exports) {

$parcel$export(module.exports, "indentComment", () => $5d25c22dacd159bf$export$9933eb161eea191d, (v) => $5d25c22dacd159bf$export$9933eb161eea191d = v);
$parcel$export(module.exports, "lineComment", () => $5d25c22dacd159bf$export$5d080f5a78d4f5b3, (v) => $5d25c22dacd159bf$export$5d080f5a78d4f5b3 = v);
$parcel$export(module.exports, "stringifyComment", () => $5d25c22dacd159bf$export$bda2970260483e9e, (v) => $5d25c22dacd159bf$export$bda2970260483e9e = v);
var $5d25c22dacd159bf$export$9933eb161eea191d;
var $5d25c22dacd159bf$export$5d080f5a78d4f5b3;
var $5d25c22dacd159bf$export$bda2970260483e9e;
"use strict";
/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */ const $5d25c22dacd159bf$var$stringifyComment = (str)=>str.replace(/^(?!$)(?: $)?/gm, "#");
function $5d25c22dacd159bf$var$indentComment(comment, indent) {
    if (/^\n+$/.test(comment)) return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const $5d25c22dacd159bf$var$lineComment = (str, indent, comment)=>str.endsWith("\n") ? $5d25c22dacd159bf$var$indentComment(comment, indent) : comment.includes("\n") ? "\n" + $5d25c22dacd159bf$var$indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
$5d25c22dacd159bf$export$9933eb161eea191d = $5d25c22dacd159bf$var$indentComment;
$5d25c22dacd159bf$export$5d080f5a78d4f5b3 = $5d25c22dacd159bf$var$lineComment;
$5d25c22dacd159bf$export$bda2970260483e9e = $5d25c22dacd159bf$var$stringifyComment;

});

parcelRegister("bkIH8", function(module, exports) {

$parcel$export(module.exports, "stringifyString", () => $84043b6b70d7bbd7$export$3457ffbf9a1af5aa, (v) => $84043b6b70d7bbd7$export$3457ffbf9a1af5aa = v);
var $84043b6b70d7bbd7$export$3457ffbf9a1af5aa;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $4vHWk = parcelRequire("4vHWk");
const $84043b6b70d7bbd7$var$getFoldOptions = (ctx, isBlock)=>({
        indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
    });
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const $84043b6b70d7bbd7$var$containsDocumentMarker = (str)=>/^(%|---|\.\.\.)/m.test(str);
function $84043b6b70d7bbd7$var$lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0) return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit) return false;
    for(let i = 0, start = 0; i < strLen; ++i)if (str[i] === "\n") {
        if (i - start > limit) return true;
        start = i + 1;
        if (strLen - start <= limit) return false;
    }
    return true;
}
function $84043b6b70d7bbd7$var$doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON) return json;
    const { implicitKey: implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || ($84043b6b70d7bbd7$var$containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for(let i = 0, ch = json[i]; ch; ch = json[++i]){
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + "\\ ";
            i += 1;
            start = i;
            ch = "\\";
        }
        if (ch === "\\") switch(json[i + 1]){
            case "u":
                {
                    str += json.slice(start, i);
                    const code = json.substr(i + 2, 4);
                    switch(code){
                        case "0000":
                            str += "\\0";
                            break;
                        case "0007":
                            str += "\\a";
                            break;
                        case "000b":
                            str += "\\v";
                            break;
                        case "001b":
                            str += "\\e";
                            break;
                        case "0085":
                            str += "\\N";
                            break;
                        case "00a0":
                            str += "\\_";
                            break;
                        case "2028":
                            str += "\\L";
                            break;
                        case "2029":
                            str += "\\P";
                            break;
                        default:
                            if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
                            else str += json.substr(i, 6);
                    }
                    i += 5;
                    start = i + 1;
                }
                break;
            case "n":
                if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) i += 1;
                else {
                    // folding will eat first newline
                    str += json.slice(start, i) + "\n\n";
                    while(json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"'){
                        str += "\n";
                        i += 2;
                    }
                    str += indent;
                    // space after newline needs to be escaped to not be folded
                    if (json[i + 2] === " ") str += "\\";
                    i += 1;
                    start = i + 1;
                }
                break;
            default:
                i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : $4vHWk.foldFlowLines(str, indent, $4vHWk.FOLD_QUOTED, $84043b6b70d7bbd7$var$getFoldOptions(ctx, false));
}
function $84043b6b70d7bbd7$var$singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    ) return $84043b6b70d7bbd7$var$doubleQuotedString(value, ctx);
    const indent = ctx.indent || ($84043b6b70d7bbd7$var$containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey ? res : $4vHWk.foldFlowLines(res, indent, $4vHWk.FOLD_FLOW, $84043b6b70d7bbd7$var$getFoldOptions(ctx, false));
}
function $84043b6b70d7bbd7$var$quotedString(value, ctx) {
    const { singleQuote: singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false) qs = $84043b6b70d7bbd7$var$doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle) qs = $84043b6b70d7bbd7$var$singleQuotedString;
        else if (hasSingle && !hasDouble) qs = $84043b6b70d7bbd7$var$doubleQuotedString;
        else qs = singleQuote ? $84043b6b70d7bbd7$var$singleQuotedString : $84043b6b70d7bbd7$var$doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let $84043b6b70d7bbd7$var$blockEndNewlines;
try {
    $84043b6b70d7bbd7$var$blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch  {
    $84043b6b70d7bbd7$var$blockEndNewlines = /\n+(?!\n|$)/g;
}
function $84043b6b70d7bbd7$var$blockString({ comment: comment, type: type, value: value }, ctx, onComment, onChompKeep) {
    const { blockQuote: blockQuote, commentString: commentString, lineWidth: lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) return $84043b6b70d7bbd7$var$quotedString(value, ctx);
    const indent = ctx.indent || (ctx.forceBlockIndent || $84043b6b70d7bbd7$var$containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === $k84gT.Scalar.BLOCK_FOLDED ? false : type === $k84gT.Scalar.BLOCK_LITERAL ? true : !$84043b6b70d7bbd7$var$lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value) return literal ? "|\n" : ">\n";
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for(endStart = value.length; endStart > 0; --endStart){
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ") break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1) chomp = "-"; // strip
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+"; // keep
        if (onChompKeep) onChompKeep();
    } else chomp = ""; // clip
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n") end = end.slice(0, -1);
        end = end.replace($84043b6b70d7bbd7$var$blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for(startEnd = 0; startEnd < value.length; ++startEnd){
        const ch = value[startEnd];
        if (ch === " ") startWithSpace = true;
        else if (ch === "\n") startNlPos = startEnd;
        else break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1"; // root is at -1
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment) onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2") // more-indented lines aren't folded
    //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
    .replace(/\n+/g, `$&${indent}`);
    const body = $4vHWk.foldFlowLines(`${start}${value}${end}`, indent, $4vHWk.FOLD_BLOCK, $84043b6b70d7bbd7$var$getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function $84043b6b70d7bbd7$var$plainString(item, ctx, onComment, onChompKeep) {
    const { type: type, value: value } = item;
    const { actualString: actualString, implicitKey: implicitKey, indent: indent, indentStep: indentStep, inFlow: inFlow } = ctx;
    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return $84043b6b70d7bbd7$var$quotedString(value, ctx);
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || !value.includes("\n") ? $84043b6b70d7bbd7$var$quotedString(value, ctx) : $84043b6b70d7bbd7$var$blockString(item, ctx, onComment, onChompKeep);
    if (!implicitKey && !inFlow && type !== $k84gT.Scalar.PLAIN && value.includes("\n")) // Where allowed & type not set explicitly, prefer block style for multiline strings
    return $84043b6b70d7bbd7$var$blockString(item, ctx, onComment, onChompKeep);
    if ($84043b6b70d7bbd7$var$containsDocumentMarker(value)) {
        if (indent === "") {
            ctx.forceBlockIndent = true;
            return $84043b6b70d7bbd7$var$blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) return $84043b6b70d7bbd7$var$quotedString(value, ctx);
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag)=>tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat: compat, tags: tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return $84043b6b70d7bbd7$var$quotedString(value, ctx);
    }
    return implicitKey ? str : $4vHWk.foldFlowLines(str, indent, $4vHWk.FOLD_FLOW, $84043b6b70d7bbd7$var$getFoldOptions(ctx, false));
}
function $84043b6b70d7bbd7$var$stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey: implicitKey, inFlow: inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, {
        value: String(item.value)
    });
    let { type: type } = item;
    if (type !== $k84gT.Scalar.QUOTE_DOUBLE) // force double quotes on control characters & unpaired surrogates
    {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = $k84gT.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type)=>{
        switch(_type){
            case $k84gT.Scalar.BLOCK_FOLDED:
            case $k84gT.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow ? $84043b6b70d7bbd7$var$quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                 : $84043b6b70d7bbd7$var$blockString(ss, ctx, onComment, onChompKeep);
            case $k84gT.Scalar.QUOTE_DOUBLE:
                return $84043b6b70d7bbd7$var$doubleQuotedString(ss.value, ctx);
            case $k84gT.Scalar.QUOTE_SINGLE:
                return $84043b6b70d7bbd7$var$singleQuotedString(ss.value, ctx);
            case $k84gT.Scalar.PLAIN:
                return $84043b6b70d7bbd7$var$plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType: defaultKeyType, defaultStringType: defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null) throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}
$84043b6b70d7bbd7$export$3457ffbf9a1af5aa = $84043b6b70d7bbd7$var$stringifyString;

});
parcelRegister("4vHWk", function(module, exports) {

$parcel$export(module.exports, "FOLD_BLOCK", () => $348c2438d69670f6$export$609fbd56c8a85825, (v) => $348c2438d69670f6$export$609fbd56c8a85825 = v);
$parcel$export(module.exports, "FOLD_FLOW", () => $348c2438d69670f6$export$dfafce8168b25546, (v) => $348c2438d69670f6$export$dfafce8168b25546 = v);
$parcel$export(module.exports, "FOLD_QUOTED", () => $348c2438d69670f6$export$74d9ae4055c4d6cf, (v) => $348c2438d69670f6$export$74d9ae4055c4d6cf = v);
$parcel$export(module.exports, "foldFlowLines", () => $348c2438d69670f6$export$e82a5ab0b770aa09, (v) => $348c2438d69670f6$export$e82a5ab0b770aa09 = v);
var $348c2438d69670f6$export$609fbd56c8a85825;
var $348c2438d69670f6$export$dfafce8168b25546;
var $348c2438d69670f6$export$74d9ae4055c4d6cf;
var $348c2438d69670f6$export$e82a5ab0b770aa09;
"use strict";
const $348c2438d69670f6$var$FOLD_FLOW = "flow";
const $348c2438d69670f6$var$FOLD_BLOCK = "block";
const $348c2438d69670f6$var$FOLD_QUOTED = "quoted";
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */ function $348c2438d69670f6$var$foldFlowLines(text, indent, mode = "flow", { indentAtStart: indentAtStart, lineWidth: lineWidth = 80, minContentWidth: minContentWidth = 20, onFold: onFold, onOverflow: onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0) return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep) return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === $348c2438d69670f6$var$FOLD_BLOCK) {
        i = $348c2438d69670f6$var$consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1) end = i + endStep;
    }
    for(let ch; ch = text[i += 1];){
        if (mode === $348c2438d69670f6$var$FOLD_QUOTED && ch === "\\") {
            escStart = i;
            switch(text[i + 1]){
                case "x":
                    i += 3;
                    break;
                case "u":
                    i += 5;
                    break;
                case "U":
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === "\n") {
            if (mode === $348c2438d69670f6$var$FOLD_BLOCK) i = $348c2438d69670f6$var$consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        } else {
            if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== " " && next !== "\n" && next !== "	") split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                } else if (mode === $348c2438d69670f6$var$FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while(prev === " " || prev === "	"){
                        prev = ch;
                        ch = text[i += 1];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j]) return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                } else overflow = true;
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow) onOverflow();
    if (folds.length === 0) return text;
    if (onFold) onFold();
    let res = text.slice(0, folds[0]);
    for(let i = 0; i < folds.length; ++i){
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === $348c2438d69670f6$var$FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */ function $348c2438d69670f6$var$consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while(ch === " " || ch === "	")if (i < start + indent) ch = text[++i];
    else {
        do ch = text[++i];
        while (ch && ch !== "\n");
        end = i;
        start = i + 1;
        ch = text[start];
    }
    return end;
}
$348c2438d69670f6$export$609fbd56c8a85825 = $348c2438d69670f6$var$FOLD_BLOCK;
$348c2438d69670f6$export$dfafce8168b25546 = $348c2438d69670f6$var$FOLD_FLOW;
$348c2438d69670f6$export$74d9ae4055c4d6cf = $348c2438d69670f6$var$FOLD_QUOTED;
$348c2438d69670f6$export$e82a5ab0b770aa09 = $348c2438d69670f6$var$foldFlowLines;

});




parcelRegister("jSZqD", function(module, exports) {

$parcel$export(module.exports, "addPairToJSMap", () => $e7a2b5e26f092df8$export$fdef4d6a4585851d, (v) => $e7a2b5e26f092df8$export$fdef4d6a4585851d = v);
var $e7a2b5e26f092df8$export$fdef4d6a4585851d;
"use strict";

var $hdpqh = parcelRequire("hdpqh");

var $dq9bU = parcelRequire("dq9bU");

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");

var $iCaaN = parcelRequire("iCaaN");
const $e7a2b5e26f092df8$var$MERGE_KEY = "<<";
function $e7a2b5e26f092df8$var$addPairToJSMap(ctx, map, { key: key, value: value }) {
    if (ctx?.doc.schema.merge && $e7a2b5e26f092df8$var$isMergeKey(key)) {
        value = $8XpWs.isAlias(value) ? value.resolve(ctx.doc) : value;
        if ($8XpWs.isSeq(value)) for (const it of value.items)$e7a2b5e26f092df8$var$mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value)) for (const it of value)$e7a2b5e26f092df8$var$mergeToJSMap(ctx, map, it);
        else $e7a2b5e26f092df8$var$mergeToJSMap(ctx, map, value);
    } else {
        const jsKey = $iCaaN.toJS(key, "", ctx);
        if (map instanceof Map) map.set(jsKey, $iCaaN.toJS(value, jsKey, ctx));
        else if (map instanceof Set) map.add(jsKey);
        else {
            const stringKey = $e7a2b5e26f092df8$var$stringifyKey(key, jsKey, ctx);
            const jsValue = $iCaaN.toJS(value, stringKey, ctx);
            if (stringKey in map) Object.defineProperty(map, stringKey, {
                value: jsValue,
                writable: true,
                enumerable: true,
                configurable: true
            });
            else map[stringKey] = jsValue;
        }
    }
    return map;
}
const $e7a2b5e26f092df8$var$isMergeKey = (key)=>key === $e7a2b5e26f092df8$var$MERGE_KEY || $8XpWs.isScalar(key) && key.value === $e7a2b5e26f092df8$var$MERGE_KEY && (!key.type || key.type === $k84gT.Scalar.PLAIN);
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function $e7a2b5e26f092df8$var$mergeToJSMap(ctx, map, value) {
    const source = ctx && $8XpWs.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!$8XpWs.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap){
        if (map instanceof Map) {
            if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) map.add(key);
        else if (!Object.prototype.hasOwnProperty.call(map, key)) Object.defineProperty(map, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
        });
    }
    return map;
}
function $e7a2b5e26f092df8$var$stringifyKey(key, jsKey, ctx) {
    if (jsKey === null) return "";
    if (typeof jsKey !== "object") return String(jsKey);
    if ($8XpWs.isNode(key) && ctx?.doc) {
        const strCtx = $dq9bU.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
            $hdpqh.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}
$e7a2b5e26f092df8$export$fdef4d6a4585851d = $e7a2b5e26f092df8$var$addPairToJSMap;

});
parcelRegister("hdpqh", function(module, exports) {

$parcel$export(module.exports, "warn", () => $c8875f02540abc33$export$c106dd0671a0fc2d, (v) => $c8875f02540abc33$export$c106dd0671a0fc2d = v);
var $c8875f02540abc33$export$1c9f709888824e05;
var $c8875f02540abc33$export$c106dd0671a0fc2d;
"use strict";
function $c8875f02540abc33$var$debug(logLevel, ...messages) {
    if (logLevel === "debug") console.log(...messages);
}
function $c8875f02540abc33$var$warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== "undefined" && process.emitWarning) process.emitWarning(warning);
        else console.warn(warning);
    }
}
$c8875f02540abc33$export$1c9f709888824e05 = $c8875f02540abc33$var$debug;
$c8875f02540abc33$export$c106dd0671a0fc2d = $c8875f02540abc33$var$warn;

});



parcelRegister("lz3js", function(module, exports) {

$parcel$export(module.exports, "Schema", () => $fb2f6fba3e424437$export$19342e026b58ebb7, (v) => $fb2f6fba3e424437$export$19342e026b58ebb7 = v);
var $fb2f6fba3e424437$export$19342e026b58ebb7;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $9kv4s = parcelRequire("9kv4s");

var $6MHnR = parcelRequire("6MHnR");

var $43ktt = parcelRequire("43ktt");

var $6n5wD = parcelRequire("6n5wD");
const $fb2f6fba3e424437$var$sortMapEntriesByKey = (a, b)=>a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class $fb2f6fba3e424437$var$Schema {
    constructor({ compat: compat, customTags: customTags, merge: merge, resolveKnownTags: resolveKnownTags, schema: schema, sortMapEntries: sortMapEntries, toStringDefaults: toStringDefaults }){
        this.compat = Array.isArray(compat) ? $6n5wD.getTags(compat, "compat") : compat ? $6n5wD.getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? $6n5wD.coreKnownTags : {};
        this.tags = $6n5wD.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, $8XpWs.MAP, {
            value: $9kv4s.map
        });
        Object.defineProperty(this, $8XpWs.SCALAR, {
            value: $43ktt.string
        });
        Object.defineProperty(this, $8XpWs.SEQ, {
            value: $6MHnR.seq
        });
        // Used by createMap()
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? $fb2f6fba3e424437$var$sortMapEntriesByKey : null;
    }
    clone() {
        const copy = Object.create($fb2f6fba3e424437$var$Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}
$fb2f6fba3e424437$export$19342e026b58ebb7 = $fb2f6fba3e424437$var$Schema;

});
parcelRegister("9kv4s", function(module, exports) {

$parcel$export(module.exports, "map", () => $6cae155569a46ee1$export$871de8747c9eaa88, (v) => $6cae155569a46ee1$export$871de8747c9eaa88 = v);
var $6cae155569a46ee1$export$871de8747c9eaa88;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $k3oDt = parcelRequire("k3oDt");
const $6cae155569a46ee1$var$map = {
    collection: "map",
    default: true,
    nodeClass: $k3oDt.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve (map, onError) {
        if (!$8XpWs.isMap(map)) onError("Expected a mapping for this tag");
        return map;
    },
    createNode: (schema, obj, ctx)=>$k3oDt.YAMLMap.from(schema, obj, ctx)
};
$6cae155569a46ee1$export$871de8747c9eaa88 = $6cae155569a46ee1$var$map;

});
parcelRegister("k3oDt", function(module, exports) {

$parcel$export(module.exports, "YAMLMap", () => $e997329564a7a21e$export$eb1691c4b19bb5eb, (v) => $e997329564a7a21e$export$eb1691c4b19bb5eb = v);
$parcel$export(module.exports, "findPair", () => $e997329564a7a21e$export$cb7eebdbb143b550, (v) => $e997329564a7a21e$export$cb7eebdbb143b550 = v);
var $e997329564a7a21e$export$eb1691c4b19bb5eb;
var $e997329564a7a21e$export$cb7eebdbb143b550;
"use strict";

var $bAPto = parcelRequire("bAPto");

var $jSZqD = parcelRequire("jSZqD");

var $lgfhz = parcelRequire("lgfhz");

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $k84gT = parcelRequire("k84gT");
function $e997329564a7a21e$var$findPair(items, key) {
    const k = $8XpWs.isScalar(key) ? key.value : key;
    for (const it of items)if ($8XpWs.isPair(it)) {
        if (it.key === key || it.key === k) return it;
        if ($8XpWs.isScalar(it.key) && it.key.value === k) return it;
    }
    return undefined;
}
class $e997329564a7a21e$var$YAMLMap extends $lgfhz.Collection {
    static get tagName() {
        return "tag:yaml.org,2002:map";
    }
    constructor(schema){
        super($8XpWs.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */ static from(schema, obj, ctx) {
        const { keepUndefined: keepUndefined, replacer: replacer } = ctx;
        const map = new this(schema);
        const add = (key, value)=>{
            if (typeof replacer === "function") value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key)) return;
            if (value !== undefined || keepUndefined) map.items.push($3difO.createPair(key, value, ctx));
        };
        if (obj instanceof Map) for (const [key, value] of obj)add(key, value);
        else if (obj && typeof obj === "object") for (const key of Object.keys(obj))add(key, obj[key]);
        if (typeof schema.sortMapEntries === "function") map.items.sort(schema.sortMapEntries);
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */ add(pair, overwrite) {
        let _pair;
        if ($8XpWs.isPair(pair)) _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) // In TypeScript, this never happens.
        _pair = new $3difO.Pair(pair, pair?.value);
        else _pair = new $3difO.Pair(pair.key, pair.value);
        const prev = $e997329564a7a21e$var$findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if ($8XpWs.isScalar(prev.value) && $k84gT.isScalarValue(_pair.value)) prev.value.value = _pair.value;
            else prev.value = _pair.value;
        } else if (sortEntries) {
            const i = this.items.findIndex((item)=>sortEntries(_pair, item) < 0);
            if (i === -1) this.items.push(_pair);
            else this.items.splice(i, 0, _pair);
        } else this.items.push(_pair);
    }
    delete(key) {
        const it = $e997329564a7a21e$var$findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = $e997329564a7a21e$var$findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && $8XpWs.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!$e997329564a7a21e$var$findPair(this.items, key);
    }
    set(key, value) {
        this.add(new $3difO.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */ toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const item of this.items)$jSZqD.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items){
            if (!$8XpWs.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {
            allNullValues: true
        });
        return $bAPto.stringifyCollection(this, ctx, {
            blockItemPrefix: "",
            flowChars: {
                start: "{",
                end: "}"
            },
            itemIndent: ctx.indent || "",
            onChompKeep: onChompKeep,
            onComment: onComment
        });
    }
}
$e997329564a7a21e$export$eb1691c4b19bb5eb = $e997329564a7a21e$var$YAMLMap;
$e997329564a7a21e$export$cb7eebdbb143b550 = $e997329564a7a21e$var$findPair;

});
parcelRegister("bAPto", function(module, exports) {

$parcel$export(module.exports, "stringifyCollection", () => $870afc009862450e$export$b570edac7df98594, (v) => $870afc009862450e$export$b570edac7df98594 = v);
var $870afc009862450e$export$b570edac7df98594;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $dq9bU = parcelRequire("dq9bU");

var $7ZOXt = parcelRequire("7ZOXt");
function $870afc009862450e$var$stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? $870afc009862450e$var$stringifyFlowCollection : $870afc009862450e$var$stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function $870afc009862450e$var$stringifyBlockCollection({ comment: comment, items: items }, ctx, { blockItemPrefix: blockItemPrefix, flowChars: flowChars, itemIndent: itemIndent, onChompKeep: onChompKeep, onComment: onComment }) {
    const { indent: indent, options: { commentString: commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        type: null
    });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for(let i = 0; i < items.length; ++i){
        const item = items[i];
        let comment = null;
        if ($8XpWs.isNode(item)) {
            if (!chompKeep && item.spaceBefore) lines.push("");
            $870afc009862450e$var$addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment) comment = item.comment;
        } else if ($8XpWs.isPair(item)) {
            const ik = $8XpWs.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore) lines.push("");
                $870afc009862450e$var$addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = $dq9bU.stringify(item, itemCtx, ()=>comment = null, ()=>chompKeep = true);
        if (comment) str += $7ZOXt.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment) chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) str = flowChars.start + flowChars.end;
    else {
        str = lines[0];
        for(let i = 1; i < lines.length; ++i){
            const line = lines[i];
            str += line ? `\n${indent}${line}` : "\n";
        }
    }
    if (comment) {
        str += "\n" + $7ZOXt.indentComment(commentString(comment), indent);
        if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();
    return str;
}
function $870afc009862450e$var$stringifyFlowCollection({ items: items }, ctx, { flowChars: flowChars, itemIndent: itemIndent }) {
    const { indent: indent, indentStep: indentStep, flowCollectionPadding: fcPadding, options: { commentString: commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for(let i = 0; i < items.length; ++i){
        const item = items[i];
        let comment = null;
        if ($8XpWs.isNode(item)) {
            if (item.spaceBefore) lines.push("");
            $870afc009862450e$var$addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment) comment = item.comment;
        } else if ($8XpWs.isPair(item)) {
            const ik = $8XpWs.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore) lines.push("");
                $870afc009862450e$var$addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment) reqNewline = true;
            }
            const iv = $8XpWs.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment) comment = iv.comment;
                if (iv.commentBefore) reqNewline = true;
            } else if (item.value == null && ik?.comment) comment = ik.comment;
        }
        if (comment) reqNewline = true;
        let str = $dq9bU.stringify(item, itemCtx, ()=>comment = null);
        if (i < items.length - 1) str += ",";
        if (comment) str += $7ZOXt.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start: start, end: end } = flowChars;
    if (lines.length === 0) return start + end;
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line)=>sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)str += line ? `\n${indentStep}${indent}${line}` : "\n";
            return `${str}\n${indent}${end}`;
        } else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
}
function $870afc009862450e$var$addCommentBefore({ indent: indent, options: { commentString: commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
    if (comment) {
        const ic = $7ZOXt.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}
$870afc009862450e$export$b570edac7df98594 = $870afc009862450e$var$stringifyCollection;

});



parcelRegister("6MHnR", function(module, exports) {

$parcel$export(module.exports, "seq", () => $4f08e0e5f87638d4$export$1041d4276c328e4d, (v) => $4f08e0e5f87638d4$export$1041d4276c328e4d = v);
var $4f08e0e5f87638d4$export$1041d4276c328e4d;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $dsY7M = parcelRequire("dsY7M");
const $4f08e0e5f87638d4$var$seq = {
    collection: "seq",
    default: true,
    nodeClass: $dsY7M.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve (seq, onError) {
        if (!$8XpWs.isSeq(seq)) onError("Expected a sequence for this tag");
        return seq;
    },
    createNode: (schema, obj, ctx)=>$dsY7M.YAMLSeq.from(schema, obj, ctx)
};
$4f08e0e5f87638d4$export$1041d4276c328e4d = $4f08e0e5f87638d4$var$seq;

});
parcelRegister("dsY7M", function(module, exports) {

$parcel$export(module.exports, "YAMLSeq", () => $9cdc8755a65944e9$export$47adc25f769055b2, (v) => $9cdc8755a65944e9$export$47adc25f769055b2 = v);
var $9cdc8755a65944e9$export$47adc25f769055b2;
"use strict";

var $3G4bN = parcelRequire("3G4bN");

var $bAPto = parcelRequire("bAPto");

var $lgfhz = parcelRequire("lgfhz");

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");

var $iCaaN = parcelRequire("iCaaN");
class $9cdc8755a65944e9$var$YAMLSeq extends $lgfhz.Collection {
    static get tagName() {
        return "tag:yaml.org,2002:seq";
    }
    constructor(schema){
        super($8XpWs.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */ delete(key) {
        const idx = $9cdc8755a65944e9$var$asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = $9cdc8755a65944e9$var$asItemIndex(key);
        if (typeof idx !== "number") return undefined;
        const it = this.items[idx];
        return !keepScalar && $8XpWs.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */ has(key) {
        const idx = $9cdc8755a65944e9$var$asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */ set(key, value) {
        const idx = $9cdc8755a65944e9$var$asItemIndex(key);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if ($8XpWs.isScalar(prev) && $k84gT.isScalarValue(value)) prev.value = value;
        else this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate) ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)seq.push($iCaaN.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return $bAPto.stringifyCollection(this, ctx, {
            blockItemPrefix: "- ",
            flowChars: {
                start: "[",
                end: "]"
            },
            itemIndent: (ctx.indent || "") + "  ",
            onChompKeep: onChompKeep,
            onComment: onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer: replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj){
                if (typeof replacer === "function") {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push($3G4bN.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function $9cdc8755a65944e9$var$asItemIndex(key) {
    let idx = $8XpWs.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string") idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
$9cdc8755a65944e9$export$47adc25f769055b2 = $9cdc8755a65944e9$var$YAMLSeq;

});


parcelRegister("43ktt", function(module, exports) {

$parcel$export(module.exports, "string", () => $2f3753043da53d41$export$22b082955e083ec3, (v) => $2f3753043da53d41$export$22b082955e083ec3 = v);
var $2f3753043da53d41$export$22b082955e083ec3;
"use strict";

var $bkIH8 = parcelRequire("bkIH8");
const $2f3753043da53d41$var$string = {
    identify: (value)=>typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str)=>str,
    stringify (item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
            actualString: true
        }, ctx);
        return $bkIH8.stringifyString(item, ctx, onComment, onChompKeep);
    }
};
$2f3753043da53d41$export$22b082955e083ec3 = $2f3753043da53d41$var$string;

});

parcelRegister("6n5wD", function(module, exports) {

$parcel$export(module.exports, "coreKnownTags", () => $4a392d4b0ad26f7d$export$aa155beb708c8cc4, (v) => $4a392d4b0ad26f7d$export$aa155beb708c8cc4 = v);
$parcel$export(module.exports, "getTags", () => $4a392d4b0ad26f7d$export$af63d7414243dad3, (v) => $4a392d4b0ad26f7d$export$af63d7414243dad3 = v);
var $4a392d4b0ad26f7d$export$aa155beb708c8cc4;
var $4a392d4b0ad26f7d$export$af63d7414243dad3;
"use strict";

var $9kv4s = parcelRequire("9kv4s");

var $h6W6B = parcelRequire("h6W6B");

var $6MHnR = parcelRequire("6MHnR");

var $43ktt = parcelRequire("43ktt");

var $7TlUL = parcelRequire("7TlUL");

var $2Te0G = parcelRequire("2Te0G");

var $6CmEJ = parcelRequire("6CmEJ");

var $eB04A = parcelRequire("eB04A");

var $kqQuq = parcelRequire("kqQuq");

var $djUOf = parcelRequire("djUOf");

var $8aNQm = parcelRequire("8aNQm");

var $2CXKs = parcelRequire("2CXKs");

var $aC5YQ = parcelRequire("aC5YQ");

var $lfDFb = parcelRequire("lfDFb");

var $4toVT = parcelRequire("4toVT");
const $4a392d4b0ad26f7d$var$schemas = new Map([
    [
        "core",
        $eB04A.schema
    ],
    [
        "failsafe",
        [
            $9kv4s.map,
            $6MHnR.seq,
            $43ktt.string
        ]
    ],
    [
        "json",
        $kqQuq.schema
    ],
    [
        "yaml11",
        $aC5YQ.schema
    ],
    [
        "yaml-1.1",
        $aC5YQ.schema
    ]
]);
const $4a392d4b0ad26f7d$var$tagsByName = {
    binary: $djUOf.binary,
    bool: $7TlUL.boolTag,
    float: $2Te0G.float,
    floatExp: $2Te0G.floatExp,
    floatNaN: $2Te0G.floatNaN,
    floatTime: $4toVT.floatTime,
    int: $6CmEJ.int,
    intHex: $6CmEJ.intHex,
    intOct: $6CmEJ.intOct,
    intTime: $4toVT.intTime,
    map: $9kv4s.map,
    null: $h6W6B.nullTag,
    omap: $8aNQm.omap,
    pairs: $2CXKs.pairs,
    seq: $6MHnR.seq,
    set: $lfDFb.set,
    timestamp: $4toVT.timestamp
};
const $4a392d4b0ad26f7d$var$coreKnownTags = {
    "tag:yaml.org,2002:binary": $djUOf.binary,
    "tag:yaml.org,2002:omap": $8aNQm.omap,
    "tag:yaml.org,2002:pairs": $2CXKs.pairs,
    "tag:yaml.org,2002:set": $lfDFb.set,
    "tag:yaml.org,2002:timestamp": $4toVT.timestamp
};
function $4a392d4b0ad26f7d$var$getTags(customTags, schemaName) {
    let tags = $4a392d4b0ad26f7d$var$schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags)) tags = [];
        else {
            const keys = Array.from($4a392d4b0ad26f7d$var$schemas.keys()).filter((key)=>key !== "yaml11").map((key)=>JSON.stringify(key)).join(", ");
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) for (const tag of customTags)tags = tags.concat(tag);
    else if (typeof customTags === "function") tags = customTags(tags.slice());
    return tags.map((tag)=>{
        if (typeof tag !== "string") return tag;
        const tagObj = $4a392d4b0ad26f7d$var$tagsByName[tag];
        if (tagObj) return tagObj;
        const keys = Object.keys($4a392d4b0ad26f7d$var$tagsByName).map((key)=>JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}
$4a392d4b0ad26f7d$export$aa155beb708c8cc4 = $4a392d4b0ad26f7d$var$coreKnownTags;
$4a392d4b0ad26f7d$export$af63d7414243dad3 = $4a392d4b0ad26f7d$var$getTags;

});
parcelRegister("h6W6B", function(module, exports) {

$parcel$export(module.exports, "nullTag", () => $c75011b97032e926$export$a4f9db1e8324ef6b, (v) => $c75011b97032e926$export$a4f9db1e8324ef6b = v);
var $c75011b97032e926$export$a4f9db1e8324ef6b;
"use strict";

var $k84gT = parcelRequire("k84gT");
const $c75011b97032e926$var$nullTag = {
    identify: (value)=>value == null,
    createNode: ()=>new $k84gT.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: ()=>new $k84gT.Scalar(null),
    stringify: ({ source: source }, ctx)=>typeof source === "string" && $c75011b97032e926$var$nullTag.test.test(source) ? source : ctx.options.nullStr
};
$c75011b97032e926$export$a4f9db1e8324ef6b = $c75011b97032e926$var$nullTag;

});

parcelRegister("7TlUL", function(module, exports) {

$parcel$export(module.exports, "boolTag", () => $5beeab37e2ffe537$export$4f52eaca20f174c1, (v) => $5beeab37e2ffe537$export$4f52eaca20f174c1 = v);
var $5beeab37e2ffe537$export$4f52eaca20f174c1;
"use strict";

var $k84gT = parcelRequire("k84gT");
const $5beeab37e2ffe537$var$boolTag = {
    identify: (value)=>typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str)=>new $k84gT.Scalar(str[0] === "t" || str[0] === "T"),
    stringify ({ source: source, value: value }, ctx) {
        if (source && $5beeab37e2ffe537$var$boolTag.test.test(source)) {
            const sv = source[0] === "t" || source[0] === "T";
            if (value === sv) return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};
$5beeab37e2ffe537$export$4f52eaca20f174c1 = $5beeab37e2ffe537$var$boolTag;

});

parcelRegister("2Te0G", function(module, exports) {

$parcel$export(module.exports, "float", () => $21ab95f09ce7aa88$export$6b5cd3983e3ee5ab, (v) => $21ab95f09ce7aa88$export$6b5cd3983e3ee5ab = v);
$parcel$export(module.exports, "floatExp", () => $21ab95f09ce7aa88$export$d62805e4174324af, (v) => $21ab95f09ce7aa88$export$d62805e4174324af = v);
$parcel$export(module.exports, "floatNaN", () => $21ab95f09ce7aa88$export$37d6b822c496e154, (v) => $21ab95f09ce7aa88$export$37d6b822c496e154 = v);
var $21ab95f09ce7aa88$export$6b5cd3983e3ee5ab;
var $21ab95f09ce7aa88$export$d62805e4174324af;
var $21ab95f09ce7aa88$export$37d6b822c496e154;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $5oIfK = parcelRequire("5oIfK");
const $21ab95f09ce7aa88$var$floatNaN = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: (str)=>str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $5oIfK.stringifyNumber
};
const $21ab95f09ce7aa88$var$floatExp = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str)=>parseFloat(str),
    stringify (node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : $5oIfK.stringifyNumber(node);
    }
};
const $21ab95f09ce7aa88$var$float = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve (str) {
        const node = new $k84gT.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: $5oIfK.stringifyNumber
};
$21ab95f09ce7aa88$export$6b5cd3983e3ee5ab = $21ab95f09ce7aa88$var$float;
$21ab95f09ce7aa88$export$d62805e4174324af = $21ab95f09ce7aa88$var$floatExp;
$21ab95f09ce7aa88$export$37d6b822c496e154 = $21ab95f09ce7aa88$var$floatNaN;

});
parcelRegister("5oIfK", function(module, exports) {

$parcel$export(module.exports, "stringifyNumber", () => $3ee1855d1d736ca0$export$4c03b48e25071796, (v) => $3ee1855d1d736ca0$export$4c03b48e25071796 = v);
var $3ee1855d1d736ca0$export$4c03b48e25071796;
"use strict";
function $3ee1855d1d736ca0$var$stringifyNumber({ format: format, minFractionDigits: minFractionDigits, tag: tag, value: value }) {
    if (typeof value === "bigint") return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
            i = n.length;
            n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while(d-- > 0)n += "0";
    }
    return n;
}
$3ee1855d1d736ca0$export$4c03b48e25071796 = $3ee1855d1d736ca0$var$stringifyNumber;

});


parcelRegister("6CmEJ", function(module, exports) {

$parcel$export(module.exports, "int", () => $4d17ddac8d68181c$export$7d260a2a5f8bc19e, (v) => $4d17ddac8d68181c$export$7d260a2a5f8bc19e = v);
$parcel$export(module.exports, "intHex", () => $4d17ddac8d68181c$export$3aff77776319ec6e, (v) => $4d17ddac8d68181c$export$3aff77776319ec6e = v);
$parcel$export(module.exports, "intOct", () => $4d17ddac8d68181c$export$3d3e8b3bce028aae, (v) => $4d17ddac8d68181c$export$3d3e8b3bce028aae = v);
var $4d17ddac8d68181c$export$7d260a2a5f8bc19e;
var $4d17ddac8d68181c$export$3aff77776319ec6e;
var $4d17ddac8d68181c$export$3d3e8b3bce028aae;
"use strict";

var $5oIfK = parcelRequire("5oIfK");
const $4d17ddac8d68181c$var$intIdentify = (value)=>typeof value === "bigint" || Number.isInteger(value);
const $4d17ddac8d68181c$var$intResolve = (str, offset, radix, { intAsBigInt: intAsBigInt })=>intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function $4d17ddac8d68181c$var$intStringify(node, radix, prefix) {
    const { value: value } = node;
    if ($4d17ddac8d68181c$var$intIdentify(value) && value >= 0) return prefix + value.toString(radix);
    return $5oIfK.stringifyNumber(node);
}
const $4d17ddac8d68181c$var$intOct = {
    identify: (value)=>$4d17ddac8d68181c$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt)=>$4d17ddac8d68181c$var$intResolve(str, 2, 8, opt),
    stringify: (node)=>$4d17ddac8d68181c$var$intStringify(node, 8, "0o")
};
const $4d17ddac8d68181c$var$int = {
    identify: $4d17ddac8d68181c$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt)=>$4d17ddac8d68181c$var$intResolve(str, 0, 10, opt),
    stringify: $5oIfK.stringifyNumber
};
const $4d17ddac8d68181c$var$intHex = {
    identify: (value)=>$4d17ddac8d68181c$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt)=>$4d17ddac8d68181c$var$intResolve(str, 2, 16, opt),
    stringify: (node)=>$4d17ddac8d68181c$var$intStringify(node, 16, "0x")
};
$4d17ddac8d68181c$export$7d260a2a5f8bc19e = $4d17ddac8d68181c$var$int;
$4d17ddac8d68181c$export$3aff77776319ec6e = $4d17ddac8d68181c$var$intHex;
$4d17ddac8d68181c$export$3d3e8b3bce028aae = $4d17ddac8d68181c$var$intOct;

});

parcelRegister("eB04A", function(module, exports) {

$parcel$export(module.exports, "schema", () => $aa0493e2f4c74dbf$export$4902baddc787debb, (v) => $aa0493e2f4c74dbf$export$4902baddc787debb = v);
var $aa0493e2f4c74dbf$export$4902baddc787debb;
"use strict";

var $9kv4s = parcelRequire("9kv4s");

var $h6W6B = parcelRequire("h6W6B");

var $6MHnR = parcelRequire("6MHnR");

var $43ktt = parcelRequire("43ktt");

var $7TlUL = parcelRequire("7TlUL");

var $2Te0G = parcelRequire("2Te0G");

var $6CmEJ = parcelRequire("6CmEJ");
const $aa0493e2f4c74dbf$var$schema = [
    $9kv4s.map,
    $6MHnR.seq,
    $43ktt.string,
    $h6W6B.nullTag,
    $7TlUL.boolTag,
    $6CmEJ.intOct,
    $6CmEJ.int,
    $6CmEJ.intHex,
    $2Te0G.floatNaN,
    $2Te0G.floatExp,
    $2Te0G.float
];
$aa0493e2f4c74dbf$export$4902baddc787debb = $aa0493e2f4c74dbf$var$schema;

});

parcelRegister("kqQuq", function(module, exports) {

$parcel$export(module.exports, "schema", () => $edfef3b8b0ec12c1$export$4902baddc787debb, (v) => $edfef3b8b0ec12c1$export$4902baddc787debb = v);
var $edfef3b8b0ec12c1$export$4902baddc787debb;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $9kv4s = parcelRequire("9kv4s");

var $6MHnR = parcelRequire("6MHnR");
function $edfef3b8b0ec12c1$var$intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
}
const $edfef3b8b0ec12c1$var$stringifyJSON = ({ value: value })=>JSON.stringify(value);
const $edfef3b8b0ec12c1$var$jsonScalars = [
    {
        identify: (value)=>typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str)=>str,
        stringify: $edfef3b8b0ec12c1$var$stringifyJSON
    },
    {
        identify: (value)=>value == null,
        createNode: ()=>new $k84gT.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: ()=>null,
        stringify: $edfef3b8b0ec12c1$var$stringifyJSON
    },
    {
        identify: (value)=>typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str)=>str === "true",
        stringify: $edfef3b8b0ec12c1$var$stringifyJSON
    },
    {
        identify: $edfef3b8b0ec12c1$var$intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt: intAsBigInt })=>intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value: value })=>$edfef3b8b0ec12c1$var$intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: (value)=>typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str)=>parseFloat(str),
        stringify: $edfef3b8b0ec12c1$var$stringifyJSON
    }
];
const $edfef3b8b0ec12c1$var$jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve (str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const $edfef3b8b0ec12c1$var$schema = [
    $9kv4s.map,
    $6MHnR.seq
].concat($edfef3b8b0ec12c1$var$jsonScalars, $edfef3b8b0ec12c1$var$jsonError);
$edfef3b8b0ec12c1$export$4902baddc787debb = $edfef3b8b0ec12c1$var$schema;

});

parcelRegister("djUOf", function(module, exports) {

$parcel$export(module.exports, "binary", () => $9b291ddc395c10fa$export$33902b7329277358, (v) => $9b291ddc395c10fa$export$33902b7329277358 = v);
var $9b291ddc395c10fa$export$33902b7329277358;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $bkIH8 = parcelRequire("bkIH8");
const $9b291ddc395c10fa$var$binary = {
    identify: (value)=>value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */ resolve (src, onError) {
        if (typeof Buffer === "function") return Buffer.from(src, "base64");
        else if (typeof atob === "function") {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ""));
            const buffer = new Uint8Array(str.length);
            for(let i = 0; i < str.length; ++i)buffer[i] = str.charCodeAt(i);
            return buffer;
        } else {
            onError("This environment does not support reading binary tags; either Buffer or atob is required");
            return src;
        }
    },
    stringify ({ comment: comment, type: type, value: value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === "function") str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        else if (typeof btoa === "function") {
            let s = "";
            for(let i = 0; i < buf.length; ++i)s += String.fromCharCode(buf[i]);
            str = btoa(s);
        } else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        if (!type) type = $k84gT.Scalar.BLOCK_LITERAL;
        if (type !== $k84gT.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for(let i = 0, o = 0; i < n; ++i, o += lineWidth)lines[i] = str.substr(o, lineWidth);
            str = lines.join(type === $k84gT.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return $bkIH8.stringifyString({
            comment: comment,
            type: type,
            value: str
        }, ctx, onComment, onChompKeep);
    }
};
$9b291ddc395c10fa$export$33902b7329277358 = $9b291ddc395c10fa$var$binary;

});

parcelRegister("8aNQm", function(module, exports) {

$parcel$export(module.exports, "omap", () => $5f35ebce28fe9423$export$5a6b5e3152d599a2, (v) => $5f35ebce28fe9423$export$5a6b5e3152d599a2 = v);
var $5f35ebce28fe9423$export$7006ac3fb49022d8;
var $5f35ebce28fe9423$export$5a6b5e3152d599a2;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $iCaaN = parcelRequire("iCaaN");

var $k3oDt = parcelRequire("k3oDt");

var $dsY7M = parcelRequire("dsY7M");

var $2CXKs = parcelRequire("2CXKs");
class $5f35ebce28fe9423$var$YAMLOMap extends $dsY7M.YAMLSeq {
    constructor(){
        super();
        this.add = $k3oDt.YAMLMap.prototype.add.bind(this);
        this.delete = $k3oDt.YAMLMap.prototype.delete.bind(this);
        this.get = $k3oDt.YAMLMap.prototype.get.bind(this);
        this.has = $k3oDt.YAMLMap.prototype.has.bind(this);
        this.set = $k3oDt.YAMLMap.prototype.set.bind(this);
        this.tag = $5f35ebce28fe9423$var$YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */ toJSON(_, ctx) {
        if (!ctx) return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const pair of this.items){
            let key, value;
            if ($8XpWs.isPair(pair)) {
                key = $iCaaN.toJS(pair.key, "", ctx);
                value = $iCaaN.toJS(pair.value, key, ctx);
            } else key = $iCaaN.toJS(pair, "", ctx);
            if (map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = $2CXKs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
$5f35ebce28fe9423$var$YAMLOMap.tag = "tag:yaml.org,2002:omap";
const $5f35ebce28fe9423$var$omap = {
    collection: "seq",
    identify: (value)=>value instanceof Map,
    nodeClass: $5f35ebce28fe9423$var$YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve (seq, onError) {
        const pairs$1 = $2CXKs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key: key } of pairs$1.items)if ($8XpWs.isScalar(key)) {
            if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            else seenKeys.push(key.value);
        }
        return Object.assign(new $5f35ebce28fe9423$var$YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx)=>$5f35ebce28fe9423$var$YAMLOMap.from(schema, iterable, ctx)
};
$5f35ebce28fe9423$export$7006ac3fb49022d8 = $5f35ebce28fe9423$var$YAMLOMap;
$5f35ebce28fe9423$export$5a6b5e3152d599a2 = $5f35ebce28fe9423$var$omap;

});
parcelRegister("2CXKs", function(module, exports) {

$parcel$export(module.exports, "createPairs", () => $1e9d7a20ab78c0ea$export$27bb6a7978f1f74a, (v) => $1e9d7a20ab78c0ea$export$27bb6a7978f1f74a = v);
$parcel$export(module.exports, "pairs", () => $1e9d7a20ab78c0ea$export$589748d90c221be3, (v) => $1e9d7a20ab78c0ea$export$589748d90c221be3 = v);
$parcel$export(module.exports, "resolvePairs", () => $1e9d7a20ab78c0ea$export$f3d665c6925c05a1, (v) => $1e9d7a20ab78c0ea$export$f3d665c6925c05a1 = v);
var $1e9d7a20ab78c0ea$export$27bb6a7978f1f74a;
var $1e9d7a20ab78c0ea$export$589748d90c221be3;
var $1e9d7a20ab78c0ea$export$f3d665c6925c05a1;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $k84gT = parcelRequire("k84gT");

var $dsY7M = parcelRequire("dsY7M");
function $1e9d7a20ab78c0ea$var$resolvePairs(seq, onError) {
    if ($8XpWs.isSeq(seq)) for(let i = 0; i < seq.items.length; ++i){
        let item = seq.items[i];
        if ($8XpWs.isPair(item)) continue;
        else if ($8XpWs.isMap(item)) {
            if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new $3difO.Pair(new $k84gT.Scalar(null));
            if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
                const cn = pair.value ?? pair.key;
                cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
            }
            item = pair;
        }
        seq.items[i] = $8XpWs.isPair(item) ? item : new $3difO.Pair(item);
    }
    else onError("Expected a sequence for this tag");
    return seq;
}
function $1e9d7a20ab78c0ea$var$createPairs(schema, iterable, ctx) {
    const { replacer: replacer } = ctx;
    const pairs = new $dsY7M.YAMLSeq(schema);
    pairs.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable){
        if (typeof replacer === "function") it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
            if (it.length === 2) {
                key = it[0];
                value = it[1];
            } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
                key = keys[0];
                value = it[key];
            } else throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        } else key = it;
        pairs.items.push($3difO.createPair(key, value, ctx));
    }
    return pairs;
}
const $1e9d7a20ab78c0ea$var$pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: $1e9d7a20ab78c0ea$var$resolvePairs,
    createNode: $1e9d7a20ab78c0ea$var$createPairs
};
$1e9d7a20ab78c0ea$export$27bb6a7978f1f74a = $1e9d7a20ab78c0ea$var$createPairs;
$1e9d7a20ab78c0ea$export$589748d90c221be3 = $1e9d7a20ab78c0ea$var$pairs;
$1e9d7a20ab78c0ea$export$f3d665c6925c05a1 = $1e9d7a20ab78c0ea$var$resolvePairs;

});


parcelRegister("aC5YQ", function(module, exports) {

$parcel$export(module.exports, "schema", () => $7ba217923be82bff$export$4902baddc787debb, (v) => $7ba217923be82bff$export$4902baddc787debb = v);
var $7ba217923be82bff$export$4902baddc787debb;
"use strict";

var $9kv4s = parcelRequire("9kv4s");

var $h6W6B = parcelRequire("h6W6B");

var $6MHnR = parcelRequire("6MHnR");

var $43ktt = parcelRequire("43ktt");

var $djUOf = parcelRequire("djUOf");

var $4Z2lQ = parcelRequire("4Z2lQ");

var $gjMUK = parcelRequire("gjMUK");

var $bhE5D = parcelRequire("bhE5D");

var $8aNQm = parcelRequire("8aNQm");

var $2CXKs = parcelRequire("2CXKs");

var $lfDFb = parcelRequire("lfDFb");

var $4toVT = parcelRequire("4toVT");
const $7ba217923be82bff$var$schema = [
    $9kv4s.map,
    $6MHnR.seq,
    $43ktt.string,
    $h6W6B.nullTag,
    $4Z2lQ.trueTag,
    $4Z2lQ.falseTag,
    $bhE5D.intBin,
    $bhE5D.intOct,
    $bhE5D.int,
    $bhE5D.intHex,
    $gjMUK.floatNaN,
    $gjMUK.floatExp,
    $gjMUK.float,
    $djUOf.binary,
    $8aNQm.omap,
    $2CXKs.pairs,
    $lfDFb.set,
    $4toVT.intTime,
    $4toVT.floatTime,
    $4toVT.timestamp
];
$7ba217923be82bff$export$4902baddc787debb = $7ba217923be82bff$var$schema;

});
parcelRegister("4Z2lQ", function(module, exports) {

$parcel$export(module.exports, "falseTag", () => $3a0eaedcbfa44d8e$export$250e1f5a64500a2e, (v) => $3a0eaedcbfa44d8e$export$250e1f5a64500a2e = v);
$parcel$export(module.exports, "trueTag", () => $3a0eaedcbfa44d8e$export$ae6fbb429290d2fa, (v) => $3a0eaedcbfa44d8e$export$ae6fbb429290d2fa = v);
var $3a0eaedcbfa44d8e$export$250e1f5a64500a2e;
var $3a0eaedcbfa44d8e$export$ae6fbb429290d2fa;
"use strict";

var $k84gT = parcelRequire("k84gT");
function $3a0eaedcbfa44d8e$var$boolStringify({ value: value, source: source }, ctx) {
    const boolObj = value ? $3a0eaedcbfa44d8e$var$trueTag : $3a0eaedcbfa44d8e$var$falseTag;
    if (source && boolObj.test.test(source)) return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const $3a0eaedcbfa44d8e$var$trueTag = {
    identify: (value)=>value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: ()=>new $k84gT.Scalar(true),
    stringify: $3a0eaedcbfa44d8e$var$boolStringify
};
const $3a0eaedcbfa44d8e$var$falseTag = {
    identify: (value)=>value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: ()=>new $k84gT.Scalar(false),
    stringify: $3a0eaedcbfa44d8e$var$boolStringify
};
$3a0eaedcbfa44d8e$export$250e1f5a64500a2e = $3a0eaedcbfa44d8e$var$falseTag;
$3a0eaedcbfa44d8e$export$ae6fbb429290d2fa = $3a0eaedcbfa44d8e$var$trueTag;

});

parcelRegister("gjMUK", function(module, exports) {

$parcel$export(module.exports, "float", () => $be145d0d3d178405$export$6b5cd3983e3ee5ab, (v) => $be145d0d3d178405$export$6b5cd3983e3ee5ab = v);
$parcel$export(module.exports, "floatExp", () => $be145d0d3d178405$export$d62805e4174324af, (v) => $be145d0d3d178405$export$d62805e4174324af = v);
$parcel$export(module.exports, "floatNaN", () => $be145d0d3d178405$export$37d6b822c496e154, (v) => $be145d0d3d178405$export$37d6b822c496e154 = v);
var $be145d0d3d178405$export$6b5cd3983e3ee5ab;
var $be145d0d3d178405$export$d62805e4174324af;
var $be145d0d3d178405$export$37d6b822c496e154;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $5oIfK = parcelRequire("5oIfK");
const $be145d0d3d178405$var$floatNaN = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str)=>str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $5oIfK.stringifyNumber
};
const $be145d0d3d178405$var$floatExp = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str)=>parseFloat(str.replace(/_/g, "")),
    stringify (node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : $5oIfK.stringifyNumber(node);
    }
};
const $be145d0d3d178405$var$float = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve (str) {
        const node = new $k84gT.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, "");
            if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: $5oIfK.stringifyNumber
};
$be145d0d3d178405$export$6b5cd3983e3ee5ab = $be145d0d3d178405$var$float;
$be145d0d3d178405$export$d62805e4174324af = $be145d0d3d178405$var$floatExp;
$be145d0d3d178405$export$37d6b822c496e154 = $be145d0d3d178405$var$floatNaN;

});

parcelRegister("bhE5D", function(module, exports) {

$parcel$export(module.exports, "int", () => $8370613e217f6150$export$7d260a2a5f8bc19e, (v) => $8370613e217f6150$export$7d260a2a5f8bc19e = v);
$parcel$export(module.exports, "intBin", () => $8370613e217f6150$export$a0833348c72870ac, (v) => $8370613e217f6150$export$a0833348c72870ac = v);
$parcel$export(module.exports, "intHex", () => $8370613e217f6150$export$3aff77776319ec6e, (v) => $8370613e217f6150$export$3aff77776319ec6e = v);
$parcel$export(module.exports, "intOct", () => $8370613e217f6150$export$3d3e8b3bce028aae, (v) => $8370613e217f6150$export$3d3e8b3bce028aae = v);
var $8370613e217f6150$export$7d260a2a5f8bc19e;
var $8370613e217f6150$export$a0833348c72870ac;
var $8370613e217f6150$export$3aff77776319ec6e;
var $8370613e217f6150$export$3d3e8b3bce028aae;
"use strict";

var $5oIfK = parcelRequire("5oIfK");
const $8370613e217f6150$var$intIdentify = (value)=>typeof value === "bigint" || Number.isInteger(value);
function $8370613e217f6150$var$intResolve(str, offset, radix, { intAsBigInt: intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+") offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
        switch(radix){
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === "-" ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
}
function $8370613e217f6150$var$intStringify(node, radix, prefix) {
    const { value: value } = node;
    if ($8370613e217f6150$var$intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return $5oIfK.stringifyNumber(node);
}
const $8370613e217f6150$var$intBin = {
    identify: $8370613e217f6150$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt)=>$8370613e217f6150$var$intResolve(str, 2, 2, opt),
    stringify: (node)=>$8370613e217f6150$var$intStringify(node, 2, "0b")
};
const $8370613e217f6150$var$intOct = {
    identify: $8370613e217f6150$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt)=>$8370613e217f6150$var$intResolve(str, 1, 8, opt),
    stringify: (node)=>$8370613e217f6150$var$intStringify(node, 8, "0")
};
const $8370613e217f6150$var$int = {
    identify: $8370613e217f6150$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt)=>$8370613e217f6150$var$intResolve(str, 0, 10, opt),
    stringify: $5oIfK.stringifyNumber
};
const $8370613e217f6150$var$intHex = {
    identify: $8370613e217f6150$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt)=>$8370613e217f6150$var$intResolve(str, 2, 16, opt),
    stringify: (node)=>$8370613e217f6150$var$intStringify(node, 16, "0x")
};
$8370613e217f6150$export$7d260a2a5f8bc19e = $8370613e217f6150$var$int;
$8370613e217f6150$export$a0833348c72870ac = $8370613e217f6150$var$intBin;
$8370613e217f6150$export$3aff77776319ec6e = $8370613e217f6150$var$intHex;
$8370613e217f6150$export$3d3e8b3bce028aae = $8370613e217f6150$var$intOct;

});

parcelRegister("lfDFb", function(module, exports) {

$parcel$export(module.exports, "set", () => $f789c3f9c5410e1a$export$adaa4cf7ef1b65be, (v) => $f789c3f9c5410e1a$export$adaa4cf7ef1b65be = v);
var $f789c3f9c5410e1a$export$d64eaa29dab13634;
var $f789c3f9c5410e1a$export$adaa4cf7ef1b65be;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $k3oDt = parcelRequire("k3oDt");
class $f789c3f9c5410e1a$var$YAMLSet extends $k3oDt.YAMLMap {
    constructor(schema){
        super(schema);
        this.tag = $f789c3f9c5410e1a$var$YAMLSet.tag;
    }
    add(key) {
        let pair;
        if ($8XpWs.isPair(key)) pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new $3difO.Pair(key.key, null);
        else pair = new $3difO.Pair(key, null);
        const prev = $k3oDt.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */ get(key, keepPair) {
        const pair = $k3oDt.findPair(this.items, key);
        return !keepPair && $8XpWs.isPair(pair) ? $8XpWs.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = $k3oDt.findPair(this.items, key);
        if (prev && !value) this.items.splice(this.items.indexOf(prev), 1);
        else if (!prev && value) this.items.push(new $3difO.Pair(key));
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, {
            allNullValues: true
        }), onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
        const { replacer: replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable){
            if (typeof replacer === "function") value = replacer.call(iterable, value, value);
            set.items.push($3difO.createPair(value, null, ctx));
        }
        return set;
    }
}
$f789c3f9c5410e1a$var$YAMLSet.tag = "tag:yaml.org,2002:set";
const $f789c3f9c5410e1a$var$set = {
    collection: "map",
    identify: (value)=>value instanceof Set,
    nodeClass: $f789c3f9c5410e1a$var$YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx)=>$f789c3f9c5410e1a$var$YAMLSet.from(schema, iterable, ctx),
    resolve (map, onError) {
        if ($8XpWs.isMap(map)) {
            if (map.hasAllNullValues(true)) return Object.assign(new $f789c3f9c5410e1a$var$YAMLSet(), map);
            else onError("Set items must all have null values");
        } else onError("Expected a mapping for this tag");
        return map;
    }
};
$f789c3f9c5410e1a$export$d64eaa29dab13634 = $f789c3f9c5410e1a$var$YAMLSet;
$f789c3f9c5410e1a$export$adaa4cf7ef1b65be = $f789c3f9c5410e1a$var$set;

});

parcelRegister("4toVT", function(module, exports) {

$parcel$export(module.exports, "floatTime", () => $341d35f99ab3d197$export$1ca419aed578763e, (v) => $341d35f99ab3d197$export$1ca419aed578763e = v);
$parcel$export(module.exports, "intTime", () => $341d35f99ab3d197$export$14aedb0832cb7538, (v) => $341d35f99ab3d197$export$14aedb0832cb7538 = v);
$parcel$export(module.exports, "timestamp", () => $341d35f99ab3d197$export$fc00ee57782020aa, (v) => $341d35f99ab3d197$export$fc00ee57782020aa = v);
var $341d35f99ab3d197$export$1ca419aed578763e;
var $341d35f99ab3d197$export$14aedb0832cb7538;
var $341d35f99ab3d197$export$fc00ee57782020aa;
"use strict";

var $5oIfK = parcelRequire("5oIfK");
/** Internal types handle bigint as number, because TS can't figure it out. */ function $341d35f99ab3d197$var$parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n)=>asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res, p)=>res * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */ function $341d35f99ab3d197$var$stringifySexagesimal(node) {
    let { value: value } = node;
    let num = (n)=>n;
    if (typeof value === "bigint") num = (n)=>BigInt(n);
    else if (isNaN(value) || !isFinite(value)) return $5oIfK.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
        sign = "-";
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [
        value % _60
    ]; // seconds, including ms
    if (value < 60) parts.unshift(0); // at least one : is required
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return sign + parts.map((n)=>String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "") // % 60 may introduce error
    ;
}
const $341d35f99ab3d197$var$intTime = {
    identify: (value)=>typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt: intAsBigInt })=>$341d35f99ab3d197$var$parseSexagesimal(str, intAsBigInt),
    stringify: $341d35f99ab3d197$var$stringifySexagesimal
};
const $341d35f99ab3d197$var$floatTime = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str)=>$341d35f99ab3d197$var$parseSexagesimal(str, false),
    stringify: $341d35f99ab3d197$var$stringifySexagesimal
};
const $341d35f99ab3d197$var$timestamp = {
    identify: (value)=>value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve (str) {
        const match = str.match($341d35f99ab3d197$var$timestamp.test);
        if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
            let d = $341d35f99ab3d197$var$parseSexagesimal(tz, false);
            if (Math.abs(d) < 30) d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value: value })=>value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
$341d35f99ab3d197$export$1ca419aed578763e = $341d35f99ab3d197$var$floatTime;
$341d35f99ab3d197$export$14aedb0832cb7538 = $341d35f99ab3d197$var$intTime;
$341d35f99ab3d197$export$fc00ee57782020aa = $341d35f99ab3d197$var$timestamp;

});




parcelRegister("jHLhT", function(module, exports) {

$parcel$export(module.exports, "stringifyDocument", () => $e586b6c7e20946bb$export$4ad5e7f5f7ff7493, (v) => $e586b6c7e20946bb$export$4ad5e7f5f7ff7493 = v);
var $e586b6c7e20946bb$export$4ad5e7f5f7ff7493;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $dq9bU = parcelRequire("dq9bU");

var $7ZOXt = parcelRequire("7ZOXt");
function $e586b6c7e20946bb$var$stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        } else if (doc.directives.docStart) hasDirectives = true;
    }
    if (hasDirectives) lines.push("---");
    const ctx = $dq9bU.createStringifyContext(doc, options);
    const { commentString: commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1) lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift($7ZOXt.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if ($8XpWs.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives) lines.push("");
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push($7ZOXt.indentComment(cs, ""));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : ()=>chompKeep = true;
        let body = $dq9bU.stringify(doc.contents, ctx, ()=>contentComment = null, onChompKeep);
        if (contentComment) body += $7ZOXt.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") // Top-level block scalars with a preceding doc marker ought to use the
        // same line for their header.
        lines[lines.length - 1] = `--- ${body}`;
        else lines.push(body);
    } else lines.push($dq9bU.stringify(doc.contents, ctx));
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes("\n")) {
                lines.push("...");
                lines.push($7ZOXt.indentComment(cs, ""));
            } else lines.push(`... ${cs}`);
        } else lines.push("...");
    } else {
        let dc = doc.comment;
        if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
            lines.push($7ZOXt.indentComment(commentString(dc), ""));
        }
    }
    return lines.join("\n") + "\n";
}
$e586b6c7e20946bb$export$4ad5e7f5f7ff7493 = $e586b6c7e20946bb$var$stringifyDocument;

});


parcelRegister("1MTYj", function(module, exports) {

$parcel$export(module.exports, "YAMLError", () => $14d5b0f3829a6845$export$699cd54d617b337f, (v) => $14d5b0f3829a6845$export$699cd54d617b337f = v);
$parcel$export(module.exports, "YAMLParseError", () => $14d5b0f3829a6845$export$c1188aaa49090a5c, (v) => $14d5b0f3829a6845$export$c1188aaa49090a5c = v);
$parcel$export(module.exports, "YAMLWarning", () => $14d5b0f3829a6845$export$856b463bac79f971, (v) => $14d5b0f3829a6845$export$856b463bac79f971 = v);
$parcel$export(module.exports, "prettifyError", () => $14d5b0f3829a6845$export$44eaaa72d914fe8c, (v) => $14d5b0f3829a6845$export$44eaaa72d914fe8c = v);
var $14d5b0f3829a6845$export$699cd54d617b337f;
var $14d5b0f3829a6845$export$c1188aaa49090a5c;
var $14d5b0f3829a6845$export$856b463bac79f971;
var $14d5b0f3829a6845$export$44eaaa72d914fe8c;
"use strict";
class $14d5b0f3829a6845$var$YAMLError extends Error {
    constructor(name, pos, code, message){
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class $14d5b0f3829a6845$var$YAMLParseError extends $14d5b0f3829a6845$var$YAMLError {
    constructor(pos, code, message){
        super("YAMLParseError", pos, code, message);
    }
}
class $14d5b0f3829a6845$var$YAMLWarning extends $14d5b0f3829a6845$var$YAMLError {
    constructor(pos, code, message){
        super("YAMLWarning", pos, code, message);
    }
}
const $14d5b0f3829a6845$var$prettifyError = (src, lc)=>(error)=>{
        if (error.pos[0] === -1) return;
        error.linePos = error.pos.map((pos)=>lc.linePos(pos));
        const { line: line, col: col } = error.linePos[0];
        error.message += ` at line ${line}, column ${col}`;
        let ci = col - 1;
        let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
        // Trim to max 80 chars, keeping col position near the middle
        if (ci >= 60 && lineStr.length > 80) {
            const trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = "\u2026" + lineStr.substring(trimStart);
            ci -= trimStart - 1;
        }
        if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "\u2026";
        // Include previous line in context if pointing at line start
        if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            // Regexp won't match if start is trimmed
            let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            if (prev.length > 80) prev = prev.substring(0, 79) + "\u2026\n";
            lineStr = prev + lineStr;
        }
        if (/[^ ]/.test(lineStr)) {
            let count = 1;
            const end = error.linePos[1];
            if (end && end.line === line && end.col > col) count = Math.max(1, Math.min(end.col - col, 80 - ci));
            const pointer = " ".repeat(ci) + "^".repeat(count);
            error.message += `:\n\n${lineStr}\n${pointer}\n`;
        }
    };
$14d5b0f3829a6845$export$699cd54d617b337f = $14d5b0f3829a6845$var$YAMLError;
$14d5b0f3829a6845$export$c1188aaa49090a5c = $14d5b0f3829a6845$var$YAMLParseError;
$14d5b0f3829a6845$export$856b463bac79f971 = $14d5b0f3829a6845$var$YAMLWarning;
$14d5b0f3829a6845$export$44eaaa72d914fe8c = $14d5b0f3829a6845$var$prettifyError;

});

parcelRegister("aHTfY", function(module, exports) {

$parcel$export(module.exports, "composeDoc", () => $7cb8c85d6278795e$export$5456c7d031a42a2a, (v) => $7cb8c85d6278795e$export$5456c7d031a42a2a = v);
var $7cb8c85d6278795e$export$5456c7d031a42a2a;
"use strict";

var $e3GNt = parcelRequire("e3GNt");

var $9rqmA = parcelRequire("9rqmA");

var $3YAog = parcelRequire("3YAog");

var $dCdee = parcelRequire("dCdee");
function $7cb8c85d6278795e$var$composeDoc(options, directives, { offset: offset, start: start, value: value, end: end }, onError) {
    const opts = Object.assign({
        _directives: directives
    }, options);
    const doc = new $e3GNt.Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = $dCdee.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset: offset,
        onError: onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value ? $9rqmA.composeNode(ctx, value, props, onError) : $9rqmA.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = $3YAog.resolveEnd(end, contentEnd, false, onError);
    if (re.comment) doc.comment = re.comment;
    doc.range = [
        offset,
        contentEnd,
        re.offset
    ];
    return doc;
}
$7cb8c85d6278795e$export$5456c7d031a42a2a = $7cb8c85d6278795e$var$composeDoc;

});
parcelRegister("9rqmA", function(module, exports) {

$parcel$export(module.exports, "composeEmptyNode", () => $6dfb15dbe7a7dd43$export$ca2a6312a2caa181, (v) => $6dfb15dbe7a7dd43$export$ca2a6312a2caa181 = v);
$parcel$export(module.exports, "composeNode", () => $6dfb15dbe7a7dd43$export$9247f8d3b1b759e0, (v) => $6dfb15dbe7a7dd43$export$9247f8d3b1b759e0 = v);
var $6dfb15dbe7a7dd43$export$ca2a6312a2caa181;
var $6dfb15dbe7a7dd43$export$9247f8d3b1b759e0;
"use strict";

var $2QkGt = parcelRequire("2QkGt");

var $kHV7x = parcelRequire("kHV7x");

var $d7YBr = parcelRequire("d7YBr");

var $3YAog = parcelRequire("3YAog");

var $fiR4I = parcelRequire("fiR4I");
const $6dfb15dbe7a7dd43$var$CN = {
    composeNode: $6dfb15dbe7a7dd43$var$composeNode,
    composeEmptyNode: $6dfb15dbe7a7dd43$var$composeEmptyNode
};
function $6dfb15dbe7a7dd43$var$composeNode(ctx, token, props, onError) {
    const { spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag } = props;
    let node;
    let isSrcToken = true;
    switch(token.type){
        case "alias":
            node = $6dfb15dbe7a7dd43$var$composeAlias(ctx, token, onError);
            if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
            break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
            node = $d7YBr.composeScalar(ctx, token, tag, onError);
            if (anchor) node.anchor = anchor.source.substring(1);
            break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
            node = $kHV7x.composeCollection($6dfb15dbe7a7dd43$var$CN, ctx, token, tag, onError);
            if (anchor) node.anchor = anchor.source.substring(1);
            break;
        default:
            {
                const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
                onError(token, "UNEXPECTED_TOKEN", message);
                node = $6dfb15dbe7a7dd43$var$composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
                isSrcToken = false;
            }
    }
    if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (spaceBefore) node.spaceBefore = true;
    if (comment) {
        if (token.type === "scalar" && token.source === "") node.comment = comment;
        else node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
    return node;
}
function $6dfb15dbe7a7dd43$var$composeEmptyNode(ctx, offset, before, pos, { spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag, end: end }, onError) {
    const token = {
        type: "scalar",
        offset: $fiR4I.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
    };
    const node = $d7YBr.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore) node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function $6dfb15dbe7a7dd43$var$composeAlias({ options: options }, { offset: offset, source: source, end: end }, onError) {
    const alias = new $2QkGt.Alias(source.substring(1));
    if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = $3YAog.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [
        offset,
        valueEnd,
        re.offset
    ];
    if (re.comment) alias.comment = re.comment;
    return alias;
}
$6dfb15dbe7a7dd43$export$ca2a6312a2caa181 = $6dfb15dbe7a7dd43$var$composeEmptyNode;
$6dfb15dbe7a7dd43$export$9247f8d3b1b759e0 = $6dfb15dbe7a7dd43$var$composeNode;

});
parcelRegister("kHV7x", function(module, exports) {

$parcel$export(module.exports, "composeCollection", () => $f13421bb88f2cc7c$export$670d412b724aec43, (v) => $f13421bb88f2cc7c$export$670d412b724aec43 = v);
var $f13421bb88f2cc7c$export$670d412b724aec43;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");

var $k3oDt = parcelRequire("k3oDt");

var $dsY7M = parcelRequire("dsY7M");

var $gkNJy = parcelRequire("gkNJy");

var $aX5bb = parcelRequire("aX5bb");

var $bqxj2 = parcelRequire("bqxj2");
function $f13421bb88f2cc7c$var$resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? $gkNJy.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? $aX5bb.resolveBlockSeq(CN, ctx, token, onError, tag) : $bqxj2.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName) coll.tag = tagName;
    return coll;
}
function $f13421bb88f2cc7c$var$composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken || !tagName || tagName === "!" || tagName === $k3oDt.YAMLMap.tagName && expType === "map" || tagName === $dsY7M.YAMLSeq.tagName && expType === "seq" || !expType) return $f13421bb88f2cc7c$var$resolveCollection(CN, ctx, token, onError, tagName);
    let tag = ctx.schema.tags.find((t)=>t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, {
                default: false
            }));
            tag = kt;
        } else {
            if (kt?.collection) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
            return $f13421bb88f2cc7c$var$resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = $f13421bb88f2cc7c$var$resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = $8XpWs.isNode(res) ? res : new $k84gT.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format) node.format = tag.format;
    return node;
}
$f13421bb88f2cc7c$export$670d412b724aec43 = $f13421bb88f2cc7c$var$composeCollection;

});
parcelRegister("gkNJy", function(module, exports) {

$parcel$export(module.exports, "resolveBlockMap", () => $be4517b255c5d4a0$export$9c415700b1dbff3b, (v) => $be4517b255c5d4a0$export$9c415700b1dbff3b = v);
var $be4517b255c5d4a0$export$9c415700b1dbff3b;
"use strict";

var $3difO = parcelRequire("3difO");

var $k3oDt = parcelRequire("k3oDt");

var $dCdee = parcelRequire("dCdee");

var $heWEy = parcelRequire("heWEy");

var $b4oGp = parcelRequire("b4oGp");

var $c51eG = parcelRequire("c51eG");
const $be4517b255c5d4a0$var$startColMsg = "All mapping items must start at the same column";
function $be4517b255c5d4a0$var$resolveBlockMap({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $k3oDt.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot) ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items){
        const { start: start, key: key, sep: sep, value: value } = collItem;
        // key properties
        const keyProps = $dCdee.resolveProps(start, {
            indicator: "explicit-key-ind",
            next: key ?? sep?.[0],
            offset: offset,
            onError: onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
                else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", $be4517b255c5d4a0$var$startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment) map.comment += "\n" + keyProps.comment;
                    else map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || $heWEy.containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        } else if (keyProps.found?.indent !== bm.indent) onError(offset, "BAD_INDENT", $be4517b255c5d4a0$var$startColMsg);
        // key value
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat) $b4oGp.flowIndentCheck(bm.indent, key, onError);
        if ($c51eG.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        // value properties
        const valueProps = $dCdee.resolveProps(sep ?? [], {
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError: onError,
            startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
                if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
            }
            // value value
            const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat) $b4oGp.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new $3difO.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            map.items.push(pair);
        } else {
            // key with no value
            if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
            if (valueProps.comment) {
                if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
                else keyNode.comment = valueProps.comment;
            }
            const pair = new $3difO.Pair(keyNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [
        bm.offset,
        offset,
        commentEnd ?? offset
    ];
    return map;
}
$be4517b255c5d4a0$export$9c415700b1dbff3b = $be4517b255c5d4a0$var$resolveBlockMap;

});
parcelRegister("dCdee", function(module, exports) {

$parcel$export(module.exports, "resolveProps", () => $9e9915dcebd4fe02$export$3947d67c7569cd22, (v) => $9e9915dcebd4fe02$export$3947d67c7569cd22 = v);
var $9e9915dcebd4fe02$export$3947d67c7569cd22;
"use strict";
function $9e9915dcebd4fe02$var$resolveProps(tokens, { flow: flow, indicator: indicator, next: next, offset: offset, onError: onError, startOnNewline: startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens){
        if (reqSpace) {
            if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
            reqSpace = false;
        }
        switch(token.type){
            case "space":
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	") onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
                hasSpace = true;
                break;
            case "comment":
                {
                    if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    const cb = token.source.substring(1) || " ";
                    if (!comment) comment = cb;
                    else comment += commentSep + cb;
                    commentSep = "";
                    atNewline = false;
                    break;
                }
            case "newline":
                if (atNewline) {
                    if (comment) comment += token.source;
                    else spaceBefore = true;
                } else commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag) hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case "anchor":
                if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
                if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
                anchor = token;
                if (start === null) start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case "tag":
                if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
                tag = token;
                if (start === null) start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
                if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case "comma":
                if (flow) {
                    if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    return {
        comma: comma,
        found: found,
        spaceBefore: spaceBefore,
        comment: comment,
        hasNewline: hasNewline,
        hasNewlineAfterProp: hasNewlineAfterProp,
        anchor: anchor,
        tag: tag,
        end: end,
        start: start ?? end
    };
}
$9e9915dcebd4fe02$export$3947d67c7569cd22 = $9e9915dcebd4fe02$var$resolveProps;

});

parcelRegister("heWEy", function(module, exports) {

$parcel$export(module.exports, "containsNewline", () => $c8d13dc2f69c9d30$export$72c4c19842d44e03, (v) => $c8d13dc2f69c9d30$export$72c4c19842d44e03 = v);
var $c8d13dc2f69c9d30$export$72c4c19842d44e03;
"use strict";
function $c8d13dc2f69c9d30$var$containsNewline(key) {
    if (!key) return null;
    switch(key.type){
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
            if (key.source.includes("\n")) return true;
            if (key.end) {
                for (const st of key.end)if (st.type === "newline") return true;
            }
            return false;
        case "flow-collection":
            for (const it of key.items){
                for (const st of it.start)if (st.type === "newline") return true;
                if (it.sep) {
                    for (const st of it.sep)if (st.type === "newline") return true;
                }
                if ($c8d13dc2f69c9d30$var$containsNewline(it.key) || $c8d13dc2f69c9d30$var$containsNewline(it.value)) return true;
            }
            return false;
        default:
            return true;
    }
}
$c8d13dc2f69c9d30$export$72c4c19842d44e03 = $c8d13dc2f69c9d30$var$containsNewline;

});

parcelRegister("b4oGp", function(module, exports) {

$parcel$export(module.exports, "flowIndentCheck", () => $80f336f0e60a3d40$export$6195a21984b7a892, (v) => $80f336f0e60a3d40$export$6195a21984b7a892 = v);
var $80f336f0e60a3d40$export$6195a21984b7a892;
"use strict";

var $heWEy = parcelRequire("heWEy");
function $80f336f0e60a3d40$var$flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && $heWEy.containsNewline(fc)) {
            const msg = "Flow end indicator should be more indented than parent";
            onError(end, "BAD_INDENT", msg, true);
        }
    }
}
$80f336f0e60a3d40$export$6195a21984b7a892 = $80f336f0e60a3d40$var$flowIndentCheck;

});

parcelRegister("c51eG", function(module, exports) {

$parcel$export(module.exports, "mapIncludes", () => $8cb6e90d6ec1c511$export$ab8ef54c273a4fc3, (v) => $8cb6e90d6ec1c511$export$ab8ef54c273a4fc3 = v);
var $8cb6e90d6ec1c511$export$ab8ef54c273a4fc3;
"use strict";

var $8XpWs = parcelRequire("8XpWs");
function $8cb6e90d6ec1c511$var$mapIncludes(ctx, items, search) {
    const { uniqueKeys: uniqueKeys } = ctx.options;
    if (uniqueKeys === false) return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b)=>a === b || $8XpWs.isScalar(a) && $8XpWs.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
    return items.some((pair)=>isEqual(pair.key, search));
}
$8cb6e90d6ec1c511$export$ab8ef54c273a4fc3 = $8cb6e90d6ec1c511$var$mapIncludes;

});


parcelRegister("aX5bb", function(module, exports) {

$parcel$export(module.exports, "resolveBlockSeq", () => $7f936e9c643fb78b$export$2db6dd42184ff7ac, (v) => $7f936e9c643fb78b$export$2db6dd42184ff7ac = v);
var $7f936e9c643fb78b$export$2db6dd42184ff7ac;
"use strict";

var $dsY7M = parcelRequire("dsY7M");

var $dCdee = parcelRequire("dCdee");

var $b4oGp = parcelRequire("b4oGp");
function $7f936e9c643fb78b$var$resolveBlockSeq({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $dsY7M.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot) ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start: start, value: value } of bs.items){
        const props = $dCdee.resolveProps(start, {
            indicator: "seq-item-ind",
            next: value,
            offset: offset,
            onError: onError,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
                else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
            } else {
                commentEnd = props.end;
                if (props.comment) seq.comment = props.comment;
                continue;
            }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat) $b4oGp.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [
        bs.offset,
        offset,
        commentEnd ?? offset
    ];
    return seq;
}
$7f936e9c643fb78b$export$2db6dd42184ff7ac = $7f936e9c643fb78b$var$resolveBlockSeq;

});

parcelRegister("bqxj2", function(module, exports) {

$parcel$export(module.exports, "resolveFlowCollection", () => $851bf54a1e97ab40$export$fdd70fe10aa6d63e, (v) => $851bf54a1e97ab40$export$fdd70fe10aa6d63e = v);
var $851bf54a1e97ab40$export$fdd70fe10aa6d63e;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $3difO = parcelRequire("3difO");

var $k3oDt = parcelRequire("k3oDt");

var $dsY7M = parcelRequire("dsY7M");

var $3YAog = parcelRequire("3YAog");

var $dCdee = parcelRequire("dCdee");

var $heWEy = parcelRequire("heWEy");

var $c51eG = parcelRequire("c51eG");
const $851bf54a1e97ab40$var$blockMsg = "Block collections are not allowed within flow collections";
const $851bf54a1e97ab40$var$isBlock = (token)=>token && (token.type === "block-map" || token.type === "block-seq");
function $851bf54a1e97ab40$var$resolveFlowCollection({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? $k3oDt.YAMLMap : $dsY7M.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot) ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for(let i = 0; i < fc.items.length; ++i){
        const collItem = fc.items[i];
        const { start: start, key: key, sep: sep, value: value } = collItem;
        const props = $dCdee.resolveProps(start, {
            flow: fcName,
            indicator: "explicit-key-ind",
            next: key ?? sep?.[0],
            offset: offset,
            onError: onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment) coll.comment += "\n" + props.comment;
                    else coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && $heWEy.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
        }
        if (i === 0) {
            if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
            if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = "";
                loop: for (const st of start)switch(st.type){
                    case "comma":
                    case "space":
                        break;
                    case "comment":
                        prevItemComment = st.source.substring(1);
                        break loop;
                    default:
                        break loop;
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if ($8XpWs.isPair(prev)) prev = prev.value ?? prev.key;
                    if (prev.comment) prev.comment += "\n" + prevItemComment;
                    else prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if ($851bf54a1e97ab40$var$isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", $851bf54a1e97ab40$var$blockMsg);
        } else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if ($851bf54a1e97ab40$var$isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", $851bf54a1e97ab40$var$blockMsg);
            // value properties
            const valueProps = $dCdee.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: "map-value-ind",
                next: value,
                offset: keyNode.range[2],
                onError: onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep) for (const st of sep){
                        if (st === valueProps.found) break;
                        if (st.type === "newline") {
                            onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                            break;
                        }
                    }
                    if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                }
            } else if (value) {
                if ("source" in value && value.source && value.source[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
                else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
            if (valueNode) {
                if ($851bf54a1e97ab40$var$isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", $851bf54a1e97ab40$var$blockMsg);
            } else if (valueProps.comment) {
                if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
                else keyNode.comment = valueProps.comment;
            }
            const pair = new $3difO.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if ($c51eG.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
                map.items.push(pair);
            } else {
                const map = new $k3oDt.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1) ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = $3YAog.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment) coll.comment += "\n" + end.comment;
            else coll.comment = end.comment;
        }
        coll.range = [
            fc.offset,
            cePos,
            end.offset
        ];
    } else coll.range = [
        fc.offset,
        cePos,
        cePos
    ];
    return coll;
}
$851bf54a1e97ab40$export$fdd70fe10aa6d63e = $851bf54a1e97ab40$var$resolveFlowCollection;

});
parcelRegister("3YAog", function(module, exports) {

$parcel$export(module.exports, "resolveEnd", () => $2e533411da4bce84$export$9be3172c55e482a, (v) => $2e533411da4bce84$export$9be3172c55e482a = v);
var $2e533411da4bce84$export$9be3172c55e482a;
"use strict";
function $2e533411da4bce84$var$resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end){
            const { source: source, type: type } = token;
            switch(type){
                case "space":
                    hasSpace = true;
                    break;
                case "comment":
                    {
                        if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                        const cb = source.substring(1) || " ";
                        if (!comment) comment = cb;
                        else comment += sep + cb;
                        sep = "";
                        break;
                    }
                case "newline":
                    if (comment) sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return {
        comment: comment,
        offset: offset
    };
}
$2e533411da4bce84$export$9be3172c55e482a = $2e533411da4bce84$var$resolveEnd;

});



parcelRegister("d7YBr", function(module, exports) {

$parcel$export(module.exports, "composeScalar", () => $98eaf04987b7160b$export$1fb1e480165041ec, (v) => $98eaf04987b7160b$export$1fb1e480165041ec = v);
var $98eaf04987b7160b$export$1fb1e480165041ec;
"use strict";

var $8XpWs = parcelRequire("8XpWs");

var $k84gT = parcelRequire("k84gT");

var $fYYCl = parcelRequire("fYYCl");

var $8e8xv = parcelRequire("8e8xv");
function $98eaf04987b7160b$var$composeScalar(ctx, token, tagToken, onError) {
    const { value: value, type: type, comment: comment, range: range } = token.type === "block-scalar" ? $fYYCl.resolveBlockScalar(token, ctx.options.strict, onError) : $8e8xv.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    const tag = tagToken && tagName ? $98eaf04987b7160b$var$findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? $98eaf04987b7160b$var$findScalarTagByTest(ctx, value, token, onError) : ctx.schema[$8XpWs.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, (msg)=>onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = $8XpWs.isScalar(res) ? res : new $k84gT.Scalar(res);
    } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new $k84gT.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type) scalar.type = type;
    if (tagName) scalar.tag = tagName;
    if (tag.format) scalar.format = tag.format;
    if (comment) scalar.comment = comment;
    return scalar;
}
function $98eaf04987b7160b$var$findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!") return schema[$8XpWs.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags)if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test) matchWithTest.push(tag);
        else return tag;
    }
    for (const tag of matchWithTest)if (tag.test?.test(value)) return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, {
            default: false,
            test: undefined
        }));
        return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[$8XpWs.SCALAR];
}
function $98eaf04987b7160b$var$findScalarTagByTest({ directives: directives, schema: schema }, value, token, onError) {
    const tag = schema.tags.find((tag)=>tag.default && tag.test?.test(value)) || schema[$8XpWs.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find((tag)=>tag.default && tag.test?.test(value)) ?? schema[$8XpWs.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
    }
    return tag;
}
$98eaf04987b7160b$export$1fb1e480165041ec = $98eaf04987b7160b$var$composeScalar;

});
parcelRegister("fYYCl", function(module, exports) {

$parcel$export(module.exports, "resolveBlockScalar", () => $ba2b7afb2ce0c122$export$14aaa50a76ee848f, (v) => $ba2b7afb2ce0c122$export$14aaa50a76ee848f = v);
var $ba2b7afb2ce0c122$export$14aaa50a76ee848f;
"use strict";

var $k84gT = parcelRequire("k84gT");
function $ba2b7afb2ce0c122$var$resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = $ba2b7afb2ce0c122$var$parseBlockScalarHeader(scalar, strict, onError);
    if (!header) return {
        value: "",
        type: null,
        comment: "",
        range: [
            start,
            start,
            start
        ]
    };
    const type = header.mode === ">" ? $k84gT.Scalar.BLOCK_FOLDED : $k84gT.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? $ba2b7afb2ce0c122$var$splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for(let i = lines.length - 1; i >= 0; --i){
        const content = lines[i][1];
        if (content === "" || content === "\r") chompStart = i;
        else break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end = start + header.length;
        if (scalar.source) end += scalar.source.length;
        return {
            value: value,
            type: type,
            comment: header.comment,
            range: [
                start,
                end,
                end
            ]
        };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for(let i = 0; i < chompStart; ++i){
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
            if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
        } else {
            if (indent.length < trimIndent) {
                const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                onError(offset + indent.length, "MISSING_CHAR", message);
            }
            if (header.indent === 0) trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for(let i = lines.length - 1; i >= chompStart; --i)if (lines[i][0].length > trimIndent) chompStart = i + 1;
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for(let i = 0; i < contentStart; ++i)value += lines[i][0].slice(trimIndent) + "\n";
    for(let i = contentStart; i < chompStart; ++i){
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf) content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */ if (content && indent.length < trimIndent) {
            const src = header.indent ? "explicit indentation indicator" : "first line";
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
            indent = "";
        }
        if (type === $k84gT.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
            // more-indented content within a folded block
            if (sep === " ") sep = "\n";
            else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
            value += sep + indent.slice(trimIndent) + content;
            sep = "\n";
            prevMoreIndented = true;
        } else if (content === "") {
            // empty line
            if (sep === "\n") value += "\n";
            else sep = "\n";
        } else {
            value += sep + content;
            sep = " ";
            prevMoreIndented = false;
        }
    }
    switch(header.chomp){
        case "-":
            break;
        case "+":
            for(let i = chompStart; i < lines.length; ++i)value += "\n" + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== "\n") value += "\n";
            break;
        default:
            value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return {
        value: value,
        type: type,
        comment: header.comment,
        range: [
            start,
            end,
            end
        ]
    };
}
function $ba2b7afb2ce0c122$var$parseBlockScalarHeader({ offset: offset, props: props }, strict, onError) {
    /* istanbul ignore if should not happen */ if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
    }
    const { source: source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for(let i = 1; i < source.length; ++i){
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n) indent = n;
            else if (error === -1) error = offset + i;
        }
    }
    if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for(let i = 1; i < props.length; ++i){
        const token = props[i];
        switch(token.type){
            case "space":
                hasSpace = true;
            // fallthrough
            case "newline":
                length += token.source.length;
                break;
            case "comment":
                if (strict && !hasSpace) {
                    const message = "Comments must be separated from other tokens by white space characters";
                    onError(token, "MISSING_CHAR", message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case "error":
                onError(token, "UNEXPECTED_TOKEN", token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */ default:
                {
                    const message = `Unexpected token in block scalar header: ${token.type}`;
                    onError(token, "UNEXPECTED_TOKEN", message);
                    const ts = token.source;
                    if (ts && typeof ts === "string") length += ts.length;
                }
        }
    }
    return {
        mode: mode,
        indent: indent,
        chomp: chomp,
        comment: comment,
        length: length
    };
}
/** @returns Array of lines split up as `[indent, content]` */ function $ba2b7afb2ce0c122$var$splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [
        m[1],
        first.slice(m[1].length)
    ] : [
        "",
        first
    ];
    const lines = [
        line0
    ];
    for(let i = 1; i < split.length; i += 2)lines.push([
        split[i],
        split[i + 1]
    ]);
    return lines;
}
$ba2b7afb2ce0c122$export$14aaa50a76ee848f = $ba2b7afb2ce0c122$var$resolveBlockScalar;

});

parcelRegister("8e8xv", function(module, exports) {

$parcel$export(module.exports, "resolveFlowScalar", () => $5fd6414ff4a2ef6c$export$2f1c3b16290da8c8, (v) => $5fd6414ff4a2ef6c$export$2f1c3b16290da8c8 = v);
var $5fd6414ff4a2ef6c$export$2f1c3b16290da8c8;
"use strict";

var $k84gT = parcelRequire("k84gT");

var $3YAog = parcelRequire("3YAog");
function $5fd6414ff4a2ef6c$var$resolveFlowScalar(scalar, strict, onError) {
    const { offset: offset, type: type, source: source, end: end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg)=>onError(offset + rel, code, msg);
    switch(type){
        case "scalar":
            _type = $k84gT.Scalar.PLAIN;
            value = $5fd6414ff4a2ef6c$var$plainValue(source, _onError);
            break;
        case "single-quoted-scalar":
            _type = $k84gT.Scalar.QUOTE_SINGLE;
            value = $5fd6414ff4a2ef6c$var$singleQuotedValue(source, _onError);
            break;
        case "double-quoted-scalar":
            _type = $k84gT.Scalar.QUOTE_DOUBLE;
            value = $5fd6414ff4a2ef6c$var$doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */ default:
            onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
            return {
                value: "",
                type: null,
                comment: "",
                range: [
                    offset,
                    offset + source.length,
                    offset + source.length
                ]
            };
    }
    const valueEnd = offset + source.length;
    const re = $3YAog.resolveEnd(end, valueEnd, strict, onError);
    return {
        value: value,
        type: _type,
        comment: re.comment,
        range: [
            offset,
            valueEnd,
            re.offset
        ]
    };
}
function $5fd6414ff4a2ef6c$var$plainValue(source, onError) {
    let badChar = "";
    switch(source[0]){
        /* istanbul ignore next should not happen */ case "	":
            badChar = "a tab character";
            break;
        case ",":
            badChar = "flow indicator character ,";
            break;
        case "%":
            badChar = "directive indicator character %";
            break;
        case "|":
        case ">":
            badChar = `block scalar indicator ${source[0]}`;
            break;
        case "@":
        case "`":
            badChar = `reserved character ${source[0]}`;
            break;
    }
    if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return $5fd6414ff4a2ef6c$var$foldLines(source);
}
function $5fd6414ff4a2ef6c$var$singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return $5fd6414ff4a2ef6c$var$foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function $5fd6414ff4a2ef6c$var$foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */ let first, line;
    try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match) return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while(match = line.exec(source)){
        if (match[1] === "") {
            if (sep === "\n") res += sep;
            else sep = "\n";
        } else {
            res += sep + match[1];
            sep = " ";
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
}
function $5fd6414ff4a2ef6c$var$doubleQuotedValue(source, onError) {
    let res = "";
    for(let i = 1; i < source.length - 1; ++i){
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n") continue;
        if (ch === "\n") {
            const { fold: fold, offset: offset } = $5fd6414ff4a2ef6c$var$foldNewline(source, i);
            res += fold;
            i = offset;
        } else if (ch === "\\") {
            let next = source[++i];
            const cc = $5fd6414ff4a2ef6c$var$escapeCodes[next];
            if (cc) res += cc;
            else if (next === "\n") {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while(next === " " || next === "	")next = source[++i + 1];
            } else if (next === "\r" && source[i + 1] === "\n") {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while(next === " " || next === "	")next = source[++i + 1];
            } else if (next === "x" || next === "u" || next === "U") {
                const length = {
                    x: 2,
                    u: 4,
                    U: 8
                }[next];
                res += $5fd6414ff4a2ef6c$var$parseCharCode(source, i + 1, length, onError);
                i += length;
            } else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
                res += raw;
            }
        } else if (ch === " " || ch === "	") {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while(next === " " || next === "	")next = source[++i + 1];
            if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n")) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else res += ch;
    }
    if (source[source.length - 1] !== '"' || source.length === 1) onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */ function $5fd6414ff4a2ef6c$var$foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while(ch === " " || ch === "	" || ch === "\n" || ch === "\r"){
        if (ch === "\r" && source[offset + 2] !== "\n") break;
        if (ch === "\n") fold += "\n";
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold) fold = " ";
    return {
        fold: fold,
        offset: offset
    };
}
const $5fd6414ff4a2ef6c$var$escapeCodes = {
    "0": "\0",
    a: "\x07",
    b: "\b",
    e: "\x1b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    v: "\v",
    N: "\x85",
    _: "\xa0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "	": "	"
};
function $5fd6414ff4a2ef6c$var$parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}
$5fd6414ff4a2ef6c$export$2f1c3b16290da8c8 = $5fd6414ff4a2ef6c$var$resolveFlowScalar;

});


parcelRegister("fiR4I", function(module, exports) {

$parcel$export(module.exports, "emptyScalarPosition", () => $b241b5106c8f8738$export$b4be549696a70562, (v) => $b241b5106c8f8738$export$b4be549696a70562 = v);
var $b241b5106c8f8738$export$b4be549696a70562;
"use strict";
function $b241b5106c8f8738$var$emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null) pos = before.length;
        for(let i = pos - 1; i >= 0; --i){
            let st = before[i];
            switch(st.type){
                case "space":
                case "comment":
                case "newline":
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while(st?.type === "space"){
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}
$b241b5106c8f8738$export$b4be549696a70562 = $b241b5106c8f8738$var$emptyScalarPosition;

});




parcelRegister("dlJmx", function(module, exports) {

$parcel$export(module.exports, "createScalarToken", () => $9b806c968ea4f00a$export$bc6e7c97bb928c0c, (v) => $9b806c968ea4f00a$export$bc6e7c97bb928c0c = v);
$parcel$export(module.exports, "resolveAsScalar", () => $9b806c968ea4f00a$export$2606595716b8fd6d, (v) => $9b806c968ea4f00a$export$2606595716b8fd6d = v);
$parcel$export(module.exports, "setScalarValue", () => $9b806c968ea4f00a$export$ca02adc222d12536, (v) => $9b806c968ea4f00a$export$ca02adc222d12536 = v);
$parcel$export(module.exports, "stringify", () => $9b806c968ea4f00a$export$fac44ee5b035f737, (v) => $9b806c968ea4f00a$export$fac44ee5b035f737 = v);
$parcel$export(module.exports, "visit", () => $9b806c968ea4f00a$export$bf638b60ea8b89b7, (v) => $9b806c968ea4f00a$export$bf638b60ea8b89b7 = v);
$parcel$export(module.exports, "BOM", () => $9b806c968ea4f00a$export$159b0f4ed2e9d663, (v) => $9b806c968ea4f00a$export$159b0f4ed2e9d663 = v);
$parcel$export(module.exports, "DOCUMENT", () => $9b806c968ea4f00a$export$ef011b4e114b1fba, (v) => $9b806c968ea4f00a$export$ef011b4e114b1fba = v);
$parcel$export(module.exports, "FLOW_END", () => $9b806c968ea4f00a$export$f3c6ac4b8e8fc405, (v) => $9b806c968ea4f00a$export$f3c6ac4b8e8fc405 = v);
$parcel$export(module.exports, "SCALAR", () => $9b806c968ea4f00a$export$8dde1211cb7c9d16, (v) => $9b806c968ea4f00a$export$8dde1211cb7c9d16 = v);
$parcel$export(module.exports, "isCollection", () => $9b806c968ea4f00a$export$cea7aa84e978eba5, (v) => $9b806c968ea4f00a$export$cea7aa84e978eba5 = v);
$parcel$export(module.exports, "isScalar", () => $9b806c968ea4f00a$export$8f3495e22775e76c, (v) => $9b806c968ea4f00a$export$8f3495e22775e76c = v);
$parcel$export(module.exports, "prettyToken", () => $9b806c968ea4f00a$export$a7c32ec3dbc53b0d, (v) => $9b806c968ea4f00a$export$a7c32ec3dbc53b0d = v);
$parcel$export(module.exports, "tokenType", () => $9b806c968ea4f00a$export$290cf9fbadf470bd, (v) => $9b806c968ea4f00a$export$290cf9fbadf470bd = v);
var $9b806c968ea4f00a$export$bc6e7c97bb928c0c;
var $9b806c968ea4f00a$export$2606595716b8fd6d;
var $9b806c968ea4f00a$export$ca02adc222d12536;
var $9b806c968ea4f00a$export$fac44ee5b035f737;
var $9b806c968ea4f00a$export$bf638b60ea8b89b7;
var $9b806c968ea4f00a$export$159b0f4ed2e9d663;
var $9b806c968ea4f00a$export$ef011b4e114b1fba;
var $9b806c968ea4f00a$export$f3c6ac4b8e8fc405;
var $9b806c968ea4f00a$export$8dde1211cb7c9d16;
var $9b806c968ea4f00a$export$cea7aa84e978eba5;
var $9b806c968ea4f00a$export$8f3495e22775e76c;
var $9b806c968ea4f00a$export$a7c32ec3dbc53b0d;
var $9b806c968ea4f00a$export$290cf9fbadf470bd;
"use strict";

var $kzPTa = parcelRequire("kzPTa");

var $kTum0 = parcelRequire("kTum0");

var $i9Sbe = parcelRequire("i9Sbe");
/** The byte order mark */ const $9b806c968ea4f00a$var$BOM = "\uFEFF";
/** Start of doc-mode */ const $9b806c968ea4f00a$var$DOCUMENT = "\x02"; // C0: Start of Text
/** Unexpected end of flow-mode */ const $9b806c968ea4f00a$var$FLOW_END = "\x18"; // C0: Cancel
/** Next token is a scalar value */ const $9b806c968ea4f00a$var$SCALAR = "\x1f"; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */ const $9b806c968ea4f00a$var$isCollection = (token)=>!!token && "items" in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */ const $9b806c968ea4f00a$var$isScalar = (token)=>!!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
/* istanbul ignore next */ /** Get a printable representation of a lexer token */ function $9b806c968ea4f00a$var$prettyToken(token) {
    switch(token){
        case $9b806c968ea4f00a$var$BOM:
            return "<BOM>";
        case $9b806c968ea4f00a$var$DOCUMENT:
            return "<DOC>";
        case $9b806c968ea4f00a$var$FLOW_END:
            return "<FLOW_END>";
        case $9b806c968ea4f00a$var$SCALAR:
            return "<SCALAR>";
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */ function $9b806c968ea4f00a$var$tokenType(source) {
    switch(source){
        case $9b806c968ea4f00a$var$BOM:
            return "byte-order-mark";
        case $9b806c968ea4f00a$var$DOCUMENT:
            return "doc-mode";
        case $9b806c968ea4f00a$var$FLOW_END:
            return "flow-error-end";
        case $9b806c968ea4f00a$var$SCALAR:
            return "scalar";
        case "---":
            return "doc-start";
        case "...":
            return "doc-end";
        case "":
        case "\n":
        case "\r\n":
            return "newline";
        case "-":
            return "seq-item-ind";
        case "?":
            return "explicit-key-ind";
        case ":":
            return "map-value-ind";
        case "{":
            return "flow-map-start";
        case "}":
            return "flow-map-end";
        case "[":
            return "flow-seq-start";
        case "]":
            return "flow-seq-end";
        case ",":
            return "comma";
    }
    switch(source[0]){
        case " ":
        case "	":
            return "space";
        case "#":
            return "comment";
        case "%":
            return "directive-line";
        case "*":
            return "alias";
        case "&":
            return "anchor";
        case "!":
            return "tag";
        case "'":
            return "single-quoted-scalar";
        case '"':
            return "double-quoted-scalar";
        case "|":
        case ">":
            return "block-scalar-header";
    }
    return null;
}
$9b806c968ea4f00a$export$bc6e7c97bb928c0c = $kzPTa.createScalarToken;
$9b806c968ea4f00a$export$2606595716b8fd6d = $kzPTa.resolveAsScalar;
$9b806c968ea4f00a$export$ca02adc222d12536 = $kzPTa.setScalarValue;
$9b806c968ea4f00a$export$fac44ee5b035f737 = $kTum0.stringify;
$9b806c968ea4f00a$export$bf638b60ea8b89b7 = $i9Sbe.visit;
$9b806c968ea4f00a$export$159b0f4ed2e9d663 = $9b806c968ea4f00a$var$BOM;
$9b806c968ea4f00a$export$ef011b4e114b1fba = $9b806c968ea4f00a$var$DOCUMENT;
$9b806c968ea4f00a$export$f3c6ac4b8e8fc405 = $9b806c968ea4f00a$var$FLOW_END;
$9b806c968ea4f00a$export$8dde1211cb7c9d16 = $9b806c968ea4f00a$var$SCALAR;
$9b806c968ea4f00a$export$cea7aa84e978eba5 = $9b806c968ea4f00a$var$isCollection;
$9b806c968ea4f00a$export$8f3495e22775e76c = $9b806c968ea4f00a$var$isScalar;
$9b806c968ea4f00a$export$a7c32ec3dbc53b0d = $9b806c968ea4f00a$var$prettyToken;
$9b806c968ea4f00a$export$290cf9fbadf470bd = $9b806c968ea4f00a$var$tokenType;

});
parcelRegister("kzPTa", function(module, exports) {

$parcel$export(module.exports, "createScalarToken", () => $efaf538f1e4367bd$export$bc6e7c97bb928c0c, (v) => $efaf538f1e4367bd$export$bc6e7c97bb928c0c = v);
$parcel$export(module.exports, "resolveAsScalar", () => $efaf538f1e4367bd$export$2606595716b8fd6d, (v) => $efaf538f1e4367bd$export$2606595716b8fd6d = v);
$parcel$export(module.exports, "setScalarValue", () => $efaf538f1e4367bd$export$ca02adc222d12536, (v) => $efaf538f1e4367bd$export$ca02adc222d12536 = v);
var $efaf538f1e4367bd$export$bc6e7c97bb928c0c;
var $efaf538f1e4367bd$export$2606595716b8fd6d;
var $efaf538f1e4367bd$export$ca02adc222d12536;
"use strict";

var $fYYCl = parcelRequire("fYYCl");

var $8e8xv = parcelRequire("8e8xv");

var $1MTYj = parcelRequire("1MTYj");

var $bkIH8 = parcelRequire("bkIH8");
function $efaf538f1e4367bd$var$resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message)=>{
            const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError) onError(offset, code, message);
            else throw new $1MTYj.YAMLParseError([
                offset,
                offset + 1
            ], code, message);
        };
        switch(token.type){
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return $8e8xv.resolveFlowScalar(token, strict, _onError);
            case "block-scalar":
                return $fYYCl.resolveBlockScalar(token, strict, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */ function $efaf538f1e4367bd$var$createScalarToken(value, context) {
    const { implicitKey: implicitKey = false, indent: indent, inFlow: inFlow = false, offset: offset = -1, type: type = "PLAIN" } = context;
    const source = $bkIH8.stringifyString({
        type: type,
        value: value
    }, {
        implicitKey: implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow: inFlow,
        options: {
            blockQuote: true,
            lineWidth: -1
        }
    });
    const end = context.end ?? [
        {
            type: "newline",
            offset: -1,
            indent: indent,
            source: "\n"
        }
    ];
    switch(source[0]){
        case "|":
        case ">":
            {
                const he = source.indexOf("\n");
                const head = source.substring(0, he);
                const body = source.substring(he + 1) + "\n";
                const props = [
                    {
                        type: "block-scalar-header",
                        offset: offset,
                        indent: indent,
                        source: head
                    }
                ];
                if (!$efaf538f1e4367bd$var$addEndtoBlockProps(props, end)) props.push({
                    type: "newline",
                    offset: -1,
                    indent: indent,
                    source: "\n"
                });
                return {
                    type: "block-scalar",
                    offset: offset,
                    indent: indent,
                    props: props,
                    source: body
                };
            }
        case '"':
            return {
                type: "double-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
        case "'":
            return {
                type: "single-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
        default:
            return {
                type: "scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */ function $efaf538f1e4367bd$var$setScalarValue(token, value, context = {}) {
    let { afterKey: afterKey = false, implicitKey: implicitKey = false, inFlow: inFlow = false, type: type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number") indent += 2;
    if (!type) switch(token.type){
        case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
        case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
        case "block-scalar":
            {
                const header = token.props[0];
                if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
                type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                break;
            }
        default:
            type = "PLAIN";
    }
    const source = $bkIH8.stringifyString({
        type: type,
        value: value
    }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow: inFlow,
        options: {
            blockQuote: true,
            lineWidth: -1
        }
    });
    switch(source[0]){
        case "|":
        case ">":
            $efaf538f1e4367bd$var$setBlockScalarValue(token, source);
            break;
        case '"':
            $efaf538f1e4367bd$var$setFlowScalarValue(token, source, "double-quoted-scalar");
            break;
        case "'":
            $efaf538f1e4367bd$var$setFlowScalarValue(token, source, "single-quoted-scalar");
            break;
        default:
            $efaf538f1e4367bd$var$setFlowScalarValue(token, source, "scalar");
    }
}
function $efaf538f1e4367bd$var$setBlockScalarValue(token, source) {
    const he = source.indexOf("\n");
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + "\n";
    if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
    } else {
        const { offset: offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
            {
                type: "block-scalar-header",
                offset: offset,
                indent: indent,
                source: head
            }
        ];
        if (!$efaf538f1e4367bd$var$addEndtoBlockProps(props, "end" in token ? token.end : undefined)) props.push({
            type: "newline",
            offset: -1,
            indent: indent,
            source: "\n"
        });
        for (const key of Object.keys(token))if (key !== "type" && key !== "offset") delete token[key];
        Object.assign(token, {
            type: "block-scalar",
            indent: indent,
            props: props,
            source: body
        });
    }
}
/** @returns `true` if last token is a newline */ function $efaf538f1e4367bd$var$addEndtoBlockProps(props, end) {
    if (end) for (const st of end)switch(st.type){
        case "space":
        case "comment":
            props.push(st);
            break;
        case "newline":
            props.push(st);
            return true;
    }
    return false;
}
function $efaf538f1e4367bd$var$setFlowScalarValue(token, source, type) {
    switch(token.type){
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
            token.type = type;
            token.source = source;
            break;
        case "block-scalar":
            {
                const end = token.props.slice(1);
                let oa = source.length;
                if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
                for (const tok of end)tok.offset += oa;
                delete token.props;
                Object.assign(token, {
                    type: type,
                    source: source,
                    end: end
                });
                break;
            }
        case "block-map":
        case "block-seq":
            {
                const offset = token.offset + source.length;
                const nl = {
                    type: "newline",
                    offset: offset,
                    indent: token.indent,
                    source: "\n"
                };
                delete token.items;
                Object.assign(token, {
                    type: type,
                    source: source,
                    end: [
                        nl
                    ]
                });
                break;
            }
        default:
            {
                const indent = "indent" in token ? token.indent : -1;
                const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st)=>st.type === "space" || st.type === "comment" || st.type === "newline") : [];
                for (const key of Object.keys(token))if (key !== "type" && key !== "offset") delete token[key];
                Object.assign(token, {
                    type: type,
                    indent: indent,
                    source: source,
                    end: end
                });
            }
    }
}
$efaf538f1e4367bd$export$bc6e7c97bb928c0c = $efaf538f1e4367bd$var$createScalarToken;
$efaf538f1e4367bd$export$2606595716b8fd6d = $efaf538f1e4367bd$var$resolveAsScalar;
$efaf538f1e4367bd$export$ca02adc222d12536 = $efaf538f1e4367bd$var$setScalarValue;

});

parcelRegister("kTum0", function(module, exports) {

$parcel$export(module.exports, "stringify", () => $f3607d59c52ee207$export$fac44ee5b035f737, (v) => $f3607d59c52ee207$export$fac44ee5b035f737 = v);
var $f3607d59c52ee207$export$fac44ee5b035f737;
"use strict";
/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */ const $f3607d59c52ee207$var$stringify = (cst)=>"type" in cst ? $f3607d59c52ee207$var$stringifyToken(cst) : $f3607d59c52ee207$var$stringifyItem(cst);
function $f3607d59c52ee207$var$stringifyToken(token) {
    switch(token.type){
        case "block-scalar":
            {
                let res = "";
                for (const tok of token.props)res += $f3607d59c52ee207$var$stringifyToken(tok);
                return res + token.source;
            }
        case "block-map":
        case "block-seq":
            {
                let res = "";
                for (const item of token.items)res += $f3607d59c52ee207$var$stringifyItem(item);
                return res;
            }
        case "flow-collection":
            {
                let res = token.start.source;
                for (const item of token.items)res += $f3607d59c52ee207$var$stringifyItem(item);
                for (const st of token.end)res += st.source;
                return res;
            }
        case "document":
            {
                let res = $f3607d59c52ee207$var$stringifyItem(token);
                if (token.end) for (const st of token.end)res += st.source;
                return res;
            }
        default:
            {
                let res = token.source;
                if ("end" in token && token.end) for (const st of token.end)res += st.source;
                return res;
            }
    }
}
function $f3607d59c52ee207$var$stringifyItem({ start: start, key: key, sep: sep, value: value }) {
    let res = "";
    for (const st of start)res += st.source;
    if (key) res += $f3607d59c52ee207$var$stringifyToken(key);
    if (sep) for (const st of sep)res += st.source;
    if (value) res += $f3607d59c52ee207$var$stringifyToken(value);
    return res;
}
$f3607d59c52ee207$export$fac44ee5b035f737 = $f3607d59c52ee207$var$stringify;

});

parcelRegister("i9Sbe", function(module, exports) {

$parcel$export(module.exports, "visit", () => $d383185022e5ff5a$export$bf638b60ea8b89b7, (v) => $d383185022e5ff5a$export$bf638b60ea8b89b7 = v);
var $d383185022e5ff5a$export$bf638b60ea8b89b7;
"use strict";
const $d383185022e5ff5a$var$BREAK = Symbol("break visit");
const $d383185022e5ff5a$var$SKIP = Symbol("skip children");
const $d383185022e5ff5a$var$REMOVE = Symbol("remove item");
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */ function $d383185022e5ff5a$var$visit(cst, visitor) {
    if ("type" in cst && cst.type === "document") cst = {
        start: cst.start,
        value: cst.value
    };
    $d383185022e5ff5a$var$_visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $d383185022e5ff5a$var$visit.BREAK = $d383185022e5ff5a$var$BREAK;
/** Do not visit the children of the current item */ $d383185022e5ff5a$var$visit.SKIP = $d383185022e5ff5a$var$SKIP;
/** Remove the current item */ $d383185022e5ff5a$var$visit.REMOVE = $d383185022e5ff5a$var$REMOVE;
/** Find the item at `path` from `cst` as the root */ $d383185022e5ff5a$var$visit.itemAtPath = (cst, path)=>{
    let item = cst;
    for (const [field, index] of path){
        const tok = item?.[field];
        if (tok && "items" in tok) item = tok.items[index];
        else return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */ $d383185022e5ff5a$var$visit.parentCollection = (cst, path)=>{
    const parent = $d383185022e5ff5a$var$visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll) return coll;
    throw new Error("Parent collection not found");
};
function $d383185022e5ff5a$var$_visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol") return ctrl;
    for (const field of [
        "key",
        "value"
    ]){
        const token = item[field];
        if (token && "items" in token) {
            for(let i = 0; i < token.items.length; ++i){
                const ci = $d383185022e5ff5a$var$_visit(Object.freeze(path.concat([
                    [
                        field,
                        i
                    ]
                ])), token.items[i], visitor);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $d383185022e5ff5a$var$BREAK) return $d383185022e5ff5a$var$BREAK;
                else if (ci === $d383185022e5ff5a$var$REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
$d383185022e5ff5a$export$bf638b60ea8b89b7 = $d383185022e5ff5a$var$visit;

});


parcelRegister("2pbWl", function(module, exports) {

$parcel$export(module.exports, "Lexer", () => $1c072d9f163bfb0b$export$6168dc8908a6c652, (v) => $1c072d9f163bfb0b$export$6168dc8908a6c652 = v);
var $1c072d9f163bfb0b$export$6168dc8908a6c652;
"use strict";

var $dlJmx = parcelRequire("dlJmx");
/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/ function $1c072d9f163bfb0b$var$isEmpty(ch) {
    switch(ch){
        case undefined:
        case " ":
        case "\n":
        case "\r":
        case "	":
            return true;
        default:
            return false;
    }
}
const $1c072d9f163bfb0b$var$hexDigits = "0123456789ABCDEFabcdef".split("");
const $1c072d9f163bfb0b$var$tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
const $1c072d9f163bfb0b$var$invalidFlowScalarChars = ",[]{}".split("");
const $1c072d9f163bfb0b$var$invalidAnchorChars = " ,[]{}\n\r	".split("");
const $1c072d9f163bfb0b$var$isNotAnchorChar = (ch)=>!ch || $1c072d9f163bfb0b$var$invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */ class $1c072d9f163bfb0b$var$Lexer {
    constructor(){
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */ this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */ this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */ this.blockScalarKeep = false;
        /** Current input */ this.buffer = "";
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */ this.flowKey = false;
        /** Count of surrounding flow collection levels. */ this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */ this.indentNext = 0;
        /** Indentation level of the current line. */ this.indentValue = 0;
        /** Position of the next \n character. */ this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */ this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */ this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */ *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while(next && (incomplete || this.hasChars(1)))next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while(ch === " " || ch === "	")ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n") return true;
        if (ch === "\r") return this.buffer[i + 1] === "\n";
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while(ch === " ")ch = this.buffer[++indent + offset];
            if (ch === "\r") {
                const next = this.buffer[indent + offset + 1];
                if (next === "\n" || !next && !this.atEnd) return offset + indent + 1;
            }
            return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === "---" || dt === "...") && $1c072d9f163bfb0b$var$isEmpty(this.buffer[offset + 3])) return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
            end = this.buffer.indexOf("\n", this.pos);
            this.lineEndPos = end;
        }
        if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r") end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch(next){
            case "stream":
                return yield* this.parseStream();
            case "line-start":
                return yield* this.parseLineStart();
            case "block-start":
                return yield* this.parseBlockStart();
            case "doc":
                return yield* this.parseDocument();
            case "flow":
                return yield* this.parseFlowCollection();
            case "quoted-scalar":
                return yield* this.parseQuotedScalar();
            case "block-scalar":
                return yield* this.parseBlockScalar();
            case "plain-scalar":
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null) return this.setNext("stream");
        if (line[0] === $dlJmx.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === "%") {
            let dirEnd = line.length;
            const cs = line.indexOf("#");
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === " " || ch === "	") dirEnd = cs - 1;
            }
            while(true){
                const ch = line[dirEnd - 1];
                if (ch === " " || ch === "	") dirEnd -= 1;
                else break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return "stream";
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return "stream";
        }
        yield $dlJmx.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd) return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
            if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
            const s = this.peek(3);
            if (s === "---" && $1c072d9f163bfb0b$var$isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return "doc";
            } else if (s === "..." && $1c072d9f163bfb0b$var$isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return "stream";
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !$1c072d9f163bfb0b$var$isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd) return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && $1c072d9f163bfb0b$var$isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return "doc";
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null) return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch(line[n]){
            case "#":
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case "{":
            case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return "flow";
            case "}":
            case "]":
                // this is an error
                yield* this.pushCount(1);
                return "doc";
            case "*":
                yield* this.pushUntil($1c072d9f163bfb0b$var$isNotAnchorChar);
                return "doc";
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case "|":
            case ">":
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            } else sp = 0;
            sp += yield* this.pushSpaces(true);
        }while (nl + sp > 0);
        const line = this.getLine();
        if (line === null) return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && $1c072d9f163bfb0b$var$isEmpty(line[3])) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield $dlJmx.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while(line[n] === ","){
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch(line[n]){
            case undefined:
                return "flow";
            case "#":
                yield* this.pushCount(line.length - n);
                return "flow";
            case "{":
            case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return "flow";
            case "}":
            case "]":
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? "flow" : "doc";
            case "*":
                yield* this.pushUntil($1c072d9f163bfb0b$var$isNotAnchorChar);
                return "flow";
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ":":
                {
                    const next = this.charAt(1);
                    if (this.flowKey || $1c072d9f163bfb0b$var$isEmpty(next) || next === ",") {
                        this.flowKey = false;
                        yield* this.pushCount(1);
                        yield* this.pushSpaces(true);
                        return "flow";
                    }
                }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") while(end !== -1 && this.buffer[end + 1] === "'")end = this.buffer.indexOf("'", end + 2);
        else // double-quote
        while(end !== -1){
            let n = 0;
            while(this.buffer[end - 1 - n] === "\\")n += 1;
            if (n % 2 === 0) break;
            end = this.buffer.indexOf('"', end + 1);
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
            while(nl !== -1){
                const cs = this.continueScalar(nl + 1);
                if (cs === -1) break;
                nl = qb.indexOf("\n", cs);
            }
            if (nl !== -1) // this is an error caused by an unexpected unindent
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
        if (end === -1) {
            if (!this.atEnd) return this.setNext("quoted-scalar");
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while(true){
            const ch = this.buffer[++i];
            if (ch === "+") this.blockScalarKeep = true;
            else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== "-") break;
        }
        return yield* this.pushUntil((ch)=>$1c072d9f163bfb0b$var$isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for(let i = this.pos; ch = this.buffer[i]; ++i)switch(ch){
            case " ":
                indent += 1;
                break;
            case "\n":
                nl = i;
                indent = 0;
                break;
            case "\r":
                {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd) return this.setNext("block-scalar");
                    if (next === "\n") break;
                }
            default:
                break loop;
        }
        if (!ch && !this.atEnd) return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1) this.indentNext = indent;
            else this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1) break;
                nl = this.buffer.indexOf("\n", cs);
            }while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd) return this.setNext("block-scalar");
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) do {
            let i = nl - 1;
            let ch = this.buffer[i];
            if (ch === "\r") ch = this.buffer[--i];
            const lastChar = i; // Drop the line if last char not more indented
            while(ch === " " || ch === "	")ch = this.buffer[--i];
            if (ch === "\n" && i >= this.pos && i + 1 + indent > lastChar) nl = i;
            else break;
        }while (true);
        yield $dlJmx.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while(ch = this.buffer[++i]){
            if (ch === ":") {
                const next = this.buffer[i + 1];
                if ($1c072d9f163bfb0b$var$isEmpty(next) || inFlow && next === ",") break;
                end = i;
            } else if ($1c072d9f163bfb0b$var$isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === "\r") {
                    if (next === "\n") {
                        i += 1;
                        ch = "\n";
                        next = this.buffer[i + 1];
                    } else end = i;
                }
                if (next === "#" || inFlow && $1c072d9f163bfb0b$var$invalidFlowScalarChars.includes(next)) break;
                if (ch === "\n") {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1) break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            } else {
                if (inFlow && $1c072d9f163bfb0b$var$invalidFlowScalarChars.includes(ch)) break;
                end = i;
            }
        }
        if (!ch && !this.atEnd) return this.setNext("plain-scalar");
        yield $dlJmx.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        } else if (allowEmpty) yield "";
        return 0;
    }
    *pushIndicators() {
        switch(this.charAt(0)){
            case "!":
                return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "&":
                return (yield* this.pushUntil($1c072d9f163bfb0b$var$isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "-":
            case "?":
            case ":":
                {
                    const inFlow = this.flowLevel > 0;
                    const ch1 = this.charAt(1);
                    if ($1c072d9f163bfb0b$var$isEmpty(ch1) || inFlow && $1c072d9f163bfb0b$var$invalidFlowScalarChars.includes(ch1)) {
                        if (!inFlow) this.indentNext = this.indentValue + 1;
                        else if (this.flowKey) this.flowKey = false;
                        return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                    }
                }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === "<") {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while(!$1c072d9f163bfb0b$var$isEmpty(ch) && ch !== ">")ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while(ch){
                if ($1c072d9f163bfb0b$var$tagChars.includes(ch)) ch = this.buffer[++i];
                else if (ch === "%" && $1c072d9f163bfb0b$var$hexDigits.includes(this.buffer[i + 1]) && $1c072d9f163bfb0b$var$hexDigits.includes(this.buffer[i + 2])) ch = this.buffer[i += 3];
                else break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n") return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
        else return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do ch = this.buffer[++i];
        while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while(!test(ch))ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}
$1c072d9f163bfb0b$export$6168dc8908a6c652 = $1c072d9f163bfb0b$var$Lexer;

});

parcelRegister("93t4w", function(module, exports) {

$parcel$export(module.exports, "LineCounter", () => $697af1ed9dfc9609$export$c8a6f24ae2865e59, (v) => $697af1ed9dfc9609$export$c8a6f24ae2865e59 = v);
var $697af1ed9dfc9609$export$c8a6f24ae2865e59;
"use strict";
/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */ class $697af1ed9dfc9609$var$LineCounter {
    constructor(){
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */ this.addNewLine = (offset)=>this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */ this.linePos = (offset)=>{
            let low = 0;
            let high = this.lineStarts.length;
            while(low < high){
                const mid = low + high >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset) low = mid + 1;
                else high = mid;
            }
            if (this.lineStarts[low] === offset) return {
                line: low + 1,
                col: 1
            };
            if (low === 0) return {
                line: 0,
                col: offset
            };
            const start = this.lineStarts[low - 1];
            return {
                line: low,
                col: offset - start + 1
            };
        };
    }
}
$697af1ed9dfc9609$export$c8a6f24ae2865e59 = $697af1ed9dfc9609$var$LineCounter;

});

parcelRegister("6nt1D", function(module, exports) {

$parcel$export(module.exports, "Parser", () => $4a4b67de553d5e0e$export$7acfa6ed01010e37, (v) => $4a4b67de553d5e0e$export$7acfa6ed01010e37 = v);
var $4a4b67de553d5e0e$export$7acfa6ed01010e37;
"use strict";

var $dlJmx = parcelRequire("dlJmx");

var $2pbWl = parcelRequire("2pbWl");
function $4a4b67de553d5e0e$var$includesToken(list, type) {
    for(let i = 0; i < list.length; ++i)if (list[i].type === type) return true;
    return false;
}
function $4a4b67de553d5e0e$var$findNonEmptyIndex(list) {
    for(let i = 0; i < list.length; ++i)switch(list[i].type){
        case "space":
        case "comment":
        case "newline":
            break;
        default:
            return i;
    }
    return -1;
}
function $4a4b67de553d5e0e$var$isFlowToken(token) {
    switch(token?.type){
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
            return true;
        default:
            return false;
    }
}
function $4a4b67de553d5e0e$var$getPrevProps(parent) {
    switch(parent.type){
        case "document":
            return parent.start;
        case "block-map":
            {
                const it = parent.items[parent.items.length - 1];
                return it.sep ?? it.start;
            }
        case "block-seq":
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */ default:
            return [];
    }
}
/** Note: May modify input array */ function $4a4b67de553d5e0e$var$getFirstKeyStartProps(prev) {
    if (prev.length === 0) return [];
    let i = prev.length;
    loop: while(--i >= 0)switch(prev[i].type){
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
            break loop;
    }
    while(prev[++i]?.type === "space");
    return prev.splice(i, prev.length);
}
function $4a4b67de553d5e0e$var$fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items)if (it.sep && !it.value && !$4a4b67de553d5e0e$var$includesToken(it.start, "explicit-key-ind") && !$4a4b67de553d5e0e$var$includesToken(it.sep, "map-value-ind")) {
            if (it.key) it.value = it.key;
            delete it.key;
            if ($4a4b67de553d5e0e$var$isFlowToken(it.value)) {
                if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
                else it.value.end = it.sep;
            } else Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */ class $4a4b67de553d5e0e$var$Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */ constructor(onNewLine){
        /** If true, space and sequence indicators count as indentation */ this.atNewLine = true;
        /** If true, next token is a scalar value */ this.atScalar = false;
        /** Current indentation level */ this.indent = 0;
        /** Current offset since the start of parsing */ this.offset = 0;
        /** On the same line with a block map key */ this.onKeyLine = false;
        /** Top indicates the node that's currently being built */ this.stack = [];
        /** The source of the current token, set in parse() */ this.source = "";
        /** The type of the current token, set in parse() */ this.type = "";
        // Must be defined after `next()`
        this.lexer = new $2pbWl.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */ *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))yield* this.next(lexeme);
        if (!incomplete) yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */ *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS) console.log("|", $dlJmx.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = $dlJmx.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({
                type: "error",
                offset: this.offset,
                message: message,
                source: source
            });
            this.offset += source.length;
        } else if (type === "scalar") {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = "scalar";
        } else {
            this.type = type;
            yield* this.step();
            switch(type){
                case "newline":
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine) this.onNewLine(this.offset + source.length);
                    break;
                case "space":
                    if (this.atNewLine && source[0] === " ") this.indent += source.length;
                    break;
                case "explicit-key-ind":
                case "map-value-ind":
                case "seq-item-ind":
                    if (this.atNewLine) this.indent += source.length;
                    break;
                case "doc-mode":
                case "flow-error-end":
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */ *end() {
        while(this.stack.length > 0)yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
            while(this.stack.length > 0)yield* this.pop();
            this.stack.push({
                type: "doc-end",
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top) return yield* this.stream();
        switch(top.type){
            case "document":
                return yield* this.document(top);
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return yield* this.scalar(top);
            case "block-scalar":
                return yield* this.blockScalar(top);
            case "block-map":
                return yield* this.blockMap(top);
            case "block-seq":
                return yield* this.blockSequence(top);
            case "flow-collection":
                return yield* this.flowCollection(top);
            case "doc-end":
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */ yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */ if (!token) {
            const message = "Tried to pop an empty stack";
            yield {
                type: "error",
                offset: this.offset,
                source: "",
                message: message
            };
        } else if (this.stack.length === 0) yield token;
        else {
            const top = this.peek(1);
            if (token.type === "block-scalar") // Block scalars use their parent rather than header indent
            token.indent = "indent" in top ? top.indent : 0;
            else if (token.type === "flow-collection" && top.type === "document") // Ignore all indent for top-level flow collections
            token.indent = 0;
            if (token.type === "flow-collection") $4a4b67de553d5e0e$var$fixFlowSeqItems(token);
            switch(top.type){
                case "document":
                    top.value = token;
                    break;
                case "block-scalar":
                    top.props.push(token); // error
                    break;
                case "block-map":
                    {
                        const it = top.items[top.items.length - 1];
                        if (it.value) {
                            top.items.push({
                                start: [],
                                key: token,
                                sep: []
                            });
                            this.onKeyLine = true;
                            return;
                        } else if (it.sep) it.value = token;
                        else {
                            Object.assign(it, {
                                key: token,
                                sep: []
                            });
                            this.onKeyLine = !$4a4b67de553d5e0e$var$includesToken(it.start, "explicit-key-ind");
                            return;
                        }
                        break;
                    }
                case "block-seq":
                    {
                        const it = top.items[top.items.length - 1];
                        if (it.value) top.items.push({
                            start: [],
                            value: token
                        });
                        else it.value = token;
                        break;
                    }
                case "flow-collection":
                    {
                        const it = top.items[top.items.length - 1];
                        if (!it || it.value) top.items.push({
                            start: [],
                            key: token,
                            sep: []
                        });
                        else if (it.sep) it.value = token;
                        else Object.assign(it, {
                            key: token,
                            sep: []
                        });
                        return;
                    }
                /* istanbul ignore next should not happen */ default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
                const last = token.items[token.items.length - 1];
                if (last && !last.sep && !last.value && last.start.length > 0 && $4a4b67de553d5e0e$var$findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st)=>st.type !== "comment" || st.indent < token.indent))) {
                    if (top.type === "document") top.end = last.start;
                    else top.items.push({
                        start: last.start
                    });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch(this.type){
            case "directive-line":
                yield {
                    type: "directive",
                    offset: this.offset,
                    source: this.source
                };
                return;
            case "byte-order-mark":
            case "space":
            case "comment":
            case "newline":
                yield this.sourceToken;
                return;
            case "doc-mode":
            case "doc-start":
                {
                    const doc = {
                        type: "document",
                        offset: this.offset,
                        start: []
                    };
                    if (this.type === "doc-start") doc.start.push(this.sourceToken);
                    this.stack.push(doc);
                    return;
                }
        }
        yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value) return yield* this.lineEnd(doc);
        switch(this.type){
            case "doc-start":
                if ($4a4b67de553d5e0e$var$findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                } else doc.start.push(this.sourceToken);
                return;
            case "anchor":
            case "tag":
            case "space":
            case "comment":
            case "newline":
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv) this.stack.push(bv);
        else yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
        };
    }
    *scalar(scalar) {
        if (this.type === "map-value-ind") {
            const prev = $4a4b67de553d5e0e$var$getPrevProps(this.peek(2));
            const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            } else sep = [
                this.sourceToken
            ];
            const map = {
                type: "block-map",
                offset: scalar.offset,
                indent: scalar.indent,
                items: [
                    {
                        start: start,
                        key: scalar,
                        sep: sep
                    }
                ]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        } else yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch(this.type){
            case "space":
            case "comment":
            case "newline":
                scalar.props.push(this.sourceToken);
                return;
            case "scalar":
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf("\n") + 1;
                    while(nl !== 0){
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf("\n", nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */ default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch(this.type){
            case "newline":
                this.onKeyLine = false;
                if (it.value) {
                    const end = "end" in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === "comment") end?.push(this.sourceToken);
                    else map.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                } else if (it.sep) it.sep.push(this.sourceToken);
                else it.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (it.value) map.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else if (it.sep) it.sep.push(this.sourceToken);
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep && this.type !== "seq-item-ind";
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for(let i = 0; i < it.sep.length; ++i){
                    const st = it.sep[i];
                    switch(st.type){
                        case "newline":
                            nl.push(i);
                            break;
                        case "space":
                            break;
                        case "comment":
                            if (st.indent > map.indent) nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2) start = it.sep.splice(nl[1]);
            }
            switch(this.type){
                case "anchor":
                case "tag":
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({
                            start: start
                        });
                        this.onKeyLine = true;
                    } else if (it.sep) it.sep.push(this.sourceToken);
                    else it.start.push(this.sourceToken);
                    return;
                case "explicit-key-ind":
                    if (!it.sep && !$4a4b67de553d5e0e$var$includesToken(it.start, "explicit-key-ind")) it.start.push(this.sourceToken);
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({
                            start: start
                        });
                    } else this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: [
                                    this.sourceToken
                                ]
                            }
                        ]
                    });
                    this.onKeyLine = true;
                    return;
                case "map-value-ind":
                    if ($4a4b67de553d5e0e$var$includesToken(it.start, "explicit-key-ind")) {
                        if (!it.sep) {
                            if ($4a4b67de553d5e0e$var$includesToken(it.start, "newline")) Object.assign(it, {
                                key: null,
                                sep: [
                                    this.sourceToken
                                ]
                            });
                            else {
                                const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: "block-map",
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [
                                        {
                                            start: start,
                                            key: null,
                                            sep: [
                                                this.sourceToken
                                            ]
                                        }
                                    ]
                                });
                            }
                        } else if (it.value) map.items.push({
                            start: [],
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if ($4a4b67de553d5e0e$var$includesToken(it.sep, "map-value-ind")) this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: start,
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                }
                            ]
                        });
                        else if ($4a4b67de553d5e0e$var$isFlowToken(it.key) && !$4a4b67de553d5e0e$var$includesToken(it.sep, "newline")) {
                            const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: "block-map",
                                offset: this.offset,
                                indent: this.indent,
                                items: [
                                    {
                                        start: start,
                                        key: key,
                                        sep: sep
                                    }
                                ]
                            });
                        } else if (start.length > 0) // Not actually at next item
                        it.sep = it.sep.concat(start, this.sourceToken);
                        else it.sep.push(this.sourceToken);
                    } else {
                        if (!it.sep) Object.assign(it, {
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if (it.value || atNextItem) map.items.push({
                            start: start,
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if ($4a4b67de553d5e0e$var$includesToken(it.sep, "map-value-ind")) this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: [],
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                }
                            ]
                        });
                        else it.sep.push(this.sourceToken);
                    }
                    this.onKeyLine = true;
                    return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        if (atNextItem || it.value) {
                            map.items.push({
                                start: start,
                                key: fs,
                                sep: []
                            });
                            this.onKeyLine = true;
                        } else if (it.sep) this.stack.push(fs);
                        else {
                            Object.assign(it, {
                                key: fs,
                                sep: []
                            });
                            this.onKeyLine = true;
                        }
                        return;
                    }
                default:
                    {
                        const bv = this.startBlockValue(map);
                        if (bv) {
                            if (atNextItem && bv.type !== "block-seq" && $4a4b67de553d5e0e$var$includesToken(it.start, "explicit-key-ind")) map.items.push({
                                start: start
                            });
                            this.stack.push(bv);
                            return;
                        }
                    }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch(this.type){
            case "newline":
                if (it.value) {
                    const end = "end" in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === "comment") end?.push(this.sourceToken);
                    else seq.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                } else it.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (it.value) seq.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case "anchor":
            case "tag":
                if (it.value || this.indent <= seq.indent) break;
                it.start.push(this.sourceToken);
                return;
            case "seq-item-ind":
                if (this.indent !== seq.indent) break;
                if (it.value || $4a4b67de553d5e0e$var$includesToken(it.start, "seq-item-ind")) seq.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            }while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
            switch(this.type){
                case "comma":
                case "explicit-key-ind":
                    if (!it || it.sep) fc.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                    else it.start.push(this.sourceToken);
                    return;
                case "map-value-ind":
                    if (!it || it.value) fc.items.push({
                        start: [],
                        key: null,
                        sep: [
                            this.sourceToken
                        ]
                    });
                    else if (it.sep) it.sep.push(this.sourceToken);
                    else Object.assign(it, {
                        key: null,
                        sep: [
                            this.sourceToken
                        ]
                    });
                    return;
                case "space":
                case "comment":
                case "newline":
                case "anchor":
                case "tag":
                    if (!it || it.value) fc.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                    else if (it.sep) it.sep.push(this.sourceToken);
                    else it.start.push(this.sourceToken);
                    return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        if (!it || it.value) fc.items.push({
                            start: [],
                            key: fs,
                            sep: []
                        });
                        else if (it.sep) this.stack.push(fs);
                        else Object.assign(it, {
                            key: fs,
                            sep: []
                        });
                        return;
                    }
                case "flow-map-end":
                case "flow-seq-end":
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */ if (bv) this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        } else {
            const parent = this.peek(2);
            if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
                yield* this.pop();
                yield* this.step();
            } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
                const prev = $4a4b67de553d5e0e$var$getPrevProps(parent);
                const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(prev);
                $4a4b67de553d5e0e$var$fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: "block-map",
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [
                        {
                            start: start,
                            key: fc,
                            sep: sep
                        }
                    ]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            } else yield* this.lineEnd(fc);
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while(nl !== 0){
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
            }
        }
        return {
            type: type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch(this.type){
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return this.flowScalar(this.type);
            case "block-scalar-header":
                return {
                    type: "block-scalar",
                    offset: this.offset,
                    indent: this.indent,
                    props: [
                        this.sourceToken
                    ],
                    source: ""
                };
            case "flow-map-start":
            case "flow-seq-start":
                return {
                    type: "flow-collection",
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case "seq-item-ind":
                return {
                    type: "block-seq",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                        {
                            start: [
                                this.sourceToken
                            ]
                        }
                    ]
                };
            case "explicit-key-ind":
                {
                    this.onKeyLine = true;
                    const prev = $4a4b67de553d5e0e$var$getPrevProps(parent);
                    const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(prev);
                    start.push(this.sourceToken);
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: start
                            }
                        ]
                    };
                }
            case "map-value-ind":
                {
                    this.onKeyLine = true;
                    const prev = $4a4b67de553d5e0e$var$getPrevProps(parent);
                    const start = $4a4b67de553d5e0e$var$getFirstKeyStartProps(prev);
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: start,
                                key: null,
                                sep: [
                                    this.sourceToken
                                ]
                            }
                        ]
                    };
                }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== "comment") return false;
        if (this.indent <= indent) return false;
        return start.every((st)=>st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
            if (docEnd.end) docEnd.end.push(this.sourceToken);
            else docEnd.end = [
                this.sourceToken
            ];
            if (this.type === "newline") yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch(this.type){
            case "comma":
            case "doc-start":
            case "doc-end":
            case "flow-seq-end":
            case "flow-map-end":
            case "map-value-ind":
                yield* this.pop();
                yield* this.step();
                break;
            case "newline":
                this.onKeyLine = false;
            // fallthrough
            case "space":
            case "comment":
            default:
                // all other values are errors
                if (token.end) token.end.push(this.sourceToken);
                else token.end = [
                    this.sourceToken
                ];
                if (this.type === "newline") yield* this.pop();
        }
    }
}
$4a4b67de553d5e0e$export$7acfa6ed01010e37 = $4a4b67de553d5e0e$var$Parser;

});

parcelRegister("f2kIs", function(module, exports) {

$parcel$export(module.exports, "parse", () => $af271cad3716966e$export$98e6a39c04603d36, (v) => $af271cad3716966e$export$98e6a39c04603d36 = v);
$parcel$export(module.exports, "parseAllDocuments", () => $af271cad3716966e$export$643da2570c3b3d01, (v) => $af271cad3716966e$export$643da2570c3b3d01 = v);
$parcel$export(module.exports, "parseDocument", () => $af271cad3716966e$export$b6a9369736b19f4d, (v) => $af271cad3716966e$export$b6a9369736b19f4d = v);
$parcel$export(module.exports, "stringify", () => $af271cad3716966e$export$fac44ee5b035f737, (v) => $af271cad3716966e$export$fac44ee5b035f737 = v);
var $af271cad3716966e$export$98e6a39c04603d36;
var $af271cad3716966e$export$643da2570c3b3d01;
var $af271cad3716966e$export$b6a9369736b19f4d;
var $af271cad3716966e$export$fac44ee5b035f737;
"use strict";

var $9Ds0b = parcelRequire("9Ds0b");

var $e3GNt = parcelRequire("e3GNt");

var $1MTYj = parcelRequire("1MTYj");

var $hdpqh = parcelRequire("hdpqh");

var $93t4w = parcelRequire("93t4w");

var $6nt1D = parcelRequire("6nt1D");
function $af271cad3716966e$var$parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new $93t4w.LineCounter() || null;
    return {
        lineCounter: lineCounter$1,
        prettyErrors: prettyErrors
    };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */ function $af271cad3716966e$var$parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter, prettyErrors: prettyErrors } = $af271cad3716966e$var$parseOptions(options);
    const parser$1 = new $6nt1D.Parser(lineCounter?.addNewLine);
    const composer$1 = new $9Ds0b.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter) for (const doc of docs){
        doc.errors.forEach($1MTYj.prettifyError(source, lineCounter));
        doc.warnings.forEach($1MTYj.prettifyError(source, lineCounter));
    }
    if (docs.length > 0) return docs;
    return Object.assign([], {
        empty: true
    }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */ function $af271cad3716966e$var$parseDocument(source, options = {}) {
    const { lineCounter: lineCounter, prettyErrors: prettyErrors } = $af271cad3716966e$var$parseOptions(options);
    const parser$1 = new $6nt1D.Parser(lineCounter?.addNewLine);
    const composer$1 = new $9Ds0b.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)){
        if (!doc) doc = _doc;
        else if (doc.options.logLevel !== "silent") {
            doc.errors.push(new $1MTYj.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach($1MTYj.prettifyError(source, lineCounter));
        doc.warnings.forEach($1MTYj.prettifyError(source, lineCounter));
    }
    return doc;
}
function $af271cad3716966e$var$parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") _reviver = reviver;
    else if (options === undefined && reviver && typeof reviver === "object") options = reviver;
    const doc = $af271cad3716966e$var$parseDocument(src, options);
    if (!doc) return null;
    doc.warnings.forEach((warning)=>$hdpqh.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent") throw doc.errors[0];
        else doc.errors = [];
    }
    return doc.toJS(Object.assign({
        reviver: _reviver
    }, options));
}
function $af271cad3716966e$var$stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
    else if (options === undefined && replacer) options = replacer;
    if (typeof options === "string") options = options.length;
    if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? {
            indent: 8
        } : {
            indent: indent
        };
    }
    if (value === undefined) {
        const { keepUndefined: keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined) return undefined;
    }
    return new $e3GNt.Document(value, _replacer, options).toString(options);
}
$af271cad3716966e$export$98e6a39c04603d36 = $af271cad3716966e$var$parse;
$af271cad3716966e$export$643da2570c3b3d01 = $af271cad3716966e$var$parseAllDocuments;
$af271cad3716966e$export$b6a9369736b19f4d = $af271cad3716966e$var$parseDocument;
$af271cad3716966e$export$fac44ee5b035f737 = $af271cad3716966e$var$stringify;

});


parcelRegister("5xH1P", function(module, exports) {
const $9a1c16c9f228833d$var$frontmatterRegex = /^\s*---((?:.|\s)+?)---/;
/**
 * @param {string} toCheck
 * @returns {string | false}
 */ const $9a1c16c9f228833d$var$containsFrontmatter = (toCheck)=>$9a1c16c9f228833d$var$frontmatterRegex.exec(toCheck)?.[1] ?? false;
module.exports = {
    frontmatterRegex: $9a1c16c9f228833d$var$frontmatterRegex,
    containsFrontmatter: $9a1c16c9f228833d$var$containsFrontmatter
};

});


parcelRegister("2WRWK", function(module, exports) {
"use strict";
const wrapAnsi16 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${code + offset}m`;
    };
const wrapAnsi256 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${38 + offset};5;${code}m`;
    };
const wrapAnsi16m = (fn, offset)=>(...args)=>{
        const rgb = fn(...args);
        return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
const ansi2ansi = (n)=>n;
const rgb2rgb = (r, g, b)=>[
        r,
        g,
        b
    ];
const setLazyProperty = (object, property, get)=>{
    Object.defineProperty(object, property, {
        get: ()=>{
            const value = get();
            Object.defineProperty(object, property, {
                value: value,
                enumerable: true,
                configurable: true
            });
            return value;
        },
        enumerable: true,
        configurable: true
    });
};
/** @type {typeof import('color-convert')} */ let colorConvert;

const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
    if (colorConvert === undefined) colorConvert = (parcelRequire("4WX4s"));
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)){
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) styles[name] = wrap(identity, offset);
        else if (typeof suite === "object") styles[name] = wrap(suite[targetSpace], offset);
    }
    return styles;
};
function assembleStyles() {
    const codes = new Map();
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            // 21 isn't widely supported and 22 does the same thing
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            // Bright color
            blackBright: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            // Bright color
            bgBlackBright: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
    });
    styles.color.close = "\x1b[39m";
    styles.bgColor.close = "\x1b[49m";
    setLazyProperty(styles.color, "ansi", ()=>makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", ()=>makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", ()=>makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", ()=>makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", ()=>makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", ()=>makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
}
// Make the export immutable
Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
});

});
parcelRegister("4WX4s", function(module, exports) {

var $4QmTn = parcelRequire("4QmTn");

var $lDe5S = parcelRequire("lDe5S");
const $39aa6670fa069576$var$convert = {};
const $39aa6670fa069576$var$models = Object.keys($4QmTn);
function $39aa6670fa069576$var$wrapRaw(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) return arg0;
        if (arg0.length > 1) args = arg0;
        return fn(args);
    };
    // Preserve .conversion property if there is one
    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
    return wrappedFn;
}
function $39aa6670fa069576$var$wrapRounded(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) return arg0;
        if (arg0.length > 1) args = arg0;
        const result = fn(args);
        // We're assuming the result is an array here.
        // see notice in conversions.js; don't use box types
        // in conversion functions.
        if (typeof result === "object") for(let len = result.length, i = 0; i < len; i++)result[i] = Math.round(result[i]);
        return result;
    };
    // Preserve .conversion property if there is one
    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
    return wrappedFn;
}
$39aa6670fa069576$var$models.forEach((fromModel)=>{
    $39aa6670fa069576$var$convert[fromModel] = {};
    Object.defineProperty($39aa6670fa069576$var$convert[fromModel], "channels", {
        value: $4QmTn[fromModel].channels
    });
    Object.defineProperty($39aa6670fa069576$var$convert[fromModel], "labels", {
        value: $4QmTn[fromModel].labels
    });
    const routes = $lDe5S(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel)=>{
        const fn = routes[toModel];
        $39aa6670fa069576$var$convert[fromModel][toModel] = $39aa6670fa069576$var$wrapRounded(fn);
        $39aa6670fa069576$var$convert[fromModel][toModel].raw = $39aa6670fa069576$var$wrapRaw(fn);
    });
});
module.exports = $39aa6670fa069576$var$convert;

});
parcelRegister("4QmTn", function(module, exports) {
/* MIT license */ /* eslint-disable no-mixed-operators */ 
var $bcXwX = parcelRequire("bcXwX");
// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)
const $386dc6a8f80ab96d$var$reverseKeywords = {};
for (const key of Object.keys($bcXwX))$386dc6a8f80ab96d$var$reverseKeywords[$bcXwX[key]] = key;
const $386dc6a8f80ab96d$var$convert = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    hex: {
        channels: 1,
        labels: [
            "hex"
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            "keyword"
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            "ansi16"
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            "ansi256"
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            "h",
            "c",
            "g"
        ]
    },
    apple: {
        channels: 3,
        labels: [
            "r16",
            "g16",
            "b16"
        ]
    },
    gray: {
        channels: 1,
        labels: [
            "gray"
        ]
    }
};
module.exports = $386dc6a8f80ab96d$var$convert;
// Hide .channels and .labels properties
for (const model of Object.keys($386dc6a8f80ab96d$var$convert)){
    if (!("channels" in $386dc6a8f80ab96d$var$convert[model])) throw new Error("missing channels property: " + model);
    if (!("labels" in $386dc6a8f80ab96d$var$convert[model])) throw new Error("missing channel labels property: " + model);
    if ($386dc6a8f80ab96d$var$convert[model].labels.length !== $386dc6a8f80ab96d$var$convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
    const { channels: channels, labels: labels } = $386dc6a8f80ab96d$var$convert[model];
    delete $386dc6a8f80ab96d$var$convert[model].channels;
    delete $386dc6a8f80ab96d$var$convert[model].labels;
    Object.defineProperty($386dc6a8f80ab96d$var$convert[model], "channels", {
        value: channels
    });
    Object.defineProperty($386dc6a8f80ab96d$var$convert[model], "labels", {
        value: labels
    });
}
$386dc6a8f80ab96d$var$convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) h = 0;
    else if (r === max) h = (g - b) / delta;
    else if (g === max) h = 2 + (b - r) / delta;
    else if (b === max) h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    const l = (min + max) / 2;
    if (max === min) s = 0;
    else if (l <= 0.5) s = delta / (max + min);
    else s = delta / (2 - max - min);
    return [
        h,
        s * 100,
        l * 100
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
        return (v - c) / 6 / diff + 0.5;
    };
    if (diff === 0) {
        h = 0;
        s = 0;
    } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) h = bdif - gdif;
        else if (g === v) h = 1 / 3 + rdif - bdif;
        else if (b === v) h = 2 / 3 + gdif - rdif;
        if (h < 0) h += 1;
        else if (h > 1) h -= 1;
    }
    return [
        h * 360,
        s * 100,
        v * 100
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = $386dc6a8f80ab96d$var$convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
        h,
        w * 100,
        b * 100
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
    ];
};
function $386dc6a8f80ab96d$var$comparativeDistance(x, y) {
    /*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/ return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
$386dc6a8f80ab96d$var$convert.rgb.keyword = function(rgb) {
    const reversed = $386dc6a8f80ab96d$var$reverseKeywords[rgb];
    if (reversed) return reversed;
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys($bcXwX)){
        const value = $bcXwX[keyword];
        // Compute comparative distance
        const distance = $386dc6a8f80ab96d$var$comparativeDistance(rgb, value);
        // Check if its less, if so set as closest
        if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
        }
    }
    return currentClosestKeyword;
};
$386dc6a8f80ab96d$var$convert.keyword.rgb = function(keyword) {
    return $bcXwX[keyword];
};
$386dc6a8f80ab96d$var$convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.lab = function(rgb) {
    const xyz = $386dc6a8f80ab96d$var$convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
        val = l * 255;
        return [
            val,
            val,
            val
        ];
    }
    if (l < 0.5) t2 = l * (1 + s);
    else t2 = l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [
        0,
        0,
        0
    ];
    for(let i = 0; i < 3; i++){
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) t3++;
        if (t3 > 1) t3--;
        if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;
        else if (2 * t3 < 1) val = t2;
        else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        else val = t1;
        rgb[i] = val * 255;
    }
    return rgb;
};
$386dc6a8f80ab96d$var$convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
        h,
        sv * 100,
        v * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch(hi){
        case 0:
            return [
                v,
                t,
                p
            ];
        case 1:
            return [
                q,
                v,
                p
            ];
        case 2:
            return [
                p,
                v,
                t
            ];
        case 3:
            return [
                p,
                q,
                v
            ];
        case 4:
            return [
                t,
                p,
                v
            ];
        case 5:
            return [
                v,
                p,
                q
            ];
    }
};
$386dc6a8f80ab96d$var$convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
        h,
        sl * 100,
        l * 100
    ];
};
// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
$386dc6a8f80ab96d$var$convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    // Wh + bl cant be > 1
    if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) f = 1 - f;
    const n = wh + f * (v - wh); // Linear interpolation
    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */ switch(i){
        default:
        case 6:
        case 0:
            r = v;
            g = n;
            b = wh;
            break;
        case 1:
            r = n;
            g = v;
            b = wh;
            break;
        case 2:
            r = wh;
            g = v;
            b = n;
            break;
        case 3:
            r = wh;
            g = n;
            b = v;
            break;
        case 4:
            r = n;
            g = wh;
            b = v;
            break;
        case 5:
            r = v;
            g = wh;
            b = n;
            break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */ return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$386dc6a8f80ab96d$var$convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$386dc6a8f80ab96d$var$convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.0570;
    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$386dc6a8f80ab96d$var$convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
        x,
        y,
        z
    ];
};
$386dc6a8f80ab96d$var$convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) h += 360;
    const c = Math.sqrt(a * a + b * b);
    return [
        l,
        c,
        h
    ];
};
$386dc6a8f80ab96d$var$convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
        l,
        a,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? $386dc6a8f80ab96d$var$convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization
    value = Math.round(value / 50);
    if (value === 0) return 30;
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) ansi += 60;
    return ansi;
};
$386dc6a8f80ab96d$var$convert.hsv.ansi16 = function(args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return $386dc6a8f80ab96d$var$convert.rgb.ansi16($386dc6a8f80ab96d$var$convert.hsv.rgb(args), args[2]);
};
$386dc6a8f80ab96d$var$convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
        if (r < 8) return 16;
        if (r > 248) return 231;
        return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
};
$386dc6a8f80ab96d$var$convert.ansi16.rgb = function(args) {
    let color = args % 10;
    // Handle greyscale
    if (color === 0 || color === 7) {
        if (args > 50) color += 3.5;
        color = color / 10.5 * 255;
        return [
            color,
            color,
            color
        ];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
        r,
        g,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.ansi256.rgb = function(args) {
    // Handle greyscale
    if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
            c,
            c,
            c
        ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
        r,
        g,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
};
$386dc6a8f80ab96d$var$convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) return [
        0,
        0,
        0
    ];
    let colorString = match[0];
    if (match[0].length === 3) colorString = colorString.split("").map((char)=>{
        return char + char;
    }).join("");
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [
        r,
        g,
        b
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) grayscale = min / (1 - chroma);
    else grayscale = 0;
    if (chroma <= 0) hue = 0;
    else if (max === r) hue = (g - b) / chroma % 6;
    else if (max === g) hue = 2 + (b - r) / chroma;
    else hue = 4 + (r - g) / chroma;
    hue /= 6;
    hue %= 1;
    return [
        hue * 360,
        chroma * 100,
        grayscale * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) f = (l - 0.5 * c) / (1.0 - c);
    return [
        hsl[0],
        c * 100,
        f * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) f = (v - c) / (1 - c);
    return [
        hsv[0],
        c * 100,
        f * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) return [
        g * 255,
        g * 255,
        g * 255
    ];
    const pure = [
        0,
        0,
        0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */ switch(Math.floor(hi)){
        case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
        case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
        case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
        case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
        case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
        default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */ mg = (1.0 - c) * g;
    return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
    ];
};
$386dc6a8f80ab96d$var$convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) f = c / v;
    return [
        hcg[0],
        f * 100,
        v * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) s = c / (2 * l);
    else if (l >= 0.5 && l < 1.0) s = c / (2 * (1 - l));
    return [
        hcg[0],
        s * 100,
        l * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
    ];
};
$386dc6a8f80ab96d$var$convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) g = (v - c) / (1 - c);
    return [
        hwb[0],
        c * 100,
        g * 100
    ];
};
$386dc6a8f80ab96d$var$convert.apple.rgb = function(apple) {
    return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
    ];
};
$386dc6a8f80ab96d$var$convert.rgb.apple = function(rgb) {
    return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
    ];
};
$386dc6a8f80ab96d$var$convert.gray.rgb = function(args) {
    return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
    ];
};
$386dc6a8f80ab96d$var$convert.gray.hsl = function(args) {
    return [
        0,
        0,
        args[0]
    ];
};
$386dc6a8f80ab96d$var$convert.gray.hsv = $386dc6a8f80ab96d$var$convert.gray.hsl;
$386dc6a8f80ab96d$var$convert.gray.hwb = function(gray) {
    return [
        0,
        100,
        gray[0]
    ];
};
$386dc6a8f80ab96d$var$convert.gray.cmyk = function(gray) {
    return [
        0,
        0,
        0,
        gray[0]
    ];
};
$386dc6a8f80ab96d$var$convert.gray.lab = function(gray) {
    return [
        gray[0],
        0,
        0
    ];
};
$386dc6a8f80ab96d$var$convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
};
$386dc6a8f80ab96d$var$convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
        val / 255 * 100
    ];
};

});
parcelRegister("bcXwX", function(module, exports) {
"use strict";
module.exports = {
    "aliceblue": [
        240,
        248,
        255
    ],
    "antiquewhite": [
        250,
        235,
        215
    ],
    "aqua": [
        0,
        255,
        255
    ],
    "aquamarine": [
        127,
        255,
        212
    ],
    "azure": [
        240,
        255,
        255
    ],
    "beige": [
        245,
        245,
        220
    ],
    "bisque": [
        255,
        228,
        196
    ],
    "black": [
        0,
        0,
        0
    ],
    "blanchedalmond": [
        255,
        235,
        205
    ],
    "blue": [
        0,
        0,
        255
    ],
    "blueviolet": [
        138,
        43,
        226
    ],
    "brown": [
        165,
        42,
        42
    ],
    "burlywood": [
        222,
        184,
        135
    ],
    "cadetblue": [
        95,
        158,
        160
    ],
    "chartreuse": [
        127,
        255,
        0
    ],
    "chocolate": [
        210,
        105,
        30
    ],
    "coral": [
        255,
        127,
        80
    ],
    "cornflowerblue": [
        100,
        149,
        237
    ],
    "cornsilk": [
        255,
        248,
        220
    ],
    "crimson": [
        220,
        20,
        60
    ],
    "cyan": [
        0,
        255,
        255
    ],
    "darkblue": [
        0,
        0,
        139
    ],
    "darkcyan": [
        0,
        139,
        139
    ],
    "darkgoldenrod": [
        184,
        134,
        11
    ],
    "darkgray": [
        169,
        169,
        169
    ],
    "darkgreen": [
        0,
        100,
        0
    ],
    "darkgrey": [
        169,
        169,
        169
    ],
    "darkkhaki": [
        189,
        183,
        107
    ],
    "darkmagenta": [
        139,
        0,
        139
    ],
    "darkolivegreen": [
        85,
        107,
        47
    ],
    "darkorange": [
        255,
        140,
        0
    ],
    "darkorchid": [
        153,
        50,
        204
    ],
    "darkred": [
        139,
        0,
        0
    ],
    "darksalmon": [
        233,
        150,
        122
    ],
    "darkseagreen": [
        143,
        188,
        143
    ],
    "darkslateblue": [
        72,
        61,
        139
    ],
    "darkslategray": [
        47,
        79,
        79
    ],
    "darkslategrey": [
        47,
        79,
        79
    ],
    "darkturquoise": [
        0,
        206,
        209
    ],
    "darkviolet": [
        148,
        0,
        211
    ],
    "deeppink": [
        255,
        20,
        147
    ],
    "deepskyblue": [
        0,
        191,
        255
    ],
    "dimgray": [
        105,
        105,
        105
    ],
    "dimgrey": [
        105,
        105,
        105
    ],
    "dodgerblue": [
        30,
        144,
        255
    ],
    "firebrick": [
        178,
        34,
        34
    ],
    "floralwhite": [
        255,
        250,
        240
    ],
    "forestgreen": [
        34,
        139,
        34
    ],
    "fuchsia": [
        255,
        0,
        255
    ],
    "gainsboro": [
        220,
        220,
        220
    ],
    "ghostwhite": [
        248,
        248,
        255
    ],
    "gold": [
        255,
        215,
        0
    ],
    "goldenrod": [
        218,
        165,
        32
    ],
    "gray": [
        128,
        128,
        128
    ],
    "green": [
        0,
        128,
        0
    ],
    "greenyellow": [
        173,
        255,
        47
    ],
    "grey": [
        128,
        128,
        128
    ],
    "honeydew": [
        240,
        255,
        240
    ],
    "hotpink": [
        255,
        105,
        180
    ],
    "indianred": [
        205,
        92,
        92
    ],
    "indigo": [
        75,
        0,
        130
    ],
    "ivory": [
        255,
        255,
        240
    ],
    "khaki": [
        240,
        230,
        140
    ],
    "lavender": [
        230,
        230,
        250
    ],
    "lavenderblush": [
        255,
        240,
        245
    ],
    "lawngreen": [
        124,
        252,
        0
    ],
    "lemonchiffon": [
        255,
        250,
        205
    ],
    "lightblue": [
        173,
        216,
        230
    ],
    "lightcoral": [
        240,
        128,
        128
    ],
    "lightcyan": [
        224,
        255,
        255
    ],
    "lightgoldenrodyellow": [
        250,
        250,
        210
    ],
    "lightgray": [
        211,
        211,
        211
    ],
    "lightgreen": [
        144,
        238,
        144
    ],
    "lightgrey": [
        211,
        211,
        211
    ],
    "lightpink": [
        255,
        182,
        193
    ],
    "lightsalmon": [
        255,
        160,
        122
    ],
    "lightseagreen": [
        32,
        178,
        170
    ],
    "lightskyblue": [
        135,
        206,
        250
    ],
    "lightslategray": [
        119,
        136,
        153
    ],
    "lightslategrey": [
        119,
        136,
        153
    ],
    "lightsteelblue": [
        176,
        196,
        222
    ],
    "lightyellow": [
        255,
        255,
        224
    ],
    "lime": [
        0,
        255,
        0
    ],
    "limegreen": [
        50,
        205,
        50
    ],
    "linen": [
        250,
        240,
        230
    ],
    "magenta": [
        255,
        0,
        255
    ],
    "maroon": [
        128,
        0,
        0
    ],
    "mediumaquamarine": [
        102,
        205,
        170
    ],
    "mediumblue": [
        0,
        0,
        205
    ],
    "mediumorchid": [
        186,
        85,
        211
    ],
    "mediumpurple": [
        147,
        112,
        219
    ],
    "mediumseagreen": [
        60,
        179,
        113
    ],
    "mediumslateblue": [
        123,
        104,
        238
    ],
    "mediumspringgreen": [
        0,
        250,
        154
    ],
    "mediumturquoise": [
        72,
        209,
        204
    ],
    "mediumvioletred": [
        199,
        21,
        133
    ],
    "midnightblue": [
        25,
        25,
        112
    ],
    "mintcream": [
        245,
        255,
        250
    ],
    "mistyrose": [
        255,
        228,
        225
    ],
    "moccasin": [
        255,
        228,
        181
    ],
    "navajowhite": [
        255,
        222,
        173
    ],
    "navy": [
        0,
        0,
        128
    ],
    "oldlace": [
        253,
        245,
        230
    ],
    "olive": [
        128,
        128,
        0
    ],
    "olivedrab": [
        107,
        142,
        35
    ],
    "orange": [
        255,
        165,
        0
    ],
    "orangered": [
        255,
        69,
        0
    ],
    "orchid": [
        218,
        112,
        214
    ],
    "palegoldenrod": [
        238,
        232,
        170
    ],
    "palegreen": [
        152,
        251,
        152
    ],
    "paleturquoise": [
        175,
        238,
        238
    ],
    "palevioletred": [
        219,
        112,
        147
    ],
    "papayawhip": [
        255,
        239,
        213
    ],
    "peachpuff": [
        255,
        218,
        185
    ],
    "peru": [
        205,
        133,
        63
    ],
    "pink": [
        255,
        192,
        203
    ],
    "plum": [
        221,
        160,
        221
    ],
    "powderblue": [
        176,
        224,
        230
    ],
    "purple": [
        128,
        0,
        128
    ],
    "rebeccapurple": [
        102,
        51,
        153
    ],
    "red": [
        255,
        0,
        0
    ],
    "rosybrown": [
        188,
        143,
        143
    ],
    "royalblue": [
        65,
        105,
        225
    ],
    "saddlebrown": [
        139,
        69,
        19
    ],
    "salmon": [
        250,
        128,
        114
    ],
    "sandybrown": [
        244,
        164,
        96
    ],
    "seagreen": [
        46,
        139,
        87
    ],
    "seashell": [
        255,
        245,
        238
    ],
    "sienna": [
        160,
        82,
        45
    ],
    "silver": [
        192,
        192,
        192
    ],
    "skyblue": [
        135,
        206,
        235
    ],
    "slateblue": [
        106,
        90,
        205
    ],
    "slategray": [
        112,
        128,
        144
    ],
    "slategrey": [
        112,
        128,
        144
    ],
    "snow": [
        255,
        250,
        250
    ],
    "springgreen": [
        0,
        255,
        127
    ],
    "steelblue": [
        70,
        130,
        180
    ],
    "tan": [
        210,
        180,
        140
    ],
    "teal": [
        0,
        128,
        128
    ],
    "thistle": [
        216,
        191,
        216
    ],
    "tomato": [
        255,
        99,
        71
    ],
    "turquoise": [
        64,
        224,
        208
    ],
    "violet": [
        238,
        130,
        238
    ],
    "wheat": [
        245,
        222,
        179
    ],
    "white": [
        255,
        255,
        255
    ],
    "whitesmoke": [
        245,
        245,
        245
    ],
    "yellow": [
        255,
        255,
        0
    ],
    "yellowgreen": [
        154,
        205,
        50
    ]
};

});


parcelRegister("lDe5S", function(module, exports) {

var $4QmTn = parcelRequire("4QmTn");
/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/ function $fbf82c3f03d780ce$var$buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys($4QmTn);
    for(let len = models.length, i = 0; i < len; i++)graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
    };
    return graph;
}
// https://en.wikipedia.org/wiki/Breadth-first_search
function $fbf82c3f03d780ce$var$deriveBFS(fromModel) {
    const graph = $fbf82c3f03d780ce$var$buildGraph();
    const queue = [
        fromModel
    ]; // Unshift -> queue -> pop
    graph[fromModel].distance = 0;
    while(queue.length){
        const current = queue.pop();
        const adjacents = Object.keys($4QmTn[current]);
        for(let len = adjacents.length, i = 0; i < len; i++){
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
            }
        }
    }
    return graph;
}
function $fbf82c3f03d780ce$var$link(from, to) {
    return function(args) {
        return to(from(args));
    };
}
function $fbf82c3f03d780ce$var$wrapConversion(toModel, graph) {
    const path = [
        graph[toModel].parent,
        toModel
    ];
    let fn = $4QmTn[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while(graph[cur].parent){
        path.unshift(graph[cur].parent);
        fn = $fbf82c3f03d780ce$var$link($4QmTn[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
}
module.exports = function(fromModel) {
    const graph = $fbf82c3f03d780ce$var$deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for(let len = models.length, i = 0; i < len; i++){
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) continue;
        conversion[toModel] = $fbf82c3f03d780ce$var$wrapConversion(toModel, graph);
    }
    return conversion;
};

});



parcelRegister("gn0Qn", function(module, exports) {
"use strict";
const $beaf72e613ab97c3$var$TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const $beaf72e613ab97c3$var$STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const $beaf72e613ab97c3$var$STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const $beaf72e613ab97c3$var$ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const $beaf72e613ab97c3$var$ESCAPES = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "	"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function $beaf72e613ab97c3$var$unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) return String.fromCharCode(parseInt(c.slice(1), 16));
    if (u && bracket) return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    return $beaf72e613ab97c3$var$ESCAPES.get(c) || c;
}
function $beaf72e613ab97c3$var$parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks){
        const number = Number(chunk);
        if (!Number.isNaN(number)) results.push(number);
        else if (matches = chunk.match($beaf72e613ab97c3$var$STRING_REGEX)) results.push(matches[2].replace($beaf72e613ab97c3$var$ESCAPE_REGEX, (m, escape, character)=>escape ? $beaf72e613ab97c3$var$unescape(escape) : character));
        else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
    return results;
}
function $beaf72e613ab97c3$var$parseStyle(style) {
    $beaf72e613ab97c3$var$STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while((matches = $beaf72e613ab97c3$var$STYLE_REGEX.exec(style)) !== null){
        const name = matches[1];
        if (matches[2]) {
            const args = $beaf72e613ab97c3$var$parseArguments(name, matches[2]);
            results.push([
                name
            ].concat(args));
        } else results.push([
            name
        ]);
    }
    return results;
}
function $beaf72e613ab97c3$var$buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles)for (const style of layer.styles)enabled[style[0]] = layer.inverse ? null : style.slice(1);
    let current = chalk;
    for (const [styleName, styles] of Object.entries(enabled)){
        if (!Array.isArray(styles)) continue;
        if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
        current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
    }
    return current;
}
module.exports = (chalk, temporary)=>{
    const styles = [];
    const chunks = [];
    let chunk = [];
    // eslint-disable-next-line max-params
    temporary.replace($beaf72e613ab97c3$var$TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{
        if (escapeCharacter) chunk.push($beaf72e613ab97c3$var$unescape(escapeCharacter));
        else if (style) {
            const string = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string : $beaf72e613ab97c3$var$buildStyle(chalk, styles)(string));
            styles.push({
                inverse: inverse,
                styles: $beaf72e613ab97c3$var$parseStyle(style)
            });
        } else if (close) {
            if (styles.length === 0) throw new Error("Found extraneous } in Chalk template literal");
            chunks.push($beaf72e613ab97c3$var$buildStyle(chalk, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
        } else chunk.push(character);
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
    }
    return chunks.join("");
};

});

parcelRegister("6PNpJ", function(module, exports) {
module.exports = `
<!-- 
    MDSvex comes in handy here because it takes frontmatter and shoves it into the metadata object.
    This means that all we need to do is build out the expected page metadata
-->
<!-- Show title as h1 if defined, and not hidden -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title) && metadata.hide_title !== true}
<h1 class="title">{metadata.title ?? metadata.og?.title}</h1>
{/if}
<svelte:head>
<!-- Title has a default case; so we need to handle it in a special way -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title)}
<title>{metadata.title ?? metadata.og?.title}</title>
<meta property="og:title" content={metadata.og?.title ?? metadata.title} />
<meta name="twitter:title" content={metadata.og?.title ?? metadata.title} />
{:else}
<!-- EITHER there is no metadata, or there is no specified style -->
<title>Evidence</title>
{/if}

<!-- default twitter cardtags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@evidence_dev" />

{#if typeof metadata === "object"}
{#if metadata.description || metadata.og?.description}
  <meta
    name="description"
    content={metadata.description ?? metadata.og?.description}
  />
  <meta
    property="og:description"
    content={metadata.og?.description ?? metadata.description}
  />
  <meta
    name="twitter:description"
    content={metadata.og?.description ?? metadata.description}
  />
{/if}
{#if metadata.og?.image}
  <meta property="og:image" content={metadata.og?.image} />
  <meta name="twitter:image" content={metadata.og?.image} />
{/if}
{/if}
</svelte:head>
`;

});

var $3fd82c6737eb24ad$exports = {};


var $49260c17099cae5e$exports = {};

(function(global1, factory) {
    factory($49260c17099cae5e$exports);
})($49260c17099cae5e$exports, function(exports1) {
    "use strict";
    const now = typeof process !== "undefined" && process.hrtime ? ()=>{
        const t = process.hrtime();
        return t[0] * 1e3 + t[1] / 1e6;
    } : ()=>self.performance.now();
    function collapse_timings(timings) {
        const result = {};
        timings.forEach((timing)=>{
            result[timing.label] = Object.assign({
                total: timing.end - timing.start
            }, timing.children && collapse_timings(timing.children));
        });
        return result;
    }
    class Stats {
        constructor(){
            this.start_time = now();
            this.stack = [];
            this.current_children = this.timings = [];
        }
        start(label) {
            const timing = {
                label: label,
                start: now(),
                end: null,
                children: []
            };
            this.current_children.push(timing);
            this.stack.push(timing);
            this.current_timing = timing;
            this.current_children = timing.children;
        }
        stop(label) {
            if (label !== this.current_timing.label) throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);
            this.current_timing.end = now();
            this.stack.pop();
            this.current_timing = this.stack[this.stack.length - 1];
            this.current_children = this.current_timing ? this.current_timing.children : this.timings;
        }
        render() {
            const timings = Object.assign({
                total: now() - this.start_time
            }, collapse_timings(this.timings));
            return {
                timings: timings
            };
        }
    }
    // This file was generated. Do not modify manually!
    var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        50,
        3,
        123,
        2,
        54,
        14,
        32,
        10,
        3,
        1,
        11,
        3,
        46,
        10,
        8,
        0,
        46,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        87,
        9,
        39,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        4706,
        45,
        3,
        22,
        543,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        357,
        0,
        62,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    // This file was generated. Do not modify manually!
    var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        13,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        2,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        68,
        310,
        10,
        21,
        11,
        7,
        25,
        5,
        2,
        41,
        2,
        8,
        70,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        43,
        17,
        47,
        20,
        28,
        22,
        13,
        52,
        58,
        1,
        3,
        0,
        14,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        38,
        6,
        186,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        19,
        72,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2637,
        96,
        16,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        18,
        78,
        18,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8936,
        3,
        2,
        6,
        2,
        1,
        2,
        290,
        46,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        1845,
        30,
        482,
        44,
        11,
        6,
        17,
        0,
        322,
        29,
        19,
        43,
        1269,
        6,
        2,
        3,
        2,
        1,
        2,
        14,
        2,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42719,
        33,
        4152,
        8,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ];
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierChars = "\u200C\u200D\xb7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    // These are a run-length and offset encoded representation of the
    // Reserved word lists for various dialects of the language
    var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
    };
    // And the keywords
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    // ## Character categories
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
        var pos = 0x10000;
        for(var i = 0; i < set.length; i += 2){
            pos += set[i];
            if (pos > code) return false;
            pos += set[i + 1];
            if (pos >= code) return true;
        }
    }
    // Test whether a given character code starts an identifier.
    function isIdentifierStart(code, astral) {
        if (code < 65) return code === 36;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123) return true;
        if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        if (astral === false) return false;
        return isInAstralSet(code, astralIdentifierStartCodes);
    }
    // Test whether a given character is part of an identifier.
    function isIdentifierChar(code, astral) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123) return true;
        if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        if (astral === false) return false;
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    // ## Token types
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    var TokenType = function TokenType(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
    };
    function binop(name, prec) {
        return new TokenType(name, {
            beforeExpr: true,
            binop: prec
        });
    }
    var beforeExpr = {
        beforeExpr: true
    }, startsExpr = {
        startsExpr: true
    };
    // Map keyword names to token types.
    var keywords = {};
    // Succinct definitions of keyword token types
    function kw(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
    }
    var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", {
            beforeExpr: true,
            startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
            beforeExpr: true,
            startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
            beforeExpr: true,
            startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
            beforeExpr: true,
            startsExpr: true
        }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", {
            beforeExpr: true,
            isAssign: true
        }),
        assign: new TokenType("_=", {
            beforeExpr: true,
            isAssign: true
        }),
        incDec: new TokenType("++/--", {
            prefix: true,
            postfix: true,
            startsExpr: true
        }),
        prefix: new TokenType("!/~", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
            beforeExpr: true,
            binop: 9,
            prefix: true,
            startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", {
            beforeExpr: true
        }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
            isLoop: true,
            beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", {
            isLoop: true
        }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", {
            isLoop: true
        }),
        _with: kw("with"),
        _new: kw("new", {
            beforeExpr: true,
            startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
            beforeExpr: true,
            binop: 7
        }),
        _instanceof: kw("instanceof", {
            beforeExpr: true,
            binop: 7
        }),
        _typeof: kw("typeof", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _void: kw("void", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _delete: kw("delete", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        })
    };
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
    }
    function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for(var i = from; i < end; i++){
            var next = code.charCodeAt(i);
            if (isNewLine(next)) return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
        }
        return -1;
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty$1 = ref.hasOwnProperty;
    var toString = ref.toString;
    var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty$1.call(obj, propName);
    };
    var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
    };
    function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
    }
    function codePointToString(code) {
        // UTF-16 Decoding
        if (code <= 0xFFFF) return String.fromCharCode(code);
        code -= 0x10000;
        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
    }
    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
    };
    Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
    };
    var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) this.source = p.sourceFile;
    };
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    function getLineInfo(input, offset) {
        for(var line = 1, cur = 0;;){
            var nextBreak = nextLineBreak(input, cur, offset);
            if (nextBreak < 0) return new Position(line, offset - cur);
            ++line;
            cur = nextBreak;
        }
    }
    // A second argument must be given to configure the parser process.
    // These options are recognized (only `ecmaVersion` is required):
    var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
    };
    // Interpret and default an options object
    var warnedAboutEcmaVersion = false;
    function getOptions(opts) {
        var options = {};
        for(var opt in defaultOptions)options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
        else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
                warnedAboutEcmaVersion = true;
                console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
        if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
        if (opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
        if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
                return tokens.push(token);
            };
        }
        if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
        return options;
    }
    function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
            var comment = {
                type: block ? "Block" : "Line",
                value: text,
                start: start,
                end: end
            };
            if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
            if (options.ranges) comment.range = [
                start,
                end
            ];
            array.push(comment);
        };
    }
    // Each scope gets a bitset that may contain these flags
    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    // Used in checkLVal* and declareName to determine the type of a binding
    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
    var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") reserved += " await";
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        // Used to signal to callers of `readWord1` whether the word
        // contained any escape sequences. This is needed because words with
        // escape sequences must not be interpreted as keywords.
        this.containsEsc = false;
        // Set up token state
        // The current position of the tokenizer in the input.
        if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
        }
        // Properties of the current token:
        // Its type
        this.type = types$1.eof;
        // For tokens that include more information than their type, the value
        this.value = null;
        // Its start and end offset
        this.start = this.end = this.pos;
        // And, if locations are used, the {line, column} object
        // corresponding to those offsets
        this.startLoc = this.endLoc = this.curPosition();
        // Position information for the previous token
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        // The context stack is used to superficially track syntactic
        // context to predict whether a regular expression is allowed in a
        // given position.
        this.context = this.initialContext();
        this.exprAllowed = true;
        // Figure out if it's a module code.
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        // Used to signify the start of a potential arrow function
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        // Positions to delayed-check that yield/await does not exist in default parameters.
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        // Labels in scope.
        this.labels = [];
        // Thus-far undefined exports.
        this.undefinedExports = Object.create(null);
        // If enabled, skip leading hashbang line.
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
        // Scope tracking for duplicate variable names (see scope.js)
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        // For RegExp validation
        this.regexpState = null;
        // The stack of private names.
        // Each element has two properties: 'declared' and 'used'.
        // When it exited from the outermost class definition, all used private names must be declared.
        this.privateNameStack = [];
    };
    var prototypeAccessors = {
        inFunction: {
            configurable: true
        },
        inGenerator: {
            configurable: true
        },
        inAsync: {
            configurable: true
        },
        canAwait: {
            configurable: true
        },
        allowSuper: {
            configurable: true
        },
        allowDirectSuper: {
            configurable: true
        },
        treatFunctionsAsVar: {
            configurable: true
        },
        allowNewDotTarget: {
            configurable: true
        },
        inClassStaticBlock: {
            configurable: true
        }
    };
    Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
        for(var i = this.scopeStack.length - 1; i >= 0; i--){
            var scope = this.scopeStack[i];
            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) return false;
            if (scope.flags & SCOPE_FUNCTION) return (scope.flags & SCOPE_ASYNC) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while(len--)plugins[len] = arguments[len];
        var cls = this;
        for(var i = 0; i < plugins.length; i++)cls = plugins[i](cls);
        return cls;
    };
    Parser.parse = function parse(input, options) {
        return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    var pp$9 = Parser.prototype;
    // ## Parser utilities
    var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) return false;
        for(;;){
            // Try to find string literal.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            var match = literal.exec(this.input.slice(start));
            if (!match) return false;
            if ((match[1] || match[2]) === "use strict") {
                skipWhiteSpace.lastIndex = start + match[0].length;
                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
                var next = this.input.charAt(end);
                return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
            }
            start += match[0].length;
            // Skip semicolon, if any.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            if (this.input[start] === ";") start++;
        }
    };
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    pp$9.eat = function(type) {
        if (this.type === type) {
            this.next();
            return true;
        } else return false;
    };
    // Tests whether parsed token is a contextual keyword.
    pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    // Consumes contextual keyword if possible.
    pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) return false;
        this.next();
        return true;
    };
    // Asserts that following token is given contextual keyword.
    pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) this.unexpected();
    };
    // Test whether a semicolon can be inserted at the current position.
    pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            return true;
        }
    };
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
            if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            if (!notNext) this.next();
            return true;
        }
    };
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
    };
    // Raise an unexpected token error.
    pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    var DestructuringErrors = function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) return;
        if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) return false;
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
        if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
        if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
    };
    pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
        return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$8 = Parser.prototype;
    // ### Statement parsing
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    pp$8.parseTopLevel = function(node) {
        var exports1 = Object.create(null);
        if (!node.body) node.body = [];
        while(this.type !== types$1.eof){
            var stmt = this.parseStatement(null, true, exports1);
            node.body.push(stmt);
        }
        if (this.inModule) for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
    };
    var loopLabel = {
        kind: "loop"
    }, switchLabel = {
        kind: "switch"
    };
    pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        // For ambiguous cases, determine if a LexicalDeclaration (or only a
        // Statement) is allowed here. If context is not empty then only a Statement
        // is allowed. However, `let [` is an explicit negative lookahead for
        // ExpressionStatement, so special-case it first.
        if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;
         // '[', '/', astral
        if (context) return false;
        if (nextCh === 123) return true;
         // '{'
        if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true))++pos;
            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) return true;
        }
        return false;
    };
    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));
    };
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    pp$8.parseStatement = function(context, topLevel, exports1) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
            starttype = types$1._var;
            kind = "let";
        }
        // Most types of statements are recognized by the keyword they
        // start with. Many are trivial to parse, some require a bit of
        // complexity.
        switch(starttype){
            case types$1._break:
            case types$1._continue:
                return this.parseBreakContinueStatement(node, starttype.keyword);
            case types$1._debugger:
                return this.parseDebuggerStatement(node);
            case types$1._do:
                return this.parseDoStatement(node);
            case types$1._for:
                return this.parseForStatement(node);
            case types$1._function:
                // Function as sole body of either an if statement or a labeled statement
                // works, but not when it is part of a labeled statement that is the sole
                // body of an if statement.
                if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
                return this.parseFunctionStatement(node, false, !context);
            case types$1._class:
                if (context) this.unexpected();
                return this.parseClass(node, true);
            case types$1._if:
                return this.parseIfStatement(node);
            case types$1._return:
                return this.parseReturnStatement(node);
            case types$1._switch:
                return this.parseSwitchStatement(node);
            case types$1._throw:
                return this.parseThrowStatement(node);
            case types$1._try:
                return this.parseTryStatement(node);
            case types$1._const:
            case types$1._var:
                kind = kind || this.value;
                if (context && kind !== "var") this.unexpected();
                return this.parseVarStatement(node, kind);
            case types$1._while:
                return this.parseWhileStatement(node);
            case types$1._with:
                return this.parseWithStatement(node);
            case types$1.braceL:
                return this.parseBlock(true, node);
            case types$1.semi:
                return this.parseEmptyStatement(node);
            case types$1._export:
            case types$1._import:
                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
                    skipWhiteSpace.lastIndex = this.pos;
                    var skip = skipWhiteSpace.exec(this.input);
                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                    if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
                }
                if (!this.options.allowImportExportEverywhere) {
                    if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                    if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                }
                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);
            // If the statement does not start with a statement keyword or a
            // brace, it's an ExpressionStatement or LabeledStatement. We
            // simply start parsing an expression, and afterwards, if the
            // next token is a colon and the expression was a simple
            // Identifier node, we switch to interpreting it as a label.
            default:
                if (this.isAsyncFunction()) {
                    if (context) this.unexpected();
                    this.next();
                    return this.parseFunctionStatement(node, true, !context);
                }
                var maybeName = this.value, expr = this.parseExpression();
                if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
                else return this.parseExpressionStatement(node, expr);
        }
    };
    pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
        else if (this.type !== types$1.name) this.unexpected();
        else {
            node.label = this.parseIdent();
            this.semicolon();
        }
        // Verify that there is an actual destination to break or
        // continue to.
        var i = 0;
        for(; i < this.labels.length; ++i){
            var lab = this.labels[i];
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                if (node.label && isBreak) break;
            }
        }
        if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
        else this.semicolon();
        return this.finishNode(node, "DoWhileStatement");
    };
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
                if (this.options.ecmaVersion >= 9) {
                    if (this.type === types$1._in) {
                        if (awaitAt > -1) this.unexpected(awaitAt);
                    } else node.await = awaitAt > -1;
                }
                return this.parseForIn(node, init$1);
            }
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors;
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (this.options.ecmaVersion >= 9) {
                if (this.type === types$1._in) {
                    if (awaitAt > -1) this.unexpected(awaitAt);
                } else node.await = awaitAt > -1;
            }
            if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node, init);
        } else this.checkExpressionErrors(refDestructuringErrors, true);
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, init);
    };
    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        // allow function declarations in branches, but only in non-strict mode
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
        this.next();
        // In `return` (and `break`/`continue`), the keywords with
        // optional arguments, we eagerly look for a semicolon or the
        // possibility to insert one.
        if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
        else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        // Statements under must be grouped (by label) in SwitchCase
        // nodes. `cur` is used to keep the node that we are currently
        // adding statements to.
        var cur;
        for(var sawDefault = false; this.type !== types$1.braceR;)if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) this.finishNode(cur, "SwitchCase");
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) cur.test = this.parseExpression();
            else {
                if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                sawDefault = true;
                cur.test = null;
            }
            this.expect(types$1.colon);
        } else {
            if (!cur) this.unexpected();
            cur.consequent.push(this.parseStatement(null));
        }
        this.exitScope();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next(); // Closing brace
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
    };
    // Reused empty array added for node fields that are always empty.
    var empty$1 = [];
    pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) {
                clause.param = this.parseBindingAtom();
                var simple = clause.param.type === "Identifier";
                this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
                this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
                this.expect(types$1.parenR);
            } else {
                if (this.options.ecmaVersion < 10) this.unexpected();
                clause.param = null;
                this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
        return this.finishNode(node, "TryStatement");
    };
    pp$8.parseVarStatement = function(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node) {
        if (this.strict) this.raise(this.start, "'with' in strict mode");
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){
            var label = list[i$1];
            if (label.name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for(var i = this.labels.length - 1; i >= 0; i--){
            var label$1 = this.labels[i];
            if (label$1.statementStart === node.start) {
                // Update information about previous labels on this node
                label$1.statementStart = this.start;
                label$1.kind = kind;
            } else break;
        }
        this.labels.push({
            name: maybeName,
            kind: kind,
            statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
    };
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) this.enterScope(0);
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        if (exitStrict) this.strict = false;
        this.next();
        if (createNewLexicalScope) this.exitScope();
        return this.finishNode(node, "BlockStatement");
    };
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
    };
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    // Parse a list of variable declarations.
    pp$8.parseVar = function(node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for(;;){
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$1.eq)) decl.init = this.parseMaybeAssign(isFor);
            else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
            else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            else decl.init = null;
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$1.comma)) break;
        }
        return node;
    };
    pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).
    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
            node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        if (statement & FUNC_STATEMENT) {
            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1.name ? this.parseIdent() : null;
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
    };
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    pp$8.parseClass = function(node, isStatement) {
        this.next();
        // ecma-262 14.6 Class Definitions
        // A class definition is always strict mode code.
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while(this.type !== types$1.braceR){
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
                classBody.body.push(element);
                if (element.type === "MethodDefinition" && element.kind === "constructor") {
                    if (hadConstructor) this.raise(element.start, "Duplicate constructor in the same class");
                    hadConstructor = true;
                } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) return null;
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
            // Parse static init block
            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
                this.parseClassStaticBlock(node);
                return node;
            }
            if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
            else keyName = "static";
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
            else keyName = "async";
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
        if (!keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) kind = lastValue;
                else keyName = lastValue;
            }
        }
        // Parse element name
        if (keyName) {
            // 'async', 'get', 'set', or 'static' were not a keyword contextually.
            // The last token is any of those. Make it the element name.
            node.computed = false;
            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node.key.name = keyName;
            this.finishNode(node.key, "Identifier");
        } else this.parseClassElementName(node);
        // Parse element value
        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName(node, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
            if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
            node.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else this.parseClassField(node);
        return node;
    };
    pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
            if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
            element.computed = false;
            element.key = this.parsePrivateIdent();
        } else this.parsePropertyName(element);
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        // Check key and flags
        var key = method.key;
        if (method.kind === "constructor") {
            if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
            if (isAsync) this.raise(key.start, "Constructor can't be an async method");
        } else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
        // Parse value
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        // Check value
        if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
        if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        if (this.eat(types$1.eq)) {
            // To raise SyntaxError if 'arguments' exists in the initializer.
            var scope = this.currentThisScope();
            var inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true;
            field.value = this.parseMaybeAssign();
            scope.inClassFieldInit = inClassFieldInit;
        } else field.value = null;
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
    };
    pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
            node.id = this.parseIdent();
            if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
        } else {
            if (isStatement === true) this.unexpected();
            node.id = null;
        }
    };
    pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
    };
    pp$8.enterClassBody = function() {
        var element = {
            declared: Object.create(null),
            used: []
        };
        this.privateNameStack.push(element);
        return element.declared;
    };
    pp$8.exitClassBody = function() {
        var ref = this.privateNameStack.pop();
        var declared = ref.declared;
        var used = ref.used;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for(var i = 0; i < used.length; ++i){
            var id = used[i];
            if (!hasOwn(declared, id.name)) {
                if (parent) parent.used.push(id);
                else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
        }
    };
    function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
        // `class { get #a(){}; static set #a(_){} }` is also conflict.
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name] = "true";
            return false;
        } else if (!curr) {
            privateNameMap[name] = next;
            return false;
        } else return true;
    }
    function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
    }
    // Parses module export declaration.
    pp$8.parseExport = function(node, exports1) {
        this.next();
        // export * from '...'
        if (this.eat(types$1.star)) {
            if (this.options.ecmaVersion >= 11) {
                if (this.eatContextual("as")) {
                    node.exported = this.parseModuleExportName();
                    this.checkExport(exports1, node.exported, this.lastTokStart);
                } else node.exported = null;
            }
            this.expectContextual("from");
            if (this.type !== types$1.string) this.unexpected();
            node.source = this.parseExprAtom();
            this.semicolon();
            return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types$1._default)) {
            this.checkExport(exports1, "default", this.lastTokStart);
            var isAsync;
            if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
                var fNode = this.startNode();
                this.next();
                if (isAsync) this.next();
                node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
            } else if (this.type === types$1._class) {
                var cNode = this.startNode();
                node.declaration = this.parseClass(cNode, "nullableID");
            } else {
                node.declaration = this.parseMaybeAssign();
                this.semicolon();
            }
            return this.finishNode(node, "ExportDefaultDeclaration");
        }
        // export var|const|let|function|class ...
        if (this.shouldParseExportStatement()) {
            node.declaration = this.parseStatement(null);
            if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports1, node.declaration.declarations);
            else this.checkExport(exports1, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
        } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports1);
            if (this.eatContextual("from")) {
                if (this.type !== types$1.string) this.unexpected();
                node.source = this.parseExprAtom();
            } else {
                for(var i = 0, list = node.specifiers; i < list.length; i += 1){
                    // check for keywords used as local names
                    var spec = list[i];
                    this.checkUnreserved(spec.local);
                    // check if export is defined
                    this.checkLocalExport(spec.local);
                    if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                }
                node.source = null;
            }
            this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$8.checkExport = function(exports1, name, pos) {
        if (!exports1) return;
        if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
        if (hasOwn(exports1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        exports1[name] = true;
    };
    pp$8.checkPatternExport = function(exports1, pat) {
        var type = pat.type;
        if (type === "Identifier") this.checkExport(exports1, pat, pat.start);
        else if (type === "ObjectPattern") for(var i = 0, list = pat.properties; i < list.length; i += 1){
            var prop = list[i];
            this.checkPatternExport(exports1, prop);
        }
        else if (type === "ArrayPattern") for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){
            var elt = list$1[i$1];
            if (elt) this.checkPatternExport(exports1, elt);
        }
        else if (type === "Property") this.checkPatternExport(exports1, pat.value);
        else if (type === "AssignmentPattern") this.checkPatternExport(exports1, pat.left);
        else if (type === "RestElement") this.checkPatternExport(exports1, pat.argument);
        else if (type === "ParenthesizedExpression") this.checkPatternExport(exports1, pat.expression);
    };
    pp$8.checkVariableExport = function(exports1, decls) {
        if (!exports1) return;
        for(var i = 0, list = decls; i < list.length; i += 1){
            var decl = list[i];
            this.checkPatternExport(exports1, decl.id);
        }
    };
    pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    // Parses a comma-separated list of module exports.
    pp$8.parseExportSpecifiers = function(exports1) {
        var nodes = [], first = true;
        // export { x, y as z } [from '...']
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            var node = this.startNode();
            node.local = this.parseModuleExportName();
            node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
            this.checkExport(exports1, node.exported, node.exported.start);
            nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
    };
    // Parses import declaration.
    pp$8.parseImport = function(node) {
        this.next();
        // import '...'
        if (this.type === types$1.string) {
            node.specifiers = empty$1;
            node.source = this.parseExprAtom();
        } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
    };
    // Parses a comma-separated list of module imports.
    pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
            // import defaultObj, { x, y as z } from '...'
            var node = this.startNode();
            node.local = this.parseIdent();
            this.checkLValSimple(node.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
            if (!this.eat(types$1.comma)) return nodes;
        }
        if (this.type === types$1.star) {
            var node$1 = this.startNode();
            this.next();
            this.expectContextual("as");
            node$1.local = this.parseIdent();
            this.checkLValSimple(node$1.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
            return nodes;
        }
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            var node$2 = this.startNode();
            node$2.imported = this.parseModuleExportName();
            if (this.eatContextual("as")) node$2.local = this.parseIdent();
            else {
                this.checkUnreserved(node$2.imported);
                node$2.local = node$2.imported;
            }
            this.checkLValSimple(node$2.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
    };
    pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
            var stringLiteral = this.parseLiteral(this.value);
            if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            return stringLiteral;
        }
        return this.parseIdent(true);
    };
    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$8.adaptDirectivePrologue = function(statements) {
        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i)statements[i].directive = statements[i].expression.raw.slice(1, -1);
    };
    pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$7 = Parser.prototype;
    // Convert existing expression atom to assignable pattern
    // if possible.
    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) switch(node.type){
            case "Identifier":
                if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
                break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                break;
            case "ObjectExpression":
                node.type = "ObjectPattern";
                if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
                for(var i = 0, list = node.properties; i < list.length; i += 1){
                    var prop = list[i];
                    this.toAssignable(prop, isBinding);
                    // Early error:
                    //   AssignmentRestProperty[Yield, Await] :
                    //     `...` DestructuringAssignmentTarget[Yield, Await]
                    //
                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                    if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
                }
                break;
            case "Property":
                // AssignmentProperty has type === "Property"
                if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
                this.toAssignable(node.value, isBinding);
                break;
            case "ArrayExpression":
                node.type = "ArrayPattern";
                if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
                this.toAssignableList(node.elements, isBinding);
                break;
            case "SpreadElement":
                node.type = "RestElement";
                this.toAssignable(node.argument, isBinding);
                if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
                break;
            case "AssignmentExpression":
                if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                node.type = "AssignmentPattern";
                delete node.operator;
                this.toAssignable(node.left, isBinding);
                break;
            case "ParenthesizedExpression":
                this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                break;
            case "ChainExpression":
                this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                break;
            case "MemberExpression":
                if (!isBinding) break;
            default:
                this.raise(node.start, "Assigning to rvalue");
        }
        else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
        return node;
    };
    // Convert list of expression atoms to binding list.
    pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for(var i = 0; i < end; i++){
            var elt = exprList[i];
            if (elt) this.toAssignable(elt, isBinding);
        }
        if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
        }
        return exprList;
    };
    // Parses spread element.
    pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        // RestElement inside of a function parameter must be an identifier
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
    };
    // Parses lvalue (assignable) atom.
    pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) switch(this.type){
            case types$1.bracketL:
                var node = this.startNode();
                this.next();
                node.elements = this.parseBindingList(types$1.bracketR, true, true);
                return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
                return this.parseObj(true);
        }
        return this.parseIdent();
    };
    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (first) first = false;
            else this.expect(types$1.comma);
            if (allowEmpty && this.type === types$1.comma) elts.push(null);
            else if (allowTrailingComma && this.afterTrailingComma(close)) break;
            else if (this.type === types$1.ellipsis) {
                var rest = this.parseRestBinding();
                this.parseBindingListItem(rest);
                elts.push(rest);
                if (this.type === types$1.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                this.expect(close);
                break;
            } else {
                var elem = this.parseMaybeDefault(this.start, this.startLoc);
                this.parseBindingListItem(elem);
                elts.push(elem);
            }
        }
        return elts;
    };
    pp$7.parseBindingListItem = function(param) {
        return param;
    };
    // Parses assignment pattern around given atom if possible.
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
    };
    // The following three functions all verify that a node is an lvalue —
    // something that can be bound, or assigned to. In order to do so, they perform
    // a variety of checks:
    //
    // - Check that none of the bound/assigned-to identifiers are reserved words.
    // - Record name declarations for bindings in the appropriate scope.
    // - Check duplicate argument names, if checkClashes is set.
    //
    // If a complex binding pattern is encountered (e.g., object and array
    // destructuring), the entire pattern is recursively checked.
    //
    // There are three versions of checkLVal*() appropriate for different
    // circumstances:
    //
    // - checkLValSimple() shall be used if the syntactic construct supports
    //   nothing other than identifiers and member expressions. Parenthesized
    //   expressions are also correctly handled. This is generally appropriate for
    //   constructs for which the spec says
    //
    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   It is also appropriate for checking if an identifier is valid and not
    //   defined elsewhere, like import declarations or function/class identifiers.
    //
    //   Examples where this is used include:
    //     a += …;
    //     import a from '…';
    //   where a is the node to be checked.
    //
    // - checkLValPattern() shall be used if the syntactic construct supports
    //   anything checkLValSimple() supports, as well as object and array
    //   destructuring patterns. This is generally appropriate for constructs for
    //   which the spec says
    //
    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   Examples where this is used include:
    //     (a = …);
    //     const a = …;
    //     try { … } catch (a) { … }
    //   where a is the node to be checked.
    //
    // - checkLValInnerPattern() shall be used if the syntactic construct supports
    //   anything checkLValPattern() supports, as well as default assignment
    //   patterns, rest elements, and other constructs that may appear within an
    //   object or array destructuring pattern.
    //
    //   As a special case, function parameters also use checkLValInnerPattern(),
    //   as they also support defaults and rest constructs.
    //
    // These functions deliberately support both assignment and binding constructs,
    // as the logic for both is exceedingly similar. If the node is the target of
    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
    // should be set to the appropriate BIND_* constant, like BIND_VAR or
    // BIND_LEXICAL.
    //
    // If the function is called with a non-BIND_NONE bindingType, then
    // additionally a checkClashes object may be specified to allow checking for
    // duplicate argument names. checkClashes is ignored if the provided construct
    // is an assignment (i.e., bindingType is BIND_NONE).
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch(expr.type){
            case "Identifier":
                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
                if (isBind) {
                    if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
                    if (checkClashes) {
                        if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                        checkClashes[expr.name] = true;
                    }
                    if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
                }
                break;
            case "ChainExpression":
                this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
                break;
            case "MemberExpression":
                if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
                break;
            case "ParenthesizedExpression":
                if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
                return this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
                this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "ObjectPattern":
                for(var i = 0, list = expr.properties; i < list.length; i += 1){
                    var prop = list[i];
                    this.checkLValInnerPattern(prop, bindingType, checkClashes);
                }
                break;
            case "ArrayPattern":
                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){
                    var elem = list$1[i$1];
                    if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
                }
                break;
            default:
                this.checkLValSimple(expr, bindingType, checkClashes);
        }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "Property":
                // AssignmentProperty has type === "Property"
                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
                break;
            case "AssignmentPattern":
                this.checkLValPattern(expr.left, bindingType, checkClashes);
                break;
            case "RestElement":
                this.checkLValPattern(expr.argument, bindingType, checkClashes);
                break;
            default:
                this.checkLValPattern(expr, bindingType, checkClashes);
        }
    };
    // The algorithm used to determine whether a regexp can appear at a
    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
    };
    var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
            return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
        return [
            types.b_stat
        ];
    };
    pp$6.curContext = function() {
        return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) return true;
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) return !parent.isExpr;
        // The check for `tt.name && exprAllowed` detects whether we are
        // after a `yield` or `of` construct. See the `updateContext` for
        // `tt.name`.
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
        if (prevType === types$1.braceL) return parent === types.b_stat;
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
        return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
        for(var i = this.context.length - 1; i >= 1; i--){
            var context = this.context[i];
            if (context.token === "function") return context.generator;
        }
        return false;
    };
    pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) this.exprAllowed = false;
        else if (update = type.updateContext) update.call(this, prevType);
        else this.exprAllowed = type.beforeExpr;
    };
    // Used to handle egde cases when token context could not be inferred correctly during tokenization phase
    pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
    };
    // Token-specific context update code
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
            this.exprAllowed = true;
            return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") out = this.context.pop();
        this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
        else this.context.push(types.f_stat);
        this.exprAllowed = false;
    };
    types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) this.context.pop();
        else this.context.push(types.q_tmpl);
        this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
            var index = this.context.length - 1;
            if (this.context[index] === types.f_expr) this.context[index] = types.f_expr_gen;
            else this.context[index] = types.f_gen;
        }
        this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
            if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
        }
        this.exprAllowed = allowed;
    };
    // A recursive descent parser operates by defining functions for all
    var pp$5 = Parser.prototype;
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
        var key = prop.key;
        var name;
        switch(key.type){
            case "Identifier":
                name = key.name;
                break;
            case "Literal":
                name = String(key.value);
                break;
            default:
                return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
                if (propHash.proto) {
                    if (refDestructuringErrors) {
                        if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
                    } else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                }
                propHash.proto = true;
            }
            return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
            var redefinition;
            if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
            else redefinition = other.init || other[kind];
            if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
        } else other = propHash[name] = {
            init: false,
            get: false,
            set: false
        };
        other[kind] = true;
    };
    // ### Expression parsing
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [
                expr
            ];
            while(this.eat(types$1.comma))node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            return this.finishNode(node, "SequenceExpression");
        }
        return expr;
    };
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(forInit);
            else this.exprAllowed = false;
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
            refDestructuringErrors = new DestructuringErrors;
            ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
            this.potentialArrowAt = this.start;
            this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
            if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
             // reset because shorthand default was used correctly
            if (this.type === types$1.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
            node.left = left;
            this.next();
            node.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
            return this.finishNode(node, "AssignmentExpression");
        } else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
    };
    // Parse a ternary conditional (`?:`) operator.
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (this.eat(types$1.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types$1.colon);
            node.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
    };
    // Start the precedence parser.
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
            if (prec > minPrec) {
                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
                var coalesce = this.type === types$1.coalesce;
                if (coalesce) // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
                // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
                prec = types$1.logicalAND.binop;
                var op = this.value;
                this.next();
                var startPos = this.start, startLoc = this.startLoc;
                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
            }
        }
        return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    // Parse unary operators, both prefix and postfix.
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
        } else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types$1.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) this.checkLValSimple(node.argument);
            else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
            else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
            else sawUnary = true;
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
            if (forInit || this.privateNameStack.length === 0) this.unexpected();
            expr = this.parsePrivateIdent();
            // only could be private fields in 'in', such as #x in obj
            if (this.type !== types$1._in) this.unexpected();
        } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
            while(this.type.postfix && !this.canInsertSemicolon()){
                var node$1 = this.startNodeAt(startPos, startLoc);
                node$1.operator = this.value;
                node$1.prefix = false;
                node$1.argument = expr;
                this.checkLValSimple(expr);
                this.next();
                expr = this.finishNode(node$1, "UpdateExpression");
            }
        }
        if (!incDec && this.eat(types$1.starstar)) {
            if (sawUnary) this.unexpected(this.lastTokStart);
            else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        } else return expr;
    };
    function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
    }
    // Parse call, dot, and `[]`-subscript expressions.
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
            if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
            if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
        }
        return result;
    };
    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while(true){
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional) optionalChained = true;
            if (element === base || element.type === "ArrowFunctionExpression") {
                if (optionalChained) {
                    var chainNode = this.startNodeAt(startPos, startLoc);
                    chainNode.expression = element;
                    element = this.finishNode(chainNode, "ChainExpression");
                }
                return element;
            }
            base = element;
        }
    };
    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            if (computed) {
                node.property = this.parseExpression();
                this.expect(types$1.bracketR);
            } else if (this.type === types$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
            else node.property = this.parseIdent(this.options.allowReserved !== "never");
            node.computed = !!computed;
            if (optionalSupported) node.optional = optional;
            base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                this.awaitIdentPos = oldAwaitIdentPos;
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) node$1.optional = optional;
            base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
            if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({
                isTagged: true
            });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
    };
    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
        // If a division operator appears in an expression position, the
        // tokenizer got confused, and we force it to read a regexp instead.
        if (this.type === types$1.slash) this.readRegexp();
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch(this.type){
            case types$1._super:
                if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
                node = this.startNode();
                this.next();
                if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
                // The `super` keyword can appear at below:
                // SuperProperty:
                //     super [ Expression ]
                //     super . IdentifierName
                // SuperCall:
                //     super ( Arguments )
                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
                return this.finishNode(node, "Super");
            case types$1._this:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression");
            case types$1.name:
                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
                var id = this.parseIdent(false);
                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
                    this.overrideContext(types.f_expr);
                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
                }
                if (canBeArrow && !this.canInsertSemicolon()) {
                    if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                        id
                    ], false, forInit);
                    if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                        id = this.parseIdent(false);
                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                            id
                        ], true, forInit);
                    }
                }
                return id;
            case types$1.regexp:
                var value = this.value;
                node = this.parseLiteral(value.value);
                node.regex = {
                    pattern: value.pattern,
                    flags: value.flags
                };
                return node;
            case types$1.num:
            case types$1.string:
                return this.parseLiteral(this.value);
            case types$1._null:
            case types$1._true:
            case types$1._false:
                node = this.startNode();
                node.value = this.type === types$1._null ? null : this.type === types$1._true;
                node.raw = this.type.keyword;
                this.next();
                return this.finishNode(node, "Literal");
            case types$1.parenL:
                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
                if (refDestructuringErrors) {
                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
                    if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
                }
                return expr;
            case types$1.bracketL:
                node = this.startNode();
                this.next();
                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
                return this.finishNode(node, "ArrayExpression");
            case types$1.braceL:
                this.overrideContext(types.b_expr);
                return this.parseObj(false, refDestructuringErrors);
            case types$1._function:
                node = this.startNode();
                this.next();
                return this.parseFunction(node, 0);
            case types$1._class:
                return this.parseClass(this.startNode(), false);
            case types$1._new:
                return this.parseNew();
            case types$1.backQuote:
                return this.parseTemplate();
            case types$1._import:
                if (this.options.ecmaVersion >= 11) return this.parseExprImport();
                else return this.unexpected();
            default:
                this.unexpected();
        }
    };
    pp$5.parseExprImport = function() {
        var node = this.startNode();
        // Consume `import` as an identifier for `import.meta`.
        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        var meta = this.parseIdent(true);
        switch(this.type){
            case types$1.parenL:
                return this.parseDynamicImport(node);
            case types$1.dot:
                node.meta = meta;
                return this.parseImportMeta(node);
            default:
                this.unexpected();
        }
    };
    pp$5.parseDynamicImport = function(node) {
        this.next(); // skip `(`
        // Parse node.source.
        node.source = this.parseMaybeAssign();
        // Verify ending.
        if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            else this.unexpected(errorPos);
        }
        return this.finishNode(node, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node) {
        this.next(); // skip `.`
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        return this.finishNode(node, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        this.next();
        return this.finishNode(node, "Literal");
    };
    pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            // Do not save awaitIdentPos to allow checking awaits nested in parameters
            while(this.type !== types$1.parenR){
                first ? first = false : this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
                    lastIsComma = true;
                    break;
                } else if (this.type === types$1.ellipsis) {
                    spreadStart = this.start;
                    exprList.push(this.parseParenItem(this.parseRestBinding()));
                    if (this.type === types$1.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                    break;
                } else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            this.expect(types$1.parenR);
            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
            if (spreadStart) this.unexpected(spreadStart);
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else val = exprList[0];
        } else val = this.parseParenExpression();
        if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
        } else return val;
    };
    pp$5.parseParenItem = function(item) {
        return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.
    var empty = [];
    pp$5.parseNew = function() {
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
            node.meta = meta;
            var containsEsc = this.containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
            if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
            if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
            return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") this.raise(startPos, "Cannot use new with import()");
        if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        else node.arguments = empty;
        return this.finishNode(node, "NewExpression");
    };
    // Parse template expression.
    pp$5.parseTemplateElement = function(ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
            if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            elem.value = {
                raw: this.value,
                cooked: null
            };
        } else elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
        };
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref) {
        if (ref === void 0) ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({
            isTagged: isTagged
        });
        node.quasis = [
            curElt
        ];
        while(!curElt.tail){
            if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
            this.expect(types$1.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types$1.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({
                isTagged: isTagged
            }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    // Parse an object literal or binding pattern.
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
            node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            if (isPattern) {
                prop.argument = this.parseIdent(false);
                if (this.type === types$1.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                return this.finishNode(prop, "RestElement");
            }
            // Parse argument.
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            // To disallow trailing comma via `this.toAssignable()`.
            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
            // Finish
            return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
                startPos = this.start;
                startLoc = this.startLoc;
            }
            if (!isPattern) isGenerator = this.eat(types$1.star);
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop, refDestructuringErrors);
        } else isAsync = false;
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
        if (this.eat(types$1.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
            if (isPattern) this.unexpected();
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
            if (isGenerator || isAsync) this.unexpected();
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
            var paramCount = prop.kind === "get" ? 0 : 1;
            if (prop.value.params.length !== paramCount) {
                var start = prop.value.start;
                if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
                else this.raiseRecoverable(start, "setter should have exactly one param");
            } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) this.unexpected();
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
            prop.kind = "init";
            if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            else if (this.type === types$1.eq && refDestructuringErrors) {
                if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else prop.value = this.copyNode(prop.key);
            prop.shorthand = true;
        } else this.unexpected();
    };
    pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$1.bracketL)) {
                prop.computed = true;
                prop.key = this.parseMaybeAssign();
                this.expect(types$1.bracketR);
                return prop.key;
            } else prop.computed = false;
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    // Initialize empty function node.
    pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
        if (this.options.ecmaVersion >= 8) node.async = false;
    };
    // Parse object or class method.
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
    };
    // Parse arrow function expression with given parameters.
    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
    };
    // Parse function body and check parameters.
    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
            node.body = this.parseMaybeAssign(forInit);
            node.expression = true;
            this.checkParams(node, false);
        } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
                useStrict = this.strictDirective(this.end);
                // If this is a strict mode function, verify that argument names
                // are not repeated, and it does not try to bind the words `eval`
                // or `arguments`.
                if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
            // Start a new scope with regard to labels and the `inFunction`
            // flag (restore them to their old value afterwards).
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) this.strict = true;
            // Add the params to varDeclaredNames to ensure that an error is thrown
            // if a let/const declaration in the function clashes with one of the params.
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
            if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            this.labels = oldLabels;
        }
        this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
        for(var i = 0, list = params; i < list.length; i += 1){
            var param = list[i];
            if (param.type !== "Identifier") return false;
        }
        return true;
    };
    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.
    pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = Object.create(null);
        for(var i = 0, list = node.params; i < list.length; i += 1){
            var param = list[i];
            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
    };
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (!first) {
                this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(close)) break;
            } else first = false;
            var elt = void 0;
            if (allowEmpty && this.type === types$1.comma) elt = null;
            else if (this.type === types$1.ellipsis) {
                elt = this.parseSpread(refDestructuringErrors);
                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
            } else elt = this.parseMaybeAssign(false, refDestructuringErrors);
            elts.push(elt);
        }
        return elts;
    };
    pp$5.checkUnreserved = function(ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        if (this.currentThisScope().inClassFieldInit && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
        if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
            if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
            this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
    };
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    pp$5.parseIdent = function(liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types$1.name) node.name = this.value;
        else if (this.type.keyword) {
            node.name = this.type.keyword;
            // To fix https://github.com/acornjs/acorn/issues/575
            // `class` and `function` keywords push new context into this.context.
            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
            if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
        } else this.unexpected();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
        }
        return node;
    };
    pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) node.name = this.value;
        else this.unexpected();
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        // For validating existence
        if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
        else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        return node;
    };
    // Parses yield expression inside generator.
    pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) this.yieldPos = this.start;
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
        } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) this.awaitPos = this.start;
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
    };
    var pp$4 = Parser.prototype;
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
        if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
    };
    var pp$3 = Parser.prototype;
    var Scope = function Scope(flags) {
        this.flags = flags;
        // A list of var-declared names in the current lexical scope
        this.var = [];
        // A list of lexically-declared names in the current lexical scope
        this.lexical = [];
        // A list of lexically-declared FunctionDeclaration names in the current lexical scope
        this.functions = [];
        // A switch to disallow the identifier reference 'arguments'
        this.inClassFieldInit = false;
    };
    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
    pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
        this.scopeStack.pop();
    };
    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
        } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
            else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
            scope$2.functions.push(name);
        } else for(var i = this.scopeStack.length - 1; i >= 0; --i){
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
            if (scope$3.flags & SCOPE_VAR) break;
        }
        if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
    };
    pp$3.checkLocalExport = function(id) {
        // scope.functions must be empty as Module code is always strict.
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
    };
    pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR) return scope;
        }
    };
    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$3.currentThisScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
        }
    };
    var Node = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
        if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
        if (parser.options.ranges) this.range = [
            pos,
            0
        ];
    };
    // Start an AST node, attaching a start offset.
    var pp$2 = Parser.prototype;
    pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
    };
    // Finish an AST node, adding `type` and `end` properties.
    function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) node.loc.end = loc;
        if (this.options.ranges) node.range[1] = pos;
        return node;
    }
    pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    // Finish node at given position
    pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
    };
    pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for(var prop in node)newNode[prop] = node[prop];
        return newNode;
    };
    // This file contains Unicode properties extracted from the ECMAScript
    // specification. The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties
    };
    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
            nonBinary: {
                General_Category: wordsRegexp(unicodeGeneralCategoryValues),
                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
            }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    for(var i = 0, list = [
        9,
        10,
        11,
        12,
        13
    ]; i < list.length; i += 1){
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
    }
    var pp$1 = Parser.prototype;
    var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) return -1;
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) return c;
        var next = s.charCodeAt(i + 1);
        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) return l;
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) return i + 1;
        return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
            this.advance(forceU);
            return true;
        }
        return false;
    };
    /**
	 * Validate the flags part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */ pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for(var i = 0; i < flags.length; i++){
            var flag = flags.charAt(i);
            if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
            if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
        }
    };
    /**
	 * Validate the pattern part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */ pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
        // parsing contains a |GroupName|, reparse with the goal symbol
        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
        // exception if _P_ did not conform to the grammar, if any elements of _P_
        // were not matched by the parse, or if any Early Error conditions exist.
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
            state.switchN = true;
            this.regexp_pattern(state);
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
            // Make the same messages as V8.
            if (state.eat(0x29 /* ) */ )) state.raise("Unmatched ')'");
            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) state.raise("Lone quantifier brackets");
        }
        if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){
            var name = list[i];
            if (state.groupNames.indexOf(name) === -1) state.raise("Invalid named capture referenced");
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$1.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while(state.eat(0x7C /* | */ ))this.regexp_alternative(state);
        // Make the same message as V8.
        if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
        if (state.eat(0x7B /* { */ )) state.raise("Lone quantifier brackets");
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$1.regexp_alternative = function(state) {
        while(state.pos < state.source.length && this.regexp_eatTerm(state));
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
            // Handle `QuantifiableAssertion Quantifier` alternative.
            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
            // is a QuantifiableAssertion.
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) // Make the same message as V8.
            {
                if (state.switchU) state.raise("Invalid quantifier");
            }
            return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        // ^, $
        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) return true;
        // \b \B
        if (state.eat(0x5C /* \ */ )) {
            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) return true;
            state.pos = start;
        }
        // Lookahead / Lookbehind
        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) lookbehind = state.eat(0x3C /* < */ );
            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {
                this.regexp_disjunction(state);
                if (!state.eat(0x29 /* ) */ )) state.raise("Unterminated group");
                state.lastAssertionIsQuantifiable = !lookbehind;
                return true;
            }
        }
        state.pos = start;
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(0x3F /* ? */ );
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(0x7B /* { */ )) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
                min = state.lastIntValue;
                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
                if (state.eat(0x7D /* } */ )) {
                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                    if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
                    return true;
                }
            }
            if (state.switchU && !noError) state.raise("Incomplete quantifier");
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatAtomEscape(state)) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(0x28 /* ( */ )) {
            if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {
                this.regexp_disjunction(state);
                if (state.eat(0x29 /* ) */ )) return true;
                state.raise("Unterminated group");
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(0x28 /* ( */ )) {
            if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
            else if (state.current() === 0x3F /* ? */ ) state.raise("Invalid group");
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */ )) {
                state.numCapturingParens += 1;
                return true;
            }
            state.raise("Unterminated group");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    function isSyntaxCharacter(ch) {
        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch))state.advance();
        return state.pos !== start;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {
            state.advance();
            return true;
        }
        return false;
    };
    // GroupSpecifier ::
    //   [empty]
    //   `?` GroupName
    pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(0x3F /* ? */ )) {
            if (this.regexp_eatGroupName(state)) {
                if (state.groupNames.indexOf(state.lastStringValue) !== -1) state.raise("Duplicate capture group name");
                state.groupNames.push(state.lastStringValue);
                return;
            }
            state.raise("Invalid group");
        }
    };
    // GroupName ::
    //   `<` RegExpIdentifierName `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(0x3C /* < */ )) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) return true;
            state.raise("Invalid capture group name");
        }
        return false;
    };
    // RegExpIdentifierName ::
    //   RegExpIdentifierStart
    //   RegExpIdentifierName RegExpIdentifierPart
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
            while(this.regexp_eatRegExpIdentifierPart(state))state.lastStringValue += codePointToString(state.lastIntValue);
            return true;
        }
        return false;
    };
    // RegExpIdentifierStart ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
        if (isRegExpIdentifierStart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;
    }
    // RegExpIdentifierPart ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
        if (isRegExpIdentifierPart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
        if (state.switchU) {
            // Make the same message as V8.
            if (state.current() === 0x63 /* c */ ) state.raise("Invalid unicode escape");
            state.raise("Invalid escape");
        }
        return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
                if (n > state.maxBackReference) state.maxBackReference = n;
                return true;
            }
            if (n <= state.numCapturingParens) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(0x6B /* k */ )) {
            if (this.regexp_eatGroupName(state)) {
                state.backReferenceNames.push(state.lastStringValue);
                return true;
            }
            state.raise("Invalid named reference");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(0x63 /* c */ )) {
            if (this.regexp_eatControlLetter(state)) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatZero = function(state) {
        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 0x74 /* t */ ) {
            state.lastIntValue = 0x09; /* \t */ 
            state.advance();
            return true;
        }
        if (ch === 0x6E /* n */ ) {
            state.lastIntValue = 0x0A; /* \n */ 
            state.advance();
            return true;
        }
        if (ch === 0x76 /* v */ ) {
            state.lastIntValue = 0x0B; /* \v */ 
            state.advance();
            return true;
        }
        if (ch === 0x66 /* f */ ) {
            state.lastIntValue = 0x0C; /* \f */ 
            state.advance();
            return true;
        }
        if (ch === 0x72 /* r */ ) {
            state.lastIntValue = 0x0D; /* \r */ 
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    function isControlLetter(ch) {
        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(0x75 /* u */ )) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
                var lead = state.lastIntValue;
                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                    var leadSurrogateEnd = state.pos;
                    if (state.eat(0x5C /* \ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {
                        var trail = state.lastIntValue;
                        if (trail >= 0xDC00 && trail <= 0xDFFF) {
                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                            return true;
                        }
                    }
                    state.pos = leadSurrogateEnd;
                    state.lastIntValue = lead;
                }
                return true;
            }
            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) return true;
            if (switchU) state.raise("Invalid unicode escape");
            state.pos = start;
        }
        return false;
    };
    function isValidUnicode(ch) {
        return ch >= 0 && ch <= 0x10FFFF;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) return true;
            if (state.eat(0x2F /* / */ )) {
                state.lastIntValue = 0x2F; /* / */ 
                return true;
            }
            return false;
        }
        var ch = state.current();
        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {
            do {
                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
                state.advance();
            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50 /* P */  || ch === 0x70 /* p */ )) {
            state.lastIntValue = -1;
            state.advance();
            if (state.eat(0x7B /* { */ ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D /* } */ )) return true;
            state.raise("Invalid property name");
        }
        return false;
    };
    function isCharacterClassEscape(ch) {
        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;
    }
    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        // UnicodePropertyName `=` UnicodePropertyValue
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
                var value = state.lastStringValue;
                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
                return true;
            }
        }
        state.pos = start;
        // LoneUnicodePropertyNameOrValue
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
            return true;
        }
        return false;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
        if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) state.raise("Invalid property name");
    };
    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyNameCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 0x5F /* _ */ ;
    }
    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyValueCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
    }
    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(0x5B /* [ */ )) {
            state.eat(0x5E /* ^ */ );
            this.regexp_classRanges(state);
            if (state.eat(0x5D /* ] */ )) return true;
            // Unreachable since it threw "unterminated regular expression" error before.
            state.raise("Unterminated character class");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$1.regexp_classRanges = function(state) {
        while(this.regexp_eatClassAtom(state)){
            var left = state.lastIntValue;
            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {
                var right = state.lastIntValue;
                if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
                if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
            }
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatClassEscape(state)) return true;
            if (state.switchU) {
                // Make the same message as V8.
                var ch$1 = state.current();
                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) state.raise("Invalid class escape");
                state.raise("Invalid escape");
            }
            state.pos = start;
        }
        var ch = state.current();
        if (ch !== 0x5D /* ] */ ) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x62 /* b */ )) {
            state.lastIntValue = 0x08; /* <BS> */ 
            return true;
        }
        if (state.switchU && state.eat(0x2D /* - */ )) {
            state.lastIntValue = 0x2D; /* - */ 
            return true;
        }
        if (!state.switchU && state.eat(0x63 /* c */ )) {
            if (this.regexp_eatClassControlLetter(state)) return true;
            state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(0x78 /* x */ )) {
            if (this.regexp_eatFixedHexDigits(state, 2)) return true;
            if (state.switchU) state.raise("Invalid escape");
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isDecimalDigit(ch = state.current())){
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
            state.advance();
        }
        return state.pos !== start;
    };
    function isDecimalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isHexDigit(ch = state.current())){
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return state.pos !== start;
    };
    function isHexDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;
    }
    function hexToInt(ch) {
        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) return 10 + (ch - 0x41 /* A */ );
        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) return 10 + (ch - 0x61 /* a */ );
        return ch - 0x30 /* 0 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
                var n2 = state.lastIntValue;
                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
                else state.lastIntValue = n1 * 8 + n2;
            } else state.lastIntValue = n1;
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
            state.lastIntValue = ch - 0x30; /* 0 */ 
            state.advance();
            return true;
        }
        state.lastIntValue = 0;
        return false;
    };
    function isOctalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for(var i = 0; i < length; ++i){
            var ch = state.current();
            if (!isHexDigit(ch)) {
                state.pos = start;
                return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return true;
    };
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        if (p.options.ranges) this.range = [
            p.start,
            p.end
        ];
    };
    // ## Tokenizer
    var pp = Parser.prototype;
    // Move to the next token
    pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        if (this.options.onToken) this.options.onToken(new Token(this));
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
    };
    pp.getToken = function() {
        this.next();
        return new Token(this);
    };
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
            next: function() {
                var token = this$1$1.getToken();
                return {
                    done: token.type === types$1.eof,
                    value: token
                };
            }
        };
    };
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    // Read a single token, updating the parser object's token-related
    // properties.
    pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) this.skipSpace();
        this.start = this.pos;
        if (this.options.locations) this.startLoc = this.curPosition();
        if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
        if (curContext.override) return curContext.override(this);
        else this.readToken(this.fullCharCodeAtPos());
    };
    pp.readToken = function(code) {
        // Identifier or keyword. '\uXXXX' sequences are allowed in
        // identifiers, so '\' also dispatches to that.
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */ ) return this.readWord();
        return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 0xd7ff || code >= 0xdc00) return code;
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;
    };
    pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){
            ++this.curLine;
            pos = this.lineStart = nextBreak;
        }
        if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    };
    pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while(this.pos < this.input.length && !isNewLine(ch))ch = this.input.charCodeAt(++this.pos);
        if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    };
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    pp.skipSpace = function() {
        loop: while(this.pos < this.input.length){
            var ch = this.input.charCodeAt(this.pos);
            switch(ch){
                case 32:
                case 160:
                    ++this.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
                case 10:
                case 8232:
                case 8233:
                    ++this.pos;
                    if (this.options.locations) {
                        ++this.curLine;
                        this.lineStart = this.pos;
                    }
                    break;
                case 47:
                    switch(this.input.charCodeAt(this.pos + 1)){
                        case 42:
                            this.skipBlockComment();
                            break;
                        case 47:
                            this.skipLineComment(2);
                            break;
                        default:
                            break loop;
                    }
                    break;
                default:
                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
                    else break loop;
            }
        }
    };
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
    };
    // ### Token reading
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) return this.readNumber(true);
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            this.pos += 3;
            return this.finishToken(types$1.ellipsis);
        } else {
            ++this.pos;
            return this.finishToken(types$1.dot);
        }
    };
    pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
            ++this.pos;
            return this.readRegexp();
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        // exponentiation operator ** and **=
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types$1.starstar;
            next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, size + 1);
        return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (this.options.ecmaVersion >= 12) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 === 61) return this.finishOp(types$1.assign, 3);
            }
            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
                // A `-->` line comment
                this.skipLineComment(3);
                this.skipSpace();
                return this.nextToken();
            }
            return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
            return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
            // `<!--`, an XML-style comment that should be interpreted as a line comment
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
        }
        if (next === 61) size = 2;
        return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            this.pos += 2;
            return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 46) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
            }
            if (next === 63) {
                if (ecmaVersion >= 12) {
                    var next2$1 = this.input.charCodeAt(this.pos + 2);
                    if (next2$1 === 61) return this.finishOp(types$1.assign, 3);
                }
                return this.finishOp(types$1.coalesce, 2);
            }
        }
        return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35; // '#'
        if (ecmaVersion >= 13) {
            ++this.pos;
            code = this.fullCharCodeAtPos();
            if (isIdentifierStart(code, true) || code === 92 /* '\' */ ) return this.finishToken(types$1.privateId, this.readWord1());
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
        switch(code){
            // The interpretation of a dot depends on whether it is followed
            // by a digit or another two dots.
            case 46:
                return this.readToken_dot();
            // Punctuation tokens.
            case 40:
                ++this.pos;
                return this.finishToken(types$1.parenL);
            case 41:
                ++this.pos;
                return this.finishToken(types$1.parenR);
            case 59:
                ++this.pos;
                return this.finishToken(types$1.semi);
            case 44:
                ++this.pos;
                return this.finishToken(types$1.comma);
            case 91:
                ++this.pos;
                return this.finishToken(types$1.bracketL);
            case 93:
                ++this.pos;
                return this.finishToken(types$1.bracketR);
            case 123:
                ++this.pos;
                return this.finishToken(types$1.braceL);
            case 125:
                ++this.pos;
                return this.finishToken(types$1.braceR);
            case 58:
                ++this.pos;
                return this.finishToken(types$1.colon);
            case 96:
                if (this.options.ecmaVersion < 6) break;
                ++this.pos;
                return this.finishToken(types$1.backQuote);
            case 48:
                var next = this.input.charCodeAt(this.pos + 1);
                if (next === 120 || next === 88) return this.readRadixNumber(16);
                 // '0x', '0X' - hex number
                if (this.options.ecmaVersion >= 6) {
                    if (next === 111 || next === 79) return this.readRadixNumber(8);
                     // '0o', '0O' - octal number
                    if (next === 98 || next === 66) return this.readRadixNumber(2);
                     // '0b', '0B' - binary number
                }
            // Anything else beginning with a digit is an integer, octal
            // number, or float.
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return this.readNumber(false);
            // Quotes produce strings.
            case 34:
            case 39:
                return this.readString(code);
            // Operators are parsed inline in tiny state machines. '=' (61) is
            // often referred to. `finishOp` simply skips the amount of
            // characters it is given as second argument, and returns a token
            // of the type given by its first argument.
            case 47:
                return this.readToken_slash();
            case 37:
            case 42:
                return this.readToken_mult_modulo_exp(code);
            case 124:
            case 38:
                return this.readToken_pipe_amp(code);
            case 94:
                return this.readToken_caret();
            case 43:
            case 45:
                return this.readToken_plus_min(code);
            case 60:
            case 62:
                return this.readToken_lt_gt(code);
            case 61:
            case 33:
                return this.readToken_eq_excl(code);
            case 63:
                return this.readToken_question();
            case 126:
                return this.finishOp(types$1.prefix, 1);
            case 35:
                return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
            var ch = this.input.charAt(this.pos);
            if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
            if (!escaped) {
                if (ch === "[") inClass = true;
                else if (ch === "]" && inClass) inClass = false;
                else if (ch === "/" && !inClass) break;
                escaped = ch === "\\";
            } else escaped = false;
            ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) this.unexpected(flagsStart);
        // Validate pattern
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        // Create Literal#value property value.
        var value = null;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
        }
        return this.finishToken(types$1.regexp, {
            pattern: pattern,
            flags: flags,
            value: value
        });
    };
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        // `len` is used for character escape sequences. In that case, disallow separators.
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
        // and isn't fraction part nor exponent part. In that case, if the first digit
        // is zero then disallow separators.
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && code === 95) {
                if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
                if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
                if (i === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
                lastCode = code;
                continue;
            }
            if (code >= 97) val = code - 97 + 10;
            else if (code >= 65) val = code - 65 + 10;
            else if (code >= 48 && code <= 57) val = code - 48;
            else val = Infinity;
            if (val >= radix) break;
            lastCode = code;
            total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        if (this.pos === start || len != null && this.pos - start !== len) return null;
        return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
        return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
        if (typeof BigInt !== "function") return null;
        // `BigInt(value)` throws syntax error if the string contains numeric separators.
        return BigInt(str.replace(/_/g, ""));
    }
    pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2; // 0x
        var val = this.readInt(radix);
        if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(types$1.num, val);
    };
    // Read an integer, octal integer, or floating-point number.
    pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, "Invalid number");
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) this.raise(start, "Invalid number");
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
            return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
        if (next === 46 && !octal) {
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) ++this.pos;
             // '+-'
            if (this.readInt(10) === null) this.raise(start, "Invalid number");
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
    };
    // Read a string value, interpreting backslash-escapes.
    pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
            if (this.options.ecmaVersion < 6) this.unexpected();
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code > 0x10FFFF) this.invalidStringToken(codePos, "Code point out of bounds");
        } else code = this.readHexChar(4);
        return code;
    };
    pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(false);
                chunkStart = this.pos;
            } else if (ch === 0x2028 || ch === 0x2029) {
                if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
                ++this.pos;
                if (this.options.locations) {
                    this.curLine++;
                    this.lineStart = this.pos;
                }
            } else {
                if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
                ++this.pos;
            }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
    };
    // Reads template string tokens.
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
            this.readTmplToken();
        } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
            else throw err;
        }
        this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
        else this.raise(position, message);
    };
    pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
            var ch = this.input.charCodeAt(this.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
                    if (ch === 36) {
                        this.pos += 2;
                        return this.finishToken(types$1.dollarBraceL);
                    } else {
                        ++this.pos;
                        return this.finishToken(types$1.backQuote);
                    }
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(types$1.template, out);
            }
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(true);
                chunkStart = this.pos;
            } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.pos);
                ++this.pos;
                switch(ch){
                    case 13:
                        if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                    case 10:
                        out += "\n";
                        break;
                    default:
                        out += String.fromCharCode(ch);
                        break;
                }
                if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                }
                chunkStart = this.pos;
            } else ++this.pos;
        }
    };
    // Reads a template token to search for the end, without validating any escape sequences
    pp.readInvalidTemplateToken = function() {
        for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){
            case "\\":
                ++this.pos;
                break;
            case "$":
                if (this.input[this.pos + 1] !== "{") break;
            // falls through
            case "`":
                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
        this.raise(this.start, "Unterminated template");
    };
    // Used to read escaped characters
    pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch(ch){
            case 110:
                return "\n" // 'n' -> '\n'
                ;
            case 114:
                return "\r" // 'r' -> '\r'
                ;
            case 120:
                return String.fromCharCode(this.readHexChar(2)) // 'x'
                ;
            case 117:
                return codePointToString(this.readCodePoint()) // 'u'
                ;
            case 116:
                return "	" // 't' -> '\t'
                ;
            case 98:
                return "\b" // 'b' -> '\b'
                ;
            case 118:
                return "\v" // 'v' -> '\u000b'
                ;
            case 102:
                return "\f" // 'f' -> '\f'
                ;
            case 13:
                if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                 // '\r\n'
            case 10:
                if (this.options.locations) {
                    this.lineStart = this.pos;
                    ++this.curLine;
                }
                return "";
            case 56:
            case 57:
                if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
                if (inTemplate) {
                    var codePos = this.pos - 1;
                    this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                    return null;
                }
            default:
                if (ch >= 48 && ch <= 55) {
                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                    var octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                        octalStr = octalStr.slice(0, -1);
                        octal = parseInt(octalStr, 8);
                    }
                    this.pos += octalStr.length - 1;
                    ch = this.input.charCodeAt(this.pos);
                    if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                    return String.fromCharCode(octal);
                }
                if (isNewLine(ch)) // Unicode new line characters after \ get removed from output in both
                // template literals and strings
                return "";
                return String.fromCharCode(ch);
        }
    };
    // Used to read character escape sequences ('\x', '\u', '\U').
    pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) this.invalidStringToken(codePos, "Bad character escape sequence");
        return n;
    };
    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while(this.pos < this.input.length){
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) this.pos += ch <= 0xffff ? 1 : 2;
            else if (ch === 92) {
                this.containsEsc = true;
                word += this.input.slice(chunkStart, this.pos);
                var escStart = this.pos;
                if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
                ++this.pos;
                var esc = this.readCodePoint();
                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
                word += codePointToString(esc);
                chunkStart = this.pos;
            } else break;
            first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
    };
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) type = keywords[word];
        return this.finishToken(type, word);
    };
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    var version = "8.8.1";
    Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node,
        TokenType: TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext: TokContext,
        tokContexts: types,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
    };
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    function parse(input, options) {
        return Parser.parse(input, options);
    }
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
    }
    function flatten(nodes, target = []) {
        for(let i = 0; i < nodes.length; i += 1){
            const node = nodes[i];
            if (Array.isArray(node)) flatten(node, target);
            else target.push(node);
        }
        return target;
    }
    const regex_whitespace = /\s/;
    const regex_whitespaces = /\s+/;
    const regex_starts_with_whitespace = /^\s/;
    const regex_starts_with_whitespaces = /^[ \t\r\n]*/;
    const regex_ends_with_whitespace = /\s$/;
    const regex_ends_with_whitespaces = /[ \t\r\n]*$/;
    const regex_only_whitespaces = /^\s+$/;
    const regex_whitespace_characters = /\s/g;
    const regex_non_whitespace_character = /\S/;
    const regex_starts_with_newline = /^\r?\n/;
    const regex_not_newline_characters = /[^\n]/g;
    const regex_double_quotes = /"/g;
    const regex_backslashes = /\\/g;
    const regex_starts_with_underscore = /^_/;
    const regex_ends_with_underscore = /_$/;
    const regex_dimensions = /^(?:offset|client)(?:Width|Height)$/;
    const regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
    function extract_svelte_ignore(text) {
        const match = regex_svelte_ignore.exec(text);
        return match ? match[1].split(regex_whitespace).map((x)=>x.trim()).filter(Boolean) : [];
    }
    function extract_svelte_ignore_from_comments(node) {
        return flatten((node.leadingComments || []).map((comment)=>extract_svelte_ignore(comment.value)));
    }
    function extract_ignores_above_position(position, template_nodes) {
        const previous_node_idx = template_nodes.findIndex((child)=>child.end === position);
        if (previous_node_idx === -1) return [];
        for(let i = previous_node_idx; i >= 0; i--){
            const node = template_nodes[i];
            if (node.type !== "Comment" && node.type !== "Text") return [];
            if (node.type === "Comment") {
                if (node.ignores.length) return node.ignores;
            }
        }
        return [];
    }
    function fuzzymatch(name, names) {
        const set = new FuzzySet(names);
        const matches = set.get(name);
        return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
    }
    // adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js
    // BSD Licensed
    const GRAM_SIZE_LOWER = 2;
    const GRAM_SIZE_UPPER = 3;
    // return an edit distance from 0 to 1
    function _distance(str1, str2) {
        if (str1 === null && str2 === null) throw "Trying to compare two null values";
        if (str1 === null || str2 === null) return 0;
        str1 = String(str1);
        str2 = String(str2);
        const distance = levenshtein(str1, str2);
        if (str1.length > str2.length) return 1 - distance / str1.length;
        else return 1 - distance / str2.length;
    }
    // helper functions
    function levenshtein(str1, str2) {
        const current = [];
        let prev;
        let value;
        for(let i = 0; i <= str2.length; i++)for(let j = 0; j <= str1.length; j++){
            if (i && j) {
                if (str1.charAt(j - 1) === str2.charAt(i - 1)) value = prev;
                else value = Math.min(current[j], current[j - 1], prev) + 1;
            } else value = i + j;
            prev = current[j];
            current[j] = value;
        }
        return current.pop();
    }
    const non_word_regex = /[^\w, ]+/;
    function iterate_grams(value, gram_size = 2) {
        const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
        const len_diff = gram_size - simplified.length;
        const results = [];
        if (len_diff > 0) for(let i = 0; i < len_diff; ++i)value += "-";
        for(let i = 0; i < simplified.length - gram_size + 1; ++i)results.push(simplified.slice(i, i + gram_size));
        return results;
    }
    function gram_counter(value, gram_size = 2) {
        // return an object where key=gram, value=number of occurrences
        const result = {};
        const grams = iterate_grams(value, gram_size);
        let i = 0;
        for(i; i < grams.length; ++i)if (grams[i] in result) result[grams[i]] += 1;
        else result[grams[i]] = 1;
        return result;
    }
    function sort_descending(a, b) {
        return b[0] - a[0];
    }
    class FuzzySet {
        constructor(arr){
            this.exact_set = {};
            this.match_dict = {};
            this.items = {};
            // initialization
            for(let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i)this.items[i] = [];
            // add all the items to the set
            for(let i = 0; i < arr.length; ++i)this.add(arr[i]);
        }
        add(value) {
            const normalized_value = value.toLowerCase();
            if (normalized_value in this.exact_set) return false;
            let i = GRAM_SIZE_LOWER;
            for(i; i < GRAM_SIZE_UPPER + 1; ++i)this._add(value, i);
        }
        _add(value, gram_size) {
            const normalized_value = value.toLowerCase();
            const items = this.items[gram_size] || [];
            const index = items.length;
            items.push(0);
            const gram_counts = gram_counter(normalized_value, gram_size);
            let sum_of_square_gram_counts = 0;
            let gram;
            let gram_count;
            for(gram in gram_counts){
                gram_count = gram_counts[gram];
                sum_of_square_gram_counts += Math.pow(gram_count, 2);
                if (gram in this.match_dict) this.match_dict[gram].push([
                    index,
                    gram_count
                ]);
                else this.match_dict[gram] = [
                    [
                        index,
                        gram_count
                    ]
                ];
            }
            const vector_normal = Math.sqrt(sum_of_square_gram_counts);
            items[index] = [
                vector_normal,
                normalized_value
            ];
            this.items[gram_size] = items;
            this.exact_set[normalized_value] = value;
        }
        get(value) {
            const normalized_value = value.toLowerCase();
            const result = this.exact_set[normalized_value];
            if (result) return [
                [
                    1,
                    result
                ]
            ];
            let results = [];
            // start with high gram size and if there are no results, go to lower gram sizes
            for(let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size){
                results = this.__get(value, gram_size);
                if (results) return results;
            }
            return null;
        }
        __get(value, gram_size) {
            const normalized_value = value.toLowerCase();
            const matches = {};
            const gram_counts = gram_counter(normalized_value, gram_size);
            const items = this.items[gram_size];
            let sum_of_square_gram_counts = 0;
            let gram;
            let gram_count;
            let i;
            let index;
            let other_gram_count;
            for(gram in gram_counts){
                gram_count = gram_counts[gram];
                sum_of_square_gram_counts += Math.pow(gram_count, 2);
                if (gram in this.match_dict) for(i = 0; i < this.match_dict[gram].length; ++i){
                    index = this.match_dict[gram][i][0];
                    other_gram_count = this.match_dict[gram][i][1];
                    if (index in matches) matches[index] += gram_count * other_gram_count;
                    else matches[index] = gram_count * other_gram_count;
                }
            }
            const vector_normal = Math.sqrt(sum_of_square_gram_counts);
            let results = [];
            let match_score;
            // build a results list of [score, str]
            for(const match_index in matches){
                match_score = matches[match_index];
                results.push([
                    match_score / (vector_normal * items[match_index][0]),
                    items[match_index][1]
                ]);
            }
            results.sort(sort_descending);
            let new_results = [];
            const end_index = Math.min(50, results.length);
            // truncate somewhat arbitrarily to 50
            for(let i = 0; i < end_index; ++i)new_results.push([
                _distance(results[i][1], normalized_value),
                results[i][1]
            ]);
            results = new_results;
            results.sort(sort_descending);
            new_results = [];
            for(let i = 0; i < results.length; ++i)if (results[i][0] == results[0][0]) new_results.push([
                results[i][0],
                this.exact_set[results[i][1]]
            ]);
            return new_results;
        }
    }
    /** regex of all html void element names */ const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    /** regex of all html element names. svg and math are omitted because they belong to the svg elements namespace */ const html_element_names = /^(?:a|abbr|address|area|article|aside|audio|b|base|bdi|bdo|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|head|header|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|main|map|mark|meta|meter|nav|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|source|span|strong|style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|u|ul|var|video|wbr)$/;
    /** regex of all svg element names */ const svg = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|svg|switch|symbol|text|textPath|tref|tspan|unknown|use|view|vkern)$/;
    function is_void(name) {
        return void_element_names.test(name) || name.toLowerCase() === "!doctype";
    }
    function is_html(name) {
        return html_element_names.test(name);
    }
    function is_svg(name) {
        return svg.test(name);
    }
    function list$1(items, conjunction = "or") {
        if (items.length === 1) return items[0];
        return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
    }
    // All parser errors should be listed and accessed from here
    /**
	 * @internal
	 */ var parser_errors = {
        css_syntax_error: (message)=>({
                code: "css-syntax-error",
                message: message
            }),
        duplicate_attribute: {
            code: "duplicate-attribute",
            message: "Attributes need to be unique"
        },
        duplicate_element: (slug, name)=>({
                code: `duplicate-${slug}`,
                message: `A component can only have one <${name}> tag`
            }),
        duplicate_style: {
            code: "duplicate-style",
            message: "You can only have one top-level <style> tag per component"
        },
        empty_attribute_shorthand: {
            code: "empty-attribute-shorthand",
            message: "Attribute shorthand cannot be empty"
        },
        empty_directive_name: (type)=>({
                code: "empty-directive-name",
                message: `${type} name cannot be empty`
            }),
        empty_global_selector: {
            code: "css-syntax-error",
            message: ":global() must contain a selector"
        },
        expected_block_type: {
            code: "expected-block-type",
            message: "Expected if, each or await"
        },
        expected_name: {
            code: "expected-name",
            message: "Expected name"
        },
        invalid_catch_placement_unclosed_block: (block)=>({
                code: "invalid-catch-placement",
                message: `Expected to close ${block} before seeing {:catch} block`
            }),
        invalid_catch_placement_without_await: {
            code: "invalid-catch-placement",
            message: "Cannot have an {:catch} block outside an {#await ...} block"
        },
        invalid_component_definition: {
            code: "invalid-component-definition",
            message: "invalid component definition"
        },
        invalid_closing_tag_unopened: (name)=>({
                code: "invalid-closing-tag",
                message: `</${name}> attempted to close an element that was not open`
            }),
        invalid_closing_tag_autoclosed: (name, reason)=>({
                code: "invalid-closing-tag",
                message: `</${name}> attempted to close <${name}> that was already automatically closed by <${reason}>`
            }),
        invalid_debug_args: {
            code: "invalid-debug-args",
            message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
        },
        invalid_declaration: {
            code: "invalid-declaration",
            message: "Declaration cannot be empty"
        },
        invalid_directive_value: {
            code: "invalid-directive-value",
            message: "Directive value must be a JavaScript expression enclosed in curly braces"
        },
        invalid_elseif: {
            code: "invalid-elseif",
            message: "'elseif' should be 'else if'"
        },
        invalid_elseif_placement_outside_if: {
            code: "invalid-elseif-placement",
            message: "Cannot have an {:else if ...} block outside an {#if ...} block"
        },
        invalid_elseif_placement_unclosed_block: (block)=>({
                code: "invalid-elseif-placement",
                message: `Expected to close ${block} before seeing {:else if ...} block`
            }),
        invalid_else_placement_outside_if: {
            code: "invalid-else-placement",
            message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
        },
        invalid_else_placement_unclosed_block: (block)=>({
                code: "invalid-else-placement",
                message: `Expected to close ${block} before seeing {:else} block`
            }),
        invalid_element_content: (slug, name)=>({
                code: `invalid-${slug}-content`,
                message: `<${name}> cannot have children`
            }),
        invalid_element_definition: {
            code: "invalid-element-definition",
            message: "Invalid element definition"
        },
        invalid_element_placement: (slug, name)=>({
                code: `invalid-${slug}-placement`,
                message: `<${name}> tags cannot be inside elements or blocks`
            }),
        invalid_logic_block_placement: (location, name)=>({
                code: "invalid-logic-block-placement",
                message: `{#${name}} logic block cannot be ${location}`
            }),
        invalid_tag_placement: (location, name)=>({
                code: "invalid-tag-placement",
                message: `{@${name}} tag cannot be ${location}`
            }),
        invalid_ref_directive: (name)=>({
                code: "invalid-ref-directive",
                message: `The ref directive is no longer supported \u{2014} use \`bind:this={${name}}\` instead`
            }),
        invalid_ref_selector: {
            code: "invalid-ref-selector",
            message: "ref selectors are no longer supported"
        },
        invalid_self_placement: {
            code: "invalid-self-placement",
            message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
        },
        invalid_script_instance: {
            code: "invalid-script",
            message: "A component can only have one instance-level <script> element"
        },
        invalid_script_module: {
            code: "invalid-script",
            message: 'A component can only have one <script context="module"> element'
        },
        invalid_script_context_attribute: {
            code: "invalid-script",
            message: "context attribute must be static"
        },
        invalid_script_context_value: {
            code: "invalid-script",
            message: 'If the context attribute is supplied, its value must be "module"'
        },
        invalid_tag_name: {
            code: "invalid-tag-name",
            message: "Expected valid tag name"
        },
        invalid_tag_name_svelte_element: (tags, match)=>({
                code: "invalid-tag-name",
                message: `Valid <svelte:...> tag names are ${list$1(tags)}${match ? " (did you mean " + match + "?)" : ""}`
            }),
        invalid_then_placement_unclosed_block: (block)=>({
                code: "invalid-then-placement",
                message: `Expected to close ${block} before seeing {:then} block`
            }),
        invalid_then_placement_without_await: {
            code: "invalid-then-placement",
            message: "Cannot have an {:then} block outside an {#await ...} block"
        },
        invalid_void_content: (name)=>({
                code: "invalid-void-content",
                message: `<${name}> is a void element and cannot have children, or a closing tag`
            }),
        missing_component_definition: {
            code: "missing-component-definition",
            message: "<svelte:component> must have a 'this' attribute"
        },
        missing_attribute_value: {
            code: "missing-attribute-value",
            message: "Expected value for the attribute"
        },
        missing_element_definition: {
            code: "missing-element-definition",
            message: "<svelte:element> must have a 'this' attribute"
        },
        unclosed_script: {
            code: "unclosed-script",
            message: "<script> must have a closing tag"
        },
        unclosed_style: {
            code: "unclosed-style",
            message: "<style> must have a closing tag"
        },
        unclosed_comment: {
            code: "unclosed-comment",
            message: "comment was left open, expected -->"
        },
        unclosed_attribute_value: (token)=>({
                code: "unclosed-attribute-value",
                message: `Expected to close the attribute value with ${token}`
            }),
        unexpected_block_close: {
            code: "unexpected-block-close",
            message: "Unexpected block closing tag"
        },
        unexpected_eof: {
            code: "unexpected-eof",
            message: "Unexpected end of input"
        },
        unexpected_eof_token: (token)=>({
                code: "unexpected-eof",
                message: `Unexpected ${token}`
            }),
        unexpected_token: (token)=>({
                code: "unexpected-token",
                message: `Expected ${token}`
            }),
        unexpected_token_destructure: {
            code: "unexpected-token",
            message: "Expected identifier or destructure pattern"
        }
    };
    // @ts-check
    /** @typedef { import('estree').BaseNode} BaseNode */ /** @typedef {{
		skip: () => void;
		remove: () => void;
		replace: (node: BaseNode) => void;
	}} WalkerContext */ class WalkerBase {
        constructor(){
            /** @type {boolean} */ this.should_skip = false;
            /** @type {boolean} */ this.should_remove = false;
            /** @type {BaseNode | null} */ this.replacement = null;
            /** @type {WalkerContext} */ this.context = {
                skip: ()=>this.should_skip = true,
                remove: ()=>this.should_remove = true,
                replace: (node)=>this.replacement = node
            };
        }
        /**
		 *
		 * @param {any} parent
		 * @param {string} prop
		 * @param {number} index
		 * @param {BaseNode} node
		 */ replace(parent, prop, index, node) {
            if (parent) {
                if (index !== null) parent[prop][index] = node;
                else parent[prop] = node;
            }
        }
        /**
		 *
		 * @param {any} parent
		 * @param {string} prop
		 * @param {number} index
		 */ remove(parent, prop, index) {
            if (parent) {
                if (index !== null) parent[prop].splice(index, 1);
                else delete parent[prop];
            }
        }
    }
    // @ts-check
    /** @typedef { import('estree').BaseNode} BaseNode */ /** @typedef { import('./walker.js').WalkerContext} WalkerContext */ /** @typedef {(
	 *    this: WalkerContext,
	 *    node: BaseNode,
	 *    parent: BaseNode,
	 *    key: string,
	 *    index: number
	 * ) => void} SyncHandler */ class SyncWalker extends WalkerBase {
        /**
		 *
		 * @param {SyncHandler} enter
		 * @param {SyncHandler} leave
		 */ constructor(enter, leave){
            super();
            /** @type {SyncHandler} */ this.enter = enter;
            /** @type {SyncHandler} */ this.leave = leave;
        }
        /**
		 *
		 * @param {BaseNode} node
		 * @param {BaseNode} parent
		 * @param {string} [prop]
		 * @param {number} [index]
		 * @returns {BaseNode}
		 */ visit(node, parent, prop, index) {
            if (node) {
                if (this.enter) {
                    const _should_skip = this.should_skip;
                    const _should_remove = this.should_remove;
                    const _replacement = this.replacement;
                    this.should_skip = false;
                    this.should_remove = false;
                    this.replacement = null;
                    this.enter.call(this.context, node, parent, prop, index);
                    if (this.replacement) {
                        node = this.replacement;
                        this.replace(parent, prop, index, node);
                    }
                    if (this.should_remove) this.remove(parent, prop, index);
                    const skipped = this.should_skip;
                    const removed = this.should_remove;
                    this.should_skip = _should_skip;
                    this.should_remove = _should_remove;
                    this.replacement = _replacement;
                    if (skipped) return node;
                    if (removed) return null;
                }
                for(const key in node){
                    const value = node[key];
                    if (typeof value !== "object") continue;
                    else if (Array.isArray(value)) for(let i = 0; i < value.length; i += 1){
                        if (value[i] !== null && typeof value[i].type === "string") {
                            if (!this.visit(value[i], node, key, i)) // removed
                            i--;
                        }
                    }
                    else if (value !== null && typeof value.type === "string") this.visit(value, node, key, null);
                }
                if (this.leave) {
                    const _replacement = this.replacement;
                    const _should_remove = this.should_remove;
                    this.replacement = null;
                    this.should_remove = false;
                    this.leave.call(this.context, node, parent, prop, index);
                    if (this.replacement) {
                        node = this.replacement;
                        this.replace(parent, prop, index, node);
                    }
                    if (this.should_remove) this.remove(parent, prop, index);
                    const removed = this.should_remove;
                    this.replacement = _replacement;
                    this.should_remove = _should_remove;
                    if (removed) return null;
                }
            }
            return node;
        }
    }
    // @ts-check
    /** @typedef { import('estree').BaseNode} BaseNode */ /** @typedef { import('./sync.js').SyncHandler} SyncHandler */ /** @typedef { import('./async.js').AsyncHandler} AsyncHandler */ /**
	 *
	 * @param {BaseNode} ast
	 * @param {{
	 *   enter?: SyncHandler
	 *   leave?: SyncHandler
	 * }} walker
	 * @returns {BaseNode}
	 */ function walk(ast, { enter: enter, leave: leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
    }
    // generate an ID that is, to all intents and purposes, unique
    const id = Math.round(Math.random() * 1e20).toString(36);
    const re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
    /** @typedef {import('estree').Comment} Comment */ /** @typedef {import('estree').Node} Node */ /**
	 * @typedef {Node & {
	 *   start: number;
	 *   end: number;
	 *   has_trailing_newline?: boolean
	 * }} NodeWithLocation
	 */ /**
	 * @typedef {Comment & {
	 *   start: number;
	 *   end: number;
	 *   has_trailing_newline?: boolean
	 * }} CommentWithLocation
	 */ /**
	 * @param {CommentWithLocation[]} comments
	 * @param {string} raw
	 */ const get_comment_handlers = (comments, raw)=>({
            // pass to acorn options
            /**
		 * @param {boolean} block
		 * @param {string} value
		 * @param {number} start
		 * @param {number} end
		 */ onComment: (block, value, start, end)=>{
                if (block && /\n/.test(value)) {
                    let a = start;
                    while(a > 0 && raw[a - 1] !== "\n")a -= 1;
                    let b = a;
                    while(/[ \t]/.test(raw[b]))b += 1;
                    const indentation = raw.slice(a, b);
                    value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
                }
                comments.push({
                    type: block ? "Block" : "Line",
                    value: value,
                    start: start,
                    end: end
                });
            },
            // pass to estree-walker options
            /** @param {NodeWithLocation} node */ enter (node) {
                let comment;
                while(comments[0] && comments[0].start < node.start){
                    comment = comments.shift();
                    comment.value = comment.value.replace(re, (match, id, at, hash, value)=>{
                        if (hash) return `#${value}`;
                        if (at) return `@${value}`;
                        return match;
                    });
                    const next = comments[0] || node;
                    comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
                    (node.leadingComments || (node.leadingComments = [])).push(comment);
                }
            },
            /** @param {NodeWithLocation} node */ leave (node) {
                if (comments[0]) {
                    const slice = raw.slice(node.end, comments[0].start);
                    if (/^[,) \t]*$/.test(slice)) node.trailingComments = [
                        comments.shift()
                    ];
                }
            }
        });
    //@ts-check
    /** @typedef { import('estree').Node} Node */ /** @typedef {Node | {
	 *   type: 'PropertyDefinition';
	 *   computed: boolean;
	 *   value: Node
	 * }} NodeWithPropertyDefinition */ /**
	 *
	 * @param {NodeWithPropertyDefinition} node
	 * @param {NodeWithPropertyDefinition} parent
	 * @returns boolean
	 */ function is_reference(node, parent) {
        if (node.type === "MemberExpression") return !node.computed && is_reference(node.object, node);
        if (node.type === "Identifier") {
            if (!parent) return true;
            switch(parent.type){
                // disregard `bar` in `foo.bar`
                case "MemberExpression":
                    return parent.computed || node === parent.object;
                // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
                case "MethodDefinition":
                    return parent.computed;
                // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
                case "PropertyDefinition":
                    return parent.computed || node === parent.value;
                // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
                case "Property":
                    return parent.computed || node === parent.value;
                // disregard the `bar` in `export { foo as bar }` or
                // the foo in `import { foo as bar }`
                case "ExportSpecifier":
                case "ImportSpecifier":
                    return node === parent.local;
                // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
                case "LabeledStatement":
                case "BreakStatement":
                case "ContinueStatement":
                    return false;
                default:
                    return true;
            }
        }
        return false;
    }
    /** @param {import('estree').Node} expression */ function analyze(expression) {
        /** @typedef {import('estree').Node} Node */ /** @type {WeakMap<Node, Scope>} */ const map = new WeakMap();
        /** @type {Map<string, Node>} */ const globals = new Map();
        const scope = new Scope$1(null, false);
        /** @type {[Scope, import('estree').Identifier][]} */ const references = [];
        let current_scope = scope;
        walk(expression, {
            /**
			 * @param {Node} node
			 * @param {any} parent
			 */ enter (node, parent) {
                switch(node.type){
                    case "Identifier":
                        if (is_reference(node, parent)) references.push([
                            current_scope,
                            node
                        ]);
                        break;
                    case "ImportDeclaration":
                        node.specifiers.forEach((specifier)=>{
                            current_scope.declarations.set(specifier.local.name, specifier);
                        });
                        break;
                    case "FunctionExpression":
                    case "FunctionDeclaration":
                    case "ArrowFunctionExpression":
                        if (node.type === "FunctionDeclaration") {
                            if (node.id) current_scope.declarations.set(node.id.name, node);
                            map.set(node, current_scope = new Scope$1(current_scope, false));
                        } else {
                            map.set(node, current_scope = new Scope$1(current_scope, false));
                            if (node.type === "FunctionExpression" && node.id) current_scope.declarations.set(node.id.name, node);
                        }
                        node.params.forEach((param)=>{
                            extract_names(param).forEach((name)=>{
                                current_scope.declarations.set(name, node);
                            });
                        });
                        break;
                    case "ForStatement":
                    case "ForInStatement":
                    case "ForOfStatement":
                        map.set(node, current_scope = new Scope$1(current_scope, true));
                        break;
                    case "BlockStatement":
                        map.set(node, current_scope = new Scope$1(current_scope, true));
                        break;
                    case "ClassDeclaration":
                    case "VariableDeclaration":
                        current_scope.add_declaration(node);
                        break;
                    case "CatchClause":
                        map.set(node, current_scope = new Scope$1(current_scope, true));
                        if (node.param) extract_names(node.param).forEach((name)=>{
                            current_scope.declarations.set(name, node.param);
                        });
                        break;
                }
            },
            /** @param {Node} node */ leave (node) {
                if (map.has(node)) current_scope = current_scope.parent;
            }
        });
        for(let i = references.length - 1; i >= 0; --i){
            const [scope, reference] = references[i];
            if (!scope.references.has(reference.name)) add_reference(scope, reference.name);
            if (!scope.find_owner(reference.name)) globals.set(reference.name, reference);
        }
        return {
            map: map,
            scope: scope,
            globals: globals
        };
    }
    /**
	 *
	 * @param {Scope} scope
	 * @param {string} name
	 */ function add_reference(scope, name) {
        scope.references.add(name);
        if (scope.parent) add_reference(scope.parent, name);
    }
    class Scope$1 {
        constructor(parent, block){
            /** @type {Scope | null} */ this.parent = parent;
            /** @type {boolean} */ this.block = block;
            /** @type {Map<string, import('estree').Node>} */ this.declarations = new Map();
            /** @type {Set<string>} */ this.initialised_declarations = new Set();
            /** @type {Set<string>} */ this.references = new Set();
        }
        /** @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node */ add_declaration(node) {
            if (node.type === "VariableDeclaration") {
                if (node.kind === "var" && this.block && this.parent) this.parent.add_declaration(node);
                else {
                    /** @param {import('estree').VariableDeclarator} declarator */ const handle_declarator = (declarator)=>{
                        extract_names(declarator.id).forEach((name)=>{
                            this.declarations.set(name, node);
                            if (declarator.init) this.initialised_declarations.add(name);
                        });
                    };
                    node.declarations.forEach(handle_declarator);
                }
            } else if (node.id) this.declarations.set(node.id.name, node);
        }
        /**
		 * @param {string} name
		 * @returns {Scope | null}
		 */ find_owner(name) {
            if (this.declarations.has(name)) return this;
            return this.parent && this.parent.find_owner(name);
        }
        /**
		 * @param {string} name
		 * @returns {boolean}
		 */ has(name) {
            return this.declarations.has(name) || !!this.parent && this.parent.has(name);
        }
    }
    /**
	 * @param {import('estree').Node} param
	 * @returns {string[]}
	 */ function extract_names(param) {
        return extract_identifiers(param).map((node)=>node.name);
    }
    /**
	 * @param {import('estree').Node} param
	 * @param {import('estree').Identifier[]} nodes
	 * @returns {import('estree').Identifier[]}
	 */ function extract_identifiers(param, nodes = []) {
        switch(param.type){
            case "Identifier":
                nodes.push(param);
                break;
            case "MemberExpression":
                let object = param;
                while(object.type === "MemberExpression")object = /** @type {any} */ object.object;
                nodes.push(/** @type {any} */ object);
                break;
            case "ObjectPattern":
                /** @param {import('estree').Property | import('estree').RestElement} prop */ const handle_prop = (prop)=>{
                    if (prop.type === "RestElement") extract_identifiers(prop.argument, nodes);
                    else extract_identifiers(prop.value, nodes);
                };
                param.properties.forEach(handle_prop);
                break;
            case "ArrayPattern":
                /** @param {import('estree').Node} element */ const handle_element = (element)=>{
                    if (element) extract_identifiers(element, nodes);
                };
                param.elements.forEach(handle_element);
                break;
            case "RestElement":
                extract_identifiers(param.argument, nodes);
                break;
            case "AssignmentPattern":
                extract_identifiers(param.left, nodes);
                break;
        }
        return nodes;
    }
    /**
	 * Does `array.push` for all `items`. Needed because `array.push(...items)` throws
	 * "Maximum call stack size exceeded" when `items` is too big of an array.
	 *
	 * @param {any[]} array 
	 * @param {any[]} items 
	 */ function push_array(array, items) {
        for(let i = 0; i < items.length; i++)array.push(items[i]);
    }
    // heavily based on https://github.com/davidbonnet/astring
    /** @typedef {import('estree').ArrowFunctionExpression} ArrowFunctionExpression */ /** @typedef {import('estree').BinaryExpression} BinaryExpression */ /** @typedef {import('estree').CallExpression} CallExpression */ /** @typedef {import('estree').Comment} Comment */ /** @typedef {import('estree').ExportSpecifier} ExportSpecifier */ /** @typedef {import('estree').Expression} Expression */ /** @typedef {import('estree').FunctionDeclaration} FunctionDeclaration */ /** @typedef {import('estree').ImportDeclaration} ImportDeclaration */ /** @typedef {import('estree').ImportSpecifier} ImportSpecifier */ /** @typedef {import('estree').Literal} Literal */ /** @typedef {import('estree').LogicalExpression} LogicalExpression */ /** @typedef {import('estree').NewExpression} NewExpression */ /** @typedef {import('estree').Node} Node */ /** @typedef {import('estree').ObjectExpression} ObjectExpression */ /** @typedef {import('estree').Pattern} Pattern */ /** @typedef {import('estree').SequenceExpression} SequenceExpression */ /** @typedef {import('estree').SimpleCallExpression} SimpleCallExpression */ /** @typedef {import('estree').SwitchStatement} SwitchStatement */ /** @typedef {import('estree').VariableDeclaration} VariableDeclaration */ /**
	 * @typedef {{
	 *   content: string;
	 *   loc?: {
	 *     start: { line: number; column: number; };
	 *     end: { line: number; column: number; };
	 *   };
	 *   has_newline: boolean;
	 * }} Chunk
	 */ /**
	 * @typedef {(node: any, state: State) => Chunk[]} Handler
	 */ /**
	 * @typedef {{
	 *   indent: string;
	 *   scope: any; // TODO import from periscopic
	 *   scope_map: WeakMap<Node, any>;
	 *   getName: (name: string) => string;
	 *   deconflicted: WeakMap<Node, Map<string, string>>;
	 *   comments: Comment[];
	 * }} State
	 */ /**
	 * @param {Node} node
	 * @param {State} state
	 * @returns {Chunk[]}
	 */ function handle(node, state) {
        const handler = handlers[node.type];
        if (!handler) throw new Error(`Not implemented ${node.type}`);
        const result = handler(node, state);
        if (node.leadingComments) result.unshift(c(node.leadingComments.map((comment)=>comment.type === "Block" ? `/*${comment.value}*/${comment.has_trailing_newline ? `\n${state.indent}` : ` `}` : `//${comment.value}${comment.has_trailing_newline ? `\n${state.indent}` : ` `}`).join(``)));
        if (node.trailingComments) state.comments.push(node.trailingComments[0]); // there is only ever one
        return result;
    }
    /**
	 * @param {string} content
	 * @param {Node} [node]
	 * @returns {Chunk}
	 */ function c(content, node) {
        return {
            content: content,
            loc: node && node.loc,
            has_newline: /\n/.test(content)
        };
    }
    const OPERATOR_PRECEDENCE = {
        "||": 2,
        "&&": 3,
        "??": 4,
        "|": 5,
        "^": 6,
        "&": 7,
        "==": 8,
        "!=": 8,
        "===": 8,
        "!==": 8,
        "<": 9,
        ">": 9,
        "<=": 9,
        ">=": 9,
        in: 9,
        instanceof: 9,
        "<<": 10,
        ">>": 10,
        ">>>": 10,
        "+": 11,
        "-": 11,
        "*": 12,
        "%": 12,
        "/": 12,
        "**": 13
    };
    /** @type {Record<string, number>} */ const EXPRESSIONS_PRECEDENCE = {
        ArrayExpression: 20,
        TaggedTemplateExpression: 20,
        ThisExpression: 20,
        Identifier: 20,
        Literal: 18,
        TemplateLiteral: 20,
        Super: 20,
        SequenceExpression: 20,
        MemberExpression: 19,
        CallExpression: 19,
        NewExpression: 19,
        AwaitExpression: 17,
        ClassExpression: 17,
        FunctionExpression: 17,
        ObjectExpression: 17,
        UpdateExpression: 16,
        UnaryExpression: 15,
        BinaryExpression: 14,
        LogicalExpression: 13,
        ConditionalExpression: 4,
        ArrowFunctionExpression: 3,
        AssignmentExpression: 3,
        YieldExpression: 2,
        RestElement: 1
    };
    /**
	 *
	 * @param {Expression} node
	 * @param {BinaryExpression | LogicalExpression} parent
	 * @param {boolean} is_right
	 * @returns
	 */ function needs_parens(node, parent, is_right) {
        // special case where logical expressions and coalesce expressions cannot be mixed,
        // either of them need to be wrapped with parentheses
        if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) return true;
        const precedence = EXPRESSIONS_PRECEDENCE[node.type];
        const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
        if (precedence !== parent_precedence) // Different node types
        return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
        if (precedence !== 13 && precedence !== 14) // Not a `LogicalExpression` or `BinaryExpression`
        return false;
        if (/** @type {BinaryExpression} */ node.operator === "**" && parent.operator === "**") // Exponentiation operator has right-to-left associativity
        return !is_right;
        if (is_right) // Parenthesis are used if both operators have the same precedence
        return OPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ node.operator] <= OPERATOR_PRECEDENCE[parent.operator];
        return OPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ node.operator] < OPERATOR_PRECEDENCE[parent.operator];
    }
    /** @param {Node} node */ function has_call_expression(node) {
        while(node){
            if (node.type[0] === "CallExpression") return true;
            else if (node.type === "MemberExpression") node = node.object;
            else return false;
        }
    }
    /** @param {Chunk[]} chunks */ const has_newline = (chunks)=>{
        for(let i = 0; i < chunks.length; i += 1){
            if (chunks[i].has_newline) return true;
        }
        return false;
    };
    /** @param {Chunk[]} chunks */ const get_length = (chunks)=>{
        let total = 0;
        for(let i = 0; i < chunks.length; i += 1)total += chunks[i].content.length;
        return total;
    };
    /**
	 * @param {number} a
	 * @param {number} b
	 */ const sum = (a, b)=>a + b;
    /**
	 * @param {Chunk[][]} nodes
	 * @param {Chunk} separator
	 * @returns {Chunk[]}
	 */ const join = (nodes, separator)=>{
        if (nodes.length === 0) return [];
        const joined = [
            ...nodes[0]
        ];
        for(let i = 1; i < nodes.length; i += 1){
            joined.push(separator);
            push_array(joined, nodes[i]);
        }
        return joined;
    };
    /**
	 * @param {(node: any, state: State) => Chunk[]} fn
	 */ const scoped = (fn)=>{
        /**
		 * @param {any} node
		 * @param {State} state
		 */ const scoped_fn = (node, state)=>{
            return fn(node, {
                ...state,
                scope: state.scope_map.get(node)
            });
        };
        return scoped_fn;
    };
    /**
	 * @param {string} name
	 * @param {Set<string>} names
	 */ const deconflict = (name, names)=>{
        const original = name;
        let i = 1;
        while(names.has(name))name = `${original}$${i++}`;
        return name;
    };
    /**
	 * @param {Node[]} nodes
	 * @param {State} state
	 */ const handle_body = (nodes, state)=>{
        const chunks = [];
        const body = nodes.map((statement)=>{
            const chunks = handle(statement, {
                ...state,
                indent: state.indent
            });
            let add_newline = false;
            while(state.comments.length){
                const comment = state.comments.shift();
                const prefix = add_newline ? `\n${state.indent}` : ` `;
                chunks.push(c(comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`));
                add_newline = comment.type === "Line";
            }
            return chunks;
        });
        let needed_padding = false;
        for(let i = 0; i < body.length; i += 1){
            const needs_padding = has_newline(body[i]);
            if (i > 0) chunks.push(c(needs_padding || needed_padding ? `\n\n${state.indent}` : `\n${state.indent}`));
            push_array(chunks, body[i]);
            needed_padding = needs_padding;
        }
        return chunks;
    };
    /**
	 * @param {VariableDeclaration} node
	 * @param {State} state
	 */ const handle_var_declaration = (node, state)=>{
        const chunks = [
            c(`${node.kind} `)
        ];
        const declarators = node.declarations.map((d)=>handle(d, {
                ...state,
                indent: state.indent + (node.declarations.length === 1 ? "" : "	")
            }));
        const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
        const separator = c(multiple_lines ? `,\n${state.indent}\t` : ", ");
        push_array(chunks, join(declarators, separator));
        return chunks;
    };
    /** @type {Record<string, Handler>} */ const handlers = {
        Program (node, state) {
            return handle_body(node.body, state);
        },
        BlockStatement: scoped((node, state)=>{
            return [
                c(`{\n${state.indent}\t`),
                ...handle_body(node.body, {
                    ...state,
                    indent: state.indent + "	"
                }),
                c(`\n${state.indent}}`)
            ];
        }),
        EmptyStatement (node, state) {
            return [
                c(";")
            ];
        },
        ParenthesizedExpression (node, state) {
            return handle(node.expression, state);
        },
        ExpressionStatement (node, state) {
            if (node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern") // is an AssignmentExpression to an ObjectPattern
            return [
                c("("),
                ...handle(node.expression, state),
                c(");")
            ];
            return [
                ...handle(node.expression, state),
                c(";")
            ];
        },
        IfStatement (node, state) {
            const chunks = [
                c("if ("),
                ...handle(node.test, state),
                c(") "),
                ...handle(node.consequent, state)
            ];
            if (node.alternate) {
                chunks.push(c(" else "));
                push_array(chunks, handle(node.alternate, state));
            }
            return chunks;
        },
        LabeledStatement (node, state) {
            return [
                ...handle(node.label, state),
                c(": "),
                ...handle(node.body, state)
            ];
        },
        BreakStatement (node, state) {
            return node.label ? [
                c("break "),
                ...handle(node.label, state),
                c(";")
            ] : [
                c("break;")
            ];
        },
        ContinueStatement (node, state) {
            return node.label ? [
                c("continue "),
                ...handle(node.label, state),
                c(";")
            ] : [
                c("continue;")
            ];
        },
        WithStatement (node, state) {
            return [
                c("with ("),
                ...handle(node.object, state),
                c(") "),
                ...handle(node.body, state)
            ];
        },
        SwitchStatement (/** @type {SwitchStatement} */ node, state) {
            const chunks = [
                c("switch ("),
                ...handle(node.discriminant, state),
                c(") {")
            ];
            node.cases.forEach((block)=>{
                if (block.test) {
                    chunks.push(c(`\n${state.indent}\tcase `));
                    push_array(chunks, handle(block.test, {
                        ...state,
                        indent: `${state.indent}\t`
                    }));
                    chunks.push(c(":"));
                } else chunks.push(c(`\n${state.indent}\tdefault:`));
                block.consequent.forEach((statement)=>{
                    chunks.push(c(`\n${state.indent}\t\t`));
                    push_array(chunks, handle(statement, {
                        ...state,
                        indent: `${state.indent}\t\t`
                    }));
                });
            });
            chunks.push(c(`\n${state.indent}}`));
            return chunks;
        },
        ReturnStatement (node, state) {
            if (node.argument) {
                const contains_comment = node.argument.leadingComments && node.argument.leadingComments.some((/** @type import('../utils/comments.js').CommentWithLocation */ comment)=>comment.has_trailing_newline);
                return [
                    c(contains_comment ? "return (" : "return "),
                    ...handle(node.argument, state),
                    c(contains_comment ? ");" : ";")
                ];
            } else return [
                c("return;")
            ];
        },
        ThrowStatement (node, state) {
            return [
                c("throw "),
                ...handle(node.argument, state),
                c(";")
            ];
        },
        TryStatement (node, state) {
            const chunks = [
                c("try "),
                ...handle(node.block, state)
            ];
            if (node.handler) {
                if (node.handler.param) {
                    chunks.push(c(" catch("));
                    push_array(chunks, handle(node.handler.param, state));
                    chunks.push(c(") "));
                } else chunks.push(c(" catch "));
                push_array(chunks, handle(node.handler.body, state));
            }
            if (node.finalizer) {
                chunks.push(c(" finally "));
                push_array(chunks, handle(node.finalizer, state));
            }
            return chunks;
        },
        WhileStatement (node, state) {
            return [
                c("while ("),
                ...handle(node.test, state),
                c(") "),
                ...handle(node.body, state)
            ];
        },
        DoWhileStatement (node, state) {
            return [
                c("do "),
                ...handle(node.body, state),
                c(" while ("),
                ...handle(node.test, state),
                c(");")
            ];
        },
        ForStatement: scoped((node, state)=>{
            const chunks = [
                c("for (")
            ];
            if (node.init) {
                if (node.init.type === "VariableDeclaration") push_array(chunks, handle_var_declaration(node.init, state));
                else push_array(chunks, handle(node.init, state));
            }
            chunks.push(c("; "));
            if (node.test) push_array(chunks, handle(node.test, state));
            chunks.push(c("; "));
            if (node.update) push_array(chunks, handle(node.update, state));
            chunks.push(c(") "));
            push_array(chunks, handle(node.body, state));
            return chunks;
        }),
        ForInStatement: scoped((node, state)=>{
            const chunks = [
                c(`for ${node.await ? "await " : ""}(`)
            ];
            if (node.left.type === "VariableDeclaration") push_array(chunks, handle_var_declaration(node.left, state));
            else push_array(chunks, handle(node.left, state));
            chunks.push(c(node.type === "ForInStatement" ? ` in ` : ` of `));
            push_array(chunks, handle(node.right, state));
            chunks.push(c(") "));
            push_array(chunks, handle(node.body, state));
            return chunks;
        }),
        DebuggerStatement (node, state) {
            return [
                c("debugger", node),
                c(";")
            ];
        },
        FunctionDeclaration: scoped((/** @type {FunctionDeclaration} */ node, state)=>{
            const chunks = [];
            if (node.async) chunks.push(c("async "));
            chunks.push(c(node.generator ? "function* " : "function "));
            if (node.id) push_array(chunks, handle(node.id, state));
            chunks.push(c("("));
            const params = node.params.map((p)=>handle(p, {
                    ...state,
                    indent: state.indent + "	"
                }));
            const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
            const separator = c(multiple_lines ? `,\n${state.indent}` : ", ");
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}\t`));
                push_array(chunks, join(params, separator));
                chunks.push(c(`\n${state.indent}`));
            } else push_array(chunks, join(params, separator));
            chunks.push(c(") "));
            push_array(chunks, handle(node.body, state));
            return chunks;
        }),
        VariableDeclaration (node, state) {
            return handle_var_declaration(node, state).concat(c(";"));
        },
        VariableDeclarator (node, state) {
            if (node.init) return [
                ...handle(node.id, state),
                c(" = "),
                ...handle(node.init, state)
            ];
            else return handle(node.id, state);
        },
        ClassDeclaration (node, state) {
            const chunks = [
                c("class ")
            ];
            if (node.id) {
                push_array(chunks, handle(node.id, state));
                chunks.push(c(" "));
            }
            if (node.superClass) {
                chunks.push(c("extends "));
                push_array(chunks, handle(node.superClass, state));
                chunks.push(c(" "));
            }
            push_array(chunks, handle(node.body, state));
            return chunks;
        },
        ImportDeclaration (/** @type {ImportDeclaration} */ node, state) {
            const chunks = [
                c("import ")
            ];
            const { length: length } = node.specifiers;
            const source = handle(node.source, state);
            if (length > 0) {
                let i = 0;
                while(i < length){
                    if (i > 0) chunks.push(c(", "));
                    const specifier = node.specifiers[i];
                    if (specifier.type === "ImportDefaultSpecifier") {
                        chunks.push(c(specifier.local.name, specifier));
                        i += 1;
                    } else if (specifier.type === "ImportNamespaceSpecifier") {
                        chunks.push(c("* as " + specifier.local.name, specifier));
                        i += 1;
                    } else break;
                }
                if (i < length) {
                    // we have named specifiers
                    const specifiers = node.specifiers.slice(i).map((/** @type {ImportSpecifier} */ specifier)=>{
                        const name = handle(specifier.imported, state)[0];
                        const as = handle(specifier.local, state)[0];
                        if (name.content === as.content) return [
                            as
                        ];
                        return [
                            name,
                            c(" as "),
                            as
                        ];
                    });
                    const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
                    if (width > 80) {
                        chunks.push(c(`{\n\t`));
                        push_array(chunks, join(specifiers, c(",\n	")));
                        chunks.push(c("\n}"));
                    } else {
                        chunks.push(c(`{ `));
                        push_array(chunks, join(specifiers, c(", ")));
                        chunks.push(c(" }"));
                    }
                }
                chunks.push(c(" from "));
            }
            push_array(chunks, source);
            chunks.push(c(";"));
            return chunks;
        },
        ImportExpression (node, state) {
            return [
                c("import("),
                ...handle(node.source, state),
                c(")")
            ];
        },
        ExportDefaultDeclaration (node, state) {
            const chunks = [
                c(`export default `),
                ...handle(node.declaration, state)
            ];
            if (node.declaration.type !== "FunctionDeclaration") chunks.push(c(";"));
            return chunks;
        },
        ExportNamedDeclaration (node, state) {
            const chunks = [
                c("export ")
            ];
            if (node.declaration) push_array(chunks, handle(node.declaration, state));
            else {
                const specifiers = node.specifiers.map((/** @type {ExportSpecifier} */ specifier)=>{
                    const name = handle(specifier.local, state)[0];
                    const as = handle(specifier.exported, state)[0];
                    if (name.content === as.content) return [
                        name
                    ];
                    return [
                        name,
                        c(" as "),
                        as
                    ];
                });
                const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
                if (width > 80) {
                    chunks.push(c("{\n	"));
                    push_array(chunks, join(specifiers, c(",\n	")));
                    chunks.push(c("\n}"));
                } else {
                    chunks.push(c("{ "));
                    push_array(chunks, join(specifiers, c(", ")));
                    chunks.push(c(" }"));
                }
                if (node.source) {
                    chunks.push(c(" from "));
                    push_array(chunks, handle(node.source, state));
                }
            }
            chunks.push(c(";"));
            return chunks;
        },
        ExportAllDeclaration (node, state) {
            return [
                c(`export * from `),
                ...handle(node.source, state),
                c(`;`)
            ];
        },
        MethodDefinition (node, state) {
            const chunks = [];
            if (node.static) chunks.push(c("static "));
            if (node.kind === "get" || node.kind === "set") // Getter or setter
            chunks.push(c(node.kind + " "));
            if (node.value.async) chunks.push(c("async "));
            if (node.value.generator) chunks.push(c("*"));
            if (node.computed) {
                chunks.push(c("["));
                push_array(chunks, handle(node.key, state));
                chunks.push(c("]"));
            } else push_array(chunks, handle(node.key, state));
            chunks.push(c("("));
            const { params: params } = node.value;
            for(let i = 0; i < params.length; i += 1){
                push_array(chunks, handle(params[i], state));
                if (i < params.length - 1) chunks.push(c(", "));
            }
            chunks.push(c(") "));
            push_array(chunks, handle(node.value.body, state));
            return chunks;
        },
        ArrowFunctionExpression: scoped((/** @type {ArrowFunctionExpression} */ node, state)=>{
            const chunks = [];
            if (node.async) chunks.push(c("async "));
            if (node.params.length === 1 && node.params[0].type === "Identifier") push_array(chunks, handle(node.params[0], state));
            else {
                const params = node.params.map((param)=>handle(param, {
                        ...state,
                        indent: state.indent + "	"
                    }));
                chunks.push(c("("));
                push_array(chunks, join(params, c(", ")));
                chunks.push(c(")"));
            }
            chunks.push(c(" => "));
            if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern") {
                chunks.push(c("("));
                push_array(chunks, handle(node.body, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.body, state));
            return chunks;
        }),
        ThisExpression (node, state) {
            return [
                c("this", node)
            ];
        },
        Super (node, state) {
            return [
                c("super", node)
            ];
        },
        RestElement (node, state) {
            return [
                c("..."),
                ...handle(node.argument, state)
            ];
        },
        YieldExpression (node, state) {
            if (node.argument) return [
                c(node.delegate ? `yield* ` : `yield `),
                ...handle(node.argument, state)
            ];
            return [
                c(node.delegate ? `yield*` : `yield`)
            ];
        },
        AwaitExpression (node, state) {
            if (node.argument) {
                const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
                if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) return [
                    c("await ("),
                    ...handle(node.argument, state),
                    c(")")
                ];
                else return [
                    c("await "),
                    ...handle(node.argument, state)
                ];
            }
            return [
                c("await")
            ];
        },
        TemplateLiteral (node, state) {
            const chunks = [
                c("`")
            ];
            const { quasis: quasis, expressions: expressions } = node;
            for(let i = 0; i < expressions.length; i++){
                chunks.push(c(quasis[i].value.raw), c("${"));
                push_array(chunks, handle(expressions[i], state));
                chunks.push(c("}"));
            }
            chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
            return chunks;
        },
        TaggedTemplateExpression (node, state) {
            return handle(node.tag, state).concat(handle(node.quasi, state));
        },
        ArrayExpression (node, state) {
            const chunks = [
                c("[")
            ];
            /** @type {Chunk[][]} */ const elements = [];
            /** @type {Chunk[]} */ let sparse_commas = [];
            for(let i = 0; i < node.elements.length; i += 1){
                // can't use map/forEach because of sparse arrays
                const element = node.elements[i];
                if (element) {
                    elements.push([
                        ...sparse_commas,
                        ...handle(element, {
                            ...state,
                            indent: state.indent + "	"
                        })
                    ]);
                    sparse_commas = [];
                } else sparse_commas.push(c(","));
            }
            const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}\t`));
                push_array(chunks, join(elements, c(`,\n${state.indent}\t`)));
                chunks.push(c(`\n${state.indent}`));
                push_array(chunks, sparse_commas);
            } else {
                push_array(chunks, join(elements, c(", ")));
                push_array(chunks, sparse_commas);
            }
            chunks.push(c("]"));
            return chunks;
        },
        ObjectExpression (/** @type {ObjectExpression} */ node, state) {
            if (node.properties.length === 0) return [
                c("{}")
            ];
            let has_inline_comment = false;
            /** @type {Chunk[]} */ const chunks = [];
            const separator = c(", ");
            node.properties.forEach((p, i)=>{
                push_array(chunks, handle(p, {
                    ...state,
                    indent: state.indent + "	"
                }));
                if (state.comments.length) {
                    // TODO generalise this, so it works with ArrayExpressions and other things.
                    // At present, stuff will just get appended to the closest statement/declaration
                    chunks.push(c(", "));
                    while(state.comments.length){
                        const comment = state.comments.shift();
                        chunks.push(c(comment.type === "Block" ? `/*${comment.value}*/\n${state.indent}\t` : `//${comment.value}\n${state.indent}\t`));
                        if (comment.type === "Line") has_inline_comment = true;
                    }
                } else if (i < node.properties.length - 1) chunks.push(separator);
            });
            const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
            if (multiple_lines) separator.content = `,\n${state.indent}\t`;
            return [
                c(multiple_lines ? `{\n${state.indent}\t` : `{ `),
                ...chunks,
                c(multiple_lines ? `\n${state.indent}}` : ` }`)
            ];
        },
        Property (node, state) {
            const value = handle(node.value, state);
            if (node.key === node.value) return value;
            // special case
            if (!node.computed && node.value.type === "AssignmentPattern" && node.value.left.type === "Identifier" && node.value.left.name === node.key.name) return value;
            if (!node.computed && node.value.type === "Identifier" && (node.key.type === "Identifier" && node.key.name === value[0].content || node.key.type === "Literal" && node.key.value === value[0].content)) return value;
            const key = handle(node.key, state);
            if (node.value.type === "FunctionExpression" && !node.value.id) {
                state = {
                    ...state,
                    scope: state.scope_map.get(node.value)
                };
                const chunks = node.kind !== "init" ? [
                    c(`${node.kind} `)
                ] : [];
                if (node.value.async) chunks.push(c("async "));
                if (node.value.generator) chunks.push(c("*"));
                push_array(chunks, node.computed ? [
                    c("["),
                    ...key,
                    c("]")
                ] : key);
                chunks.push(c("("));
                push_array(chunks, join(node.value.params.map((/** @type {Pattern} */ param)=>handle(param, state)), c(", ")));
                chunks.push(c(") "));
                push_array(chunks, handle(node.value.body, state));
                return chunks;
            }
            if (node.computed) return [
                c("["),
                ...key,
                c("]: "),
                ...value
            ];
            return [
                ...key,
                c(": "),
                ...value
            ];
        },
        ObjectPattern (node, state) {
            const chunks = [
                c("{ ")
            ];
            for(let i = 0; i < node.properties.length; i += 1){
                push_array(chunks, handle(node.properties[i], state));
                if (i < node.properties.length - 1) chunks.push(c(", "));
            }
            chunks.push(c(" }"));
            return chunks;
        },
        SequenceExpression (/** @type {SequenceExpression} */ node, state) {
            const expressions = node.expressions.map((e)=>handle(e, state));
            return [
                c("("),
                ...join(expressions, c(", ")),
                c(")")
            ];
        },
        UnaryExpression (node, state) {
            const chunks = [
                c(node.operator)
            ];
            if (node.operator.length > 1) chunks.push(c(" "));
            if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
                chunks.push(c("("));
                push_array(chunks, handle(node.argument, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.argument, state));
            return chunks;
        },
        UpdateExpression (node, state) {
            return node.prefix ? [
                c(node.operator),
                ...handle(node.argument, state)
            ] : [
                ...handle(node.argument, state),
                c(node.operator)
            ];
        },
        AssignmentExpression (node, state) {
            return [
                ...handle(node.left, state),
                c(` ${node.operator || "="} `),
                ...handle(node.right, state)
            ];
        },
        BinaryExpression (node, state) {
            /**
			 * @type any[]
			 */ const chunks = [];
            // TODO
            // const is_in = node.operator === 'in';
            // if (is_in) {
            // 	// Avoids confusion in `for` loops initializers
            // 	chunks.push(c('('));
            // }
            if (needs_parens(node.left, node, false)) {
                chunks.push(c("("));
                push_array(chunks, handle(node.left, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.left, state));
            chunks.push(c(` ${node.operator} `));
            if (needs_parens(node.right, node, true)) {
                chunks.push(c("("));
                push_array(chunks, handle(node.right, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.right, state));
            return chunks;
        },
        ConditionalExpression (node, state) {
            /**
			 * @type any[]
			 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) push_array(chunks, handle(node.test, state));
            else {
                chunks.push(c("("));
                push_array(chunks, handle(node.test, state));
                chunks.push(c(")"));
            }
            const child_state = {
                ...state,
                indent: state.indent + "	"
            };
            const consequent = handle(node.consequent, child_state);
            const alternate = handle(node.alternate, child_state);
            const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}? `));
                push_array(chunks, consequent);
                chunks.push(c(`\n${state.indent}: `));
                push_array(chunks, alternate);
            } else {
                chunks.push(c(` ? `));
                push_array(chunks, consequent);
                chunks.push(c(` : `));
                push_array(chunks, alternate);
            }
            return chunks;
        },
        NewExpression (/** @type {NewExpression} */ node, state) {
            const chunks = [
                c("new ")
            ];
            if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)) {
                chunks.push(c("("));
                push_array(chunks, handle(node.callee, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.callee, state));
            // TODO this is copied from CallExpression — DRY it out
            const args = node.arguments.map((arg)=>handle(arg, {
                    ...state,
                    indent: state.indent + "	"
                }));
            const separator = args.some(has_newline) // TODO or length exceeds 80
             ? c(",\n" + state.indent) : c(", ");
            chunks.push(c("("));
            push_array(chunks, join(args, separator));
            chunks.push(c(")"));
            return chunks;
        },
        ChainExpression (node, state) {
            return handle(node.expression, state);
        },
        CallExpression (/** @type {CallExpression} */ node, state) {
            /**
			 * @type any[]
			 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
                chunks.push(c("("));
                push_array(chunks, handle(node.callee, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.callee, state));
            if (/** @type {SimpleCallExpression} */ node.optional) chunks.push(c("?."));
            const args = node.arguments.map((arg)=>handle(arg, state));
            const multiple_lines = args.slice(0, -1).some(has_newline); // TODO or length exceeds 80
            if (multiple_lines) {
                // need to handle args again. TODO find alternative approach?
                const args = node.arguments.map((arg)=>handle(arg, {
                        ...state,
                        indent: `${state.indent}\t`
                    }));
                chunks.push(c(`(\n${state.indent}\t`));
                push_array(chunks, join(args, c(`,\n${state.indent}\t`)));
                chunks.push(c(`\n${state.indent})`));
            } else {
                chunks.push(c("("));
                push_array(chunks, join(args, c(", ")));
                chunks.push(c(")"));
            }
            return chunks;
        },
        MemberExpression (node, state) {
            /**
			 * @type any[]
			 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
                chunks.push(c("("));
                push_array(chunks, handle(node.object, state));
                chunks.push(c(")"));
            } else push_array(chunks, handle(node.object, state));
            if (node.computed) {
                if (node.optional) chunks.push(c("?."));
                chunks.push(c("["));
                push_array(chunks, handle(node.property, state));
                chunks.push(c("]"));
            } else {
                chunks.push(c(node.optional ? "?." : "."));
                push_array(chunks, handle(node.property, state));
            }
            return chunks;
        },
        MetaProperty (node, state) {
            return [
                ...handle(node.meta, state),
                c("."),
                ...handle(node.property, state)
            ];
        },
        Identifier (node, state) {
            let name = node.name;
            if (name[0] === "@") name = state.getName(name.slice(1));
            else if (node.name[0] === "#") {
                const owner = state.scope.find_owner(node.name);
                if (!owner) throw new Error(`Could not find owner for node`);
                if (!state.deconflicted.has(owner)) state.deconflicted.set(owner, new Map());
                const deconflict_map = state.deconflicted.get(owner);
                if (!deconflict_map.has(node.name)) deconflict_map.set(node.name, deconflict(node.name.slice(1), owner.references));
                name = deconflict_map.get(node.name);
            }
            return [
                c(name, node)
            ];
        },
        Literal (/** @type {Literal} */ node, state) {
            if (typeof node.value === "string") return [
                // TODO do we need to handle weird unicode characters somehow?
                // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
                c((node.raw || JSON.stringify(node.value)).replace(re, (_m, _i, at, hash, name)=>{
                    if (at) return "@" + name;
                    if (hash) return "#" + name;
                    throw new Error(`this shouldn't happen`);
                }), node)
            ];
            return [
                c(node.raw || String(node.value), node)
            ];
        }
    };
    handlers.ForOfStatement = handlers.ForInStatement;
    handlers.FunctionExpression = handlers.FunctionDeclaration;
    handlers.ClassExpression = handlers.ClassDeclaration;
    handlers.ClassBody = handlers.BlockStatement;
    handlers.SpreadElement = handlers.RestElement;
    handlers.ArrayPattern = handlers.ArrayExpression;
    handlers.LogicalExpression = handlers.BinaryExpression;
    handlers.AssignmentPattern = handlers.AssignmentExpression;
    var charToInteger = {};
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for(var i$1 = 0; i$1 < chars.length; i$1++)charToInteger[chars.charCodeAt(i$1)] = i$1;
    function decode(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
            0,
            0,
            0,
            0,
            0
        ];
        var j = 0;
        for(var i = 0, shift = 0, value = 0; i < mappings.length; i++){
            var c = mappings.charCodeAt(i);
            if (c === 44) {
                segmentify(line, segment, j);
                j = 0;
            } else if (c === 59) {
                segmentify(line, segment, j);
                j = 0;
                decoded.push(line);
                line = [];
                segment[0] = 0;
            } else {
                var integer = charToInteger[c];
                if (integer === undefined) throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
                var hasContinuationBit = integer & 32;
                integer &= 31;
                value += integer << shift;
                if (hasContinuationBit) shift += 5;
                else {
                    var shouldNegate = value & 1;
                    value >>>= 1;
                    if (shouldNegate) value = value === 0 ? -2147483648 : -value;
                    segment[j] += value;
                    j++;
                    value = shift = 0; // reset
                }
            }
        }
        segmentify(line, segment, j);
        decoded.push(line);
        return decoded;
    }
    function segmentify(line, segment, j) {
        // This looks ugly, but we're creating specialized arrays with a specific
        // length. This is much faster than creating a new array (which v8 expands to
        // a capacity of 17 after pushing the first item), or slicing out a subarray
        // (which is slow). Length 4 is assumed to be the most frequent, followed by
        // length 5 (since not everything will have an associated name), followed by
        // length 1 (it's probably rare for a source substring to not have an
        // associated segment data).
        if (j === 4) line.push([
            segment[0],
            segment[1],
            segment[2],
            segment[3]
        ]);
        else if (j === 5) line.push([
            segment[0],
            segment[1],
            segment[2],
            segment[3],
            segment[4]
        ]);
        else if (j === 1) line.push([
            segment[0]
        ]);
    }
    function encode(decoded) {
        var sourceFileIndex = 0; // second field
        var sourceCodeLine = 0; // third field
        var sourceCodeColumn = 0; // fourth field
        var nameIndex = 0; // fifth field
        var mappings = "";
        for(var i = 0; i < decoded.length; i++){
            var line = decoded[i];
            if (i > 0) mappings += ";";
            if (line.length === 0) continue;
            var generatedCodeColumn = 0; // first field
            var lineMappings = [];
            for(var _i = 0, line_1 = line; _i < line_1.length; _i++){
                var segment = line_1[_i];
                var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
                generatedCodeColumn = segment[0];
                if (segment.length > 1) {
                    segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
                    sourceFileIndex = segment[1];
                    sourceCodeLine = segment[2];
                    sourceCodeColumn = segment[3];
                }
                if (segment.length === 5) {
                    segmentMappings += encodeInteger(segment[4] - nameIndex);
                    nameIndex = segment[4];
                }
                lineMappings.push(segmentMappings);
            }
            mappings += lineMappings.join(",");
        }
        return mappings;
    }
    function encodeInteger(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
            var clamped = num & 31;
            num >>>= 5;
            if (num > 0) clamped |= 32;
            result += chars[clamped];
        }while (num > 0);
        return result;
    }
    /** @type {(str?: string) => string} str */ let btoa$1 = ()=>{
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") btoa$1 = (str)=>window.btoa(unescape(encodeURIComponent(str)));
    else if (typeof Buffer === "function") btoa$1 = (str)=>Buffer.from(str, "utf-8").toString("base64");
    /** @typedef {import('estree').Node} Node */ /**
	 * @typedef {{
	 *   file?: string;
	 *   sourceMapSource?: string;
	 *   sourceMapContent?: string;
	 *   sourceMapEncodeMappings?: boolean; // default true
	 *   getName?: (name: string) => string;
	 * }} PrintOptions
	 */ /**
	 * @param {Node} node
	 * @param {PrintOptions} opts
	 * @returns {{ code: string, map: any }} // TODO
	 */ function print(node, opts = {}) {
        if (Array.isArray(node)) return print({
            type: "Program",
            body: node,
            sourceType: "module"
        }, opts);
        const { getName: getName = /** @param {string} x */ (x)=>{
            throw new Error(`Unhandled sigil @${x}`);
        } } = opts;
        let { map: scope_map, scope: scope } = analyze(node);
        const deconflicted = new WeakMap();
        const chunks = handle(node, {
            indent: "",
            getName: getName,
            scope: scope,
            scope_map: scope_map,
            deconflicted: deconflicted,
            comments: []
        });
        /** @typedef {[number, number, number, number]} Segment */ let code = "";
        let current_column = 0;
        /** @type {Segment[][]} */ let mappings = [];
        /** @type {Segment[]} */ let current_line = [];
        for(let i = 0; i < chunks.length; i += 1){
            const chunk = chunks[i];
            code += chunk.content;
            if (chunk.loc) current_line.push([
                current_column,
                0,
                chunk.loc.start.line - 1,
                chunk.loc.start.column
            ]);
            for(let i = 0; i < chunk.content.length; i += 1)if (chunk.content[i] === "\n") {
                mappings.push(current_line);
                current_line = [];
                current_column = 0;
            } else current_column += 1;
            if (chunk.loc) current_line.push([
                current_column,
                0,
                chunk.loc.end.line - 1,
                chunk.loc.end.column
            ]);
        }
        mappings.push(current_line);
        const map = {
            version: 3,
            /** @type {string[]} */ names: [],
            sources: [
                opts.sourceMapSource || null
            ],
            sourcesContent: [
                opts.sourceMapContent || null
            ],
            mappings: opts.sourceMapEncodeMappings == undefined || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
        };
        Object.defineProperties(map, {
            toString: {
                enumerable: false,
                value: function toString() {
                    return JSON.stringify(this);
                }
            },
            toUrl: {
                enumerable: false,
                value: function toUrl() {
                    return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
                }
            }
        });
        return {
            code: code,
            map: map
        };
    }
    /** @typedef {import('estree').Expression} Expression */ /** @typedef {import('estree').Node} Node */ /** @typedef {import('estree').ObjectExpression} ObjectExpression */ /** @typedef {import('estree').Property} Property */ /** @typedef {import('estree').SpreadElement} SpreadElement */ /** @typedef {import('./utils/comments').CommentWithLocation} CommentWithLocation */ /** @type {Record<string, string>} */ const sigils = {
        "@": "AT",
        "#": "HASH"
    };
    /** @param {TemplateStringsArray} strings */ const join$1 = (strings)=>{
        let str = strings[0];
        for(let i = 1; i < strings.length; i += 1)str += `_${id}_${i - 1}_${strings[i]}`;
        return str.replace(/([@#])(\w+)/g, (_m, sigil, name)=>`_${id}_${sigils[sigil]}_${name}`);
    };
    /**
	 * @param {any[]} array
	 * @param {any[]} target
	 */ const flatten_body = (array, target)=>{
        for(let i = 0; i < array.length; i += 1){
            const statement = array[i];
            if (Array.isArray(statement)) {
                flatten_body(statement, target);
                continue;
            }
            if (statement.type === "ExpressionStatement") {
                if (statement.expression === EMPTY) continue;
                if (Array.isArray(statement.expression)) {
                    // TODO this is hacktacular
                    let node = statement.expression[0];
                    while(Array.isArray(node))node = node[0];
                    if (node) node.leadingComments = statement.leadingComments;
                    flatten_body(statement.expression, target);
                    continue;
                }
                if (/(Expression|Literal)$/.test(statement.expression.type)) {
                    target.push(statement);
                    continue;
                }
                if (statement.leadingComments) statement.expression.leadingComments = statement.leadingComments;
                if (statement.trailingComments) statement.expression.trailingComments = statement.trailingComments;
                target.push(statement.expression);
                continue;
            }
            target.push(statement);
        }
        return target;
    };
    /**
	 * @param {any[]} array
	 * @param {any[]} target
	 */ const flatten_properties = (array, target)=>{
        for(let i = 0; i < array.length; i += 1){
            const property = array[i];
            if (property.value === EMPTY) continue;
            if (property.key === property.value && Array.isArray(property.key)) {
                flatten_properties(property.key, target);
                continue;
            }
            target.push(property);
        }
        return target;
    };
    /**
	 * @param {any[]} nodes
	 * @param {any[]} target
	 */ const flatten$1 = (nodes, target)=>{
        for(let i = 0; i < nodes.length; i += 1){
            const node = nodes[i];
            if (node === EMPTY) continue;
            if (Array.isArray(node)) {
                flatten$1(node, target);
                continue;
            }
            target.push(node);
        }
        return target;
    };
    const EMPTY = {
        type: "Empty"
    };
    /**
	 *
	 * @param {CommentWithLocation[]} comments
	 * @param {string} raw
	 * @returns {any}
	 */ const acorn_opts = (comments, raw)=>{
        const { onComment: onComment } = get_comment_handlers(comments, raw);
        return {
            ecmaVersion: 2020,
            sourceType: "module",
            allowAwaitOutsideFunction: true,
            allowImportExportEverywhere: true,
            allowReturnOutsideFunction: true,
            onComment: onComment
        };
    };
    /**
	 * @param {string} raw
	 * @param {Node} node
	 * @param {any[]} values
	 * @param {CommentWithLocation[]} comments
	 */ const inject = (raw, node, values, comments)=>{
        comments.forEach((comment)=>{
            comment.value = comment.value.replace(re, (m, i)=>+i in values ? values[+i] : m);
        });
        const { enter: enter, leave: leave } = get_comment_handlers(comments, raw);
        return walk(node, {
            enter: enter,
            /** @param {any} node */ leave (node) {
                if (node.type === "Identifier") {
                    re.lastIndex = 0;
                    const match = re.exec(node.name);
                    if (match) {
                        if (match[1]) {
                            if (+match[1] in values) {
                                let value = values[+match[1]];
                                if (typeof value === "string") value = {
                                    type: "Identifier",
                                    name: value,
                                    leadingComments: node.leadingComments,
                                    trailingComments: node.trailingComments
                                };
                                else if (typeof value === "number") value = {
                                    type: "Literal",
                                    value: value,
                                    leadingComments: node.leadingComments,
                                    trailingComments: node.trailingComments
                                };
                                this.replace(value || EMPTY);
                            }
                        } else node.name = `${match[2] ? `@` : `#`}${match[4]}`;
                    }
                }
                if (node.type === "Literal") {
                    if (typeof node.value === "string") {
                        re.lastIndex = 0;
                        const new_value = /** @type {string} */ node.value.replace(re, (m, i)=>+i in values ? values[+i] : m);
                        const has_changed = new_value !== node.value;
                        node.value = new_value;
                        if (has_changed && node.raw) // preserve the quotes
                        node.raw = `${node.raw[0]}${JSON.stringify(node.value).slice(1, -1)}${node.raw[node.raw.length - 1]}`;
                    }
                }
                if (node.type === "TemplateElement") {
                    re.lastIndex = 0;
                    node.value.raw = /** @type {string} */ node.value.raw.replace(re, (m, i)=>+i in values ? values[+i] : m);
                }
                if (node.type === "Program" || node.type === "BlockStatement") node.body = flatten_body(node.body, []);
                if (node.type === "ObjectExpression" || node.type === "ObjectPattern") node.properties = flatten_properties(node.properties, []);
                if (node.type === "ArrayExpression" || node.type === "ArrayPattern") node.elements = flatten$1(node.elements, []);
                if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") node.params = flatten$1(node.params, []);
                if (node.type === "CallExpression" || node.type === "NewExpression") node.arguments = flatten$1(node.arguments, []);
                if (node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") node.specifiers = flatten$1(node.specifiers, []);
                if (node.type === "ForStatement") {
                    node.init = node.init === EMPTY ? null : node.init;
                    node.test = node.test === EMPTY ? null : node.test;
                    node.update = node.update === EMPTY ? null : node.update;
                }
                leave(node);
            }
        });
    };
    /**
	 *
	 * @param {TemplateStringsArray} strings
	 * @param  {any[]} values
	 * @returns {Node[]}
	 */ function b(strings, ...values) {
        const str = join$1(strings);
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let ast = /** @type {any} */ parse(str, acorn_opts(comments, str));
            ast = inject(str, ast, values, comments);
            return ast.body;
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
	 *
	 * @param {TemplateStringsArray} strings
	 * @param  {any[]} values
	 * @returns {Expression & { start: Number, end: number }}
	 */ function x(strings, ...values) {
        const str = join$1(strings);
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let expression = /** @type {Expression & { start: Number, end: number }} */ parseExpressionAt(str, 0, acorn_opts(comments, str));
            const match = /\S+/.exec(str.slice(expression.end));
            if (match) throw new Error(`Unexpected token '${match[0]}'`);
            expression = /** @type {Expression & { start: Number, end: number }} */ inject(str, expression, values, comments);
            return expression;
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
	 *
	 * @param {TemplateStringsArray} strings
	 * @param  {any[]} values
	 * @returns {(Property | SpreadElement) & { start: Number, end: number }}
	 */ function p(strings, ...values) {
        const str = `{${join$1(strings)}}`;
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let expression = /** @type {any} */ parseExpressionAt(str, 0, acorn_opts(comments, str));
            expression = inject(str, expression, values, comments);
            return expression.properties[0];
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
	 * @param {string} str
	 * @param {Error} err
	 */ function handle_error(str, err) {
        // TODO location/code frame
        re.lastIndex = 0;
        str = str.replace(re, (m, i, at, hash, name)=>{
            if (at) return `@${name}`;
            if (hash) return `#${name}`;
            return "${...}";
        });
        console.log(`failed to parse:\n${str}`);
        throw err;
    }
    /**
	 * @param {string} source
	 * @param {any} opts
	 */ const parse$1 = (source, opts)=>{
        /** @type {CommentWithLocation[]} */ const comments = [];
        const { onComment: onComment, enter: enter, leave: leave } = get_comment_handlers(comments, source);
        const ast = /** @type {any} */ parse(source, {
            onComment: onComment,
            ...opts
        });
        walk(ast, {
            enter: enter,
            leave: leave
        });
        return ast;
    };
    /**
	 * @param {string} source
	 * @param {number} index
	 * @param {any} opts
	 */ const parseExpressionAt$1 = (source, index, opts)=>{
        /** @type {CommentWithLocation[]} */ const comments = [];
        const { onComment: onComment, enter: enter, leave: leave } = get_comment_handlers(comments, source);
        const ast = /** @type {any} */ parseExpressionAt(source, index, {
            onComment: onComment,
            ...opts
        });
        walk(ast, {
            enter: enter,
            leave: leave
        });
        return ast;
    };
    const parse$2 = (source)=>parse$1(source, {
            sourceType: "module",
            ecmaVersion: 12,
            locations: true
        });
    const parse_expression_at = (source, index)=>parseExpressionAt$1(source, index, {
            sourceType: "module",
            ecmaVersion: 12,
            locations: true
        });
    function read_expression(parser) {
        try {
            const node = parse_expression_at(parser.template, parser.index);
            let num_parens = 0;
            for(let i = parser.index; i < node.start; i += 1)if (parser.template[i] === "(") num_parens += 1;
            let index = node.end;
            while(num_parens > 0){
                const char = parser.template[index];
                if (char === ")") num_parens -= 1;
                else if (!regex_whitespace.test(char)) parser.error(parser_errors.unexpected_token(")"), index);
                index += 1;
            }
            parser.index = index;
            return node;
        } catch (err) {
            parser.acorn_error(err);
        }
    }
    const regex_closing_script_tag = /<\/script\s*>/;
    function get_context(parser, attributes, start) {
        const context = attributes.find((attribute)=>attribute.name === "context");
        if (!context) return "default";
        if (context.value.length !== 1 || context.value[0].type !== "Text") parser.error(parser_errors.invalid_script_context_attribute, start);
        const value = context.value[0].data;
        if (value !== "module") parser.error(parser_errors.invalid_script_context_value, context.start);
        return value;
    }
    function read_script(parser, start, attributes) {
        const script_start = parser.index;
        const data = parser.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
        if (parser.index >= parser.template.length) parser.error(parser_errors.unclosed_script);
        const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data;
        parser.read(regex_closing_script_tag);
        let ast;
        try {
            ast = parse$2(source);
        } catch (err) {
            parser.acorn_error(err);
        }
        // TODO is this necessary?
        ast.start = script_start;
        return {
            type: "Script",
            start: start,
            end: parser.index,
            context: get_context(parser, attributes, start),
            content: ast
        };
    }
    //
    //                              list
    //                            ┌──────┐
    //             ┌──────────────┼─head │
    //             │              │ tail─┼──────────────┐
    //             │              └──────┘              │
    //             ▼                                    ▼
    //            item        item        item        item
    //          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
    //  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
    //          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
    //          ├──────┤    ├──────┤    ├──────┤    ├──────┤
    //          │ data │    │ data │    │ data │    │ data │
    //          └──────┘    └──────┘    └──────┘    └──────┘
    //
    let releasedCursors = null;
    class List {
        static createItem(data) {
            return {
                prev: null,
                next: null,
                data: data
            };
        }
        constructor(){
            this.head = null;
            this.tail = null;
            this.cursor = null;
        }
        createItem(data) {
            return List.createItem(data);
        }
        // cursor helpers
        allocateCursor(prev, next) {
            let cursor;
            if (releasedCursors !== null) {
                cursor = releasedCursors;
                releasedCursors = releasedCursors.cursor;
                cursor.prev = prev;
                cursor.next = next;
                cursor.cursor = this.cursor;
            } else cursor = {
                prev: prev,
                next: next,
                cursor: this.cursor
            };
            this.cursor = cursor;
            return cursor;
        }
        releaseCursor() {
            const { cursor: cursor } = this;
            this.cursor = cursor.cursor;
            cursor.prev = null;
            cursor.next = null;
            cursor.cursor = releasedCursors;
            releasedCursors = cursor;
        }
        updateCursors(prevOld, prevNew, nextOld, nextNew) {
            let { cursor: cursor } = this;
            while(cursor !== null){
                if (cursor.prev === prevOld) cursor.prev = prevNew;
                if (cursor.next === nextOld) cursor.next = nextNew;
                cursor = cursor.cursor;
            }
        }
        *[Symbol.iterator]() {
            for(let cursor = this.head; cursor !== null; cursor = cursor.next)yield cursor.data;
        }
        // getters
        get size() {
            let size = 0;
            for(let cursor = this.head; cursor !== null; cursor = cursor.next)size++;
            return size;
        }
        get isEmpty() {
            return this.head === null;
        }
        get first() {
            return this.head && this.head.data;
        }
        get last() {
            return this.tail && this.tail.data;
        }
        // convertors
        fromArray(array) {
            let cursor = null;
            this.head = null;
            for (let data of array){
                const item = List.createItem(data);
                if (cursor !== null) cursor.next = item;
                else this.head = item;
                item.prev = cursor;
                cursor = item;
            }
            this.tail = cursor;
            return this;
        }
        toArray() {
            return [
                ...this
            ];
        }
        toJSON() {
            return [
                ...this
            ];
        }
        // array-like methods
        forEach(fn, thisArg = this) {
            // push cursor
            const cursor = this.allocateCursor(null, this.head);
            while(cursor.next !== null){
                const item = cursor.next;
                cursor.next = item.next;
                fn.call(thisArg, item.data, item, this);
            }
            // pop cursor
            this.releaseCursor();
        }
        forEachRight(fn, thisArg = this) {
            // push cursor
            const cursor = this.allocateCursor(this.tail, null);
            while(cursor.prev !== null){
                const item = cursor.prev;
                cursor.prev = item.prev;
                fn.call(thisArg, item.data, item, this);
            }
            // pop cursor
            this.releaseCursor();
        }
        reduce(fn, initialValue, thisArg = this) {
            // push cursor
            let cursor = this.allocateCursor(null, this.head);
            let acc = initialValue;
            let item;
            while(cursor.next !== null){
                item = cursor.next;
                cursor.next = item.next;
                acc = fn.call(thisArg, acc, item.data, item, this);
            }
            // pop cursor
            this.releaseCursor();
            return acc;
        }
        reduceRight(fn, initialValue, thisArg = this) {
            // push cursor
            let cursor = this.allocateCursor(this.tail, null);
            let acc = initialValue;
            let item;
            while(cursor.prev !== null){
                item = cursor.prev;
                cursor.prev = item.prev;
                acc = fn.call(thisArg, acc, item.data, item, this);
            }
            // pop cursor
            this.releaseCursor();
            return acc;
        }
        some(fn, thisArg = this) {
            for(let cursor = this.head; cursor !== null; cursor = cursor.next){
                if (fn.call(thisArg, cursor.data, cursor, this)) return true;
            }
            return false;
        }
        map(fn, thisArg = this) {
            const result = new List();
            for(let cursor = this.head; cursor !== null; cursor = cursor.next)result.appendData(fn.call(thisArg, cursor.data, cursor, this));
            return result;
        }
        filter(fn, thisArg = this) {
            const result = new List();
            for(let cursor = this.head; cursor !== null; cursor = cursor.next)if (fn.call(thisArg, cursor.data, cursor, this)) result.appendData(cursor.data);
            return result;
        }
        nextUntil(start, fn, thisArg = this) {
            if (start === null) return;
            // push cursor
            const cursor = this.allocateCursor(null, start);
            while(cursor.next !== null){
                const item = cursor.next;
                cursor.next = item.next;
                if (fn.call(thisArg, item.data, item, this)) break;
            }
            // pop cursor
            this.releaseCursor();
        }
        prevUntil(start, fn, thisArg = this) {
            if (start === null) return;
            // push cursor
            const cursor = this.allocateCursor(start, null);
            while(cursor.prev !== null){
                const item = cursor.prev;
                cursor.prev = item.prev;
                if (fn.call(thisArg, item.data, item, this)) break;
            }
            // pop cursor
            this.releaseCursor();
        }
        // mutation
        clear() {
            this.head = null;
            this.tail = null;
        }
        copy() {
            const result = new List();
            for (let data of this)result.appendData(data);
            return result;
        }
        prepend(item) {
            //      head
            //    ^
            // item
            this.updateCursors(null, item, this.head, item);
            // insert to the beginning of the list
            if (this.head !== null) {
                // new item <- first item
                this.head.prev = item;
                // new item -> first item
                item.next = this.head;
            } else // if list has no head, then it also has no tail
            // in this case tail points to the new item
            this.tail = item;
            // head always points to new item
            this.head = item;
            return this;
        }
        prependData(data) {
            return this.prepend(List.createItem(data));
        }
        append(item) {
            return this.insert(item);
        }
        appendData(data) {
            return this.insert(List.createItem(data));
        }
        insert(item, before = null) {
            if (before !== null) {
                // prev   before
                //      ^
                //     item
                this.updateCursors(before.prev, item, before, item);
                if (before.prev === null) {
                    // insert to the beginning of list
                    if (this.head !== before) throw new Error("before doesn't belong to list");
                    // since head points to before therefore list doesn't empty
                    // no need to check tail
                    this.head = item;
                    before.prev = item;
                    item.next = before;
                    this.updateCursors(null, item);
                } else {
                    // insert between two items
                    before.prev.next = item;
                    item.prev = before.prev;
                    before.prev = item;
                    item.next = before;
                }
            } else {
                // tail
                //      ^
                //      item
                this.updateCursors(this.tail, item, null, item);
                // insert to the ending of the list
                if (this.tail !== null) {
                    // last item -> new item
                    this.tail.next = item;
                    // last item <- new item
                    item.prev = this.tail;
                } else // if list has no tail, then it also has no head
                // in this case head points to new item
                this.head = item;
                // tail always points to new item
                this.tail = item;
            }
            return this;
        }
        insertData(data, before) {
            return this.insert(List.createItem(data), before);
        }
        remove(item) {
            //      item
            //       ^
            // prev     next
            this.updateCursors(item, item.prev, item, item.next);
            if (item.prev !== null) item.prev.next = item.next;
            else {
                if (this.head !== item) throw new Error("item doesn't belong to list");
                this.head = item.next;
            }
            if (item.next !== null) item.next.prev = item.prev;
            else {
                if (this.tail !== item) throw new Error("item doesn't belong to list");
                this.tail = item.prev;
            }
            item.prev = null;
            item.next = null;
            return item;
        }
        push(data) {
            this.insert(List.createItem(data));
        }
        pop() {
            return this.tail !== null ? this.remove(this.tail) : null;
        }
        unshift(data) {
            this.prepend(List.createItem(data));
        }
        shift() {
            return this.head !== null ? this.remove(this.head) : null;
        }
        prependList(list) {
            return this.insertList(list, this.head);
        }
        appendList(list) {
            return this.insertList(list);
        }
        insertList(list, before) {
            // ignore empty lists
            if (list.head === null) return this;
            if (before !== undefined && before !== null) {
                this.updateCursors(before.prev, list.tail, before, list.head);
                // insert in the middle of dist list
                if (before.prev !== null) {
                    // before.prev <-> list.head
                    before.prev.next = list.head;
                    list.head.prev = before.prev;
                } else this.head = list.head;
                before.prev = list.tail;
                list.tail.next = before;
            } else {
                this.updateCursors(this.tail, list.tail, null, list.head);
                // insert to end of the list
                if (this.tail !== null) {
                    // if destination list has a tail, then it also has a head,
                    // but head doesn't change
                    // dest tail -> source head
                    this.tail.next = list.head;
                    // dest tail <- source head
                    list.head.prev = this.tail;
                } else // if list has no a tail, then it also has no a head
                // in this case points head to new item
                this.head = list.head;
                // tail always start point to new item
                this.tail = list.tail;
            }
            list.head = null;
            list.tail = null;
            return this;
        }
        replace(oldItem, newItemOrList) {
            if ("head" in newItemOrList) this.insertList(newItemOrList, oldItem);
            else this.insert(newItemOrList, oldItem);
            this.remove(oldItem);
        }
    }
    function createCustomError(name, message) {
        // use Object.create(), because some VMs prevent setting line/column otherwise
        // (iOS Safari 10 even throws an exception)
        const error = Object.create(SyntaxError.prototype);
        const errorStack = new Error();
        return Object.assign(error, {
            name: name,
            message: message,
            get stack () {
                return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}\n`);
            }
        });
    }
    const MAX_LINE_LENGTH = 100;
    const OFFSET_CORRECTION = 60;
    const TAB_REPLACEMENT = "    ";
    function sourceFragment({ source: source, line: line, column: column }, extraLines) {
        function processLines(start, end) {
            return lines.slice(start, end).map((line, idx)=>String(start + idx + 1).padStart(maxNumLength) + " |" + line).join("\n");
        }
        const lines = source.split(/\r\n?|\n|\f/);
        const startLine = Math.max(1, line - extraLines) - 1;
        const endLine = Math.min(line + extraLines, lines.length + 1);
        const maxNumLength = Math.max(4, String(endLine).length) + 1;
        let cutLeft = 0;
        // column correction according to replaced tab before column
        column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
            cutLeft = column - OFFSET_CORRECTION + 3;
            column = OFFSET_CORRECTION - 2;
        }
        for(let i = startLine; i <= endLine; i++)if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
        return [
            processLines(startLine, line),
            new Array(column + maxNumLength + 2).join("-") + "^",
            processLines(line, endLine)
        ].filter(Boolean).join("\n");
    }
    function SyntaxError$1(message, source, offset, line, column) {
        const error = Object.assign(createCustomError("SyntaxError", message), {
            source: source,
            offset: offset,
            line: line,
            column: column,
            sourceFragment (extraLines) {
                return sourceFragment({
                    source: source,
                    line: line,
                    column: column
                }, isNaN(extraLines) ? 0 : extraLines);
            },
            get formattedMessage () {
                return `Parse error: ${message}\n` + sourceFragment({
                    source: source,
                    line: line,
                    column: column
                }, 2);
            }
        });
        return error;
    }
    // CSS Syntax Module Level 3
    // https://www.w3.org/TR/css-syntax-3/
    const EOF = 0; // <EOF-token>
    const Ident = 1; // <ident-token>
    const Function$1 = 2; // <function-token>
    const AtKeyword = 3; // <at-keyword-token>
    const Hash = 4; // <hash-token>
    const String$1 = 5; // <string-token>
    const BadString = 6; // <bad-string-token>
    const Url = 7; // <url-token>
    const BadUrl = 8; // <bad-url-token>
    const Delim = 9; // <delim-token>
    const Number$1 = 10; // <number-token>
    const Percentage = 11; // <percentage-token>
    const Dimension = 12; // <dimension-token>
    const WhiteSpace = 13; // <whitespace-token>
    const CDO = 14; // <CDO-token>
    const CDC = 15; // <CDC-token>
    const Colon = 16; // <colon-token>     :
    const Semicolon = 17; // <semicolon-token> ;
    const Comma = 18; // <comma-token>     ,
    const LeftSquareBracket = 19; // <[-token>
    const RightSquareBracket = 20; // <]-token>
    const LeftParenthesis = 21; // <(-token>
    const RightParenthesis = 22; // <)-token>
    const LeftCurlyBracket = 23; // <{-token>
    const RightCurlyBracket = 24; // <}-token>
    const Comment = 25;
    const EOF$1 = 0;
    // https://drafts.csswg.org/css-syntax-3/
    // § 4.2. Definitions
    // digit
    // A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
    function isDigit(code) {
        return code >= 0x0030 && code <= 0x0039;
    }
    // hex digit
    // A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
    // or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
    function isHexDigit$1(code) {
        return isDigit(code) || // 0 .. 9
        code >= 0x0041 && code <= 0x0046 || // A .. F
        code >= 0x0061 && code <= 0x0066 // a .. f
        ;
    }
    // uppercase letter
    // A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
    function isUppercaseLetter(code) {
        return code >= 0x0041 && code <= 0x005A;
    }
    // lowercase letter
    // A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
    function isLowercaseLetter(code) {
        return code >= 0x0061 && code <= 0x007A;
    }
    // letter
    // An uppercase letter or a lowercase letter.
    function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    // non-ASCII code point
    // A code point with a value equal to or greater than U+0080 <control>.
    function isNonAscii(code) {
        return code >= 0x0080;
    }
    // name-start code point
    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).
    function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 0x005F;
    }
    // name code point
    // A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
    function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 0x002D;
    }
    // non-printable code point
    // A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
    // or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
    function isNonPrintable(code) {
        return code >= 0x0000 && code <= 0x0008 || code === 0x000B || code >= 0x000E && code <= 0x001F || code === 0x007F;
    }
    // newline
    // U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
    // as they are converted to U+000A LINE FEED during preprocessing.
    // TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
    function isNewline(code) {
        return code === 0x000A || code === 0x000D || code === 0x000C;
    }
    // whitespace
    // A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
    function isWhiteSpace(code) {
        return isNewline(code) || code === 0x0020 || code === 0x0009;
    }
    // § 4.3.8. Check if two code points are a valid escape
    function isValidEscape(first, second) {
        // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
        if (first !== 0x005C) return false;
        // Otherwise, if the second code point is a newline or EOF, return false.
        if (isNewline(second) || second === EOF$1) return false;
        // Otherwise, return true.
        return true;
    }
    // § 4.3.9. Check if three code points would start an identifier
    function isIdentifierStart$1(first, second, third) {
        // Look at the first code point:
        // U+002D HYPHEN-MINUS
        if (first === 0x002D) // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return isNameStart(second) || second === 0x002D || isValidEscape(second, third);
        // name-start code point
        if (isNameStart(first)) // Return true.
        return true;
        // U+005C REVERSE SOLIDUS (\)
        if (first === 0x005C) // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape(first, second);
        // anything else
        // Return false.
        return false;
    }
    // § 4.3.10. Check if three code points would start a number
    function isNumberStart(first, second, third) {
        // Look at the first code point:
        // U+002B PLUS SIGN (+)
        // U+002D HYPHEN-MINUS (-)
        if (first === 0x002B || first === 0x002D) {
            // If the second code point is a digit, return true.
            if (isDigit(second)) return 2;
            // Otherwise, if the second code point is a U+002E FULL STOP (.)
            // and the third code point is a digit, return true.
            // Otherwise, return false.
            return second === 0x002E && isDigit(third) ? 3 : 0;
        }
        // U+002E FULL STOP (.)
        if (first === 0x002E) // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
        // digit
        if (isDigit(first)) // Return true.
        return 1;
        // anything else
        // Return false.
        return 0;
    }
    //
    // Misc
    //
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    function isBOM(code) {
        // UTF-16BE
        if (code === 0xFEFF) return 1;
        // UTF-16LE
        if (code === 0xFFFE) return 1;
        return 0;
    }
    // Fast code category
    // Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
    const CATEGORY = new Array(0x80);
    const EofCategory = 0x80;
    const WhiteSpaceCategory = 0x82;
    const DigitCategory = 0x83;
    const NameStartCategory = 0x84;
    const NonPrintableCategory = 0x85;
    for(let i = 0; i < CATEGORY.length; i++)CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
    function charCodeCategory(code) {
        return code < 0x80 ? CATEGORY[code] : NameStartCategory;
    }
    function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
        if (code === 13 /* \r */  && getCharCode(source, offset + 1) === 10 /* \n */ ) return 2;
        return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
        let code = testStr.charCodeAt(offset);
        // code.toLowerCase() for A..Z
        if (isUppercaseLetter(code)) code = code | 32;
        return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) return false;
        if (start < 0 || end > testStr.length) return false;
        for(let i = start; i < end; i++){
            const referenceCode = referenceStr.charCodeAt(i - start);
            let testCode = testStr.charCodeAt(i);
            // testCode.toLowerCase() for A..Z
            if (isUppercaseLetter(testCode)) testCode = testCode | 32;
            if (testCode !== referenceCode) return false;
        }
        return true;
    }
    function findWhiteSpaceStart(source, offset) {
        for(; offset >= 0; offset--){
            if (!isWhiteSpace(source.charCodeAt(offset))) break;
        }
        return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
        for(; offset < source.length; offset++){
            if (!isWhiteSpace(source.charCodeAt(offset))) break;
        }
        return offset;
    }
    function findDecimalNumberEnd(source, offset) {
        for(; offset < source.length; offset++){
            if (!isDigit(source.charCodeAt(offset))) break;
        }
        return offset;
    }
    // § 4.3.7. Consume an escaped code point
    function consumeEscaped(source, offset) {
        // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
        // that the next input code point has already been verified to be part of a valid escape.
        offset += 2;
        // hex digit
        if (isHexDigit$1(getCharCode(source, offset - 1))) {
            // Consume as many hex digits as possible, but no more than 5.
            // Note that this means 1-6 hex digits have been consumed in total.
            for(const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++){
                if (!isHexDigit$1(getCharCode(source, offset))) break;
            }
            // If the next input code point is whitespace, consume it as well.
            const code = getCharCode(source, offset);
            if (isWhiteSpace(code)) offset += getNewlineLength(source, offset, code);
        }
        return offset;
    }
    // §4.3.11. Consume a name
    // Note: This algorithm does not do the verification of the first few code points that are necessary
    // to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
    // ensure that the stream starts with an identifier before calling this algorithm.
    function consumeName(source, offset) {
        // Let result initially be an empty string.
        // Repeatedly consume the next input code point from the stream:
        for(; offset < source.length; offset++){
            const code = source.charCodeAt(offset);
            // name code point
            if (isName(code)) continue;
            // the stream starts with a valid escape
            if (isValidEscape(code, getCharCode(source, offset + 1))) {
                // Consume an escaped code point. Append the returned code point to result.
                offset = consumeEscaped(source, offset) - 1;
                continue;
            }
            break;
        }
        return offset;
    }
    // §4.3.12. Consume a number
    function consumeNumber(source, offset) {
        let code = source.charCodeAt(offset);
        // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
        // consume it and append it to repr.
        if (code === 0x002B || code === 0x002D) code = source.charCodeAt(offset += 1);
        // 3. While the next input code point is a digit, consume it and append it to repr.
        if (isDigit(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
            code = source.charCodeAt(offset);
        }
        // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
        if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
            // 4.1 Consume them.
            // 4.2 Append them to repr.
            offset += 2;
            // 4.3 Set type to "number".
            // TODO
            // 4.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset);
        }
        // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
        // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
        if (cmpChar(source, offset, 101 /* e */ )) {
            let sign = 0;
            code = source.charCodeAt(offset + 1);
            // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
            if (code === 0x002D || code === 0x002B) {
                sign = 1;
                code = source.charCodeAt(offset + 2);
            }
            // ... followed by a digit
            if (isDigit(code)) // 5.1 Consume them.
            // 5.2 Append them to repr.
            // 5.3 Set type to "number".
            // TODO
            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
        return offset;
    }
    // § 4.3.14. Consume the remnants of a bad url
    // ... its sole use is to consume enough of the input stream to reach a recovery point
    // where normal tokenizing can resume.
    function consumeBadUrlRemnants(source, offset) {
        // Repeatedly consume the next input code point from the stream:
        for(; offset < source.length; offset++){
            const code = source.charCodeAt(offset);
            // U+0029 RIGHT PARENTHESIS ())
            // EOF
            if (code === 0x0029) {
                // Return.
                offset++;
                break;
            }
            if (isValidEscape(code, getCharCode(source, offset + 1))) // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped(source, offset);
        }
        return offset;
    }
    // § 4.3.7. Consume an escaped code point
    // Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
    function decodeEscaped(escaped) {
        // Single char escaped that's not a hex digit
        if (escaped.length === 1 && !isHexDigit$1(escaped.charCodeAt(0))) return escaped[0];
        // Interpret the hex digits as a hexadecimal number.
        let code = parseInt(escaped, 16);
        if (code === 0 || // If this number is zero,
        code >= 0xD800 && code <= 0xDFFF || // or is for a surrogate,
        code > 0x10FFFF // or is greater than the maximum allowed code point
        ) // ... return U+FFFD REPLACEMENT CHARACTER
        code = 0xFFFD;
        // Otherwise, return the code point with that value.
        return String.fromCodePoint(code);
    }
    var tokenNames = [
        "EOF-token",
        "ident-token",
        "function-token",
        "at-keyword-token",
        "hash-token",
        "string-token",
        "bad-string-token",
        "url-token",
        "bad-url-token",
        "delim-token",
        "number-token",
        "percentage-token",
        "dimension-token",
        "whitespace-token",
        "CDO-token",
        "CDC-token",
        "colon-token",
        "semicolon-token",
        "comma-token",
        "[-token",
        "]-token",
        "(-token",
        ")-token",
        "{-token",
        "}-token"
    ];
    const MIN_SIZE = 16384;
    function adoptBuffer(buffer = null, size) {
        if (buffer === null || buffer.length < size) return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
        return buffer;
    }
    const N = 10;
    const F = 12;
    const R = 13;
    function computeLinesAndColumns(host) {
        const source = host.source;
        const sourceLength = source.length;
        const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
        const lines = adoptBuffer(host.lines, sourceLength);
        const columns = adoptBuffer(host.columns, sourceLength);
        let line = host.startLine;
        let column = host.startColumn;
        for(let i = startOffset; i < sourceLength; i++){
            const code = source.charCodeAt(i);
            lines[i] = line;
            columns[i] = column++;
            if (code === N || code === R || code === F) {
                if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                    i++;
                    lines[i] = line;
                    columns[i] = column;
                }
                line++;
                column = 1;
            }
        }
        lines[sourceLength] = line;
        columns[sourceLength] = column;
        host.lines = lines;
        host.columns = columns;
        host.computed = true;
    }
    class OffsetToLocation {
        constructor(){
            this.lines = null;
            this.columns = null;
            this.computed = false;
        }
        setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
            this.source = source;
            this.startOffset = startOffset;
            this.startLine = startLine;
            this.startColumn = startColumn;
            this.computed = false;
        }
        getLocation(offset, filename) {
            if (!this.computed) computeLinesAndColumns(this);
            return {
                source: filename,
                offset: this.startOffset + offset,
                line: this.lines[offset],
                column: this.columns[offset]
            };
        }
        getLocationRange(start, end, filename) {
            if (!this.computed) computeLinesAndColumns(this);
            return {
                source: filename,
                start: {
                    offset: this.startOffset + start,
                    line: this.lines[start],
                    column: this.columns[start]
                },
                end: {
                    offset: this.startOffset + end,
                    line: this.lines[end],
                    column: this.columns[end]
                }
            };
        }
    }
    const OFFSET_MASK = 0x00FFFFFF;
    const TYPE_SHIFT = 24;
    const balancePair = new Map([
        [
            Function$1,
            RightParenthesis
        ],
        [
            LeftParenthesis,
            RightParenthesis
        ],
        [
            LeftSquareBracket,
            RightSquareBracket
        ],
        [
            LeftCurlyBracket,
            RightCurlyBracket
        ]
    ]);
    class TokenStream {
        constructor(source, tokenize){
            this.setSource(source, tokenize);
        }
        reset() {
            this.eof = false;
            this.tokenIndex = -1;
            this.tokenType = 0;
            this.tokenStart = this.firstCharOffset;
            this.tokenEnd = this.firstCharOffset;
        }
        setSource(source = "", tokenize = ()=>{}) {
            source = String(source || "");
            const sourceLength = source.length;
            const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token
            const balance = adoptBuffer(this.balance, source.length + 1);
            let tokenCount = 0;
            let balanceCloseType = 0;
            let balanceStart = 0;
            let firstCharOffset = -1;
            // capture buffers
            this.offsetAndType = null;
            this.balance = null;
            tokenize(source, (type, start, end)=>{
                switch(type){
                    default:
                        balance[tokenCount] = sourceLength;
                        break;
                    case balanceCloseType:
                        {
                            let balancePrev = balanceStart & OFFSET_MASK;
                            balanceStart = balance[balancePrev];
                            balanceCloseType = balanceStart >> TYPE_SHIFT;
                            balance[tokenCount] = balancePrev;
                            balance[balancePrev++] = tokenCount;
                            for(; balancePrev < tokenCount; balancePrev++)if (balance[balancePrev] === sourceLength) balance[balancePrev] = tokenCount;
                            break;
                        }
                    case LeftParenthesis:
                    case Function$1:
                    case LeftSquareBracket:
                    case LeftCurlyBracket:
                        balance[tokenCount] = balanceStart;
                        balanceCloseType = balancePair.get(type);
                        balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
                        break;
                }
                offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
                if (firstCharOffset === -1) firstCharOffset = start;
            });
            // finalize buffers
            offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength; // <EOF-token>
            balance[tokenCount] = sourceLength;
            balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
            while(balanceStart !== 0){
                const balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balance[balancePrev] = sourceLength;
            }
            this.source = source;
            this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
            this.tokenCount = tokenCount;
            this.offsetAndType = offsetAndType;
            this.balance = balance;
            this.reset();
            this.next();
        }
        lookupType(offset) {
            offset += this.tokenIndex;
            if (offset < this.tokenCount) return this.offsetAndType[offset] >> TYPE_SHIFT;
            return EOF;
        }
        lookupOffset(offset) {
            offset += this.tokenIndex;
            if (offset < this.tokenCount) return this.offsetAndType[offset - 1] & OFFSET_MASK;
            return this.source.length;
        }
        lookupValue(offset, referenceStr) {
            offset += this.tokenIndex;
            if (offset < this.tokenCount) return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
            return false;
        }
        getTokenStart(tokenIndex) {
            if (tokenIndex === this.tokenIndex) return this.tokenStart;
            if (tokenIndex > 0) return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
            return this.firstCharOffset;
        }
        substrToCursor(start) {
            return this.source.substring(start, this.tokenStart);
        }
        isBalanceEdge(pos) {
            return this.balance[this.tokenIndex] < pos;
        }
        isDelim(code, offset) {
            if (offset) return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
            return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code;
        }
        skip(tokenCount) {
            let next = this.tokenIndex + tokenCount;
            if (next < this.tokenCount) {
                this.tokenIndex = next;
                this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
                next = this.offsetAndType[next];
                this.tokenType = next >> TYPE_SHIFT;
                this.tokenEnd = next & OFFSET_MASK;
            } else {
                this.tokenIndex = this.tokenCount;
                this.next();
            }
        }
        next() {
            let next = this.tokenIndex + 1;
            if (next < this.tokenCount) {
                this.tokenIndex = next;
                this.tokenStart = this.tokenEnd;
                next = this.offsetAndType[next];
                this.tokenType = next >> TYPE_SHIFT;
                this.tokenEnd = next & OFFSET_MASK;
            } else {
                this.eof = true;
                this.tokenIndex = this.tokenCount;
                this.tokenType = EOF;
                this.tokenStart = this.tokenEnd = this.source.length;
            }
        }
        skipSC() {
            while(this.tokenType === WhiteSpace || this.tokenType === Comment)this.next();
        }
        skipUntilBalanced(startToken, stopConsume) {
            let cursor = startToken;
            let balanceEnd;
            let offset;
            loop: for(; cursor < this.tokenCount; cursor++){
                balanceEnd = this.balance[cursor];
                // stop scanning on balance edge that points to offset before start token
                if (balanceEnd < startToken) break loop;
                offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
                // check stop condition
                switch(stopConsume(this.source.charCodeAt(offset))){
                    case 1:
                        break loop;
                    case 2:
                        cursor++;
                        break loop;
                    default:
                        // fast forward to the end of balanced block
                        if (this.balance[balanceEnd] === cursor) cursor = balanceEnd;
                }
            }
            this.skip(cursor - this.tokenIndex);
        }
        forEachToken(fn) {
            for(let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++){
                const start = offset;
                const item = this.offsetAndType[i];
                const end = item & OFFSET_MASK;
                const type = item >> TYPE_SHIFT;
                offset = end;
                fn(type, start, end, i);
            }
        }
        dump() {
            const tokens = new Array(this.tokenCount);
            this.forEachToken((type, start, end, index)=>{
                tokens[index] = {
                    idx: index,
                    type: tokenNames[type],
                    chunk: this.source.substring(start, end),
                    balance: this.balance[index]
                };
            });
            return tokens;
        }
    }
    function tokenize(source, onToken) {
        function getCharCode(offset) {
            return offset < sourceLength ? source.charCodeAt(offset) : 0;
        }
        // § 4.3.3. Consume a numeric token
        function consumeNumericToken() {
            // Consume a number and let number be the result.
            offset = consumeNumber(source, offset);
            // If the next 3 input code points would start an identifier, then:
            if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
                // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
                // Consume a name. Set the <dimension-token>’s unit to the returned value.
                // Return the <dimension-token>.
                type = Dimension;
                offset = consumeName(source, offset);
                return;
            }
            // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
            if (getCharCode(offset) === 0x0025) {
                // Create a <percentage-token> with the same value as number, and return it.
                type = Percentage;
                offset++;
                return;
            }
            // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
            type = Number$1;
        }
        // § 4.3.4. Consume an ident-like token
        function consumeIdentLikeToken() {
            const nameStartOffset = offset;
            // Consume a name, and let string be the result.
            offset = consumeName(source, offset);
            // If string’s value is an ASCII case-insensitive match for "url",
            // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
            if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 0x0028) {
                // While the next two input code points are whitespace, consume the next input code point.
                offset = findWhiteSpaceEnd(source, offset + 1);
                // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
                // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
                // then create a <function-token> with its value set to string and return it.
                if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
                    type = Function$1;
                    offset = nameStartOffset + 4;
                    return;
                }
                // Otherwise, consume a url token, and return it.
                consumeUrlToken();
                return;
            }
            // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
            // Create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0028) {
                type = Function$1;
                offset++;
                return;
            }
            // Otherwise, create an <ident-token> with its value set to string and return it.
            type = Ident;
        }
        // § 4.3.5. Consume a string token
        function consumeStringToken(endingCodePoint) {
            // This algorithm may be called with an ending code point, which denotes the code point
            // that ends the string. If an ending code point is not specified,
            // the current input code point is used.
            if (!endingCodePoint) endingCodePoint = getCharCode(offset++);
            // Initially create a <string-token> with its value set to the empty string.
            type = String$1;
            // Repeatedly consume the next input code point from the stream:
            for(; offset < source.length; offset++){
                const code = source.charCodeAt(offset);
                switch(charCodeCategory(code)){
                    // ending code point
                    case endingCodePoint:
                        // Return the <string-token>.
                        offset++;
                        return;
                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <string-token>.
                    // return;
                    // newline
                    case WhiteSpaceCategory:
                        if (isNewline(code)) {
                            // This is a parse error. Reconsume the current input code point,
                            // create a <bad-string-token>, and return it.
                            offset += getNewlineLength(source, offset, code);
                            type = BadString;
                            return;
                        }
                        break;
                    // U+005C REVERSE SOLIDUS (\)
                    case 0x005C:
                        // If the next input code point is EOF, do nothing.
                        if (offset === source.length - 1) break;
                        const nextCode = getCharCode(offset + 1);
                        // Otherwise, if the next input code point is a newline, consume it.
                        if (isNewline(nextCode)) offset += getNewlineLength(source, offset + 1, nextCode);
                        else if (isValidEscape(code, nextCode)) // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>’s value.
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                }
            }
        }
        // § 4.3.6. Consume a url token
        // Note: This algorithm assumes that the initial "url(" has already been consumed.
        // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
        // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
        // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
        function consumeUrlToken() {
            // Initially create a <url-token> with its value set to the empty string.
            type = Url;
            // Consume as much whitespace as possible.
            offset = findWhiteSpaceEnd(source, offset);
            // Repeatedly consume the next input code point from the stream:
            for(; offset < source.length; offset++){
                const code = source.charCodeAt(offset);
                switch(charCodeCategory(code)){
                    // U+0029 RIGHT PARENTHESIS ())
                    case 0x0029:
                        // Return the <url-token>.
                        offset++;
                        return;
                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <url-token>.
                    // return;
                    // whitespace
                    case WhiteSpaceCategory:
                        // Consume as much whitespace as possible.
                        offset = findWhiteSpaceEnd(source, offset);
                        // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                        // consume it and return the <url-token>
                        // (if EOF was encountered, this is a parse error);
                        if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                            if (offset < source.length) offset++;
                            return;
                        }
                        // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                        // and return it.
                        offset = consumeBadUrlRemnants(source, offset);
                        type = BadUrl;
                        return;
                    // U+0022 QUOTATION MARK (")
                    // U+0027 APOSTROPHE (')
                    // U+0028 LEFT PARENTHESIS (()
                    // non-printable code point
                    case 0x0022:
                    case 0x0027:
                    case 0x0028:
                    case NonPrintableCategory:
                        // This is a parse error. Consume the remnants of a bad url,
                        // create a <bad-url-token>, and return it.
                        offset = consumeBadUrlRemnants(source, offset);
                        type = BadUrl;
                        return;
                    // U+005C REVERSE SOLIDUS (\)
                    case 0x005C:
                        // If the stream starts with a valid escape, consume an escaped code point and
                        // append the returned code point to the <url-token>’s value.
                        if (isValidEscape(code, getCharCode(offset + 1))) {
                            offset = consumeEscaped(source, offset) - 1;
                            break;
                        }
                        // Otherwise, this is a parse error. Consume the remnants of a bad url,
                        // create a <bad-url-token>, and return it.
                        offset = consumeBadUrlRemnants(source, offset);
                        type = BadUrl;
                        return;
                }
            }
        }
        // ensure source is a string
        source = String(source || "");
        const sourceLength = source.length;
        let start = isBOM(getCharCode(0));
        let offset = start;
        let type;
        // https://drafts.csswg.org/css-syntax-3/#consume-token
        // § 4.3.1. Consume a token
        while(offset < sourceLength){
            const code = source.charCodeAt(offset);
            switch(charCodeCategory(code)){
                // whitespace
                case WhiteSpaceCategory:
                    // Consume as much whitespace as possible. Return a <whitespace-token>.
                    type = WhiteSpace;
                    offset = findWhiteSpaceEnd(source, offset + 1);
                    break;
                // U+0022 QUOTATION MARK (")
                case 0x0022:
                    // Consume a string token and return it.
                    consumeStringToken();
                    break;
                // U+0023 NUMBER SIGN (#)
                case 0x0023:
                    // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                    if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                        // Create a <hash-token>.
                        type = Hash;
                        // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
                        // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                        //     // TODO: set id flag
                        // }
                        // Consume a name, and set the <hash-token>’s value to the returned string.
                        offset = consumeName(source, offset + 1);
                    // Return the <hash-token>.
                    } else {
                        // Otherwise, return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+0027 APOSTROPHE (')
                case 0x0027:
                    // Consume a string token and return it.
                    consumeStringToken();
                    break;
                // U+0028 LEFT PARENTHESIS (()
                case 0x0028:
                    // Return a <(-token>.
                    type = LeftParenthesis;
                    offset++;
                    break;
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return a <)-token>.
                    type = RightParenthesis;
                    offset++;
                    break;
                // U+002B PLUS SIGN (+)
                case 0x002B:
                    // If the input stream starts with a number, ...
                    if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                    else {
                        // Otherwise, return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+002C COMMA (,)
                case 0x002C:
                    // Return a <comma-token>.
                    type = Comma;
                    offset++;
                    break;
                // U+002D HYPHEN-MINUS (-)
                case 0x002D:
                    // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                    if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) consumeNumericToken();
                    else {
                        // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                        if (getCharCode(offset + 1) === 0x002D && getCharCode(offset + 2) === 0x003E) {
                            type = CDC;
                            offset = offset + 3;
                        } else // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) // ... reconsume the current input code point, consume an ident-like token, and return it.
                        consumeIdentLikeToken();
                        else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = Delim;
                            offset++;
                        }
                    }
                    break;
                // U+002E FULL STOP (.)
                case 0x002E:
                    // If the input stream starts with a number, ...
                    if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                    else {
                        // Otherwise, return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+002F SOLIDUS (/)
                case 0x002F:
                    // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                    if (getCharCode(offset + 1) === 0x002A) {
                        // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                        // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                        type = Comment;
                        offset = source.indexOf("*/", offset + 2);
                        offset = offset === -1 ? source.length : offset + 2;
                    } else {
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+003A COLON (:)
                case 0x003A:
                    // Return a <colon-token>.
                    type = Colon;
                    offset++;
                    break;
                // U+003B SEMICOLON (;)
                case 0x003B:
                    // Return a <semicolon-token>.
                    type = Semicolon;
                    offset++;
                    break;
                // U+003C LESS-THAN SIGN (<)
                case 0x003C:
                    // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                    if (getCharCode(offset + 1) === 0x0021 && getCharCode(offset + 2) === 0x002D && getCharCode(offset + 3) === 0x002D) {
                        // ... consume them and return a <CDO-token>.
                        type = CDO;
                        offset = offset + 4;
                    } else {
                        // Otherwise, return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+0040 COMMERCIAL AT (@)
                case 0x0040:
                    // If the next 3 input code points would start an identifier, ...
                    if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                        // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                        type = AtKeyword;
                        offset = consumeName(source, offset + 1);
                    } else {
                        // Otherwise, return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+005B LEFT SQUARE BRACKET ([)
                case 0x005B:
                    // Return a <[-token>.
                    type = LeftSquareBracket;
                    offset++;
                    break;
                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the input stream starts with a valid escape, ...
                    if (isValidEscape(code, getCharCode(offset + 1))) // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                    else {
                        // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                        type = Delim;
                        offset++;
                    }
                    break;
                // U+005D RIGHT SQUARE BRACKET (])
                case 0x005D:
                    // Return a <]-token>.
                    type = RightSquareBracket;
                    offset++;
                    break;
                // U+007B LEFT CURLY BRACKET ({)
                case 0x007B:
                    // Return a <{-token>.
                    type = LeftCurlyBracket;
                    offset++;
                    break;
                // U+007D RIGHT CURLY BRACKET (})
                case 0x007D:
                    // Return a <}-token>.
                    type = RightCurlyBracket;
                    offset++;
                    break;
                // digit
                case DigitCategory:
                    // Reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                    break;
                // name-start code point
                case NameStartCategory:
                    // Reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                    break;
                // EOF
                // case EofCategory:
                // Return an <EOF-token>.
                // break;
                // anything else
                default:
                    // Return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
            }
            // put token to stream
            onToken(type, start, start = offset);
        }
    }
    function readSequence(recognizer) {
        const children = this.createList();
        let space = false;
        const context = {
            recognizer: recognizer
        };
        while(!this.eof){
            switch(this.tokenType){
                case Comment:
                    this.next();
                    continue;
                case WhiteSpace:
                    space = true;
                    this.next();
                    continue;
            }
            let child = recognizer.getNode.call(this, context);
            if (child === undefined) break;
            if (space) {
                if (recognizer.onWhiteSpace) recognizer.onWhiteSpace.call(this, child, children, context);
                space = false;
            }
            children.push(child);
        }
        if (space && recognizer.onWhiteSpace) recognizer.onWhiteSpace.call(this, null, children, context);
        return children;
    }
    const NOOP = ()=>{};
    const EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
    const NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
    const SEMICOLON = 0x003B; // U+003B SEMICOLON (;)
    const LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)
    const NULL = 0;
    function createParseContext(name) {
        return function() {
            return this[name]();
        };
    }
    function fetchParseValues(dict) {
        const result = Object.create(null);
        for(const name in dict){
            const item = dict[name];
            const fn = item.parse || item;
            if (fn) result[name] = fn;
        }
        return result;
    }
    function processConfig(config) {
        const parseConfig = {
            context: Object.create(null),
            scope: Object.assign(Object.create(null), config.scope),
            atrule: fetchParseValues(config.atrule),
            pseudo: fetchParseValues(config.pseudo),
            node: fetchParseValues(config.node)
        };
        for(const name in config.parseContext)switch(typeof config.parseContext[name]){
            case "function":
                parseConfig.context[name] = config.parseContext[name];
                break;
            case "string":
                parseConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
        }
        return {
            config: parseConfig,
            ...parseConfig,
            ...parseConfig.node
        };
    }
    function createParser(config) {
        let source = "";
        let filename = "<unknown>";
        let needPositions = false;
        let onParseError = NOOP;
        let onParseErrorThrow = false;
        const locationMap = new OffsetToLocation();
        const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
            parseAtrulePrelude: true,
            parseRulePrelude: true,
            parseValue: true,
            parseCustomProperty: false,
            readSequence: readSequence,
            consumeUntilBalanceEnd: ()=>0,
            consumeUntilLeftCurlyBracket (code) {
                return code === LEFTCURLYBRACKET ? 1 : 0;
            },
            consumeUntilLeftCurlyBracketOrSemicolon (code) {
                return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilExclamationMarkOrSemicolon (code) {
                return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilSemicolonIncluded (code) {
                return code === SEMICOLON ? 2 : 0;
            },
            createList () {
                return new List();
            },
            createSingleNodeList (node) {
                return new List().appendData(node);
            },
            getFirstListNode (list) {
                return list && list.first;
            },
            getLastListNode (list) {
                return list && list.last;
            },
            parseWithFallback (consumer, fallback) {
                const startToken = this.tokenIndex;
                try {
                    return consumer.call(this);
                } catch (e) {
                    if (onParseErrorThrow) throw e;
                    const fallbackNode = fallback.call(this, startToken);
                    onParseErrorThrow = true;
                    onParseError(e, fallbackNode);
                    onParseErrorThrow = false;
                    return fallbackNode;
                }
            },
            lookupNonWSType (offset) {
                let type;
                do {
                    type = this.lookupType(offset++);
                    if (type !== WhiteSpace) return type;
                }while (type !== NULL);
                return NULL;
            },
            charCodeAt (offset) {
                return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
            },
            substring (offsetStart, offsetEnd) {
                return source.substring(offsetStart, offsetEnd);
            },
            substrToCursor (start) {
                return this.source.substring(start, this.tokenStart);
            },
            cmpChar (offset, charCode) {
                return cmpChar(source, offset, charCode);
            },
            cmpStr (offsetStart, offsetEnd, str) {
                return cmpStr(source, offsetStart, offsetEnd, str);
            },
            consume (tokenType) {
                const start = this.tokenStart;
                this.eat(tokenType);
                return this.substrToCursor(start);
            },
            consumeFunctionName () {
                const name = source.substring(this.tokenStart, this.tokenEnd - 1);
                this.eat(Function$1);
                return name;
            },
            consumeNumber (type) {
                const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
                this.eat(type);
                return number;
            },
            eat (tokenType) {
                if (this.tokenType !== tokenType) {
                    const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m)=>m.toUpperCase());
                    let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                    let offset = this.tokenStart;
                    // tweak message and offset
                    switch(tokenType){
                        case Ident:
                            // when identifier is expected but there is a function or url
                            if (this.tokenType === Function$1 || this.tokenType === Url) {
                                offset = this.tokenEnd - 1;
                                message = "Identifier is expected but function found";
                            } else message = "Identifier is expected";
                            break;
                        case Hash:
                            if (this.isDelim(NUMBERSIGN)) {
                                this.next();
                                offset++;
                                message = "Name is expected";
                            }
                            break;
                        case Percentage:
                            if (this.tokenType === Number$1) {
                                offset = this.tokenEnd;
                                message = "Percent sign is expected";
                            }
                            break;
                    }
                    this.error(message, offset);
                }
                this.next();
            },
            eatIdent (name) {
                if (this.tokenType !== Ident || this.lookupValue(0, name) === false) this.error(`Identifier "${name}" is expected`);
                this.next();
            },
            eatDelim (code) {
                if (!this.isDelim(code)) this.error(`Delim "${String.fromCharCode(code)}" is expected`);
                this.next();
            },
            getLocation (start, end) {
                if (needPositions) return locationMap.getLocationRange(start, end, filename);
                return null;
            },
            getLocationFromList (list) {
                if (needPositions) {
                    const head = this.getFirstListNode(list);
                    const tail = this.getLastListNode(list);
                    return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
                }
                return null;
            },
            error (message, offset) {
                const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
                throw new SyntaxError$1(message || "Unexpected input", source, location.offset, location.line, location.column);
            }
        });
        const parse = function(source_, options) {
            source = source_;
            options = options || {};
            parser.setSource(source, tokenize);
            locationMap.setSource(source, options.offset, options.line, options.column);
            filename = options.filename || "<unknown>";
            needPositions = Boolean(options.positions);
            onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
            onParseErrorThrow = false;
            parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
            parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
            parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
            parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
            const { context: context = "default", onComment: onComment } = options;
            if (context in parser.context === false) throw new Error("Unknown context `" + context + "`");
            if (typeof onComment === "function") parser.forEachToken((type, start, end)=>{
                if (type === Comment) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
                    onComment(value, loc);
                }
            });
            const ast = parser.context[context].call(parser, options);
            if (!parser.eof) parser.error();
            return ast;
        };
        return Object.assign(parse, {
            SyntaxError: SyntaxError$1,
            config: parser.config
        });
    }
    const NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
    const ASTERISK = 0x002A; // U+002A ASTERISK (*)
    const PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)
    const HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
    const SOLIDUS = 0x002F; // U+002F SOLIDUS (/)
    const U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)
    function defaultRecognizer(context) {
        switch(this.tokenType){
            case Hash:
                return this.Hash();
            case Comma:
                return this.Operator();
            case LeftParenthesis:
                return this.Parentheses(this.readSequence, context.recognizer);
            case LeftSquareBracket:
                return this.Brackets(this.readSequence, context.recognizer);
            case String$1:
                return this.String();
            case Dimension:
                return this.Dimension();
            case Percentage:
                return this.Percentage();
            case Number$1:
                return this.Number();
            case Function$1:
                return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
            case Url:
                return this.Url();
            case Ident:
                // check for unicode range, it should start with u+ or U+
                if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) return this.UnicodeRange();
                else return this.Identifier();
            case Delim:
                {
                    const code = this.charCodeAt(this.tokenStart);
                    if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) return this.Operator(); // TODO: replace with Delim
                    // TODO: produce a node with Delim node type
                    if (code === NUMBERSIGN$1) this.error("Hex or identifier is expected", this.tokenStart + 1);
                    break;
                }
        }
    }
    var atrulePrelude = {
        getNode: defaultRecognizer
    };
    const NUMBERSIGN$2 = 0x0023; // U+0023 NUMBER SIGN (#)
    const ASTERISK$1 = 0x002A; // U+002A ASTERISK (*)
    const PLUSSIGN$1 = 0x002B; // U+002B PLUS SIGN (+)
    const SOLIDUS$1 = 0x002F; // U+002F SOLIDUS (/)
    const FULLSTOP = 0x002E; // U+002E FULL STOP (.)
    const GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
    const VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)
    const TILDE = 0x007E; // U+007E TILDE (~)
    function onWhiteSpace(next, children) {
        if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") children.push({
            type: "Combinator",
            loc: null,
            name: " "
        });
    }
    function getNode() {
        switch(this.tokenType){
            case LeftSquareBracket:
                return this.AttributeSelector();
            case Hash:
                return this.IdSelector();
            case Colon:
                if (this.lookupType(1) === Colon) return this.PseudoElementSelector();
                else return this.PseudoClassSelector();
            case Ident:
                return this.TypeSelector();
            case Number$1:
            case Percentage:
                return this.Percentage();
            case Dimension:
                // throws when .123ident
                if (this.charCodeAt(this.tokenStart) === FULLSTOP) this.error("Identifier is expected", this.tokenStart + 1);
                break;
            case Delim:
                {
                    const code = this.charCodeAt(this.tokenStart);
                    switch(code){
                        case PLUSSIGN$1:
                        case GREATERTHANSIGN:
                        case TILDE:
                        case SOLIDUS$1:
                            return this.Combinator();
                        case FULLSTOP:
                            return this.ClassSelector();
                        case ASTERISK$1:
                        case VERTICALLINE:
                            return this.TypeSelector();
                        case NUMBERSIGN$2:
                            return this.IdSelector();
                    }
                    break;
                }
        }
    }
    var selector = {
        onWhiteSpace: onWhiteSpace,
        getNode: getNode
    };
    // legacy IE function
    // expression( <any-value> )
    function expressionFn() {
        return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
    }
    // var( <ident> , <value>? )
    function varFn() {
        const children = this.createList();
        this.skipSC();
        // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
        children.push(this.Identifier());
        this.skipSC();
        if (this.tokenType === Comma) {
            children.push(this.Operator());
            const startIndex = this.tokenIndex;
            const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
            if (value.type === "Value" && value.children.isEmpty) {
                for(let offset = startIndex - this.tokenIndex; offset <= 0; offset++)if (this.lookupType(offset) === WhiteSpace) {
                    value.children.appendData({
                        type: "WhiteSpace",
                        loc: null,
                        value: " "
                    });
                    break;
                }
            }
            children.push(value);
        }
        return children;
    }
    function isPlusMinusOperator(node) {
        return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
    }
    var value = {
        getNode: defaultRecognizer,
        onWhiteSpace (next, children) {
            if (isPlusMinusOperator(next)) next.value = " " + next.value;
            if (isPlusMinusOperator(children.last)) children.last.value += " ";
        },
        "expression": expressionFn,
        "var": varFn
    };
    var scope = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        AtrulePrelude: atrulePrelude,
        Selector: selector,
        Value: value
    });
    var fontFace = {
        parse: {
            prelude: null,
            block () {
                return this.Block(true);
            }
        }
    };
    var importAtrule = {
        parse: {
            prelude () {
                const children = this.createList();
                this.skipSC();
                switch(this.tokenType){
                    case String$1:
                        children.push(this.String());
                        break;
                    case Url:
                    case Function$1:
                        children.push(this.Url());
                        break;
                    default:
                        this.error("String or url() is expected");
                }
                if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) children.push(this.MediaQueryList());
                return children;
            },
            block: null
        }
    };
    var media = {
        parse: {
            prelude () {
                return this.createSingleNodeList(this.MediaQueryList());
            },
            block () {
                return this.Block(false);
            }
        }
    };
    var page = {
        parse: {
            prelude () {
                return this.createSingleNodeList(this.SelectorList());
            },
            block () {
                return this.Block(true);
            }
        }
    };
    function consumeRaw() {
        return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
    }
    function parentheses() {
        this.skipSC();
        if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon) return this.createSingleNodeList(this.Declaration());
        return readSequence$1.call(this);
    }
    function readSequence$1() {
        const children = this.createList();
        let child;
        this.skipSC();
        scan: while(!this.eof){
            switch(this.tokenType){
                case Comment:
                case WhiteSpace:
                    this.next();
                    continue;
                case Function$1:
                    child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                    break;
                case Ident:
                    child = this.Identifier();
                    break;
                case LeftParenthesis:
                    child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                    break;
                default:
                    break scan;
            }
            children.push(child);
        }
        return children;
    }
    var supports = {
        parse: {
            prelude () {
                const children = readSequence$1.call(this);
                if (this.getFirstListNode(children) === null) this.error("Condition is expected");
                return children;
            },
            block () {
                return this.Block(false);
            }
        }
    };
    var atrule = {
        "font-face": fontFace,
        "import": importAtrule,
        media: media,
        page: page,
        supports: supports
    };
    const selectorList = {
        parse () {
            return this.createSingleNodeList(this.SelectorList());
        }
    };
    const selector$1 = {
        parse () {
            return this.createSingleNodeList(this.Selector());
        }
    };
    const identList = {
        parse () {
            return this.createSingleNodeList(this.Identifier());
        }
    };
    const nth = {
        parse () {
            return this.createSingleNodeList(this.Nth());
        }
    };
    var pseudo = {
        "dir": identList,
        "has": selectorList,
        "lang": identList,
        "matches": selectorList,
        "is": selectorList,
        "-moz-any": selectorList,
        "-webkit-any": selectorList,
        "where": selectorList,
        "not": selectorList,
        "nth-child": nth,
        "nth-last-child": nth,
        "nth-last-of-type": nth,
        "nth-of-type": nth,
        "slotted": selector$1
    };
    const PLUSSIGN$2 = 0x002B; // U+002B PLUS SIGN (+)
    const HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
    const N$1 = 0x006E; // U+006E LATIN SMALL LETTER N (n)
    const DISALLOW_SIGN = true;
    const ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
        let pos = this.tokenStart + offset;
        const code = this.charCodeAt(pos);
        if (code === PLUSSIGN$2 || code === HYPHENMINUS$1) {
            if (disallowSign) this.error("Number sign is not allowed");
            pos++;
        }
        for(; pos < this.tokenEnd; pos++)if (!isDigit(this.charCodeAt(pos))) this.error("Integer is expected", pos);
    }
    function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
        if (!this.cmpChar(this.tokenStart + offset, code)) {
            let msg = "";
            switch(code){
                case N$1:
                    msg = "N is expected";
                    break;
                case HYPHENMINUS$1:
                    msg = "HyphenMinus is expected";
                    break;
            }
            this.error(msg, this.tokenStart + offset);
        }
    }
    // ... <signed-integer>
    // ... ['+' | '-'] <signless-integer>
    function consumeB() {
        let offset = 0;
        let sign = 0;
        let type = this.tokenType;
        while(type === WhiteSpace || type === Comment)type = this.lookupType(++offset);
        if (type !== Number$1) {
            if (this.isDelim(PLUSSIGN$2, offset) || this.isDelim(HYPHENMINUS$1, offset)) {
                sign = this.isDelim(PLUSSIGN$2, offset) ? PLUSSIGN$2 : HYPHENMINUS$1;
                do type = this.lookupType(++offset);
                while (type === WhiteSpace || type === Comment);
                if (type !== Number$1) {
                    this.skip(offset);
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                }
            } else return null;
        }
        if (offset > 0) this.skip(offset);
        if (sign === 0) {
            type = this.charCodeAt(this.tokenStart);
            if (type !== PLUSSIGN$2 && type !== HYPHENMINUS$1) this.error("Number sign is expected");
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS$1 ? "-" + this.consume(Number$1) : this.consume(Number$1);
    }
    function parse$3() {
        /* eslint-disable brace-style*/ const start = this.tokenStart;
        let a = null;
        let b = null;
        // <integer>
        if (this.tokenType === Number$1) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(Number$1);
        } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$1)) {
            a = "-1";
            expectCharCode.call(this, 1, N$1);
            switch(this.tokenEnd - this.tokenStart){
                // -n
                // -n <signed-integer>
                // -n ['+' | '-'] <signless-integer>
                case 2:
                    this.next();
                    b = consumeB.call(this);
                    break;
                // -n- <signless-integer>
                case 3:
                    expectCharCode.call(this, 2, HYPHENMINUS$1);
                    this.next();
                    this.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = "-" + this.consume(Number$1);
                    break;
                // <dashndashdigit-ident>
                default:
                    expectCharCode.call(this, 2, HYPHENMINUS$1);
                    checkInteger.call(this, 3, DISALLOW_SIGN);
                    this.next();
                    b = this.substrToCursor(start + 2);
            }
        } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$2) && this.lookupType(1) === Ident) {
            let sign = 0;
            a = "1";
            // just ignore a plus
            if (this.isDelim(PLUSSIGN$2)) {
                sign = 1;
                this.next();
            }
            expectCharCode.call(this, 0, N$1);
            switch(this.tokenEnd - this.tokenStart){
                // '+'? n
                // '+'? n <signed-integer>
                // '+'? n ['+' | '-'] <signless-integer>
                case 1:
                    this.next();
                    b = consumeB.call(this);
                    break;
                // '+'? n- <signless-integer>
                case 2:
                    expectCharCode.call(this, 1, HYPHENMINUS$1);
                    this.next();
                    this.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = "-" + this.consume(Number$1);
                    break;
                // '+'? <ndashdigit-ident>
                default:
                    expectCharCode.call(this, 1, HYPHENMINUS$1);
                    checkInteger.call(this, 2, DISALLOW_SIGN);
                    this.next();
                    b = this.substrToCursor(start + sign + 1);
            }
        } else if (this.tokenType === Dimension) {
            const code = this.charCodeAt(this.tokenStart);
            const sign = code === PLUSSIGN$2 || code === HYPHENMINUS$1;
            let i = this.tokenStart + sign;
            for(; i < this.tokenEnd; i++){
                if (!isDigit(this.charCodeAt(i))) break;
            }
            if (i === this.tokenStart + sign) this.error("Integer is expected", this.tokenStart + sign);
            expectCharCode.call(this, i - this.tokenStart, N$1);
            a = this.substring(start, i);
            // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>
            if (i + 1 === this.tokenEnd) {
                this.next();
                b = consumeB.call(this);
            } else {
                expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$1);
                // <ndash-dimension> <signless-integer>
                if (i + 2 === this.tokenEnd) {
                    this.next();
                    this.skipSC();
                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
                    b = "-" + this.consume(Number$1);
                } else {
                    checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
                    this.next();
                    b = this.substrToCursor(i + 1);
                }
            }
        } else this.error();
        if (a !== null && a.charCodeAt(0) === PLUSSIGN$2) a = a.substr(1);
        if (b !== null && b.charCodeAt(0) === PLUSSIGN$2) b = b.substr(1);
        return {
            type: "AnPlusB",
            loc: this.getLocation(start, this.tokenStart),
            a: a,
            b: b
        };
    }
    function consumeRaw$1(startToken) {
        return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
        for(let offset = 1, type; type = this.lookupType(offset); offset++){
            if (type === RightCurlyBracket) return true;
            if (type === LeftCurlyBracket || type === AtKeyword) return false;
        }
        return false;
    }
    function parse$4() {
        const start = this.tokenStart;
        let name;
        let nameLowerCase;
        let prelude = null;
        let block = null;
        this.eat(AtKeyword);
        name = this.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.skipSC();
        // parse prelude
        if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
            if (this.parseAtrulePrelude) prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw$1);
            else prelude = consumeRaw$1.call(this, this.tokenIndex);
            this.skipSC();
        }
        switch(this.tokenType){
            case Semicolon:
                this.next();
                break;
            case LeftCurlyBracket:
                if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") block = this.atrule[nameLowerCase].block.call(this);
                else // TODO: should consume block content as Raw?
                block = this.Block(isDeclarationBlockAtrule.call(this));
                break;
        }
        return {
            type: "Atrule",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    }
    function parse$5(name) {
        let children = null;
        if (name !== null) name = name.toLowerCase();
        this.skipSC();
        if (hasOwnProperty.call(this.atrule, name) && typeof this.atrule[name].prelude === "function") // custom consumer
        children = this.atrule[name].prelude.call(this);
        else // default consumer
        children = this.readSequence(this.scope.AtrulePrelude);
        this.skipSC();
        if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) this.error("Semicolon or block is expected");
        return {
            type: "AtrulePrelude",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    const DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)
    const ASTERISK$2 = 0x002A; // U+002A ASTERISK (*)
    const EQUALSSIGN = 0x003D; // U+003D EQUALS SIGN (=)
    const CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
    const VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)
    const TILDE$1 = 0x007E; // U+007E TILDE (~)
    function getAttributeName() {
        if (this.eof) this.error("Unexpected end of input");
        const start = this.tokenStart;
        let expectIdent = false;
        if (this.isDelim(ASTERISK$2)) {
            expectIdent = true;
            this.next();
        } else if (!this.isDelim(VERTICALLINE$1)) this.eat(Ident);
        if (this.isDelim(VERTICALLINE$1)) {
            if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
                this.next();
                this.eat(Ident);
            } else if (expectIdent) this.error("Identifier is expected", this.tokenEnd);
        } else if (expectIdent) this.error("Vertical line is expected");
        return {
            type: "Identifier",
            loc: this.getLocation(start, this.tokenStart),
            name: this.substrToCursor(start)
        };
    }
    function getOperator() {
        const start = this.tokenStart;
        const code = this.charCodeAt(start);
        if (code !== EQUALSSIGN && // =
        code !== TILDE$1 && // ~=
        code !== CIRCUMFLEXACCENT && // ^=
        code !== DOLLARSIGN && // $=
        code !== ASTERISK$2 && // *=
        code !== VERTICALLINE$1 // |=
        ) this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        this.next();
        if (code !== EQUALSSIGN) {
            if (!this.isDelim(EQUALSSIGN)) this.error("Equal sign is expected");
            this.next();
        }
        return this.substrToCursor(start);
    }
    function parse$6() {
        const start = this.tokenStart;
        let name;
        let matcher = null;
        let value = null;
        let flags = null;
        this.eat(LeftSquareBracket);
        this.skipSC();
        name = getAttributeName.call(this);
        this.skipSC();
        if (this.tokenType !== RightSquareBracket) {
            // avoid case `[name i]`
            if (this.tokenType !== Ident) {
                matcher = getOperator.call(this);
                this.skipSC();
                value = this.tokenType === String$1 ? this.String() : this.Identifier();
                this.skipSC();
            }
            // attribute flags
            if (this.tokenType === Ident) {
                flags = this.consume(Ident);
                this.skipSC();
            }
        }
        this.eat(RightSquareBracket);
        return {
            type: "AttributeSelector",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    }
    function consumeRaw$2(startToken) {
        return this.Raw(startToken, null, true);
    }
    function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw$2);
    }
    function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    function consumeDeclaration() {
        if (this.tokenType === Semicolon) return consumeRawDeclaration.call(this, this.tokenIndex);
        const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
        if (this.tokenType === Semicolon) this.next();
        return node;
    }
    function parse$7(isDeclaration) {
        const consumer = isDeclaration ? consumeDeclaration : consumeRule;
        const start = this.tokenStart;
        let children = this.createList();
        this.eat(LeftCurlyBracket);
        scan: while(!this.eof)switch(this.tokenType){
            case RightCurlyBracket:
                break scan;
            case WhiteSpace:
            case Comment:
                this.next();
                break;
            case AtKeyword:
                children.push(this.parseWithFallback(this.Atrule, consumeRaw$2));
                break;
            default:
                children.push(consumer.call(this));
        }
        if (!this.eof) this.eat(RightCurlyBracket);
        return {
            type: "Block",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    function parse$8(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(LeftSquareBracket);
        children = readSequence.call(this, recognizer);
        if (!this.eof) this.eat(RightSquareBracket);
        return {
            type: "Brackets",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    function parse$9() {
        const start = this.tokenStart;
        this.eat(CDC); // -->
        return {
            type: "CDC",
            loc: this.getLocation(start, this.tokenStart)
        };
    }
    function parse$a() {
        const start = this.tokenStart;
        this.eat(CDO); // <!--
        return {
            type: "CDO",
            loc: this.getLocation(start, this.tokenStart)
        };
    }
    const FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)
    function parse$b() {
        this.eatDelim(FULLSTOP$1);
        return {
            type: "ClassSelector",
            loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
            name: this.consume(Ident)
        };
    }
    const PLUSSIGN$3 = 0x002B; // U+002B PLUS SIGN (+)
    const SOLIDUS$2 = 0x002F; // U+002F SOLIDUS (/)
    const GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
    const TILDE$2 = 0x007E; // U+007E TILDE (~)
    // + | > | ~ | /deep/
    function parse$c() {
        const start = this.tokenStart;
        let name;
        switch(this.tokenType){
            case WhiteSpace:
                name = " ";
                break;
            case Delim:
                switch(this.charCodeAt(this.tokenStart)){
                    case GREATERTHANSIGN$1:
                    case PLUSSIGN$3:
                    case TILDE$2:
                        this.next();
                        break;
                    case SOLIDUS$2:
                        this.next();
                        this.eatIdent("deep");
                        this.eatDelim(SOLIDUS$2);
                        break;
                    default:
                        this.error("Combinator is expected");
                }
                name = this.substrToCursor(start);
                break;
        }
        return {
            type: "Combinator",
            loc: this.getLocation(start, this.tokenStart),
            name: name
        };
    }
    const ASTERISK$3 = 0x002A; // U+002A ASTERISK (*)
    const SOLIDUS$3 = 0x002F; // U+002F SOLIDUS (/)
    function parse$d() {
        const start = this.tokenStart;
        let end = this.tokenEnd;
        this.eat(Comment);
        if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$3 && this.charCodeAt(end - 1) === SOLIDUS$3) end -= 2;
        return {
            type: "Comment",
            loc: this.getLocation(start, this.tokenStart),
            value: this.substring(start + 2, end)
        };
    }
    const HYPHENMINUS$2 = 45; // '-'.charCodeAt()
    function isCustomProperty(str, offset) {
        offset = offset || 0;
        return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$2 && str.charCodeAt(offset + 1) === HYPHENMINUS$2;
    }
    const EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
    const NUMBERSIGN$3 = 0x0023; // U+0023 NUMBER SIGN (#)
    const DOLLARSIGN$1 = 0x0024; // U+0024 DOLLAR SIGN ($)
    const AMPERSAND = 0x0026; // U+0026 AMPERSAND (&)
    const ASTERISK$4 = 0x002A; // U+002A ASTERISK (*)
    const PLUSSIGN$4 = 0x002B; // U+002B PLUS SIGN (+)
    const SOLIDUS$4 = 0x002F; // U+002F SOLIDUS (/)
    function consumeValueRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
        const startValueToken = this.tokenIndex;
        const value = this.Value();
        if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) this.error();
        return value;
    }
    function parse$e() {
        const start = this.tokenStart;
        const startToken = this.tokenIndex;
        const property = readProperty.call(this);
        const customProperty = isCustomProperty(property);
        const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        let important = false;
        let value;
        this.skipSC();
        this.eat(Colon);
        const valueStart = this.tokenIndex;
        if (!customProperty) this.skipSC();
        if (parseValue) value = this.parseWithFallback(consumeValue, consumeRaw);
        else value = consumeRaw.call(this, this.tokenIndex);
        if (customProperty && value.type === "Value" && value.children.isEmpty) {
            for(let offset = valueStart - this.tokenIndex; offset <= 0; offset++)if (this.lookupType(offset) === WhiteSpace) {
                value.children.appendData({
                    type: "WhiteSpace",
                    loc: null,
                    value: " "
                });
                break;
            }
        }
        if (this.isDelim(EXCLAMATIONMARK$1)) {
            important = getImportant.call(this);
            this.skipSC();
        }
        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram
        if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) this.error();
        return {
            type: "Declaration",
            loc: this.getLocation(start, this.tokenStart),
            important: important,
            property: property,
            value: value
        };
    }
    function readProperty() {
        const start = this.tokenStart;
        // hacks
        if (this.tokenType === Delim) switch(this.charCodeAt(this.tokenStart)){
            case ASTERISK$4:
            case DOLLARSIGN$1:
            case PLUSSIGN$4:
            case NUMBERSIGN$3:
            case AMPERSAND:
                this.next();
                break;
            // TODO: not sure we should support this hack
            case SOLIDUS$4:
                this.next();
                if (this.isDelim(SOLIDUS$4)) this.next();
                break;
        }
        if (this.tokenType === Hash) this.eat(Hash);
        else this.eat(Ident);
        return this.substrToCursor(start);
    }
    // ! ws* important
    function getImportant() {
        this.eat(Delim);
        this.skipSC();
        const important = this.consume(Ident);
        // store original value in case it differ from `important`
        // for better original source restoring and hacks like `!ie` support
        return important === "important" ? true : important;
    }
    function consumeRaw$3(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    function parse$f() {
        const children = this.createList();
        while(!this.eof)switch(this.tokenType){
            case WhiteSpace:
            case Comment:
            case Semicolon:
                this.next();
                break;
            default:
                children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
        }
        return {
            type: "DeclarationList",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    function parse$g() {
        const start = this.tokenStart;
        const value = this.consumeNumber(Dimension);
        return {
            type: "Dimension",
            loc: this.getLocation(start, this.tokenStart),
            value: value,
            unit: this.substring(start + value.length, this.tokenStart)
        };
    }
    // <function-token> <sequence> )
    function parse$h(readSequence, recognizer) {
        const start = this.tokenStart;
        const name = this.consumeFunctionName();
        const nameLowerCase = name.toLowerCase();
        let children;
        children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
        if (!this.eof) this.eat(RightParenthesis);
        return {
            type: "Function",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            children: children
        };
    }
    function parse$i() {
        const start = this.tokenStart;
        this.eat(Hash);
        return {
            type: "Hash",
            loc: this.getLocation(start, this.tokenStart),
            value: this.substrToCursor(start + 1)
        };
    }
    function parse$j() {
        return {
            type: "Identifier",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            name: this.consume(Ident)
        };
    }
    function parse$k() {
        const start = this.tokenStart;
        // TODO: check value is an ident
        this.eat(Hash);
        return {
            type: "IdSelector",
            loc: this.getLocation(start, this.tokenStart),
            name: this.substrToCursor(start + 1)
        };
    }
    function parse$l() {
        const start = this.tokenStart;
        let name;
        let value = null;
        this.eat(LeftParenthesis);
        this.skipSC();
        name = this.consume(Ident);
        this.skipSC();
        if (this.tokenType !== RightParenthesis) {
            this.eat(Colon);
            this.skipSC();
            switch(this.tokenType){
                case Number$1:
                    if (this.lookupNonWSType(1) === Delim) value = this.Ratio();
                    else value = this.Number();
                    break;
                case Dimension:
                    value = this.Dimension();
                    break;
                case Ident:
                    value = this.Identifier();
                    break;
                default:
                    this.error("Number, dimension, ratio or identifier is expected");
            }
            this.skipSC();
        }
        this.eat(RightParenthesis);
        return {
            type: "MediaFeature",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            value: value
        };
    }
    function parse$m() {
        const children = this.createList();
        let child = null;
        this.skipSC();
        scan: while(!this.eof){
            switch(this.tokenType){
                case Comment:
                case WhiteSpace:
                    this.next();
                    continue;
                case Ident:
                    child = this.Identifier();
                    break;
                case LeftParenthesis:
                    child = this.MediaFeature();
                    break;
                default:
                    break scan;
            }
            children.push(child);
        }
        if (child === null) this.error("Identifier or parenthesis is expected");
        return {
            type: "MediaQuery",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    function parse$n() {
        const children = this.createList();
        this.skipSC();
        while(!this.eof){
            children.push(this.MediaQuery());
            if (this.tokenType !== Comma) break;
            this.next();
        }
        return {
            type: "MediaQueryList",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    function parse$o() {
        this.skipSC();
        const start = this.tokenStart;
        let end = start;
        let selector = null;
        let nth;
        if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) nth = this.Identifier();
        else nth = this.AnPlusB();
        end = this.tokenStart;
        this.skipSC();
        if (this.lookupValue(0, "of")) {
            this.next();
            selector = this.SelectorList();
            end = this.tokenStart;
        }
        return {
            type: "Nth",
            loc: this.getLocation(start, end),
            nth: nth,
            selector: selector
        };
    }
    function parse$p() {
        return {
            type: "Number",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: this.consume(Number$1)
        };
    }
    // '/' | '*' | ',' | ':' | '+' | '-'
    function parse$q() {
        const start = this.tokenStart;
        this.next();
        return {
            type: "Operator",
            loc: this.getLocation(start, this.tokenStart),
            value: this.substrToCursor(start)
        };
    }
    function parse$r(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(LeftParenthesis);
        children = readSequence.call(this, recognizer);
        if (!this.eof) this.eat(RightParenthesis);
        return {
            type: "Parentheses",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    function parse$s() {
        return {
            type: "Percentage",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: this.consumeNumber(Percentage)
        };
    }
    // : [ <ident> | <function-token> <any-value>? ) ]
    function parse$t() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(Colon);
        if (this.tokenType === Function$1) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
                this.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.skipSC();
            } else {
                children = this.createList();
                children.push(this.Raw(this.tokenIndex, null, false));
            }
            this.eat(RightParenthesis);
        } else name = this.consume(Ident);
        return {
            type: "PseudoClassSelector",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            children: children
        };
    }
    // :: [ <ident> | <function-token> <any-value>? ) ]
    function parse$u() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(Colon);
        this.eat(Colon);
        if (this.tokenType === Function$1) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
                this.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.skipSC();
            } else {
                children = this.createList();
                children.push(this.Raw(this.tokenIndex, null, false));
            }
            this.eat(RightParenthesis);
        } else name = this.consume(Ident);
        return {
            type: "PseudoElementSelector",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            children: children
        };
    }
    const SOLIDUS$5 = 0x002F; // U+002F SOLIDUS (/)
    const FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)
    // Terms of <ratio> should be a positive numbers (not zero or negative)
    // (see https://drafts.csswg.org/mediaqueries-3/#values)
    // However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
    // and this is using by various sites. Therefore we relax checking on parse
    // to test a term is unsigned number without an exponent part.
    // Additional checking may be applied on lexer validation.
    function consumeNumber$1() {
        this.skipSC();
        const value = this.consume(Number$1);
        for(let i = 0; i < value.length; i++){
            const code = value.charCodeAt(i);
            if (!isDigit(code) && code !== FULLSTOP$2) this.error("Unsigned number is expected", this.tokenStart - value.length + i);
        }
        if (Number(value) === 0) this.error("Zero number is not allowed", this.tokenStart - value.length);
        return value;
    }
    // <positive-integer> S* '/' S* <positive-integer>
    function parse$v() {
        const start = this.tokenStart;
        const left = consumeNumber$1.call(this);
        let right;
        this.skipSC();
        this.eatDelim(SOLIDUS$5);
        right = consumeNumber$1.call(this);
        return {
            type: "Ratio",
            loc: this.getLocation(start, this.tokenStart),
            left: left,
            right: right
        };
    }
    function getOffsetExcludeWS() {
        if (this.tokenIndex > 0) {
            if (this.lookupType(-1) === WhiteSpace) return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
        }
        return this.tokenStart;
    }
    function parse$w(startToken, consumeUntil, excludeWhiteSpace) {
        const startOffset = this.getTokenStart(startToken);
        let endOffset;
        this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
        if (excludeWhiteSpace && this.tokenStart > startOffset) endOffset = getOffsetExcludeWS.call(this);
        else endOffset = this.tokenStart;
        return {
            type: "Raw",
            loc: this.getLocation(startOffset, endOffset),
            value: this.substring(startOffset, endOffset)
        };
    }
    function consumeRaw$4(startToken) {
        return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
    }
    function consumePrelude() {
        const prelude = this.SelectorList();
        if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) this.error();
        return prelude;
    }
    function parse$x() {
        const startToken = this.tokenIndex;
        const startOffset = this.tokenStart;
        let prelude;
        let block;
        if (this.parseRulePrelude) prelude = this.parseWithFallback(consumePrelude, consumeRaw$4);
        else prelude = consumeRaw$4.call(this, startToken);
        block = this.Block(true);
        return {
            type: "Rule",
            loc: this.getLocation(startOffset, this.tokenStart),
            prelude: prelude,
            block: block
        };
    }
    function parse$y() {
        const children = this.readSequence(this.scope.Selector);
        // nothing were consumed
        if (this.getFirstListNode(children) === null) this.error("Selector is expected");
        return {
            type: "Selector",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    function parse$z() {
        const children = this.createList();
        while(!this.eof){
            children.push(this.Selector());
            if (this.tokenType === Comma) {
                this.next();
                continue;
            }
            break;
        }
        return {
            type: "SelectorList",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    const REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)
    const QUOTATION_MARK = 0x0022; // "
    const APOSTROPHE = 0x0027; // '
    function decode$1(str) {
        const len = str.length;
        const firstChar = str.charCodeAt(0);
        const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
        const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
        let decoded = "";
        for(let i = start; i <= end; i++){
            let code = str.charCodeAt(i);
            if (code === REVERSE_SOLIDUS) {
                // special case at the ending
                if (i === end) {
                    // if the next input code point is EOF, do nothing
                    // otherwise include last quote as escaped
                    if (i !== len - 1) decoded = str.substr(i + 1);
                    break;
                }
                code = str.charCodeAt(++i);
                // consume escaped
                if (isValidEscape(REVERSE_SOLIDUS, code)) {
                    const escapeStart = i - 1;
                    const escapeEnd = consumeEscaped(str, escapeStart);
                    i = escapeEnd - 1;
                    decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
                } else // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) i++;
            } else decoded += str[i];
        }
        return decoded;
    }
    function parse$A() {
        return {
            type: "String",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: decode$1(this.consume(String$1))
        };
    }
    const EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
    function consumeRaw$5(startToken) {
        return this.Raw(startToken, null, false);
    }
    function parse$B() {
        const start = this.tokenStart;
        const children = this.createList();
        let child;
        while(!this.eof){
            switch(this.tokenType){
                case WhiteSpace:
                    this.next();
                    continue;
                case Comment:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK$2) {
                        this.next();
                        continue;
                    }
                    child = this.Comment();
                    break;
                case CDO:
                    child = this.CDO();
                    break;
                case CDC:
                    child = this.CDC();
                    break;
                // CSS Syntax Module Level 3
                // §2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case AtKeyword:
                    child = this.parseWithFallback(this.Atrule, consumeRaw$5);
                    break;
                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw$5);
            }
            children.push(child);
        }
        return {
            type: "StyleSheet",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    const ASTERISK$5 = 0x002A; // U+002A ASTERISK (*)
    const VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)
    function eatIdentifierOrAsterisk() {
        if (this.tokenType !== Ident && this.isDelim(ASTERISK$5) === false) this.error("Identifier or asterisk is expected");
        this.next();
    }
    // ident
    // ident|ident
    // ident|*
    // *
    // *|ident
    // *|*
    // |ident
    // |*
    function parse$C() {
        const start = this.tokenStart;
        if (this.isDelim(VERTICALLINE$2)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);
            if (this.isDelim(VERTICALLINE$2)) {
                this.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }
        return {
            type: "TypeSelector",
            loc: this.getLocation(start, this.tokenStart),
            name: this.substrToCursor(start)
        };
    }
    const PLUSSIGN$5 = 0x002B; // U+002B PLUS SIGN (+)
    const HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
    const QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
    function eatHexSequence(offset, allowDash) {
        let len = 0;
        for(let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++){
            const code = this.charCodeAt(pos);
            if (code === HYPHENMINUS$3 && allowDash && len !== 0) {
                eatHexSequence.call(this, offset + len + 1, false);
                return -1;
            }
            if (!isHexDigit$1(code)) this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
            if (++len > 6) this.error("Too many hex digits", pos);
        }
        this.next();
        return len;
    }
    function eatQuestionMarkSequence(max) {
        let count = 0;
        while(this.isDelim(QUESTIONMARK)){
            if (++count > max) this.error("Too many question marks");
            this.next();
        }
    }
    function startsWith(code) {
        if (this.charCodeAt(this.tokenStart) !== code) this.error((code === PLUSSIGN$5 ? "Plus sign" : "Hyphen minus") + " is expected");
    }
    // https://drafts.csswg.org/css-syntax/#urange
    // Informally, the <urange> production has three forms:
    // U+0001
    //      Defines a range consisting of a single code point, in this case the code point "1".
    // U+0001-00ff
    //      Defines a range of codepoints between the first and the second value, in this case
    //      the range between "1" and "ff" (255 in decimal) inclusive.
    // U+00??
    //      Defines a range of codepoints where the "?" characters range over all hex digits,
    //      in this case defining the same as the value U+0000-00ff.
    // In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
    //
    // <urange> =
    //   u '+' <ident-token> '?'* |
    //   u <dimension-token> '?'* |
    //   u <number-token> '?'* |
    //   u <number-token> <dimension-token> |
    //   u <number-token> <number-token> |
    //   u '+' '?'+
    function scanUnicodeRange() {
        let hexLength = 0;
        switch(this.tokenType){
            case Number$1:
                // u <number-token> '?'*
                // u <number-token> <dimension-token>
                // u <number-token> <number-token>
                hexLength = eatHexSequence.call(this, 1, true);
                if (this.isDelim(QUESTIONMARK)) {
                    eatQuestionMarkSequence.call(this, 6 - hexLength);
                    break;
                }
                if (this.tokenType === Dimension || this.tokenType === Number$1) {
                    startsWith.call(this, HYPHENMINUS$3);
                    eatHexSequence.call(this, 1, false);
                    break;
                }
                break;
            case Dimension:
                // u <dimension-token> '?'*
                hexLength = eatHexSequence.call(this, 1, true);
                if (hexLength > 0) eatQuestionMarkSequence.call(this, 6 - hexLength);
                break;
            default:
                // u '+' <ident-token> '?'*
                // u '+' '?'+
                this.eatDelim(PLUSSIGN$5);
                if (this.tokenType === Ident) {
                    hexLength = eatHexSequence.call(this, 0, true);
                    if (hexLength > 0) eatQuestionMarkSequence.call(this, 6 - hexLength);
                    break;
                }
                if (this.isDelim(QUESTIONMARK)) {
                    this.next();
                    eatQuestionMarkSequence.call(this, 5);
                    break;
                }
                this.error("Hex digit or question mark is expected");
        }
    }
    function parse$D() {
        const start = this.tokenStart;
        // U or u
        this.eatIdent("u");
        scanUnicodeRange.call(this);
        return {
            type: "UnicodeRange",
            loc: this.getLocation(start, this.tokenStart),
            value: this.substrToCursor(start)
        };
    }
    const REVERSE_SOLIDUS$1 = 0x005c; // U+005C REVERSE SOLIDUS (\)
    const RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())
    function decode$2(str) {
        const len = str.length;
        let start = 4; // length of "url("
        let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
        let decoded = "";
        while(start < end && isWhiteSpace(str.charCodeAt(start)))start++;
        while(start < end && isWhiteSpace(str.charCodeAt(end)))end--;
        for(let i = start; i <= end; i++){
            let code = str.charCodeAt(i);
            if (code === REVERSE_SOLIDUS$1) {
                // special case at the ending
                if (i === end) {
                    // if the next input code point is EOF, do nothing
                    // otherwise include last left parenthesis as escaped
                    if (i !== len - 1) decoded = str.substr(i + 1);
                    break;
                }
                code = str.charCodeAt(++i);
                // consume escaped
                if (isValidEscape(REVERSE_SOLIDUS$1, code)) {
                    const escapeStart = i - 1;
                    const escapeEnd = consumeEscaped(str, escapeStart);
                    i = escapeEnd - 1;
                    decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
                } else // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) i++;
            } else decoded += str[i];
        }
        return decoded;
    }
    // <url-token> | <function-token> <string> )
    function parse$E() {
        const start = this.tokenStart;
        let value;
        switch(this.tokenType){
            case Url:
                value = decode$2(this.consume(Url));
                break;
            case Function$1:
                if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) this.error("Function name must be `url`");
                this.eat(Function$1);
                this.skipSC();
                value = decode$1(this.consume(String$1));
                this.skipSC();
                if (!this.eof) this.eat(RightParenthesis);
                break;
            default:
                this.error("Url or Function is expected");
        }
        return {
            type: "Url",
            loc: this.getLocation(start, this.tokenStart),
            value: value
        };
    }
    function parse$F() {
        const start = this.tokenStart;
        const children = this.readSequence(this.scope.Value);
        return {
            type: "Value",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    const SPACE = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " "
    });
    function parse$G() {
        this.eat(WhiteSpace);
        return SPACE;
    // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
    }
    var node = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        AnPlusB: parse$3,
        Atrule: parse$4,
        AtrulePrelude: parse$5,
        AttributeSelector: parse$6,
        Block: parse$7,
        Brackets: parse$8,
        CDC: parse$9,
        CDO: parse$a,
        ClassSelector: parse$b,
        Combinator: parse$c,
        Comment: parse$d,
        Declaration: parse$e,
        DeclarationList: parse$f,
        Dimension: parse$g,
        Function: parse$h,
        Hash: parse$i,
        Identifier: parse$j,
        IdSelector: parse$k,
        MediaFeature: parse$l,
        MediaQuery: parse$m,
        MediaQueryList: parse$n,
        Nth: parse$o,
        Number: parse$p,
        Operator: parse$q,
        Parentheses: parse$r,
        Percentage: parse$s,
        PseudoClassSelector: parse$t,
        PseudoElementSelector: parse$u,
        Ratio: parse$v,
        Raw: parse$w,
        Rule: parse$x,
        Selector: parse$y,
        SelectorList: parse$z,
        String: parse$A,
        StyleSheet: parse$B,
        TypeSelector: parse$C,
        UnicodeRange: parse$D,
        Url: parse$E,
        Value: parse$F,
        WhiteSpace: parse$G
    });
    var config = {
        parseContext: {
            default: "StyleSheet",
            stylesheet: "StyleSheet",
            atrule: "Atrule",
            atrulePrelude (options) {
                return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
            },
            mediaQueryList: "MediaQueryList",
            mediaQuery: "MediaQuery",
            rule: "Rule",
            selectorList: "SelectorList",
            selector: "Selector",
            block () {
                return this.Block(true);
            },
            declarationList: "DeclarationList",
            declaration: "Declaration",
            value: "Value"
        },
        scope: scope,
        atrule: atrule,
        pseudo: pseudo,
        node: node
    };
    var parse$H = createParser(config);
    // @ts-ignore
    const regex_closing_style_tag = /<\/style\s*>/;
    function read_style(parser, start, attributes) {
        const content_start = parser.index;
        const styles = parser.read_until(regex_closing_style_tag, parser_errors.unclosed_style);
        if (parser.index >= parser.template.length) parser.error(parser_errors.unclosed_style);
        const content_end = parser.index;
        // discard styles when css is disabled
        if (parser.css_mode === "none") {
            parser.read(regex_closing_style_tag);
            return null;
        }
        let ast;
        try {
            ast = parse$H(styles, {
                positions: true,
                offset: content_start,
                onParseError (error) {
                    throw error;
                }
            });
        } catch (err) {
            if (err.name === "SyntaxError") parser.error(parser_errors.css_syntax_error(err.message), err.offset);
            else throw err;
        }
        ast = JSON.parse(JSON.stringify(ast));
        // tidy up AST
        walk(ast, {
            enter: (node)=>{
                // replace `ref:a` nodes
                if (node.type === "Selector") for(let i = 0; i < node.children.length; i += 1){
                    const a = node.children[i];
                    const b = node.children[i + 1];
                    if (is_ref_selector(a, b)) parser.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
                }
                if (node.type === "Declaration" && node.value.type === "Value" && node.value.children.length === 0) parser.error(parser_errors.invalid_declaration, node.start);
                if (node.type === "PseudoClassSelector" && node.name === "global" && node.children === null) parser.error(parser_errors.empty_global_selector, node.loc.start.offset);
                if (node.loc) {
                    node.start = node.loc.start.offset;
                    node.end = node.loc.end.offset;
                    delete node.loc;
                }
            }
        });
        parser.read(regex_closing_style_tag);
        const end = parser.index;
        return {
            type: "Style",
            start: start,
            end: end,
            attributes: attributes,
            children: ast.children,
            content: {
                start: content_start,
                end: content_end,
                styles: styles
            }
        };
    }
    function is_ref_selector(a, b) {
        if (!b) return false;
        return a.type === "TypeSelector" && a.name === "ref" && b.type === "PseudoClassSelector";
    }
    // https://dev.w3.org/html5/html-author/charref
    var entities = {
        CounterClockwiseContourIntegral: 8755,
        ClockwiseContourIntegral: 8754,
        DoubleLongLeftRightArrow: 10234,
        DiacriticalDoubleAcute: 733,
        NotSquareSupersetEqual: 8931,
        CloseCurlyDoubleQuote: 8221,
        DoubleContourIntegral: 8751,
        FilledVerySmallSquare: 9642,
        NegativeVeryThinSpace: 8203,
        NotPrecedesSlantEqual: 8928,
        NotRightTriangleEqual: 8941,
        NotSucceedsSlantEqual: 8929,
        CapitalDifferentialD: 8517,
        DoubleLeftRightArrow: 8660,
        DoubleLongRightArrow: 10233,
        EmptyVerySmallSquare: 9643,
        NestedGreaterGreater: 8811,
        NotDoubleVerticalBar: 8742,
        NotLeftTriangleEqual: 8940,
        NotSquareSubsetEqual: 8930,
        OpenCurlyDoubleQuote: 8220,
        ReverseUpEquilibrium: 10607,
        DoubleLongLeftArrow: 10232,
        DownLeftRightVector: 10576,
        LeftArrowRightArrow: 8646,
        NegativeMediumSpace: 8203,
        RightArrowLeftArrow: 8644,
        SquareSupersetEqual: 8850,
        leftrightsquigarrow: 8621,
        DownRightTeeVector: 10591,
        DownRightVectorBar: 10583,
        LongLeftRightArrow: 10231,
        Longleftrightarrow: 10234,
        NegativeThickSpace: 8203,
        PrecedesSlantEqual: 8828,
        ReverseEquilibrium: 8651,
        RightDoubleBracket: 10215,
        RightDownTeeVector: 10589,
        RightDownVectorBar: 10581,
        RightTriangleEqual: 8885,
        SquareIntersection: 8851,
        SucceedsSlantEqual: 8829,
        blacktriangleright: 9656,
        longleftrightarrow: 10231,
        DoubleUpDownArrow: 8661,
        DoubleVerticalBar: 8741,
        DownLeftTeeVector: 10590,
        DownLeftVectorBar: 10582,
        FilledSmallSquare: 9724,
        GreaterSlantEqual: 10878,
        LeftDoubleBracket: 10214,
        LeftDownTeeVector: 10593,
        LeftDownVectorBar: 10585,
        LeftTriangleEqual: 8884,
        NegativeThinSpace: 8203,
        NotReverseElement: 8716,
        NotTildeFullEqual: 8775,
        RightAngleBracket: 10217,
        RightUpDownVector: 10575,
        SquareSubsetEqual: 8849,
        VerticalSeparator: 10072,
        blacktriangledown: 9662,
        blacktriangleleft: 9666,
        leftrightharpoons: 8651,
        rightleftharpoons: 8652,
        twoheadrightarrow: 8608,
        DiacriticalAcute: 180,
        DiacriticalGrave: 96,
        DiacriticalTilde: 732,
        DoubleRightArrow: 8658,
        DownArrowUpArrow: 8693,
        EmptySmallSquare: 9723,
        GreaterEqualLess: 8923,
        GreaterFullEqual: 8807,
        LeftAngleBracket: 10216,
        LeftUpDownVector: 10577,
        LessEqualGreater: 8922,
        NonBreakingSpace: 160,
        NotRightTriangle: 8939,
        NotSupersetEqual: 8841,
        RightTriangleBar: 10704,
        RightUpTeeVector: 10588,
        RightUpVectorBar: 10580,
        UnderParenthesis: 9181,
        UpArrowDownArrow: 8645,
        circlearrowright: 8635,
        downharpoonright: 8642,
        ntrianglerighteq: 8941,
        rightharpoondown: 8641,
        rightrightarrows: 8649,
        twoheadleftarrow: 8606,
        vartriangleright: 8883,
        CloseCurlyQuote: 8217,
        ContourIntegral: 8750,
        DoubleDownArrow: 8659,
        DoubleLeftArrow: 8656,
        DownRightVector: 8641,
        LeftRightVector: 10574,
        LeftTriangleBar: 10703,
        LeftUpTeeVector: 10592,
        LeftUpVectorBar: 10584,
        LowerRightArrow: 8600,
        NotGreaterEqual: 8817,
        NotGreaterTilde: 8821,
        NotLeftTriangle: 8938,
        OverParenthesis: 9180,
        RightDownVector: 8642,
        ShortRightArrow: 8594,
        UpperRightArrow: 8599,
        bigtriangledown: 9661,
        circlearrowleft: 8634,
        curvearrowright: 8631,
        downharpoonleft: 8643,
        leftharpoondown: 8637,
        leftrightarrows: 8646,
        nLeftrightarrow: 8654,
        nleftrightarrow: 8622,
        ntrianglelefteq: 8940,
        rightleftarrows: 8644,
        rightsquigarrow: 8605,
        rightthreetimes: 8908,
        straightepsilon: 1013,
        trianglerighteq: 8885,
        vartriangleleft: 8882,
        DiacriticalDot: 729,
        DoubleRightTee: 8872,
        DownLeftVector: 8637,
        GreaterGreater: 10914,
        HorizontalLine: 9472,
        InvisibleComma: 8291,
        InvisibleTimes: 8290,
        LeftDownVector: 8643,
        LeftRightArrow: 8596,
        Leftrightarrow: 8660,
        LessSlantEqual: 10877,
        LongRightArrow: 10230,
        Longrightarrow: 10233,
        LowerLeftArrow: 8601,
        NestedLessLess: 8810,
        NotGreaterLess: 8825,
        NotLessGreater: 8824,
        NotSubsetEqual: 8840,
        NotVerticalBar: 8740,
        OpenCurlyQuote: 8216,
        ReverseElement: 8715,
        RightTeeVector: 10587,
        RightVectorBar: 10579,
        ShortDownArrow: 8595,
        ShortLeftArrow: 8592,
        SquareSuperset: 8848,
        TildeFullEqual: 8773,
        UpperLeftArrow: 8598,
        ZeroWidthSpace: 8203,
        curvearrowleft: 8630,
        doublebarwedge: 8966,
        downdownarrows: 8650,
        hookrightarrow: 8618,
        leftleftarrows: 8647,
        leftrightarrow: 8596,
        leftthreetimes: 8907,
        longrightarrow: 10230,
        looparrowright: 8620,
        nshortparallel: 8742,
        ntriangleright: 8939,
        rightarrowtail: 8611,
        rightharpoonup: 8640,
        trianglelefteq: 8884,
        upharpoonright: 8638,
        ApplyFunction: 8289,
        DifferentialD: 8518,
        DoubleLeftTee: 10980,
        DoubleUpArrow: 8657,
        LeftTeeVector: 10586,
        LeftVectorBar: 10578,
        LessFullEqual: 8806,
        LongLeftArrow: 10229,
        Longleftarrow: 10232,
        NotTildeEqual: 8772,
        NotTildeTilde: 8777,
        Poincareplane: 8460,
        PrecedesEqual: 10927,
        PrecedesTilde: 8830,
        RightArrowBar: 8677,
        RightTeeArrow: 8614,
        RightTriangle: 8883,
        RightUpVector: 8638,
        SucceedsEqual: 10928,
        SucceedsTilde: 8831,
        SupersetEqual: 8839,
        UpEquilibrium: 10606,
        VerticalTilde: 8768,
        VeryThinSpace: 8202,
        bigtriangleup: 9651,
        blacktriangle: 9652,
        divideontimes: 8903,
        fallingdotseq: 8786,
        hookleftarrow: 8617,
        leftarrowtail: 8610,
        leftharpoonup: 8636,
        longleftarrow: 10229,
        looparrowleft: 8619,
        measuredangle: 8737,
        ntriangleleft: 8938,
        shortparallel: 8741,
        smallsetminus: 8726,
        triangleright: 9657,
        upharpoonleft: 8639,
        DownArrowBar: 10515,
        DownTeeArrow: 8615,
        ExponentialE: 8519,
        GreaterEqual: 8805,
        GreaterTilde: 8819,
        HilbertSpace: 8459,
        HumpDownHump: 8782,
        Intersection: 8898,
        LeftArrowBar: 8676,
        LeftTeeArrow: 8612,
        LeftTriangle: 8882,
        LeftUpVector: 8639,
        NotCongruent: 8802,
        NotLessEqual: 8816,
        NotLessTilde: 8820,
        Proportional: 8733,
        RightCeiling: 8969,
        RoundImplies: 10608,
        ShortUpArrow: 8593,
        SquareSubset: 8847,
        UnderBracket: 9141,
        VerticalLine: 124,
        blacklozenge: 10731,
        exponentiale: 8519,
        risingdotseq: 8787,
        triangledown: 9663,
        triangleleft: 9667,
        CircleMinus: 8854,
        CircleTimes: 8855,
        Equilibrium: 8652,
        GreaterLess: 8823,
        LeftCeiling: 8968,
        LessGreater: 8822,
        MediumSpace: 8287,
        NotPrecedes: 8832,
        NotSucceeds: 8833,
        OverBracket: 9140,
        RightVector: 8640,
        Rrightarrow: 8667,
        RuleDelayed: 10740,
        SmallCircle: 8728,
        SquareUnion: 8852,
        SubsetEqual: 8838,
        UpDownArrow: 8597,
        Updownarrow: 8661,
        VerticalBar: 8739,
        backepsilon: 1014,
        blacksquare: 9642,
        circledcirc: 8858,
        circleddash: 8861,
        curlyeqprec: 8926,
        curlyeqsucc: 8927,
        diamondsuit: 9830,
        eqslantless: 10901,
        expectation: 8496,
        nRightarrow: 8655,
        nrightarrow: 8603,
        preccurlyeq: 8828,
        precnapprox: 10937,
        quaternions: 8461,
        straightphi: 981,
        succcurlyeq: 8829,
        succnapprox: 10938,
        thickapprox: 8776,
        updownarrow: 8597,
        Bernoullis: 8492,
        CirclePlus: 8853,
        EqualTilde: 8770,
        Fouriertrf: 8497,
        ImaginaryI: 8520,
        Laplacetrf: 8466,
        LeftVector: 8636,
        Lleftarrow: 8666,
        NotElement: 8713,
        NotGreater: 8815,
        Proportion: 8759,
        RightArrow: 8594,
        RightFloor: 8971,
        Rightarrow: 8658,
        TildeEqual: 8771,
        TildeTilde: 8776,
        UnderBrace: 9183,
        UpArrowBar: 10514,
        UpTeeArrow: 8613,
        circledast: 8859,
        complement: 8705,
        curlywedge: 8911,
        eqslantgtr: 10902,
        gtreqqless: 10892,
        lessapprox: 10885,
        lesseqqgtr: 10891,
        lmoustache: 9136,
        longmapsto: 10236,
        mapstodown: 8615,
        mapstoleft: 8612,
        nLeftarrow: 8653,
        nleftarrow: 8602,
        precapprox: 10935,
        rightarrow: 8594,
        rmoustache: 9137,
        sqsubseteq: 8849,
        sqsupseteq: 8850,
        subsetneqq: 10955,
        succapprox: 10936,
        supsetneqq: 10956,
        upuparrows: 8648,
        varepsilon: 949,
        varnothing: 8709,
        Backslash: 8726,
        CenterDot: 183,
        CircleDot: 8857,
        Congruent: 8801,
        Coproduct: 8720,
        DoubleDot: 168,
        DownArrow: 8595,
        DownBreve: 785,
        Downarrow: 8659,
        HumpEqual: 8783,
        LeftArrow: 8592,
        LeftFloor: 8970,
        Leftarrow: 8656,
        LessTilde: 8818,
        Mellintrf: 8499,
        MinusPlus: 8723,
        NotCupCap: 8813,
        NotExists: 8708,
        OverBrace: 9182,
        PlusMinus: 177,
        Therefore: 8756,
        ThinSpace: 8201,
        TripleDot: 8411,
        UnionPlus: 8846,
        backprime: 8245,
        backsimeq: 8909,
        bigotimes: 10754,
        centerdot: 183,
        checkmark: 10003,
        complexes: 8450,
        dotsquare: 8865,
        downarrow: 8595,
        gtrapprox: 10886,
        gtreqless: 8923,
        heartsuit: 9829,
        leftarrow: 8592,
        lesseqgtr: 8922,
        nparallel: 8742,
        nshortmid: 8740,
        nsubseteq: 8840,
        nsupseteq: 8841,
        pitchfork: 8916,
        rationals: 8474,
        spadesuit: 9824,
        subseteqq: 10949,
        subsetneq: 8842,
        supseteqq: 10950,
        supsetneq: 8843,
        therefore: 8756,
        triangleq: 8796,
        varpropto: 8733,
        DDotrahd: 10513,
        DotEqual: 8784,
        Integral: 8747,
        LessLess: 10913,
        NotEqual: 8800,
        NotTilde: 8769,
        PartialD: 8706,
        Precedes: 8826,
        RightTee: 8866,
        Succeeds: 8827,
        SuchThat: 8715,
        Superset: 8835,
        Uarrocir: 10569,
        UnderBar: 818,
        andslope: 10840,
        angmsdaa: 10664,
        angmsdab: 10665,
        angmsdac: 10666,
        angmsdad: 10667,
        angmsdae: 10668,
        angmsdaf: 10669,
        angmsdag: 10670,
        angmsdah: 10671,
        angrtvbd: 10653,
        approxeq: 8778,
        awconint: 8755,
        backcong: 8780,
        barwedge: 8965,
        bbrktbrk: 9142,
        bigoplus: 10753,
        bigsqcup: 10758,
        biguplus: 10756,
        bigwedge: 8896,
        boxminus: 8863,
        boxtimes: 8864,
        capbrcup: 10825,
        circledR: 174,
        circledS: 9416,
        cirfnint: 10768,
        clubsuit: 9827,
        cupbrcap: 10824,
        curlyvee: 8910,
        cwconint: 8754,
        doteqdot: 8785,
        dotminus: 8760,
        drbkarow: 10512,
        dzigrarr: 10239,
        elinters: 9191,
        emptyset: 8709,
        eqvparsl: 10725,
        fpartint: 10765,
        geqslant: 10878,
        gesdotol: 10884,
        gnapprox: 10890,
        hksearow: 10533,
        hkswarow: 10534,
        imagline: 8464,
        imagpart: 8465,
        infintie: 10717,
        integers: 8484,
        intercal: 8890,
        intlarhk: 10775,
        laemptyv: 10676,
        ldrushar: 10571,
        leqslant: 10877,
        lesdotor: 10883,
        llcorner: 8990,
        lnapprox: 10889,
        lrcorner: 8991,
        lurdshar: 10570,
        mapstoup: 8613,
        multimap: 8888,
        naturals: 8469,
        otimesas: 10806,
        parallel: 8741,
        plusacir: 10787,
        pointint: 10773,
        precneqq: 10933,
        precnsim: 8936,
        profalar: 9006,
        profline: 8978,
        profsurf: 8979,
        raemptyv: 10675,
        realpart: 8476,
        rppolint: 10770,
        rtriltri: 10702,
        scpolint: 10771,
        setminus: 8726,
        shortmid: 8739,
        smeparsl: 10724,
        sqsubset: 8847,
        sqsupset: 8848,
        subseteq: 8838,
        succneqq: 10934,
        succnsim: 8937,
        supseteq: 8839,
        thetasym: 977,
        thicksim: 8764,
        timesbar: 10801,
        triangle: 9653,
        triminus: 10810,
        trpezium: 9186,
        ulcorner: 8988,
        urcorner: 8989,
        varkappa: 1008,
        varsigma: 962,
        vartheta: 977,
        Because: 8757,
        Cayleys: 8493,
        Cconint: 8752,
        Cedilla: 184,
        Diamond: 8900,
        DownTee: 8868,
        Element: 8712,
        Epsilon: 917,
        Implies: 8658,
        LeftTee: 8867,
        NewLine: 10,
        NoBreak: 8288,
        NotLess: 8814,
        Omicron: 927,
        OverBar: 175,
        Product: 8719,
        UpArrow: 8593,
        Uparrow: 8657,
        Upsilon: 933,
        alefsym: 8501,
        angrtvb: 8894,
        angzarr: 9084,
        asympeq: 8781,
        backsim: 8765,
        because: 8757,
        bemptyv: 10672,
        between: 8812,
        bigcirc: 9711,
        bigodot: 10752,
        bigstar: 9733,
        boxplus: 8862,
        ccupssm: 10832,
        cemptyv: 10674,
        cirscir: 10690,
        coloneq: 8788,
        congdot: 10861,
        cudarrl: 10552,
        cudarrr: 10549,
        cularrp: 10557,
        curarrm: 10556,
        dbkarow: 10511,
        ddagger: 8225,
        ddotseq: 10871,
        demptyv: 10673,
        diamond: 8900,
        digamma: 989,
        dotplus: 8724,
        dwangle: 10662,
        epsilon: 949,
        eqcolon: 8789,
        equivDD: 10872,
        gesdoto: 10882,
        gtquest: 10876,
        gtrless: 8823,
        harrcir: 10568,
        intprod: 10812,
        isindot: 8949,
        larrbfs: 10527,
        larrsim: 10611,
        lbrksld: 10639,
        lbrkslu: 10637,
        ldrdhar: 10599,
        lesdoto: 10881,
        lessdot: 8918,
        lessgtr: 8822,
        lesssim: 8818,
        lotimes: 10804,
        lozenge: 9674,
        ltquest: 10875,
        luruhar: 10598,
        maltese: 10016,
        minusdu: 10794,
        napprox: 8777,
        natural: 9838,
        nearrow: 8599,
        nexists: 8708,
        notinva: 8713,
        notinvb: 8951,
        notinvc: 8950,
        notniva: 8716,
        notnivb: 8958,
        notnivc: 8957,
        npolint: 10772,
        nsqsube: 8930,
        nsqsupe: 8931,
        nvinfin: 10718,
        nwarrow: 8598,
        olcross: 10683,
        omicron: 959,
        orderof: 8500,
        orslope: 10839,
        pertenk: 8241,
        planckh: 8462,
        pluscir: 10786,
        plussim: 10790,
        plustwo: 10791,
        precsim: 8830,
        quatint: 10774,
        questeq: 8799,
        rarrbfs: 10528,
        rarrsim: 10612,
        rbrksld: 10638,
        rbrkslu: 10640,
        rdldhar: 10601,
        realine: 8475,
        rotimes: 10805,
        ruluhar: 10600,
        searrow: 8600,
        simplus: 10788,
        simrarr: 10610,
        subedot: 10947,
        submult: 10945,
        subplus: 10943,
        subrarr: 10617,
        succsim: 8831,
        supdsub: 10968,
        supedot: 10948,
        suphsub: 10967,
        suplarr: 10619,
        supmult: 10946,
        supplus: 10944,
        swarrow: 8601,
        topfork: 10970,
        triplus: 10809,
        tritime: 10811,
        uparrow: 8593,
        upsilon: 965,
        uwangle: 10663,
        vzigzag: 10650,
        zigrarr: 8669,
        Aacute: 193,
        Abreve: 258,
        Agrave: 192,
        Assign: 8788,
        Atilde: 195,
        Barwed: 8966,
        Bumpeq: 8782,
        Cacute: 262,
        Ccaron: 268,
        Ccedil: 199,
        Colone: 10868,
        Conint: 8751,
        CupCap: 8781,
        Dagger: 8225,
        Dcaron: 270,
        DotDot: 8412,
        Dstrok: 272,
        Eacute: 201,
        Ecaron: 282,
        Egrave: 200,
        Exists: 8707,
        ForAll: 8704,
        Gammad: 988,
        Gbreve: 286,
        Gcedil: 290,
        HARDcy: 1066,
        Hstrok: 294,
        Iacute: 205,
        Igrave: 204,
        Itilde: 296,
        Jsercy: 1032,
        Kcedil: 310,
        Lacute: 313,
        Lambda: 923,
        Lcaron: 317,
        Lcedil: 315,
        Lmidot: 319,
        Lstrok: 321,
        Nacute: 323,
        Ncaron: 327,
        Ncedil: 325,
        Ntilde: 209,
        Oacute: 211,
        Odblac: 336,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Otimes: 10807,
        Racute: 340,
        Rarrtl: 10518,
        Rcaron: 344,
        Rcedil: 342,
        SHCHcy: 1065,
        SOFTcy: 1068,
        Sacute: 346,
        Scaron: 352,
        Scedil: 350,
        Square: 9633,
        Subset: 8912,
        Supset: 8913,
        Tcaron: 356,
        Tcedil: 354,
        Tstrok: 358,
        Uacute: 218,
        Ubreve: 364,
        Udblac: 368,
        Ugrave: 217,
        Utilde: 360,
        Vdashl: 10982,
        Verbar: 8214,
        Vvdash: 8874,
        Yacute: 221,
        Zacute: 377,
        Zcaron: 381,
        aacute: 225,
        abreve: 259,
        agrave: 224,
        andand: 10837,
        angmsd: 8737,
        angsph: 8738,
        apacir: 10863,
        approx: 8776,
        atilde: 227,
        barvee: 8893,
        barwed: 8965,
        becaus: 8757,
        bernou: 8492,
        bigcap: 8898,
        bigcup: 8899,
        bigvee: 8897,
        bkarow: 10509,
        bottom: 8869,
        bowtie: 8904,
        boxbox: 10697,
        bprime: 8245,
        brvbar: 166,
        bullet: 8226,
        bumpeq: 8783,
        cacute: 263,
        capand: 10820,
        capcap: 10827,
        capcup: 10823,
        capdot: 10816,
        ccaron: 269,
        ccedil: 231,
        circeq: 8791,
        cirmid: 10991,
        colone: 8788,
        commat: 64,
        compfn: 8728,
        conint: 8750,
        coprod: 8720,
        copysr: 8471,
        cularr: 8630,
        cupcap: 10822,
        cupcup: 10826,
        cupdot: 8845,
        curarr: 8631,
        curren: 164,
        cylcty: 9005,
        dagger: 8224,
        daleth: 8504,
        dcaron: 271,
        dfisht: 10623,
        divide: 247,
        divonx: 8903,
        dlcorn: 8990,
        dlcrop: 8973,
        dollar: 36,
        drcorn: 8991,
        drcrop: 8972,
        dstrok: 273,
        eacute: 233,
        easter: 10862,
        ecaron: 283,
        ecolon: 8789,
        egrave: 232,
        egsdot: 10904,
        elsdot: 10903,
        emptyv: 8709,
        emsp13: 8196,
        emsp14: 8197,
        eparsl: 10723,
        eqcirc: 8790,
        equals: 61,
        equest: 8799,
        female: 9792,
        ffilig: 64259,
        ffllig: 64260,
        forall: 8704,
        frac12: 189,
        frac13: 8531,
        frac14: 188,
        frac15: 8533,
        frac16: 8537,
        frac18: 8539,
        frac23: 8532,
        frac25: 8534,
        frac34: 190,
        frac35: 8535,
        frac38: 8540,
        frac45: 8536,
        frac56: 8538,
        frac58: 8541,
        frac78: 8542,
        gacute: 501,
        gammad: 989,
        gbreve: 287,
        gesdot: 10880,
        gesles: 10900,
        gtlPar: 10645,
        gtrarr: 10616,
        gtrdot: 8919,
        gtrsim: 8819,
        hairsp: 8202,
        hamilt: 8459,
        hardcy: 1098,
        hearts: 9829,
        hellip: 8230,
        hercon: 8889,
        homtht: 8763,
        horbar: 8213,
        hslash: 8463,
        hstrok: 295,
        hybull: 8259,
        hyphen: 8208,
        iacute: 237,
        igrave: 236,
        iiiint: 10764,
        iinfin: 10716,
        incare: 8453,
        inodot: 305,
        intcal: 8890,
        iquest: 191,
        isinsv: 8947,
        itilde: 297,
        jsercy: 1112,
        kappav: 1008,
        kcedil: 311,
        kgreen: 312,
        lAtail: 10523,
        lacute: 314,
        lagran: 8466,
        lambda: 955,
        langle: 10216,
        larrfs: 10525,
        larrhk: 8617,
        larrlp: 8619,
        larrpl: 10553,
        larrtl: 8610,
        latail: 10521,
        lbrace: 123,
        lbrack: 91,
        lcaron: 318,
        lcedil: 316,
        ldquor: 8222,
        lesdot: 10879,
        lesges: 10899,
        lfisht: 10620,
        lfloor: 8970,
        lharul: 10602,
        llhard: 10603,
        lmidot: 320,
        lmoust: 9136,
        loplus: 10797,
        lowast: 8727,
        lowbar: 95,
        lparlt: 10643,
        lrhard: 10605,
        lsaquo: 8249,
        lsquor: 8218,
        lstrok: 322,
        lthree: 8907,
        ltimes: 8905,
        ltlarr: 10614,
        ltrPar: 10646,
        mapsto: 8614,
        marker: 9646,
        mcomma: 10793,
        midast: 42,
        midcir: 10992,
        middot: 183,
        minusb: 8863,
        minusd: 8760,
        mnplus: 8723,
        models: 8871,
        mstpos: 8766,
        nVDash: 8879,
        nVdash: 8878,
        nacute: 324,
        ncaron: 328,
        ncedil: 326,
        nearhk: 10532,
        nequiv: 8802,
        nesear: 10536,
        nexist: 8708,
        nltrie: 8940,
        nprcue: 8928,
        nrtrie: 8941,
        nsccue: 8929,
        nsimeq: 8772,
        ntilde: 241,
        numero: 8470,
        nvDash: 8877,
        nvHarr: 10500,
        nvdash: 8876,
        nvlArr: 10498,
        nvrArr: 10499,
        nwarhk: 10531,
        nwnear: 10535,
        oacute: 243,
        odblac: 337,
        odsold: 10684,
        ograve: 242,
        ominus: 8854,
        origof: 8886,
        oslash: 248,
        otilde: 245,
        otimes: 8855,
        parsim: 10995,
        percnt: 37,
        period: 46,
        permil: 8240,
        phmmat: 8499,
        planck: 8463,
        plankv: 8463,
        plusdo: 8724,
        plusdu: 10789,
        plusmn: 177,
        preceq: 10927,
        primes: 8473,
        prnsim: 8936,
        propto: 8733,
        prurel: 8880,
        puncsp: 8200,
        qprime: 8279,
        rAtail: 10524,
        racute: 341,
        rangle: 10217,
        rarrap: 10613,
        rarrfs: 10526,
        rarrhk: 8618,
        rarrlp: 8620,
        rarrpl: 10565,
        rarrtl: 8611,
        ratail: 10522,
        rbrace: 125,
        rbrack: 93,
        rcaron: 345,
        rcedil: 343,
        rdquor: 8221,
        rfisht: 10621,
        rfloor: 8971,
        rharul: 10604,
        rmoust: 9137,
        roplus: 10798,
        rpargt: 10644,
        rsaquo: 8250,
        rsquor: 8217,
        rthree: 8908,
        rtimes: 8906,
        sacute: 347,
        scaron: 353,
        scedil: 351,
        scnsim: 8937,
        searhk: 10533,
        seswar: 10537,
        sfrown: 8994,
        shchcy: 1097,
        sigmaf: 962,
        sigmav: 962,
        simdot: 10858,
        smashp: 10803,
        softcy: 1100,
        solbar: 9023,
        spades: 9824,
        sqsube: 8849,
        sqsupe: 8850,
        square: 9633,
        squarf: 9642,
        ssetmn: 8726,
        ssmile: 8995,
        sstarf: 8902,
        subdot: 10941,
        subset: 8834,
        subsim: 10951,
        subsub: 10965,
        subsup: 10963,
        succeq: 10928,
        supdot: 10942,
        supset: 8835,
        supsim: 10952,
        supsub: 10964,
        supsup: 10966,
        swarhk: 10534,
        swnwar: 10538,
        target: 8982,
        tcaron: 357,
        tcedil: 355,
        telrec: 8981,
        there4: 8756,
        thetav: 977,
        thinsp: 8201,
        thksim: 8764,
        timesb: 8864,
        timesd: 10800,
        topbot: 9014,
        topcir: 10993,
        tprime: 8244,
        tridot: 9708,
        tstrok: 359,
        uacute: 250,
        ubreve: 365,
        udblac: 369,
        ufisht: 10622,
        ugrave: 249,
        ulcorn: 8988,
        ulcrop: 8975,
        urcorn: 8989,
        urcrop: 8974,
        utilde: 361,
        vangrt: 10652,
        varphi: 966,
        varrho: 1009,
        veebar: 8891,
        vellip: 8942,
        verbar: 124,
        wedbar: 10847,
        wedgeq: 8793,
        weierp: 8472,
        wreath: 8768,
        xoplus: 10753,
        xotime: 10754,
        xsqcup: 10758,
        xuplus: 10756,
        xwedge: 8896,
        yacute: 253,
        zacute: 378,
        zcaron: 382,
        zeetrf: 8488,
        AElig: 198,
        Acirc: 194,
        Alpha: 913,
        Amacr: 256,
        Aogon: 260,
        Aring: 197,
        Breve: 728,
        Ccirc: 264,
        Colon: 8759,
        Cross: 10799,
        Dashv: 10980,
        Delta: 916,
        Ecirc: 202,
        Emacr: 274,
        Eogon: 280,
        Equal: 10869,
        Gamma: 915,
        Gcirc: 284,
        Hacek: 711,
        Hcirc: 292,
        IJlig: 306,
        Icirc: 206,
        Imacr: 298,
        Iogon: 302,
        Iukcy: 1030,
        Jcirc: 308,
        Jukcy: 1028,
        Kappa: 922,
        OElig: 338,
        Ocirc: 212,
        Omacr: 332,
        Omega: 937,
        Prime: 8243,
        RBarr: 10512,
        Scirc: 348,
        Sigma: 931,
        THORN: 222,
        TRADE: 8482,
        TSHcy: 1035,
        Theta: 920,
        Tilde: 8764,
        Ubrcy: 1038,
        Ucirc: 219,
        Umacr: 362,
        Union: 8899,
        Uogon: 370,
        UpTee: 8869,
        Uring: 366,
        VDash: 8875,
        Vdash: 8873,
        Wcirc: 372,
        Wedge: 8896,
        Ycirc: 374,
        acirc: 226,
        acute: 180,
        aelig: 230,
        aleph: 8501,
        alpha: 945,
        amacr: 257,
        amalg: 10815,
        angle: 8736,
        angrt: 8735,
        angst: 8491,
        aogon: 261,
        aring: 229,
        asymp: 8776,
        awint: 10769,
        bcong: 8780,
        bdquo: 8222,
        bepsi: 1014,
        blank: 9251,
        blk12: 9618,
        blk14: 9617,
        blk34: 9619,
        block: 9608,
        boxDL: 9559,
        boxDR: 9556,
        boxDl: 9558,
        boxDr: 9555,
        boxHD: 9574,
        boxHU: 9577,
        boxHd: 9572,
        boxHu: 9575,
        boxUL: 9565,
        boxUR: 9562,
        boxUl: 9564,
        boxUr: 9561,
        boxVH: 9580,
        boxVL: 9571,
        boxVR: 9568,
        boxVh: 9579,
        boxVl: 9570,
        boxVr: 9567,
        boxdL: 9557,
        boxdR: 9554,
        boxdl: 9488,
        boxdr: 9484,
        boxhD: 9573,
        boxhU: 9576,
        boxhd: 9516,
        boxhu: 9524,
        boxuL: 9563,
        boxuR: 9560,
        boxul: 9496,
        boxur: 9492,
        boxvH: 9578,
        boxvL: 9569,
        boxvR: 9566,
        boxvh: 9532,
        boxvl: 9508,
        boxvr: 9500,
        breve: 728,
        bsemi: 8271,
        bsime: 8909,
        bsolb: 10693,
        bumpE: 10926,
        bumpe: 8783,
        caret: 8257,
        caron: 711,
        ccaps: 10829,
        ccirc: 265,
        ccups: 10828,
        cedil: 184,
        check: 10003,
        clubs: 9827,
        colon: 58,
        comma: 44,
        crarr: 8629,
        cross: 10007,
        csube: 10961,
        csupe: 10962,
        ctdot: 8943,
        cuepr: 8926,
        cuesc: 8927,
        cupor: 10821,
        cuvee: 8910,
        cuwed: 8911,
        cwint: 8753,
        dashv: 8867,
        dblac: 733,
        ddarr: 8650,
        delta: 948,
        dharl: 8643,
        dharr: 8642,
        diams: 9830,
        disin: 8946,
        doteq: 8784,
        dtdot: 8945,
        dtrif: 9662,
        duarr: 8693,
        duhar: 10607,
        eDDot: 10871,
        ecirc: 234,
        efDot: 8786,
        emacr: 275,
        empty: 8709,
        eogon: 281,
        eplus: 10865,
        epsiv: 949,
        eqsim: 8770,
        equiv: 8801,
        erDot: 8787,
        erarr: 10609,
        esdot: 8784,
        exist: 8707,
        fflig: 64256,
        filig: 64257,
        fllig: 64258,
        fltns: 9649,
        forkv: 10969,
        frasl: 8260,
        frown: 8994,
        gamma: 947,
        gcirc: 285,
        gescc: 10921,
        gimel: 8503,
        gneqq: 8809,
        gnsim: 8935,
        grave: 96,
        gsime: 10894,
        gsiml: 10896,
        gtcir: 10874,
        gtdot: 8919,
        harrw: 8621,
        hcirc: 293,
        hoarr: 8703,
        icirc: 238,
        iexcl: 161,
        iiint: 8749,
        iiota: 8489,
        ijlig: 307,
        imacr: 299,
        image: 8465,
        imath: 305,
        imped: 437,
        infin: 8734,
        iogon: 303,
        iprod: 10812,
        isinE: 8953,
        isins: 8948,
        isinv: 8712,
        iukcy: 1110,
        jcirc: 309,
        jmath: 567,
        jukcy: 1108,
        kappa: 954,
        lAarr: 8666,
        lBarr: 10510,
        langd: 10641,
        laquo: 171,
        larrb: 8676,
        lbarr: 10508,
        lbbrk: 10098,
        lbrke: 10635,
        lceil: 8968,
        ldquo: 8220,
        lescc: 10920,
        lhard: 8637,
        lharu: 8636,
        lhblk: 9604,
        llarr: 8647,
        lltri: 9722,
        lneqq: 8808,
        lnsim: 8934,
        loang: 10220,
        loarr: 8701,
        lobrk: 10214,
        lopar: 10629,
        lrarr: 8646,
        lrhar: 8651,
        lrtri: 8895,
        lsime: 10893,
        lsimg: 10895,
        lsquo: 8216,
        ltcir: 10873,
        ltdot: 8918,
        ltrie: 8884,
        ltrif: 9666,
        mDDot: 8762,
        mdash: 8212,
        micro: 181,
        minus: 8722,
        mumap: 8888,
        nabla: 8711,
        napos: 329,
        natur: 9838,
        ncong: 8775,
        ndash: 8211,
        neArr: 8663,
        nearr: 8599,
        ngsim: 8821,
        nhArr: 8654,
        nharr: 8622,
        nhpar: 10994,
        nlArr: 8653,
        nlarr: 8602,
        nless: 8814,
        nlsim: 8820,
        nltri: 8938,
        notin: 8713,
        notni: 8716,
        nprec: 8832,
        nrArr: 8655,
        nrarr: 8603,
        nrtri: 8939,
        nsime: 8772,
        nsmid: 8740,
        nspar: 8742,
        nsube: 8840,
        nsucc: 8833,
        nsupe: 8841,
        numsp: 8199,
        nwArr: 8662,
        nwarr: 8598,
        ocirc: 244,
        odash: 8861,
        oelig: 339,
        ofcir: 10687,
        ohbar: 10677,
        olarr: 8634,
        olcir: 10686,
        oline: 8254,
        omacr: 333,
        omega: 969,
        operp: 10681,
        oplus: 8853,
        orarr: 8635,
        order: 8500,
        ovbar: 9021,
        parsl: 11005,
        phone: 9742,
        plusb: 8862,
        pluse: 10866,
        pound: 163,
        prcue: 8828,
        prime: 8242,
        prnap: 10937,
        prsim: 8830,
        quest: 63,
        rAarr: 8667,
        rBarr: 10511,
        radic: 8730,
        rangd: 10642,
        range: 10661,
        raquo: 187,
        rarrb: 8677,
        rarrc: 10547,
        rarrw: 8605,
        ratio: 8758,
        rbarr: 10509,
        rbbrk: 10099,
        rbrke: 10636,
        rceil: 8969,
        rdquo: 8221,
        reals: 8477,
        rhard: 8641,
        rharu: 8640,
        rlarr: 8644,
        rlhar: 8652,
        rnmid: 10990,
        roang: 10221,
        roarr: 8702,
        robrk: 10215,
        ropar: 10630,
        rrarr: 8649,
        rsquo: 8217,
        rtrie: 8885,
        rtrif: 9656,
        sbquo: 8218,
        sccue: 8829,
        scirc: 349,
        scnap: 10938,
        scsim: 8831,
        sdotb: 8865,
        sdote: 10854,
        seArr: 8664,
        searr: 8600,
        setmn: 8726,
        sharp: 9839,
        sigma: 963,
        simeq: 8771,
        simgE: 10912,
        simlE: 10911,
        simne: 8774,
        slarr: 8592,
        smile: 8995,
        sqcap: 8851,
        sqcup: 8852,
        sqsub: 8847,
        sqsup: 8848,
        srarr: 8594,
        starf: 9733,
        strns: 175,
        subnE: 10955,
        subne: 8842,
        supnE: 10956,
        supne: 8843,
        swArr: 8665,
        swarr: 8601,
        szlig: 223,
        theta: 952,
        thkap: 8776,
        thorn: 254,
        tilde: 732,
        times: 215,
        trade: 8482,
        trisb: 10701,
        tshcy: 1115,
        twixt: 8812,
        ubrcy: 1118,
        ucirc: 251,
        udarr: 8645,
        udhar: 10606,
        uharl: 8639,
        uharr: 8638,
        uhblk: 9600,
        ultri: 9720,
        umacr: 363,
        uogon: 371,
        uplus: 8846,
        upsih: 978,
        uring: 367,
        urtri: 9721,
        utdot: 8944,
        utrif: 9652,
        uuarr: 8648,
        vBarv: 10985,
        vDash: 8872,
        varpi: 982,
        vdash: 8866,
        veeeq: 8794,
        vltri: 8882,
        vprop: 8733,
        vrtri: 8883,
        wcirc: 373,
        wedge: 8743,
        xcirc: 9711,
        xdtri: 9661,
        xhArr: 10234,
        xharr: 10231,
        xlArr: 10232,
        xlarr: 10229,
        xodot: 10752,
        xrArr: 10233,
        xrarr: 10230,
        xutri: 9651,
        ycirc: 375,
        Aopf: 120120,
        Ascr: 119964,
        Auml: 196,
        Barv: 10983,
        Beta: 914,
        Bopf: 120121,
        Bscr: 8492,
        CHcy: 1063,
        COPY: 169,
        Cdot: 266,
        Copf: 8450,
        Cscr: 119966,
        DJcy: 1026,
        DScy: 1029,
        DZcy: 1039,
        Darr: 8609,
        Dopf: 120123,
        Dscr: 119967,
        Edot: 278,
        Eopf: 120124,
        Escr: 8496,
        Esim: 10867,
        Euml: 203,
        Fopf: 120125,
        Fscr: 8497,
        GJcy: 1027,
        Gdot: 288,
        Gopf: 120126,
        Gscr: 119970,
        Hopf: 8461,
        Hscr: 8459,
        IEcy: 1045,
        IOcy: 1025,
        Idot: 304,
        Iopf: 120128,
        Iota: 921,
        Iscr: 8464,
        Iuml: 207,
        Jopf: 120129,
        Jscr: 119973,
        KHcy: 1061,
        KJcy: 1036,
        Kopf: 120130,
        Kscr: 119974,
        LJcy: 1033,
        Lang: 10218,
        Larr: 8606,
        Lopf: 120131,
        Lscr: 8466,
        Mopf: 120132,
        Mscr: 8499,
        NJcy: 1034,
        Nopf: 8469,
        Nscr: 119977,
        Oopf: 120134,
        Oscr: 119978,
        Ouml: 214,
        Popf: 8473,
        Pscr: 119979,
        QUOT: 34,
        Qopf: 8474,
        Qscr: 119980,
        Rang: 10219,
        Rarr: 8608,
        Ropf: 8477,
        Rscr: 8475,
        SHcy: 1064,
        Sopf: 120138,
        Sqrt: 8730,
        Sscr: 119982,
        Star: 8902,
        TScy: 1062,
        Topf: 120139,
        Tscr: 119983,
        Uarr: 8607,
        Uopf: 120140,
        Upsi: 978,
        Uscr: 119984,
        Uuml: 220,
        Vbar: 10987,
        Vert: 8214,
        Vopf: 120141,
        Vscr: 119985,
        Wopf: 120142,
        Wscr: 119986,
        Xopf: 120143,
        Xscr: 119987,
        YAcy: 1071,
        YIcy: 1031,
        YUcy: 1070,
        Yopf: 120144,
        Yscr: 119988,
        Yuml: 376,
        ZHcy: 1046,
        Zdot: 379,
        Zeta: 918,
        Zopf: 8484,
        Zscr: 119989,
        andd: 10844,
        andv: 10842,
        ange: 10660,
        aopf: 120146,
        apid: 8779,
        apos: 39,
        ascr: 119990,
        auml: 228,
        bNot: 10989,
        bbrk: 9141,
        beta: 946,
        beth: 8502,
        bnot: 8976,
        bopf: 120147,
        boxH: 9552,
        boxV: 9553,
        boxh: 9472,
        boxv: 9474,
        bscr: 119991,
        bsim: 8765,
        bsol: 92,
        bull: 8226,
        bump: 8782,
        cdot: 267,
        cent: 162,
        chcy: 1095,
        cirE: 10691,
        circ: 710,
        cire: 8791,
        comp: 8705,
        cong: 8773,
        copf: 120148,
        copy: 169,
        cscr: 119992,
        csub: 10959,
        csup: 10960,
        dArr: 8659,
        dHar: 10597,
        darr: 8595,
        dash: 8208,
        diam: 8900,
        djcy: 1106,
        dopf: 120149,
        dscr: 119993,
        dscy: 1109,
        dsol: 10742,
        dtri: 9663,
        dzcy: 1119,
        eDot: 8785,
        ecir: 8790,
        edot: 279,
        emsp: 8195,
        ensp: 8194,
        eopf: 120150,
        epar: 8917,
        epsi: 1013,
        escr: 8495,
        esim: 8770,
        euml: 235,
        euro: 8364,
        excl: 33,
        flat: 9837,
        fnof: 402,
        fopf: 120151,
        fork: 8916,
        fscr: 119995,
        gdot: 289,
        geqq: 8807,
        gjcy: 1107,
        gnap: 10890,
        gneq: 10888,
        gopf: 120152,
        gscr: 8458,
        gsim: 8819,
        gtcc: 10919,
        hArr: 8660,
        half: 189,
        harr: 8596,
        hbar: 8463,
        hopf: 120153,
        hscr: 119997,
        iecy: 1077,
        imof: 8887,
        iocy: 1105,
        iopf: 120154,
        iota: 953,
        iscr: 119998,
        isin: 8712,
        iuml: 239,
        jopf: 120155,
        jscr: 119999,
        khcy: 1093,
        kjcy: 1116,
        kopf: 120156,
        kscr: 120000,
        lArr: 8656,
        lHar: 10594,
        lang: 10216,
        larr: 8592,
        late: 10925,
        lcub: 123,
        ldca: 10550,
        ldsh: 8626,
        leqq: 8806,
        ljcy: 1113,
        lnap: 10889,
        lneq: 10887,
        lopf: 120157,
        lozf: 10731,
        lpar: 40,
        lscr: 120001,
        lsim: 8818,
        lsqb: 91,
        ltcc: 10918,
        ltri: 9667,
        macr: 175,
        male: 9794,
        malt: 10016,
        mlcp: 10971,
        mldr: 8230,
        mopf: 120158,
        mscr: 120002,
        nbsp: 160,
        ncap: 10819,
        ncup: 10818,
        ngeq: 8817,
        ngtr: 8815,
        nisd: 8954,
        njcy: 1114,
        nldr: 8229,
        nleq: 8816,
        nmid: 8740,
        nopf: 120159,
        npar: 8742,
        nscr: 120003,
        nsim: 8769,
        nsub: 8836,
        nsup: 8837,
        ntgl: 8825,
        ntlg: 8824,
        oast: 8859,
        ocir: 8858,
        odiv: 10808,
        odot: 8857,
        ogon: 731,
        oint: 8750,
        omid: 10678,
        oopf: 120160,
        opar: 10679,
        ordf: 170,
        ordm: 186,
        oror: 10838,
        oscr: 8500,
        osol: 8856,
        ouml: 246,
        para: 182,
        part: 8706,
        perp: 8869,
        phiv: 966,
        plus: 43,
        popf: 120161,
        prap: 10935,
        prec: 8826,
        prnE: 10933,
        prod: 8719,
        prop: 8733,
        pscr: 120005,
        qint: 10764,
        qopf: 120162,
        qscr: 120006,
        quot: 34,
        rArr: 8658,
        rHar: 10596,
        race: 10714,
        rang: 10217,
        rarr: 8594,
        rcub: 125,
        rdca: 10551,
        rdsh: 8627,
        real: 8476,
        rect: 9645,
        rhov: 1009,
        ring: 730,
        ropf: 120163,
        rpar: 41,
        rscr: 120007,
        rsqb: 93,
        rtri: 9657,
        scap: 10936,
        scnE: 10934,
        sdot: 8901,
        sect: 167,
        semi: 59,
        sext: 10038,
        shcy: 1096,
        sime: 8771,
        simg: 10910,
        siml: 10909,
        smid: 8739,
        smte: 10924,
        solb: 10692,
        sopf: 120164,
        spar: 8741,
        squf: 9642,
        sscr: 120008,
        star: 9734,
        subE: 10949,
        sube: 8838,
        succ: 8827,
        sung: 9834,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        supE: 10950,
        supe: 8839,
        tbrk: 9140,
        tdot: 8411,
        tint: 8749,
        toea: 10536,
        topf: 120165,
        tosa: 10537,
        trie: 8796,
        tscr: 120009,
        tscy: 1094,
        uArr: 8657,
        uHar: 10595,
        uarr: 8593,
        uopf: 120166,
        upsi: 965,
        uscr: 120010,
        utri: 9653,
        uuml: 252,
        vArr: 8661,
        vBar: 10984,
        varr: 8597,
        vert: 124,
        vopf: 120167,
        vscr: 120011,
        wopf: 120168,
        wscr: 120012,
        xcap: 8898,
        xcup: 8899,
        xmap: 10236,
        xnis: 8955,
        xopf: 120169,
        xscr: 120013,
        xvee: 8897,
        yacy: 1103,
        yicy: 1111,
        yopf: 120170,
        yscr: 120014,
        yucy: 1102,
        yuml: 255,
        zdot: 380,
        zeta: 950,
        zhcy: 1078,
        zopf: 120171,
        zscr: 120015,
        zwnj: 8204,
        AMP: 38,
        Acy: 1040,
        Afr: 120068,
        And: 10835,
        Bcy: 1041,
        Bfr: 120069,
        Cap: 8914,
        Cfr: 8493,
        Chi: 935,
        Cup: 8915,
        Dcy: 1044,
        Del: 8711,
        Dfr: 120071,
        Dot: 168,
        ENG: 330,
        ETH: 208,
        Ecy: 1069,
        Efr: 120072,
        Eta: 919,
        Fcy: 1060,
        Ffr: 120073,
        Gcy: 1043,
        Gfr: 120074,
        Hat: 94,
        Hfr: 8460,
        Icy: 1048,
        Ifr: 8465,
        Int: 8748,
        Jcy: 1049,
        Jfr: 120077,
        Kcy: 1050,
        Kfr: 120078,
        Lcy: 1051,
        Lfr: 120079,
        Lsh: 8624,
        Map: 10501,
        Mcy: 1052,
        Mfr: 120080,
        Ncy: 1053,
        Nfr: 120081,
        Not: 10988,
        Ocy: 1054,
        Ofr: 120082,
        Pcy: 1055,
        Pfr: 120083,
        Phi: 934,
        Psi: 936,
        Qfr: 120084,
        REG: 174,
        Rcy: 1056,
        Rfr: 8476,
        Rho: 929,
        Rsh: 8625,
        Scy: 1057,
        Sfr: 120086,
        Sub: 8912,
        Sum: 8721,
        Sup: 8913,
        Tab: 9,
        Tau: 932,
        Tcy: 1058,
        Tfr: 120087,
        Ucy: 1059,
        Ufr: 120088,
        Vcy: 1042,
        Vee: 8897,
        Vfr: 120089,
        Wfr: 120090,
        Xfr: 120091,
        Ycy: 1067,
        Yfr: 120092,
        Zcy: 1047,
        Zfr: 8488,
        acd: 8767,
        acy: 1072,
        afr: 120094,
        amp: 38,
        and: 8743,
        ang: 8736,
        apE: 10864,
        ape: 8778,
        ast: 42,
        bcy: 1073,
        bfr: 120095,
        bot: 8869,
        cap: 8745,
        cfr: 120096,
        chi: 967,
        cir: 9675,
        cup: 8746,
        dcy: 1076,
        deg: 176,
        dfr: 120097,
        die: 168,
        div: 247,
        dot: 729,
        ecy: 1101,
        efr: 120098,
        egs: 10902,
        ell: 8467,
        els: 10901,
        eng: 331,
        eta: 951,
        eth: 240,
        fcy: 1092,
        ffr: 120099,
        gEl: 10892,
        gap: 10886,
        gcy: 1075,
        gel: 8923,
        geq: 8805,
        ges: 10878,
        gfr: 120100,
        ggg: 8921,
        glE: 10898,
        gla: 10917,
        glj: 10916,
        gnE: 8809,
        gne: 10888,
        hfr: 120101,
        icy: 1080,
        iff: 8660,
        ifr: 120102,
        int: 8747,
        jcy: 1081,
        jfr: 120103,
        kcy: 1082,
        kfr: 120104,
        lEg: 10891,
        lap: 10885,
        lat: 10923,
        lcy: 1083,
        leg: 8922,
        leq: 8804,
        les: 10877,
        lfr: 120105,
        lgE: 10897,
        lnE: 8808,
        lne: 10887,
        loz: 9674,
        lrm: 8206,
        lsh: 8624,
        map: 8614,
        mcy: 1084,
        mfr: 120106,
        mho: 8487,
        mid: 8739,
        nap: 8777,
        ncy: 1085,
        nfr: 120107,
        nge: 8817,
        ngt: 8815,
        nis: 8956,
        niv: 8715,
        nle: 8816,
        nlt: 8814,
        not: 172,
        npr: 8832,
        nsc: 8833,
        num: 35,
        ocy: 1086,
        ofr: 120108,
        ogt: 10689,
        ohm: 8486,
        olt: 10688,
        ord: 10845,
        orv: 10843,
        par: 8741,
        pcy: 1087,
        pfr: 120109,
        phi: 966,
        piv: 982,
        prE: 10931,
        pre: 10927,
        psi: 968,
        qfr: 120110,
        rcy: 1088,
        reg: 174,
        rfr: 120111,
        rho: 961,
        rlm: 8207,
        rsh: 8625,
        scE: 10932,
        sce: 10928,
        scy: 1089,
        sfr: 120112,
        shy: 173,
        sim: 8764,
        smt: 10922,
        sol: 47,
        squ: 9633,
        sub: 8834,
        sum: 8721,
        sup: 8835,
        tau: 964,
        tcy: 1090,
        tfr: 120113,
        top: 8868,
        ucy: 1091,
        ufr: 120114,
        uml: 168,
        vcy: 1074,
        vee: 8744,
        vfr: 120115,
        wfr: 120116,
        xfr: 120117,
        ycy: 1099,
        yen: 165,
        yfr: 120118,
        zcy: 1079,
        zfr: 120119,
        zwj: 8205,
        DD: 8517,
        GT: 62,
        Gg: 8921,
        Gt: 8811,
        Im: 8465,
        LT: 60,
        Ll: 8920,
        Lt: 8810,
        Mu: 924,
        Nu: 925,
        Or: 10836,
        Pi: 928,
        Pr: 10939,
        Re: 8476,
        Sc: 10940,
        Xi: 926,
        ac: 8766,
        af: 8289,
        ap: 8776,
        dd: 8518,
        ee: 8519,
        eg: 10906,
        el: 10905,
        gE: 8807,
        ge: 8805,
        gg: 8811,
        gl: 8823,
        gt: 62,
        ic: 8291,
        ii: 8520,
        in: 8712,
        it: 8290,
        lE: 8806,
        le: 8804,
        lg: 8822,
        ll: 8810,
        lt: 60,
        mp: 8723,
        mu: 956,
        ne: 8800,
        ni: 8715,
        nu: 957,
        oS: 9416,
        or: 8744,
        pi: 960,
        pm: 177,
        pr: 8826,
        rx: 8478,
        sc: 8827,
        wp: 8472,
        wr: 8768,
        xi: 958
    };
    const windows_1252 = [
        8364,
        129,
        8218,
        402,
        8222,
        8230,
        8224,
        8225,
        710,
        8240,
        352,
        8249,
        338,
        141,
        381,
        143,
        144,
        8216,
        8217,
        8220,
        8221,
        8226,
        8211,
        8212,
        732,
        8482,
        353,
        8250,
        339,
        157,
        382,
        376
    ];
    const entity_pattern = new RegExp(`&(#?(?:x[\\w\\d]+|\\d+|${Object.keys(entities).join("|")}))(?:;|\\b)`, "g");
    function decode_character_references(html) {
        return html.replace(entity_pattern, (match, entity)=>{
            let code;
            // Handle named entities
            if (entity[0] !== "#") code = entities[entity];
            else if (entity[1] === "x") code = parseInt(entity.substring(2), 16);
            else code = parseInt(entity.substring(1), 10);
            if (!code) return match;
            return String.fromCodePoint(validate_code(code));
        });
    }
    const NUL = 0;
    // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
    // code points with alternatives in some cases - since we're bypassing that mechanism, we need
    // to replace them ourselves
    //
    // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
    function validate_code(code) {
        // line feed becomes generic whitespace
        if (code === 10) return 32;
        // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
        if (code < 128) return code;
        // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
        // to correct the mistake or we'll end up with missing € signs and so on
        if (code <= 159) return windows_1252[code - 128];
        // basic multilingual plane
        if (code < 55296) return code;
        // UTF-16 surrogate halves
        if (code <= 57343) return NUL;
        // rest of the basic multilingual plane
        if (code <= 65535) return code;
        // supplementary multilingual plane 0x10000 - 0x1ffff
        if (code >= 65536 && code <= 131071) return code;
        // supplementary ideographic plane 0x20000 - 0x2ffff
        if (code >= 131072 && code <= 196607) return code;
        return NUL;
    }
    // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
    const disallowed_contents = new Map([
        [
            "li",
            new Set([
                "li"
            ])
        ],
        [
            "dt",
            new Set([
                "dt",
                "dd"
            ])
        ],
        [
            "dd",
            new Set([
                "dt",
                "dd"
            ])
        ],
        [
            "p",
            new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
        ],
        [
            "rt",
            new Set([
                "rt",
                "rp"
            ])
        ],
        [
            "rp",
            new Set([
                "rt",
                "rp"
            ])
        ],
        [
            "optgroup",
            new Set([
                "optgroup"
            ])
        ],
        [
            "option",
            new Set([
                "option",
                "optgroup"
            ])
        ],
        [
            "thead",
            new Set([
                "tbody",
                "tfoot"
            ])
        ],
        [
            "tbody",
            new Set([
                "tbody",
                "tfoot"
            ])
        ],
        [
            "tfoot",
            new Set([
                "tbody"
            ])
        ],
        [
            "tr",
            new Set([
                "tr",
                "tbody"
            ])
        ],
        [
            "td",
            new Set([
                "td",
                "th",
                "tr"
            ])
        ],
        [
            "th",
            new Set([
                "td",
                "th",
                "tr"
            ])
        ]
    ]);
    // can this be a child of the parent element, or does it implicitly
    // close it, like `<li>one<li>two`?
    function closing_tag_omitted(current, next) {
        if (disallowed_contents.has(current)) {
            if (!next || disallowed_contents.get(current).has(next)) return true;
        }
        return false;
    }
    // eslint-disable-next-line no-useless-escape
    const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
    const meta_tags = new Map([
        [
            "svelte:head",
            "Head"
        ],
        [
            "svelte:options",
            "Options"
        ],
        [
            "svelte:window",
            "Window"
        ],
        [
            "svelte:body",
            "Body"
        ]
    ]);
    const valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment", "svelte:element");
    const specials = new Map([
        [
            "script",
            {
                read: read_script,
                property: "js"
            }
        ],
        [
            "style",
            {
                read: read_style,
                property: "css"
            }
        ]
    ]);
    const SELF = /^svelte:self(?=[\s/>])/;
    const COMPONENT = /^svelte:component(?=[\s/>])/;
    const SLOT = /^svelte:fragment(?=[\s/>])/;
    const ELEMENT = /^svelte:element(?=[\s/>])/;
    function parent_is_head(stack) {
        let i = stack.length;
        while(i--){
            const { type: type } = stack[i];
            if (type === "Head") return true;
            if (type === "Element" || type === "InlineComponent") return false;
        }
        return false;
    }
    const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
    const regex_closing_comment = /-->/;
    const regex_capital_letter = /[A-Z]/;
    function tag(parser) {
        const start = parser.index++;
        let parent = parser.current();
        if (parser.eat("!--")) {
            const data = parser.read_until(regex_closing_comment);
            parser.eat("-->", true, parser_errors.unclosed_comment);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "Comment",
                data: data,
                ignores: extract_svelte_ignore(data)
            });
            return;
        }
        const is_closing_tag = parser.eat("/");
        const name = read_tag_name(parser);
        if (meta_tags.has(name)) {
            const slug = meta_tags.get(name).toLowerCase();
            if (is_closing_tag) {
                if ((name === "svelte:window" || name === "svelte:body") && parser.current().children.length) parser.error(parser_errors.invalid_element_content(slug, name), parser.current().children[0].start);
            } else {
                if (name in parser.meta_tags) parser.error(parser_errors.duplicate_element(slug, name), start);
                if (parser.stack.length > 1) parser.error(parser_errors.invalid_element_placement(slug, name), start);
                parser.meta_tags[name] = true;
            }
        }
        const type = meta_tags.has(name) ? meta_tags.get(name) : regex_capital_letter.test(name[0]) || name === "svelte:self" || name === "svelte:component" ? "InlineComponent" : name === "svelte:fragment" ? "SlotTemplate" : name === "title" && parent_is_head(parser.stack) ? "Title" : name === "slot" && !parser.customElement ? "Slot" : "Element";
        const element = {
            start: start,
            end: null,
            type: type,
            name: name,
            attributes: [],
            children: []
        };
        parser.allow_whitespace();
        if (is_closing_tag) {
            if (is_void(name)) parser.error(parser_errors.invalid_void_content(name), start);
            parser.eat(">", true);
            // close any elements that don't have their own closing tags, e.g. <div><p></div>
            while(parent.name !== name){
                if (parent.type !== "Element") {
                    const error = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name ? parser_errors.invalid_closing_tag_autoclosed(name, parser.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name);
                    parser.error(error, start);
                }
                parent.end = start;
                parser.stack.pop();
                parent = parser.current();
            }
            parent.end = parser.index;
            parser.stack.pop();
            if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) parser.last_auto_closed_tag = null;
            return;
        } else if (closing_tag_omitted(parent.name, name)) {
            parent.end = start;
            parser.stack.pop();
            parser.last_auto_closed_tag = {
                tag: parent.name,
                reason: name,
                depth: parser.stack.length
            };
        }
        const unique_names = new Set();
        let attribute;
        while(attribute = read_attribute(parser, unique_names)){
            element.attributes.push(attribute);
            parser.allow_whitespace();
        }
        if (name === "svelte:component") {
            const index = element.attributes.findIndex((attr)=>attr.type === "Attribute" && attr.name === "this");
            if (index === -1) parser.error(parser_errors.missing_component_definition, start);
            const definition = element.attributes.splice(index, 1)[0];
            if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") parser.error(parser_errors.invalid_component_definition, definition.start);
            element.expression = definition.value[0].expression;
        }
        if (name === "svelte:element") {
            const index = element.attributes.findIndex((attr)=>attr.type === "Attribute" && attr.name === "this");
            if (index === -1) parser.error(parser_errors.missing_element_definition, start);
            const definition = element.attributes.splice(index, 1)[0];
            if (definition.value === true) parser.error(parser_errors.invalid_element_definition, definition.start);
            element.tag = definition.value[0].data || definition.value[0].expression;
        }
        // special cases – top-level <script> and <style>
        if (specials.has(name) && parser.stack.length === 1) {
            const special = specials.get(name);
            parser.eat(">", true);
            const content = special.read(parser, start, element.attributes);
            if (content) parser[special.property].push(content);
            return;
        }
        parser.current().children.push(element);
        const self_closing = parser.eat("/") || is_void(name);
        parser.eat(">", true);
        if (self_closing) // don't push self-closing elements onto the stack
        element.end = parser.index;
        else if (name === "textarea") {
            // special case
            element.children = read_sequence(parser, ()=>regex_closing_textarea_tag.test(parser.template.slice(parser.index)), "inside <textarea>");
            parser.read(regex_closing_textarea_tag);
            element.end = parser.index;
        } else if (name === "script" || name === "style") {
            // special case
            const start = parser.index;
            const data = parser.read_until(new RegExp(`</${name}>`));
            const end = parser.index;
            element.children.push({
                start: start,
                end: end,
                type: "Text",
                data: data
            });
            parser.eat(`</${name}>`, true);
            element.end = parser.index;
        } else parser.stack.push(element);
    }
    const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
    function read_tag_name(parser) {
        const start = parser.index;
        if (parser.read(SELF)) {
            // check we're inside a block, otherwise this
            // will cause infinite recursion
            let i = parser.stack.length;
            let legal = false;
            while(i--){
                const fragment = parser.stack[i];
                if (fragment.type === "IfBlock" || fragment.type === "EachBlock" || fragment.type === "InlineComponent") {
                    legal = true;
                    break;
                }
            }
            if (!legal) parser.error(parser_errors.invalid_self_placement, start);
            return "svelte:self";
        }
        if (parser.read(COMPONENT)) return "svelte:component";
        if (parser.read(ELEMENT)) return "svelte:element";
        if (parser.read(SLOT)) return "svelte:fragment";
        const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
        if (meta_tags.has(name)) return name;
        if (name.startsWith("svelte:")) {
            const match = fuzzymatch(name.slice(7), valid_meta_tags);
            parser.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
        }
        if (!valid_tag_name.test(name)) parser.error(parser_errors.invalid_tag_name, start);
        return name;
    }
    // eslint-disable-next-line no-useless-escape
    const regex_token_ending_character = /[\s=\/>"']/;
    const regex_quote_characters = /["']/;
    function read_attribute(parser, unique_names) {
        const start = parser.index;
        function check_unique(name) {
            if (unique_names.has(name)) parser.error(parser_errors.duplicate_attribute, start);
            unique_names.add(name);
        }
        if (parser.eat("{")) {
            parser.allow_whitespace();
            if (parser.eat("...")) {
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                return {
                    start: start,
                    end: parser.index,
                    type: "Spread",
                    expression: expression
                };
            } else {
                const value_start = parser.index;
                const name = parser.read_identifier();
                parser.allow_whitespace();
                parser.eat("}", true);
                if (name === null) parser.error(parser_errors.empty_attribute_shorthand, start);
                check_unique(name);
                return {
                    start: start,
                    end: parser.index,
                    type: "Attribute",
                    name: name,
                    value: [
                        {
                            start: value_start,
                            end: value_start + name.length,
                            type: "AttributeShorthand",
                            expression: {
                                start: value_start,
                                end: value_start + name.length,
                                type: "Identifier",
                                name: name
                            }
                        }
                    ]
                };
            }
        }
        const name = parser.read_until(regex_token_ending_character);
        if (!name) return null;
        let end = parser.index;
        parser.allow_whitespace();
        const colon_index = name.indexOf(":");
        const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
        let value = true;
        if (parser.eat("=")) {
            parser.allow_whitespace();
            value = read_attribute_value(parser);
            end = parser.index;
        } else if (parser.match_regex(regex_quote_characters)) parser.error(parser_errors.unexpected_token("="), parser.index);
        if (type) {
            const [directive_name, ...modifiers] = name.slice(colon_index + 1).split("|");
            if (directive_name === "") parser.error(parser_errors.empty_directive_name(type), start + colon_index + 1);
            if (type === "Binding" && directive_name !== "this") check_unique(directive_name);
            else if (type !== "EventHandler" && type !== "Action") check_unique(name);
            if (type === "Ref") parser.error(parser_errors.invalid_ref_directive(directive_name), start);
            if (type === "StyleDirective") return {
                start: start,
                end: end,
                type: type,
                name: directive_name,
                modifiers: modifiers,
                value: value
            };
            const first_value = value[0];
            let expression = null;
            if (first_value) {
                const attribute_contains_text = value.length > 1 || first_value.type === "Text";
                if (attribute_contains_text) parser.error(parser_errors.invalid_directive_value, first_value.start);
                else expression = first_value.expression;
            }
            const directive = {
                start: start,
                end: end,
                type: type,
                name: directive_name,
                modifiers: modifiers,
                expression: expression
            };
            if (type === "Transition") {
                const direction = name.slice(0, colon_index);
                directive.intro = direction === "in" || direction === "transition";
                directive.outro = direction === "out" || direction === "transition";
            }
            // Directive name is expression, e.g. <p class:isRed />
            if (!directive.expression && (type === "Binding" || type === "Class")) directive.expression = {
                start: directive.start + colon_index + 1,
                end: directive.end,
                type: "Identifier",
                name: directive.name
            };
            return directive;
        }
        check_unique(name);
        return {
            start: start,
            end: end,
            type: "Attribute",
            name: name,
            value: value
        };
    }
    function get_directive_type(name) {
        if (name === "use") return "Action";
        if (name === "animate") return "Animation";
        if (name === "bind") return "Binding";
        if (name === "class") return "Class";
        if (name === "style") return "StyleDirective";
        if (name === "on") return "EventHandler";
        if (name === "let") return "Let";
        if (name === "ref") return "Ref";
        if (name === "in" || name === "out" || name === "transition") return "Transition";
    }
    function read_attribute_value(parser) {
        const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
        if (quote_mark && parser.eat(quote_mark)) return [
            {
                start: parser.index - 1,
                end: parser.index - 1,
                type: "Text",
                raw: "",
                data: ""
            }
        ];
        const regex = quote_mark === "'" ? /'/ : quote_mark === '"' ? /"/ : /(\/>|[\s"'=<>`])/;
        let value;
        try {
            value = read_sequence(parser, ()=>!!parser.match_regex(regex), "in attribute value");
        } catch (error) {
            if (error.code === "parse-error") // if the attribute value didn't close + self-closing tag
            // eg: `<Component test={{a:1} />`
            // acorn may throw a `Unterminated regular expression` because of `/>`
            {
                if (parser.template.slice(error.pos - 1, error.pos + 1) === "/>") {
                    parser.index = error.pos;
                    parser.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
                }
            }
            throw error;
        }
        if (value.length === 0 && !quote_mark) parser.error(parser_errors.missing_attribute_value);
        if (quote_mark) parser.index += 1;
        return value;
    }
    function read_sequence(parser, done, location) {
        let current_chunk = {
            start: parser.index,
            end: null,
            type: "Text",
            raw: "",
            data: null
        };
        const chunks = [];
        function flush(end) {
            if (current_chunk.raw) {
                current_chunk.data = decode_character_references(current_chunk.raw);
                current_chunk.end = end;
                chunks.push(current_chunk);
            }
        }
        while(parser.index < parser.template.length){
            const index = parser.index;
            if (done()) {
                flush(parser.index);
                return chunks;
            } else if (parser.eat("{")) {
                if (parser.match("#")) {
                    const index = parser.index - 1;
                    parser.eat("#");
                    const name = parser.read_until(/[^a-z]/);
                    parser.error(parser_errors.invalid_logic_block_placement(location, name), index);
                } else if (parser.match("@")) {
                    const index = parser.index - 1;
                    parser.eat("@");
                    const name = parser.read_until(/[^a-z]/);
                    parser.error(parser_errors.invalid_tag_placement(location, name), index);
                }
                flush(parser.index - 1);
                parser.allow_whitespace();
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                chunks.push({
                    start: index,
                    end: parser.index,
                    type: "MustacheTag",
                    expression: expression
                });
                current_chunk = {
                    start: parser.index,
                    end: null,
                    type: "Text",
                    raw: "",
                    data: null
                };
            } else current_chunk.raw += parser.template[parser.index++];
        }
        parser.error(parser_errors.unexpected_eof);
    }
    // Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
    // Reproduced under MIT License https://github.com/acornjs/acorn/blob/master/LICENSE
    function full_char_code_at(str, i) {
        const code = str.charCodeAt(i);
        if (code <= 0xd7ff || code >= 0xe000) return code;
        const next = str.charCodeAt(i + 1);
        return (code << 10) + next - 0x35fdc00;
    }
    const SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
    const SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
    const CURLY_BRACKET_OPEN = "{".charCodeAt(0);
    const CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
    function is_bracket_open(code) {
        return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
    }
    function is_bracket_close(code) {
        return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
    }
    function is_bracket_pair(open, close) {
        return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
    }
    function get_bracket_close(open) {
        if (open === SQUARE_BRACKET_OPEN) return SQUARE_BRACKET_CLOSE;
        if (open === CURLY_BRACKET_OPEN) return CURLY_BRACKET_CLOSE;
    }
    function read_context(parser) {
        const start = parser.index;
        let i = parser.index;
        const code = full_char_code_at(parser.template, i);
        if (isIdentifierStart(code, true)) return {
            type: "Identifier",
            name: parser.read_identifier(),
            start: start,
            end: parser.index
        };
        if (!is_bracket_open(code)) parser.error(parser_errors.unexpected_token_destructure);
        const bracket_stack = [
            code
        ];
        i += code <= 0xffff ? 1 : 2;
        while(i < parser.template.length){
            const code = full_char_code_at(parser.template, i);
            if (is_bracket_open(code)) bracket_stack.push(code);
            else if (is_bracket_close(code)) {
                if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code)) parser.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
                bracket_stack.pop();
                if (bracket_stack.length === 0) {
                    i += code <= 0xffff ? 1 : 2;
                    break;
                }
            }
            i += code <= 0xffff ? 1 : 2;
        }
        parser.index = i;
        const pattern_string = parser.template.slice(start, i);
        try {
            // the length of the `space_with_newline` has to be start - 1
            // because we added a `(` in front of the pattern_string,
            // which shifted the entire string to right by 1
            // so we offset it by removing 1 character in the `space_with_newline`
            // to achieve that, we remove the 1st space encountered,
            // so it will not affect the `column` of the node
            let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
            const first_space = space_with_newline.indexOf(" ");
            space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
            return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
        } catch (error) {
            parser.acorn_error(error);
        }
    }
    function trim_start(str) {
        return str.replace(regex_starts_with_whitespaces, "");
    }
    function trim_end(str) {
        return str.replace(regex_ends_with_whitespaces, "");
    }
    function to_string(node) {
        switch(node.type){
            case "IfBlock":
                return "{#if} block";
            case "ThenBlock":
                return "{:then} block";
            case "ElseBlock":
                return "{:else} block";
            case "PendingBlock":
            case "AwaitBlock":
                return "{#await} block";
            case "CatchBlock":
                return "{:catch} block";
            case "EachBlock":
                return "{#each} block";
            case "RawMustacheTag":
                return "{@html} block";
            case "DebugTag":
                return "{@debug} block";
            case "ConstTag":
                return "{@const} tag";
            case "Element":
            case "InlineComponent":
            case "Slot":
            case "Title":
                return `<${node.name}> tag`;
            default:
                return node.type;
        }
    }
    function trim_whitespace(block, trim_before, trim_after) {
        if (!block.children || block.children.length === 0) return; // AwaitBlock
        const first_child = block.children[0];
        const last_child = block.children[block.children.length - 1];
        if (first_child.type === "Text" && trim_before) {
            first_child.data = trim_start(first_child.data);
            if (!first_child.data) block.children.shift();
        }
        if (last_child.type === "Text" && trim_after) {
            last_child.data = trim_end(last_child.data);
            if (!last_child.data) block.children.pop();
        }
        if (block.else) trim_whitespace(block.else, trim_before, trim_after);
        if (first_child.elseif) trim_whitespace(first_child, trim_before, trim_after);
    }
    const regex_whitespace_with_closing_curly_brace = /\s*}/;
    function mustache(parser) {
        const start = parser.index;
        parser.index += 1;
        parser.allow_whitespace();
        // {/if}, {/each}, {/await} or {/key}
        if (parser.eat("/")) {
            let block = parser.current();
            let expected;
            if (closing_tag_omitted(block.name)) {
                block.end = start;
                parser.stack.pop();
                block = parser.current();
            }
            if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
                block.end = start;
                parser.stack.pop();
                block = parser.current();
                expected = "await";
            }
            if (block.type === "IfBlock") expected = "if";
            else if (block.type === "EachBlock") expected = "each";
            else if (block.type === "AwaitBlock") expected = "await";
            else if (block.type === "KeyBlock") expected = "key";
            else parser.error(parser_errors.unexpected_block_close);
            parser.eat(expected, true);
            parser.allow_whitespace();
            parser.eat("}", true);
            while(block.elseif){
                block.end = parser.index;
                parser.stack.pop();
                block = parser.current();
                if (block.else) block.else.end = start;
            }
            // strip leading/trailing whitespace as necessary
            const char_before = parser.template[block.start - 1];
            const char_after = parser.template[parser.index];
            const trim_before = !char_before || regex_whitespace.test(char_before);
            const trim_after = !char_after || regex_whitespace.test(char_after);
            trim_whitespace(block, trim_before, trim_after);
            block.end = parser.index;
            parser.stack.pop();
        } else if (parser.eat(":else")) {
            if (parser.eat("if")) parser.error(parser_errors.invalid_elseif);
            parser.allow_whitespace();
            // :else if
            if (parser.eat("if")) {
                const block = parser.current();
                if (block.type !== "IfBlock") parser.error(parser.stack.some((block)=>block.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block)) : parser_errors.invalid_elseif_placement_outside_if);
                parser.require_whitespace();
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                block.else = {
                    start: parser.index,
                    end: null,
                    type: "ElseBlock",
                    children: [
                        {
                            start: parser.index,
                            end: null,
                            type: "IfBlock",
                            elseif: true,
                            expression: expression,
                            children: []
                        }
                    ]
                };
                parser.stack.push(block.else.children[0]);
            } else {
                // :else
                const block = parser.current();
                if (block.type !== "IfBlock" && block.type !== "EachBlock") parser.error(parser.stack.some((block)=>block.type === "IfBlock" || block.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string(block)) : parser_errors.invalid_else_placement_outside_if);
                parser.allow_whitespace();
                parser.eat("}", true);
                block.else = {
                    start: parser.index,
                    end: null,
                    type: "ElseBlock",
                    children: []
                };
                parser.stack.push(block.else);
            }
        } else if (parser.match(":then") || parser.match(":catch")) {
            const block = parser.current();
            const is_then = parser.eat(":then") || !parser.eat(":catch");
            if (is_then) {
                if (block.type !== "PendingBlock") parser.error(parser.stack.some((block)=>block.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string(block)) : parser_errors.invalid_then_placement_without_await);
            } else if (block.type !== "ThenBlock" && block.type !== "PendingBlock") parser.error(parser.stack.some((block)=>block.type === "ThenBlock" || block.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string(block)) : parser_errors.invalid_catch_placement_without_await);
            block.end = start;
            parser.stack.pop();
            const await_block = parser.current();
            if (!parser.eat("}")) {
                parser.require_whitespace();
                await_block[is_then ? "value" : "error"] = read_context(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
            }
            const new_block = {
                start: start,
                end: null,
                type: is_then ? "ThenBlock" : "CatchBlock",
                children: [],
                skip: false
            };
            await_block[is_then ? "then" : "catch"] = new_block;
            parser.stack.push(new_block);
        } else if (parser.eat("#")) {
            // {#if foo}, {#each foo} or {#await foo}
            let type;
            if (parser.eat("if")) type = "IfBlock";
            else if (parser.eat("each")) type = "EachBlock";
            else if (parser.eat("await")) type = "AwaitBlock";
            else if (parser.eat("key")) type = "KeyBlock";
            else parser.error(parser_errors.expected_block_type);
            parser.require_whitespace();
            const expression = read_expression(parser);
            const block = type === "AwaitBlock" ? {
                start: start,
                end: null,
                type: type,
                expression: expression,
                value: null,
                error: null,
                pending: {
                    start: null,
                    end: null,
                    type: "PendingBlock",
                    children: [],
                    skip: true
                },
                then: {
                    start: null,
                    end: null,
                    type: "ThenBlock",
                    children: [],
                    skip: true
                },
                catch: {
                    start: null,
                    end: null,
                    type: "CatchBlock",
                    children: [],
                    skip: true
                }
            } : {
                start: start,
                end: null,
                type: type,
                expression: expression,
                children: []
            };
            parser.allow_whitespace();
            // {#each} blocks must declare a context – {#each list as item}
            if (type === "EachBlock") {
                parser.eat("as", true);
                parser.require_whitespace();
                block.context = read_context(parser);
                parser.allow_whitespace();
                if (parser.eat(",")) {
                    parser.allow_whitespace();
                    block.index = parser.read_identifier();
                    if (!block.index) parser.error(parser_errors.expected_name);
                    parser.allow_whitespace();
                }
                if (parser.eat("(")) {
                    parser.allow_whitespace();
                    block.key = read_expression(parser);
                    parser.allow_whitespace();
                    parser.eat(")", true);
                    parser.allow_whitespace();
                }
            }
            const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
            if (await_block_shorthand) {
                if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) parser.allow_whitespace();
                else {
                    parser.require_whitespace();
                    block.value = read_context(parser);
                    parser.allow_whitespace();
                }
            }
            const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
            if (await_block_catch_shorthand) {
                if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) parser.allow_whitespace();
                else {
                    parser.require_whitespace();
                    block.error = read_context(parser);
                    parser.allow_whitespace();
                }
            }
            parser.eat("}", true);
            parser.current().children.push(block);
            parser.stack.push(block);
            if (type === "AwaitBlock") {
                let child_block;
                if (await_block_shorthand) {
                    block.then.skip = false;
                    child_block = block.then;
                } else if (await_block_catch_shorthand) {
                    block.catch.skip = false;
                    child_block = block.catch;
                } else {
                    block.pending.skip = false;
                    child_block = block.pending;
                }
                child_block.start = parser.index;
                parser.stack.push(child_block);
            }
        } else if (parser.eat("@html")) {
            // {@html content} tag
            parser.require_whitespace();
            const expression = read_expression(parser);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "RawMustacheTag",
                expression: expression
            });
        } else if (parser.eat("@debug")) {
            let identifiers;
            // Implies {@debug} which indicates "debug all"
            if (parser.read(regex_whitespace_with_closing_curly_brace)) identifiers = [];
            else {
                const expression = read_expression(parser);
                identifiers = expression.type === "SequenceExpression" ? expression.expressions : [
                    expression
                ];
                identifiers.forEach((node)=>{
                    if (node.type !== "Identifier") parser.error(parser_errors.invalid_debug_args, node.start);
                });
                parser.allow_whitespace();
                parser.eat("}", true);
            }
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "DebugTag",
                identifiers: identifiers
            });
        } else if (parser.eat("@const")) {
            // {@const a = b}
            parser.require_whitespace();
            const expression = read_expression(parser);
            if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) parser.error({
                code: "invalid-const-args",
                message: "{@const ...} must be an assignment."
            }, start);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "ConstTag",
                expression: expression
            });
        } else {
            const expression = read_expression(parser);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "MustacheTag",
                expression: expression
            });
        }
    }
    function text(parser) {
        const start = parser.index;
        let data = "";
        while(parser.index < parser.template.length && !parser.match("<") && !parser.match("{"))data += parser.template[parser.index++];
        const node = {
            start: start,
            end: parser.index,
            type: "Text",
            raw: data,
            data: decode_character_references(data)
        };
        parser.current().children.push(node);
    }
    function fragment(parser) {
        if (parser.match("<")) return tag;
        if (parser.match("{")) return mustache;
        return text;
    }
    const reserved = new Set([
        "arguments",
        "await",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "eval",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "implements",
        "import",
        "in",
        "instanceof",
        "interface",
        "let",
        "new",
        "null",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "static",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
    ]);
    function is_valid(str) {
        let i = 0;
        while(i < str.length){
            const code = full_char_code_at(str, i);
            if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code, true)) return false;
            i += code <= 0xffff ? 1 : 2;
        }
        return true;
    }
    const regex_non_standard_characters = /[^a-zA-Z0-9_]+/g;
    const regex_starts_with_number = /^[0-9]/;
    function sanitize(name) {
        return name.replace(regex_non_standard_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_number, "_$&");
    }
    function getLocator(source, options) {
        if (options === void 0) options = {};
        var offsetLine = options.offsetLine || 0;
        var offsetColumn = options.offsetColumn || 0;
        var originalLines = source.split("\n");
        var start = 0;
        var lineRanges = originalLines.map(function(line, i) {
            var end = start + line.length + 1;
            var range = {
                start: start,
                end: end,
                line: i
            };
            start = end;
            return range;
        });
        var i = 0;
        function rangeContains(range, index) {
            return range.start <= index && index < range.end;
        }
        function getLocation(range, index) {
            return {
                line: offsetLine + range.line,
                column: offsetColumn + index - range.start,
                character: index
            };
        }
        function locate(search, startIndex) {
            if (typeof search === "string") search = source.indexOf(search, startIndex || 0);
            var range = lineRanges[i];
            var d = search >= range.end ? 1 : -1;
            while(range){
                if (rangeContains(range, search)) return getLocation(range, search);
                i += d;
                range = lineRanges[i];
            }
        }
        return locate;
    }
    function locate(source, search, options) {
        if (typeof options === "number") throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
        return getLocator(source, options)(search, options && options.startIndex);
    }
    const regex_tabs = /^\t+/;
    function tabs_to_spaces(str) {
        return str.replace(regex_tabs, (match)=>match.split("	").join("  "));
    }
    function get_code_frame(source, line, column) {
        const lines = source.split("\n");
        const frame_start = Math.max(0, line - 2);
        const frame_end = Math.min(line + 3, lines.length);
        const digits = String(frame_end + 1).length;
        return lines.slice(frame_start, frame_end).map((str, i)=>{
            const isErrorLine = frame_start + i === line;
            const line_num = String(i + frame_start + 1).padStart(digits, " ");
            if (isErrorLine) {
                const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
                return `${line_num}: ${tabs_to_spaces(str)}\n${indicator}`;
            }
            return `${line_num}: ${tabs_to_spaces(str)}`;
        }).join("\n");
    }
    class CompileError extends Error {
        toString() {
            return `${this.message} (${this.start.line}:${this.start.column})\n${this.frame}`;
        }
    }
    function error(message, props) {
        const error = new CompileError(message);
        error.name = props.name;
        const start = locate(props.source, props.start, {
            offsetLine: 1
        });
        const end = locate(props.source, props.end || props.start, {
            offsetLine: 1
        });
        error.code = props.code;
        error.start = start;
        error.end = end;
        error.pos = props.start;
        error.filename = props.filename;
        error.frame = get_code_frame(props.source, start.line - 1, start.column);
        throw error;
    }
    const regex_position_indicator = / \(\d+:\d+\)$/;
    class Parser$1 {
        constructor(template, options){
            this.index = 0;
            this.stack = [];
            this.css = [];
            this.js = [];
            this.meta_tags = {};
            if (typeof template !== "string") throw new TypeError("Template must be a string");
            this.template = template.trimRight();
            this.filename = options.filename;
            this.customElement = options.customElement;
            this.css_mode = options.css;
            this.html = {
                start: null,
                end: null,
                type: "Fragment",
                children: []
            };
            this.stack.push(this.html);
            let state = fragment;
            while(this.index < this.template.length)state = state(this) || fragment;
            if (this.stack.length > 1) {
                const current = this.current();
                const type = current.type === "Element" ? `<${current.name}>` : "Block";
                const slug = current.type === "Element" ? "element" : "block";
                this.error({
                    code: `unclosed-${slug}`,
                    message: `${type} was left open`
                }, current.start);
            }
            if (state !== fragment) this.error({
                code: "unexpected-eof",
                message: "Unexpected end of input"
            });
            if (this.html.children.length) {
                let start = this.html.children[0].start;
                while(regex_whitespace.test(template[start]))start += 1;
                let end = this.html.children[this.html.children.length - 1].end;
                while(regex_whitespace.test(template[end - 1]))end -= 1;
                this.html.start = start;
                this.html.end = end;
            } else this.html.start = this.html.end = null;
        }
        current() {
            return this.stack[this.stack.length - 1];
        }
        acorn_error(err) {
            this.error({
                code: "parse-error",
                message: err.message.replace(regex_position_indicator, "")
            }, err.pos);
        }
        error({ code: code, message: message }, index = this.index) {
            error(message, {
                name: "ParseError",
                code: code,
                source: this.template,
                start: index,
                filename: this.filename
            });
        }
        eat(str, required, error) {
            if (this.match(str)) {
                this.index += str.length;
                return true;
            }
            if (required) this.error(error || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str) : parser_errors.unexpected_token(str)));
            return false;
        }
        match(str) {
            return this.template.slice(this.index, this.index + str.length) === str;
        }
        match_regex(pattern) {
            const match = pattern.exec(this.template.slice(this.index));
            if (!match || match.index !== 0) return null;
            return match[0];
        }
        allow_whitespace() {
            while(this.index < this.template.length && regex_whitespace.test(this.template[this.index]))this.index++;
        }
        read(pattern) {
            const result = this.match_regex(pattern);
            if (result) this.index += result.length;
            return result;
        }
        read_identifier(allow_reserved = false) {
            const start = this.index;
            let i = this.index;
            const code = full_char_code_at(this.template, i);
            if (!isIdentifierStart(code, true)) return null;
            i += code <= 0xffff ? 1 : 2;
            while(i < this.template.length){
                const code = full_char_code_at(this.template, i);
                if (!isIdentifierChar(code, true)) break;
                i += code <= 0xffff ? 1 : 2;
            }
            const identifier = this.template.slice(this.index, this.index = i);
            if (!allow_reserved && reserved.has(identifier)) this.error({
                code: "unexpected-reserved-word",
                message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
            }, start);
            return identifier;
        }
        read_until(pattern, error_message) {
            if (this.index >= this.template.length) this.error(error_message || {
                code: "unexpected-eof",
                message: "Unexpected end of input"
            });
            const start = this.index;
            const match = pattern.exec(this.template.slice(start));
            if (match) {
                this.index = start + match.index;
                return this.template.slice(start, this.index);
            }
            this.index = this.template.length;
            return this.template.slice(start);
        }
        require_whitespace() {
            if (!regex_whitespace.test(this.template[this.index])) this.error({
                code: "missing-whitespace",
                message: "Expected whitespace"
            });
            this.allow_whitespace();
        }
    }
    function parse$I(template, options = {}) {
        const parser = new Parser$1(template, options);
        // TODO we may want to allow multiple <style> tags —
        // one scoped, one global. for now, only allow one
        if (parser.css.length > 1) parser.error(parser_errors.duplicate_style, parser.css[1].start);
        const instance_scripts = parser.js.filter((script)=>script.context === "default");
        const module_scripts = parser.js.filter((script)=>script.context === "module");
        if (instance_scripts.length > 1) parser.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
        if (module_scripts.length > 1) parser.error(parser_errors.invalid_script_module, module_scripts[1].start);
        return {
            html: parser.html,
            css: parser.css[0],
            instance: instance_scripts[0],
            module: module_scripts[0]
        };
    }
    function is_head(node) {
        return node && node.type === "MemberExpression" && node.object["name"] === "@_document" && node.property["name"] === "head";
    }
    class Block {
        constructor(options){
            this.dependencies = new Set();
            this.binding_group_initialised = new Set();
            this.event_listeners = [];
            this.variables = new Map();
            this.has_update_method = false;
            this.parent = options.parent;
            this.renderer = options.renderer;
            this.name = options.name;
            this.type = options.type;
            this.comment = options.comment;
            this.wrappers = [];
            // for keyed each blocks
            this.key = options.key;
            this.first = null;
            this.bindings = options.bindings;
            this.chunks = {
                declarations: [],
                init: [],
                create: [],
                claim: [],
                hydrate: [],
                mount: [],
                measure: [],
                restore_measurements: [],
                fix: [],
                animate: [],
                intro: [],
                update: [],
                outro: [],
                destroy: []
            };
            this.has_animation = false;
            this.has_intro_method = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros
            this.has_outro_method = false;
            this.outros = 0;
            this.get_unique_name = this.renderer.component.get_unique_name_maker();
            this.aliases = new Map();
            if (this.key) this.aliases.set("key", this.get_unique_name("key"));
        }
        assign_variable_names() {
            const seen = new Set();
            const dupes = new Set();
            let i = this.wrappers.length;
            while(i--){
                const wrapper = this.wrappers[i];
                if (!wrapper.var) continue;
                if (seen.has(wrapper.var.name)) dupes.add(wrapper.var.name);
                seen.add(wrapper.var.name);
            }
            const counts = new Map();
            i = this.wrappers.length;
            while(i--){
                const wrapper = this.wrappers[i];
                if (!wrapper.var) continue;
                let suffix = "";
                if (dupes.has(wrapper.var.name)) {
                    const i = counts.get(wrapper.var.name) || 0;
                    counts.set(wrapper.var.name, i + 1);
                    suffix = i;
                }
                wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
            }
        }
        add_dependencies(dependencies) {
            dependencies.forEach((dependency)=>{
                this.dependencies.add(dependency);
            });
            this.has_update_method = true;
            if (this.parent) this.parent.add_dependencies(dependencies);
        }
        add_element(id, render_statement, claim_statement, parent_node, no_detach) {
            this.add_variable(id);
            this.chunks.create.push(b`${id} = ${render_statement};`);
            if (this.renderer.options.hydratable) this.chunks.claim.push(b`${id} = ${claim_statement || render_statement};`);
            if (parent_node) {
                this.chunks.mount.push(b`@append(${parent_node}, ${id});`);
                if (is_head(parent_node) && !no_detach) this.chunks.destroy.push(b`@detach(${id});`);
            } else {
                this.chunks.mount.push(b`@insert(#target, ${id}, #anchor);`);
                if (!no_detach) this.chunks.destroy.push(b`if (detaching) @detach(${id});`);
            }
        }
        add_intro(local) {
            this.has_intros = this.has_intro_method = true;
            if (!local && this.parent) this.parent.add_intro();
        }
        add_outro(local) {
            this.has_outros = this.has_outro_method = true;
            this.outros += 1;
            if (!local && this.parent) this.parent.add_outro();
        }
        add_animation() {
            this.has_animation = true;
        }
        add_variable(id, init) {
            if (this.variables.has(id.name)) throw new Error(`Variable '${id.name}' already initialised with a different value`);
            this.variables.set(id.name, {
                id: id,
                init: init
            });
        }
        alias(name) {
            if (!this.aliases.has(name)) this.aliases.set(name, this.get_unique_name(name));
            return this.aliases.get(name);
        }
        child(options) {
            return new Block(Object.assign({}, this, {
                key: null
            }, options, {
                parent: this
            }));
        }
        get_contents(key) {
            const { dev: dev } = this.renderer.options;
            if (this.has_outros) {
                this.add_variable({
                    type: "Identifier",
                    name: "#current"
                });
                if (this.chunks.intro.length > 0) {
                    this.chunks.intro.push(b`#current = true;`);
                    this.chunks.mount.push(b`#current = true;`);
                }
                if (this.chunks.outro.length > 0) this.chunks.outro.push(b`#current = false;`);
            }
            if (this.autofocus) {
                if (this.autofocus.condition_expression) this.chunks.mount.push(b`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`);
                else this.chunks.mount.push(b`${this.autofocus.element_var}.focus();`);
            }
            this.render_listeners();
            const properties = {};
            const noop = x`@noop`;
            properties.key = key;
            if (this.first) {
                properties.first = x`null`;
                this.chunks.hydrate.push(b`this.first = ${this.first};`);
            }
            if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) properties.create = noop;
            else {
                const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
                properties.create = x`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
            }
            if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
                if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) properties.claim = noop;
                else properties.claim = x`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b`this.h();`}
				}`;
            }
            if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) properties.hydrate = x`function #hydrate() {
				${this.chunks.hydrate}
			}`;
            if (this.chunks.mount.length === 0) properties.mount = noop;
            else if (this.event_listeners.length === 0) properties.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
            else properties.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
            if (this.has_update_method || this.maintain_context) {
                if (this.chunks.update.length === 0 && !this.maintain_context) properties.update = noop;
                else {
                    const ctx = this.maintain_context ? x`#new_ctx` : x`#ctx`;
                    let dirty = {
                        type: "Identifier",
                        name: "#dirty"
                    };
                    if (!this.renderer.context_overflow && !this.parent) dirty = {
                        type: "ArrayPattern",
                        elements: [
                            dirty
                        ]
                    };
                    properties.update = x`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
                }
            }
            if (this.has_animation) {
                properties.measure = x`function #measure() {
				${this.chunks.measure}
			}`;
                if (this.chunks.restore_measurements.length) properties.restore_measurements = x`function #restore_measurements(#measurement) {
					${this.chunks.restore_measurements}
				}`;
                properties.fix = x`function #fix() {
				${this.chunks.fix}
			}`;
                properties.animate = x`function #animate() {
				${this.chunks.animate}
			}`;
            }
            if (this.has_intro_method || this.has_outro_method) {
                if (this.chunks.intro.length === 0) properties.intro = noop;
                else properties.intro = x`function #intro(#local) {
					${this.has_outros && b`if (#current) return;`}
					${this.chunks.intro}
				}`;
                if (this.chunks.outro.length === 0) properties.outro = noop;
                else properties.outro = x`function #outro(#local) {
					${this.chunks.outro}
				}`;
            }
            if (this.chunks.destroy.length === 0) properties.destroy = noop;
            else properties.destroy = x`function #destroy(detaching) {
				${this.chunks.destroy}
			}`;
            if (!this.renderer.component.compile_options.dev) // allow shorthand names
            for(const name in properties){
                const property = properties[name];
                if (property) property.id = null;
            }
            const return_value = x`{
			key: ${properties.key},
			first: ${properties.first},
			c: ${properties.create},
			l: ${properties.claim},
			h: ${properties.hydrate},
			m: ${properties.mount},
			p: ${properties.update},
			r: ${properties.measure},
			s: ${properties.restore_measurements},
			f: ${properties.fix},
			a: ${properties.animate},
			i: ${properties.intro},
			o: ${properties.outro},
			d: ${properties.destroy}
		}`;
            const block = dev && this.get_unique_name("block");
            const body = b`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id: id, init: init })=>{
                return init ? b`let ${id} = ${init}` : b`let ${id}`;
            })}

			${this.chunks.init}

			${dev ? b`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b`
					return ${return_value};`}
		`;
            return body;
        }
        has_content() {
            return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
        }
        render() {
            const key = this.key && this.get_unique_name("key");
            const args = [
                x`#ctx`
            ];
            if (key) args.unshift(key);
            const fn = b`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
            return this.comment ? b`
				// ${this.comment}
				${fn}` : fn;
        }
        render_listeners(chunk = "") {
            if (this.event_listeners.length > 0) {
                this.add_variable({
                    type: "Identifier",
                    name: "#mounted"
                });
                this.chunks.destroy.push(b`#mounted = false`);
                const dispose = {
                    type: "Identifier",
                    name: `#dispose${chunk}`
                };
                this.add_variable(dispose);
                if (this.event_listeners.length === 1) {
                    this.chunks.mount.push(b`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
                    this.chunks.destroy.push(b`${dispose}();`);
                } else {
                    this.chunks.mount.push(b`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
                    this.chunks.destroy.push(b`@run_all(${dispose});`);
                }
            }
        }
    }
    class Wrapper {
        constructor(renderer, block, parent, node){
            this.node = node;
            // make these non-enumerable so that they can be logged sensibly
            // (TODO in dev only?)
            Object.defineProperties(this, {
                renderer: {
                    value: renderer
                },
                parent: {
                    value: parent
                }
            });
            this.can_use_innerhtml = !renderer.options.hydratable;
            this.is_static_content = !renderer.options.hydratable;
            block.wrappers.push(this);
        }
        cannot_use_innerhtml() {
            this.can_use_innerhtml = false;
            if (this.parent) this.parent.cannot_use_innerhtml();
        }
        not_static_content() {
            this.is_static_content = false;
            if (this.parent) this.parent.not_static_content();
        }
        get_or_create_anchor(block, parent_node, parent_nodes) {
            // TODO use this in EachBlock and IfBlock — tricky because
            // children need to be created first
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
                type: "Identifier",
                name: "null"
            };
            if (needs_anchor) block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
            return anchor;
        }
        get_update_mount_node(anchor) {
            return this.parent && this.parent.is_dom_node() ? this.parent.var : x`${anchor}.parentNode`;
        }
        is_dom_node() {
            return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
        }
        render(_block, _parent_node, _parent_nodes) {
            throw Error("Wrapper class is not renderable");
        }
    }
    function create_debugging_comment(node, component) {
        const { locate: locate, source: source } = component;
        let c = node.start;
        if (node.type === "ElseBlock") {
            while(source[c - 1] !== "{")c -= 1;
            while(source[c - 1] === "{")c -= 1;
        }
        let d;
        if (node.type === "InlineComponent" || node.type === "Element" || node.type === "SlotTemplate") {
            if (node.children.length) {
                d = node.children[0].start;
                while(source[d - 1] !== ">")d -= 1;
            } else {
                d = node.start;
                while(source[d] !== ">")d += 1;
                d += 1;
            }
        } else if (node.type === "Text" || node.type === "Comment") d = node.end;
        else {
            // @ts-ignore
            d = node.expression ? node.expression.node.end : c;
            while(source[d] !== "}" && d <= source.length)d += 1;
            while(source[d] === "}")d += 1;
        }
        const start = locate(c);
        const loc = `(${start.line}:${start.column})`;
        return `${loc} ${source.slice(c, d)}`.replace(regex_whitespace_characters, " ");
    }
    class Node$1 {
        constructor(component, parent, _scope, info){
            this.start = info.start;
            this.end = info.end;
            this.type = info.type;
            // this makes properties non-enumerable, which makes logging
            // bearable. might have a performance cost. TODO remove in prod?
            Object.defineProperties(this, {
                component: {
                    value: component
                },
                parent: {
                    value: parent
                }
            });
        }
        cannot_use_innerhtml() {
            if (this.can_use_innerhtml !== false) {
                this.can_use_innerhtml = false;
                if (this.parent) this.parent.cannot_use_innerhtml();
            }
        }
        find_nearest(selector) {
            if (selector.test(this.type)) return this;
            if (this.parent) return this.parent.find_nearest(selector);
        }
        get_static_attribute_value(name) {
            const attribute = this.attributes && this.attributes.find((attr)=>attr.type === "Attribute" && attr.name.toLowerCase() === name);
            if (!attribute) return null;
            if (attribute.is_true) return true;
            if (attribute.chunks.length === 0) return "";
            if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text") return attribute.chunks[0].data;
            return null;
        }
        has_ancestor(type) {
            return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
        }
    }
    // All compiler warnings should be listed and accessed from here
    /**
	 * @internal
	 */ var compiler_warnings = {
        custom_element_no_tag: {
            code: "custom-element-no-tag",
            message: "No custom element 'tag' option was specified. To automatically register a custom element, specify a name with a hyphen in it, e.g. <svelte:options tag=\"my-thing\"/>. To hide this warning, use <svelte:options tag={null}/>"
        },
        unused_export_let: (component, property)=>({
                code: "unused-export-let",
                message: `${component} has unused export property '${property}'. If it is for external reference only, please consider using \`export const ${property}\``
            }),
        module_script_reactive_declaration: {
            code: "module-script-reactive-declaration",
            message: "$: has no effect in a module script"
        },
        non_top_level_reactive_declaration: {
            code: "non-top-level-reactive-declaration",
            message: "$: has no effect outside of the top-level"
        },
        module_script_variable_reactive_declaration: (names)=>({
                code: "module-script-reactive-declaration",
                message: `${names.map((name)=>`"${name}"`).join(", ")} ${names.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
            }),
        missing_declaration: (name, has_script)=>({
                code: "missing-declaration",
                message: `'${name}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name}' to declare a prop`)
            }),
        missing_custom_element_compile_options: {
            code: "missing-custom-element-compile-options",
            message: "The 'tag' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
        },
        css_unused_selector: (selector)=>({
                code: "css-unused-selector",
                message: `Unused CSS selector "${selector}"`
            }),
        empty_block: {
            code: "empty-block",
            message: "Empty block"
        },
        reactive_component: (name)=>({
                code: "reactive-component",
                message: `<${name}/> will not be reactive if ${name} changes. Use <svelte:component this={${name}}/> if you want this reactivity.`
            }),
        component_name_lowercase: (name)=>({
                code: "component-name-lowercase",
                message: `<${name}> will be treated as an HTML element unless it begins with a capital letter`
            }),
        avoid_is: {
            code: "avoid-is",
            message: "The 'is' attribute is not supported cross-browser and should be avoided"
        },
        invalid_html_attribute: (name, suggestion)=>({
                code: "invalid-html-attribute",
                message: `'${name}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
            }),
        a11y_aria_attributes: (name)=>({
                code: "a11y-aria-attributes",
                message: `A11y: <${name}> should not have aria-* attributes`
            }),
        a11y_incorrect_attribute_type: (schema, attribute)=>{
            let message;
            switch(schema.type){
                case "boolean":
                    message = `The value of '${attribute}' must be exactly one of true or false`;
                    break;
                case "id":
                    message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
                    break;
                case "idlist":
                    message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
                    break;
                case "tristate":
                    message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
                    break;
                case "token":
                    message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(", ")}`;
                    break;
                case "tokenlist":
                    message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
                    break;
                default:
                    message = `The value of '${attribute}' must be of type ${schema.type}`;
            }
            return {
                code: "a11y-incorrect-aria-attribute-type",
                message: `A11y: ${message}`
            };
        },
        a11y_unknown_aria_attribute: (attribute, suggestion)=>({
                code: "a11y-unknown-aria-attribute",
                message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        a11y_hidden: (name)=>({
                code: "a11y-hidden",
                message: `A11y: <${name}> element should not be hidden`
            }),
        a11y_misplaced_role: (name)=>({
                code: "a11y-misplaced-role",
                message: `A11y: <${name}> should not have role attribute`
            }),
        a11y_unknown_role: (role, suggestion)=>({
                code: "a11y-unknown-role",
                message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        a11y_no_abstract_role: (role)=>({
                code: "a11y-no-abstract-role",
                message: `A11y: Abstract role '${role}' is forbidden`
            }),
        a11y_no_redundant_roles: (role)=>({
                code: "a11y-no-redundant-roles",
                message: `A11y: Redundant role '${role}'`
            }),
        a11y_no_interactive_element_to_noninteractive_role: (role, element)=>({
                code: "a11y-no-interactive-element-to-noninteractive-role",
                message: `A11y: <${element}> cannot have role '${role}'`
            }),
        a11y_role_has_required_aria_props: (role, props)=>({
                code: "a11y-role-has-required-aria-props",
                message: `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name)=>`"${name}"`).join(", ")}`
            }),
        a11y_accesskey: {
            code: "a11y-accesskey",
            message: "A11y: Avoid using accesskey"
        },
        a11y_autofocus: {
            code: "a11y-autofocus",
            message: "A11y: Avoid using autofocus"
        },
        a11y_misplaced_scope: {
            code: "a11y-misplaced-scope",
            message: "A11y: The scope attribute should only be used with <th> elements"
        },
        a11y_positive_tabindex: {
            code: "a11y-positive-tabindex",
            message: "A11y: avoid tabindex values above zero"
        },
        a11y_invalid_attribute: (href_attribute, href_value)=>({
                code: "a11y-invalid-attribute",
                message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
            }),
        a11y_missing_attribute: (name, article, sequence)=>({
                code: "a11y-missing-attribute",
                message: `A11y: <${name}> element should have ${article} ${sequence} attribute`
            }),
        a11y_img_redundant_alt: {
            code: "a11y-img-redundant-alt",
            message: "A11y: Screenreaders already announce <img> elements as an image."
        },
        a11y_label_has_associated_control: {
            code: "a11y-label-has-associated-control",
            message: "A11y: A form label must be associated with a control."
        },
        a11y_media_has_caption: {
            code: "a11y-media-has-caption",
            message: 'A11y: <video> elements must have a <track kind="captions">'
        },
        a11y_distracting_elements: (name)=>({
                code: "a11y-distracting-elements",
                message: `A11y: Avoid <${name}> elements`
            }),
        a11y_structure_immediate: {
            code: "a11y-structure",
            message: "A11y: <figcaption> must be an immediate child of <figure>"
        },
        a11y_structure_first_or_last: {
            code: "a11y-structure",
            message: "A11y: <figcaption> must be first or last child of <figure>"
        },
        a11y_mouse_events_have_key_events: (event, accompanied_by)=>({
                code: "a11y-mouse-events-have-key-events",
                message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
            }),
        a11y_click_events_have_key_events: ()=>({
                code: "a11y-click-events-have-key-events",
                message: "A11y: visible, non-interactive elements with an on:click event must be accompanied by an on:keydown, on:keyup, or on:keypress event."
            }),
        a11y_missing_content: (name)=>({
                code: "a11y-missing-content",
                message: `A11y: <${name}> element should have child content`
            }),
        a11y_no_noninteractive_tabindex: {
            code: "a11y-no-noninteractive-tabindex",
            message: "A11y: noninteractive element cannot have positive tabIndex value"
        },
        redundant_event_modifier_for_touch: {
            code: "redundant-event-modifier",
            message: "Touch event handlers that don't use the 'event' object are passive by default"
        },
        redundant_event_modifier_passive: {
            code: "redundant-event-modifier",
            message: "The passive modifier only works with wheel and touch events"
        },
        invalid_rest_eachblock_binding: (rest_element_name)=>({
                code: "invalid-rest-eachblock-binding",
                message: `...${rest_element_name} operator will create a new object and binding propagation with original object will not work`
            })
    };
    const regex_non_whitespace_characters = /[^ \r\n\f\v\t]/;
    class AbstractBlock extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
        }
        warn_if_empty_block() {
            if (!this.children || this.children.length > 1) return;
            const child = this.children[0];
            if (!child || child.type === "Text" && !regex_non_whitespace_characters.test(child.data)) this.component.warn(this, compiler_warnings.empty_block);
        }
    }
    function flatten_reference(node) {
        const nodes = [];
        const parts = [];
        while(node.type === "MemberExpression"){
            nodes.unshift(node.property);
            if (!node.computed) parts.unshift(node.property.name);
            else {
                const computed_property = to_string$1(node.property);
                if (computed_property) parts.unshift(`[${computed_property}]`);
            }
            node = node.object;
        }
        const name = node.type === "Identifier" ? node.name : node.type === "ThisExpression" ? "this" : null;
        nodes.unshift(node);
        parts.unshift(name);
        return {
            name: name,
            nodes: nodes,
            parts: parts
        };
    }
    function to_string$1(node) {
        switch(node.type){
            case "Literal":
                return String(node.value);
            case "Identifier":
                return node.name;
        }
    }
    function create_scopes(expression) {
        return analyze(expression);
    }
    function get_object(node) {
        while(node.type === "MemberExpression")node = node.object;
        return node;
    }
    const reserved_keywords = new Set([
        "$$props",
        "$$restProps",
        "$$slots"
    ]);
    function is_reserved_keyword(name) {
        return reserved_keywords.has(name);
    }
    function is_dynamic(variable) {
        if (variable) {
            if (variable.mutated || variable.reassigned) return true; // dynamic internal state
            if (!variable.module && variable.writable && variable.export_name) return true; // writable props
            if (is_reserved_keyword(variable.name)) return true;
        }
        return false;
    }
    function nodes_match(a, b) {
        if (!!a !== !!b) return false;
        if (Array.isArray(a) !== Array.isArray(b)) return false;
        if (a && typeof a === "object") {
            if (Array.isArray(a)) {
                if (a.length !== b.length) return false;
                return a.every((child, i)=>nodes_match(child, b[i]));
            }
            const a_keys = Object.keys(a).sort();
            const b_keys = Object.keys(b).sort();
            if (a_keys.length !== b_keys.length) return false;
            let i = a_keys.length;
            while(i--){
                const key = a_keys[i];
                if (b_keys[i] !== key) return false;
                if (key === "start" || key === "end") continue;
                if (!nodes_match(a[key], b[key])) return false;
            }
            return true;
        }
        return a === b;
    }
    function invalidate(renderer, scope, node, names, main_execution_context = false) {
        const { component: component } = renderer;
        const [head, ...tail] = Array.from(names).filter((name)=>{
            const owner = scope.find_owner(name);
            return !owner || owner === component.instance_scope;
        }).map((name)=>component.var_lookup.get(name)).filter((variable)=>{
            return variable && !variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$");
        });
        function get_invalidated(variable, node) {
            if (main_execution_context && !variable.subscribable && variable.name[0] !== "$") return node;
            return renderer_invalidate(renderer, variable.name, undefined, main_execution_context);
        }
        if (!head) return node;
        component.has_reactive_assignments = true;
        if (node.type === "AssignmentExpression" && node.operator === "=" && nodes_match(node.left, node.right) && tail.length === 0) return get_invalidated(head, node);
        const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
        const extra_args = tail.map((variable)=>get_invalidated(variable)).filter(Boolean);
        if (is_store_value) return x`@set_store_value(${head.name.slice(1)}, ${node}, ${head.name}, ${extra_args})`;
        let invalidate;
        if (!main_execution_context) {
            const pass_value = extra_args.length > 0 || node.type === "AssignmentExpression" && node.left.type !== "Identifier" || node.type === "UpdateExpression" && (!node.prefix || node.argument.type !== "Identifier");
            if (pass_value) extra_args.unshift({
                type: "Identifier",
                name: head.name
            });
            invalidate = x`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node}, ${extra_args})`;
        } else // skip `$$invalidate` if it is in the main execution context
        invalidate = extra_args.length ? [
            node,
            ...extra_args
        ] : node;
        if (head.subscribable && head.reassigned) {
            const subscribe = `$$subscribe_${head.name}`;
            invalidate = x`${subscribe}(${invalidate})`;
        }
        return invalidate;
    }
    function renderer_invalidate(renderer, name, value, main_execution_context = false) {
        const variable = renderer.component.var_lookup.get(name);
        if (variable && variable.subscribable && (variable.reassigned || variable.export_name)) {
            if (main_execution_context) return x`${`$$subscribe_${name}`}(${value || name})`;
            else {
                const member = renderer.context_lookup.get(name);
                return x`${`$$subscribe_${name}`}($$invalidate(${member.index}, ${value || name}))`;
            }
        }
        if (name[0] === "$" && name[1] !== "$") return x`${name.slice(1)}.set(${value || name})`;
        if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name.startsWith("$$"))) return value || name;
        if (value) {
            if (main_execution_context) return x`${value}`;
            else {
                const member = renderer.context_lookup.get(name);
                return x`$$invalidate(${member.index}, ${value})`;
            }
        }
        if (main_execution_context) return;
        // if this is a reactive declaration, invalidate dependencies recursively
        const deps = new Set([
            name
        ]);
        deps.forEach((name)=>{
            const reactive_declarations = renderer.component.reactive_declarations.filter((x)=>x.assignees.has(name));
            reactive_declarations.forEach((declaration)=>{
                declaration.dependencies.forEach((name)=>{
                    deps.add(name);
                });
            });
        });
        // TODO ideally globals etc wouldn't be here in the first place
        const filtered = Array.from(deps).filter((n)=>renderer.context_lookup.has(n));
        if (!filtered.length) return null;
        return filtered.map((n)=>x`$$invalidate(${renderer.context_lookup.get(n).index}, ${n})`).reduce((lhs, rhs)=>x`${lhs}, ${rhs}`);
    }
    function replace_object(node, replacement) {
        if (node.type === "Identifier") return replacement;
        const ancestor = node;
        let parent;
        while(node.type === "MemberExpression"){
            parent = node;
            node = node.object;
        }
        parent.object = replacement;
        return ancestor;
    }
    function is_contextual(component, scope, name) {
        if (is_reserved_keyword(name)) return true;
        // if it's a name below root scope, it's contextual
        if (!scope.is_top_level(name)) return true;
        const variable = component.var_lookup.get(name);
        // hoistables, module declarations, and imports are non-contextual
        if (!variable || variable.hoistable) return false;
        // assume contextual
        return true;
    }
    // adapted from klona v2.0.4 - https://github.com/lukeed/klona
    // (c) Luke Edwards, under MIT License
    // The sole modification is to skip function values in objects when cloning, so we don't break tests.
    function clone(val) {
        let k, out, tmp;
        if (Array.isArray(val)) {
            out = Array(k = val.length);
            while(k--)out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
            return out;
        }
        if (Object.prototype.toString.call(val) === "[object Object]") {
            out = {}; // null
            for(k in val){
                if (k === "__proto__") Object.defineProperty(out, k, {
                    value: clone(val[k]),
                    configurable: true,
                    enumerable: true,
                    writable: true
                });
                else if (typeof val[k] !== "function") out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
            }
            return out;
        }
        return val;
    }
    // All compiler errors should be listed and accessed from here
    /**
	 * @internal
	 */ var compiler_errors = {
        invalid_binding_elements: (element, binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding on <${element}> elements`
            }),
        invalid_binding_element_with: (elements, binding)=>({
                code: "invalid-binding",
                message: `'${binding}' binding can only be used with ${elements}`
            }),
        invalid_binding_on: (binding, element, post)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding on ${element}` + (post || "")
            }),
        invalid_binding_foreign: (binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
            }),
        invalid_binding_no_checkbox: (binding, is_radio)=>({
                code: "invalid-binding",
                message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? " \u2014 for <input type=\"radio\">, use 'group' binding" : "")
            }),
        invalid_binding: (binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding`
            }),
        invalid_binding_window: (parts)=>({
                code: "invalid-binding",
                message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
            }),
        invalid_binding_let: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with the let: directive"
        },
        invalid_binding_await: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
        },
        invalid_binding_const: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with {@const ...}"
        },
        invalid_binding_writibale: {
            code: "invalid-binding",
            message: "Cannot bind to a variable which is not writable"
        },
        binding_undeclared: (name)=>({
                code: "binding-undeclared",
                message: `${name} is not declared`
            }),
        invalid_type: {
            code: "invalid-type",
            message: "'type' attribute cannot be dynamic if input uses two-way binding"
        },
        missing_type: {
            code: "missing-type",
            message: "'type' attribute must be specified"
        },
        dynamic_multiple_attribute: {
            code: "dynamic-multiple-attribute",
            message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
        },
        missing_contenteditable_attribute: {
            code: "missing-contenteditable-attribute",
            message: "'contenteditable' attribute is required for textContent and innerHTML two-way bindings"
        },
        dynamic_contenteditable_attribute: {
            code: "dynamic-contenteditable-attribute",
            message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
        },
        invalid_event_modifier_combination: (modifier1, modifier2)=>({
                code: "invalid-event-modifier",
                message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
            }),
        invalid_event_modifier_legacy: (modifier)=>({
                code: "invalid-event-modifier",
                message: `The '${modifier}' modifier cannot be used in legacy mode`
            }),
        invalid_event_modifier: (valid)=>({
                code: "invalid-event-modifier",
                message: `Valid event modifiers are ${valid}`
            }),
        invalid_event_modifier_component: {
            code: "invalid-event-modifier",
            message: "Event modifiers other than 'once' can only be used on DOM elements"
        },
        textarea_duplicate_value: {
            code: "textarea-duplicate-value",
            message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
        },
        illegal_attribute: (name)=>({
                code: "illegal-attribute",
                message: `'${name}' is not a valid attribute name`
            }),
        invalid_slot_attribute: {
            code: "invalid-slot-attribute",
            message: "slot attribute cannot have a dynamic value"
        },
        duplicate_slot_attribute: (name)=>({
                code: "duplicate-slot-attribute",
                message: `Duplicate '${name}' slot`
            }),
        invalid_slotted_content: {
            code: "invalid-slotted-content",
            message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
        },
        invalid_attribute_head: {
            code: "invalid-attribute",
            message: "<svelte:head> should not have any attributes or directives"
        },
        invalid_action: {
            code: "invalid-action",
            message: "Actions can only be applied to DOM elements, not components"
        },
        invalid_class: {
            code: "invalid-class",
            message: "Classes can only be applied to DOM elements, not components"
        },
        invalid_transition: {
            code: "invalid-transition",
            message: "Transitions can only be applied to DOM elements, not components"
        },
        invalid_let: {
            code: "invalid-let",
            message: "let directive value must be an identifier or an object/array pattern"
        },
        invalid_slot_directive: {
            code: "invalid-slot-directive",
            message: "<slot> cannot have directives"
        },
        dynamic_slot_name: {
            code: "dynamic-slot-name",
            message: "<slot> name cannot be dynamic"
        },
        invalid_slot_name: {
            code: "invalid-slot-name",
            message: "default is a reserved word \u2014 it cannot be used as a slot name"
        },
        invalid_slot_attribute_value_missing: {
            code: "invalid-slot-attribute",
            message: "slot attribute value is missing"
        },
        invalid_slotted_content_fragment: {
            code: "invalid-slotted-content",
            message: "<svelte:fragment> must be a child of a component"
        },
        illegal_attribute_title: {
            code: "illegal-attribute",
            message: "<title> cannot have attributes"
        },
        illegal_structure_title: {
            code: "illegal-structure",
            message: "<title> can only contain text and {tags}"
        },
        duplicate_transition: (directive, parent_directive)=>{
            function describe(_directive) {
                return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
            }
            const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(directive)} directive`;
            return {
                code: "duplicate-transition",
                message: message
            };
        },
        contextual_store: {
            code: "contextual-store",
            message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
        },
        default_export: {
            code: "default-export",
            message: "A component cannot have a default export"
        },
        illegal_declaration: {
            code: "illegal-declaration",
            message: "The $ prefix is reserved, and cannot be used for variable and import names"
        },
        illegal_subscription: {
            code: "illegal-subscription",
            message: 'Cannot reference store value inside <script context="module">'
        },
        illegal_global: (name)=>({
                code: "illegal-global",
                message: `${name} is an illegal variable name`
            }),
        illegal_variable_declaration: {
            code: "illegal-variable-declaration",
            message: 'Cannot declare same variable name which is imported inside <script context="module">'
        },
        cyclical_reactive_declaration: (cycle)=>({
                code: "cyclical-reactive-declaration",
                message: `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
            }),
        invalid_tag_property: {
            code: "invalid-tag-property",
            message: "tag name must be two or more words joined by the '-' character"
        },
        invalid_tag_attribute: {
            code: "invalid-tag-attribute",
            message: "'tag' must be a string literal"
        },
        invalid_namespace_property: (namespace, suggestion)=>({
                code: "invalid-namespace-property",
                message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        invalid_namespace_attribute: {
            code: "invalid-namespace-attribute",
            message: "The 'namespace' attribute must be a string literal representing a valid namespace"
        },
        invalid_attribute_value: (name)=>({
                code: `invalid-${name}-value`,
                message: `${name} attribute must be true or false`
            }),
        invalid_options_attribute_unknown: {
            code: "invalid-options-attribute",
            message: "<svelte:options> unknown attribute"
        },
        invalid_options_attribute: {
            code: "invalid-options-attribute",
            message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
        },
        css_invalid_global: {
            code: "css-invalid-global",
            message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
        },
        css_invalid_global_selector: {
            code: "css-invalid-global-selector",
            message: ":global(...) must contain a single selector"
        },
        css_invalid_selector: (selector)=>({
                code: "css-invalid-selector",
                message: `Invalid selector "${selector}"`
            }),
        duplicate_animation: {
            code: "duplicate-animation",
            message: "An element can only have one 'animate' directive"
        },
        invalid_animation_immediate: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be the immediate child of a keyed each block"
        },
        invalid_animation_key: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?"
        },
        invalid_animation_sole: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be the sole child of a keyed each block"
        },
        invalid_animation_dynamic_element: {
            code: "invalid-animation",
            message: "<svelte:element> cannot have a animate directive"
        },
        invalid_directive_value: {
            code: "invalid-directive-value",
            message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
        },
        invalid_const_placement: {
            code: "invalid-const-placement",
            message: "{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>"
        },
        invalid_const_declaration: (name)=>({
                code: "invalid-const-declaration",
                message: `'${name}' has already been declared`
            }),
        invalid_const_update: (name)=>({
                code: "invalid-const-update",
                message: `'${name}' is declared using {@const ...} and is read-only`
            }),
        cyclical_const_tags: (cycle)=>({
                code: "cyclical-const-tags",
                message: `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
            }),
        invalid_component_style_directive: {
            code: "invalid-component-style-directive",
            message: "Style directives cannot be used on components"
        },
        invalid_style_directive_modifier: (valid)=>({
                code: "invalid-style-directive-modifier",
                message: `Valid modifiers for style directives are: ${valid}`
            })
    };
    const regex_contains_term_function_expression = /FunctionExpression/;
    class Expression {
        constructor(component, owner, template_scope, info, lazy){
            this.type = "Expression";
            this.references = new Set();
            this.dependencies = new Set();
            this.contextual_dependencies = new Set();
            this.declarations = [];
            this.uses_context = false;
            // TODO revert to direct property access in prod?
            Object.defineProperties(this, {
                component: {
                    value: component
                }
            });
            this.node = info;
            this.template_scope = template_scope;
            this.owner = owner;
            const { dependencies: dependencies, contextual_dependencies: contextual_dependencies, references: references } = this;
            let { map: map, scope: scope } = create_scopes(info);
            this.scope = scope;
            this.scope_map = map;
            const expression = this;
            let function_expression;
            // discover dependencies, but don't change the code yet
            walk(info, {
                enter (node, parent, key) {
                    // don't manipulate shorthand props twice
                    if (key === "key" && parent.shorthand) return;
                    // don't manipulate `import.meta`, `new.target`
                    if (node.type === "MetaProperty") return this.skip();
                    if (map.has(node)) scope = map.get(node);
                    if (!function_expression && regex_contains_term_function_expression.test(node.type)) function_expression = node;
                    if (is_reference(node, parent)) {
                        const { name: name, nodes: nodes } = flatten_reference(node);
                        references.add(name);
                        if (scope.has(name)) return;
                        if (name[0] === "$") {
                            const store_name = name.slice(1);
                            if (template_scope.names.has(store_name) || scope.has(store_name)) return component.error(node, compiler_errors.contextual_store);
                        }
                        if (template_scope.is_let(name)) {
                            if (!lazy) {
                                contextual_dependencies.add(name);
                                dependencies.add(name);
                            }
                        } else if (template_scope.names.has(name)) {
                            expression.uses_context = true;
                            contextual_dependencies.add(name);
                            const owner = template_scope.get_owner(name);
                            const is_index = owner.type === "EachBlock" && owner.key && name === owner.index;
                            if (!lazy || is_index) template_scope.dependencies_for_name.get(name).forEach((name)=>dependencies.add(name));
                        } else {
                            if (!lazy) dependencies.add(name);
                            component.add_reference(node, name);
                            component.warn_if_undefined(name, nodes[0], template_scope);
                        }
                        this.skip();
                    }
                    // track any assignments from template expressions as mutable
                    let names;
                    let deep = false;
                    if (function_expression) {
                        if (node.type === "AssignmentExpression") {
                            deep = node.left.type === "MemberExpression";
                            names = extract_names(deep ? get_object(node.left) : node.left);
                        } else if (node.type === "UpdateExpression") {
                            deep = node.argument.type === "MemberExpression";
                            names = extract_names(get_object(node.argument));
                        }
                    }
                    if (names) names.forEach((name)=>{
                        var _a;
                        if (template_scope.names.has(name)) {
                            if (template_scope.is_const(name)) component.error(node, compiler_errors.invalid_const_update(name));
                            template_scope.dependencies_for_name.get(name).forEach((name)=>{
                                const variable = component.var_lookup.get(name);
                                if (variable) variable[deep ? "mutated" : "reassigned"] = true;
                            });
                            const each_block = template_scope.get_owner(name);
                            each_block.has_binding = true;
                        } else {
                            component.add_reference(node, name);
                            const variable = component.var_lookup.get(name);
                            if (variable) variable[deep ? "mutated" : "reassigned"] = true;
                            const declaration = (_a = scope.find_owner(name)) === null || _a === void 0 ? void 0 : _a.declarations.get(name);
                            if (declaration) {
                                if (declaration.kind === "const" && !deep) component.error(node, {
                                    code: "assignment-to-const",
                                    message: "You are assigning to a const"
                                });
                            } else if (variable && variable.writable === false && !deep) component.error(node, {
                                code: "assignment-to-const",
                                message: "You are assigning to a const"
                            });
                        }
                    });
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (node === function_expression) function_expression = null;
                }
            });
        }
        dynamic_dependencies() {
            return Array.from(this.dependencies).filter((name)=>{
                if (this.template_scope.is_let(name)) return true;
                if (is_reserved_keyword(name)) return true;
                const variable = this.component.var_lookup.get(name);
                return is_dynamic(variable);
            });
        }
        // TODO move this into a render-dom wrapper?
        manipulate(block, ctx) {
            // TODO ideally we wouldn't end up calling this method
            // multiple times
            if (this.manipulated) return this.manipulated;
            const { component: component, declarations: declarations, scope_map: map, template_scope: template_scope, owner: owner } = this;
            let scope = this.scope;
            let function_expression;
            let dependencies;
            let contextual_dependencies;
            const node = walk(this.node, {
                enter (node, parent) {
                    if (node.type === "Property" && node.shorthand) {
                        node.value = clone(node.value);
                        node.shorthand = false;
                    }
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "Identifier" && is_reference(node, parent)) {
                        const { name: name } = flatten_reference(node);
                        if (scope.has(name)) return;
                        if (function_expression) {
                            if (template_scope.names.has(name)) {
                                contextual_dependencies.add(name);
                                template_scope.dependencies_for_name.get(name).forEach((dependency)=>{
                                    dependencies.add(dependency);
                                });
                            } else {
                                dependencies.add(name);
                                component.add_reference(node, name); // TODO is this redundant/misplaced?
                            }
                        } else if (is_contextual(component, template_scope, name)) {
                            const reference = block.renderer.reference(node, ctx);
                            this.replace(reference);
                        }
                        this.skip();
                    }
                    if (!function_expression) {
                        node.type;
                        if (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
                            function_expression = node;
                            dependencies = new Set();
                            contextual_dependencies = new Set();
                        }
                    }
                },
                leave (node, parent) {
                    if (map.has(node)) scope = scope.parent;
                    if (node === function_expression) {
                        const id = component.get_unique_name(sanitize(get_function_name(node, owner)));
                        const declaration = b`const ${id} = ${node}`;
                        const extract_functions = ()=>{
                            const deps = Array.from(contextual_dependencies);
                            const function_expression = node;
                            const has_args = function_expression.params.length > 0;
                            function_expression.params = [
                                ...deps.map((name)=>({
                                        type: "Identifier",
                                        name: name
                                    })),
                                ...function_expression.params
                            ];
                            const context_args = deps.map((name)=>block.renderer.reference(name, ctx));
                            component.partly_hoisted.push(declaration);
                            block.renderer.add_to_context(id.name);
                            const callee = block.renderer.reference(id);
                            this.replace(id);
                            const func_declaration = has_args ? b`function ${id}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b`function ${id}() {
								return ${callee}(${context_args});
							}`;
                            return {
                                deps: deps,
                                func_declaration: func_declaration
                            };
                        };
                        if (owner.type === "ConstTag") {
                            // we need a combo block/init recipe
                            if (contextual_dependencies.size === 0) {
                                let child_scope = scope;
                                walk(node, {
                                    enter (node, parent) {
                                        if (map.has(node)) child_scope = map.get(node);
                                        if (node.type === "Identifier" && is_reference(node, parent)) {
                                            if (child_scope.has(node.name)) return;
                                            this.replace(block.renderer.reference(node, ctx));
                                        }
                                    },
                                    leave (node) {
                                        if (map.has(node)) child_scope = child_scope.parent;
                                    }
                                });
                            } else {
                                const { func_declaration: func_declaration } = extract_functions();
                                this.replace(func_declaration[0]);
                            }
                        } else if (dependencies.size === 0 && contextual_dependencies.size === 0) {
                            // we can hoist this out of the component completely
                            component.fully_hoisted.push(declaration);
                            this.replace(id);
                            component.add_var(node, {
                                name: id.name,
                                internal: true,
                                hoistable: true,
                                referenced: true
                            });
                        } else if (contextual_dependencies.size === 0) {
                            // function can be hoisted inside the component init
                            component.partly_hoisted.push(declaration);
                            block.renderer.add_to_context(id.name);
                            this.replace(block.renderer.reference(id));
                        } else {
                            // we need a combo block/init recipe
                            const { deps: deps, func_declaration: func_declaration } = extract_functions();
                            if (owner.type === "Attribute" && owner.parent.name === "slot") {
                                const dep_scopes = new Set(deps.map((name)=>template_scope.get_owner(name)));
                                // find the nearest scopes
                                let node = owner.parent;
                                while(node && !dep_scopes.has(node))node = node.parent;
                                const func_expression = func_declaration[0];
                                if (node.type === "InlineComponent" || node.type === "SlotTemplate") // <Comp let:data />
                                this.replace(func_expression);
                                else {
                                    // {#each}, {#await}
                                    const func_id = component.get_unique_name(id.name + "_func");
                                    block.renderer.add_to_context(func_id.name, true);
                                    // rename #ctx -> child_ctx;
                                    walk(func_expression, {
                                        enter (node) {
                                            if (node.type === "Identifier" && node.name === "#ctx") node.name = "child_ctx";
                                        }
                                    });
                                    // add to get_xxx_context
                                    // child_ctx[x] = function () { ... }
                                    template_scope.get_owner(deps[0]).contexts.push({
                                        key: func_id,
                                        modifier: ()=>func_expression,
                                        default_modifier: (node)=>node
                                    });
                                    this.replace(block.renderer.reference(func_id));
                                }
                            } else declarations.push(func_declaration);
                        }
                        function_expression = null;
                        dependencies = null;
                        contextual_dependencies = null;
                        if (parent && parent.type === "Property") parent.method = false;
                    }
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const object_name = get_object(assignee).name;
                        if (scope.has(object_name)) return;
                        // normally (`a = 1`, `b.c = 2`), there'll be a single name
                        // (a or b). In destructuring cases (`[d, e] = [e, d]`) there
                        // may be more, in which case we need to tack the extra ones
                        // onto the initial function call
                        const names = new Set(extract_names(assignee));
                        const traced = new Set();
                        names.forEach((name)=>{
                            const dependencies = template_scope.dependencies_for_name.get(name);
                            if (dependencies) dependencies.forEach((name)=>traced.add(name));
                            else traced.add(name);
                        });
                        const context = block.bindings.get(object_name);
                        if (context) {
                            // for `{#each array as item}`
                            // replace `item = 1` to `each_array[each_index] = 1`, this allow us to mutate the array
                            // rather than mutating the local `item` variable
                            const { snippet: snippet, object: object, property: property } = context;
                            const replaced = replace_object(assignee, snippet);
                            if (node.type === "AssignmentExpression") node.left = replaced;
                            else node.argument = replaced;
                            contextual_dependencies.add(object.name);
                            contextual_dependencies.add(property.name);
                        }
                        this.replace(invalidate(block.renderer, scope, node, traced));
                    }
                }
            });
            if (declarations.length > 0) {
                block.maintain_context = true;
                declarations.forEach((declaration)=>{
                    block.chunks.init.push(declaration);
                });
            }
            return this.manipulated = node;
        }
    }
    function get_function_name(_node, parent) {
        if (parent.type === "EventHandler") return `${parent.name}_handler`;
        if (parent.type === "Action") return `${parent.name}_function`;
        return "func";
    }
    function unpack_destructuring({ contexts: contexts, node: node, modifier: modifier = (node)=>node, default_modifier: default_modifier = (node)=>node, scope: scope, component: component, context_rest_properties: context_rest_properties }) {
        if (!node) return;
        if (node.type === "Identifier") contexts.push({
            key: node,
            modifier: modifier,
            default_modifier: default_modifier
        });
        else if (node.type === "RestElement") {
            contexts.push({
                key: node.argument,
                modifier: modifier,
                default_modifier: default_modifier
            });
            context_rest_properties.set(node.argument.name, node);
        } else if (node.type === "ArrayPattern") node.elements.forEach((element, i)=>{
            if (element && element.type === "RestElement") {
                unpack_destructuring({
                    contexts: contexts,
                    node: element,
                    modifier: (node)=>x`${modifier(node)}.slice(${i})`,
                    default_modifier: default_modifier,
                    scope: scope,
                    component: component,
                    context_rest_properties: context_rest_properties
                });
                context_rest_properties.set(element.argument.name, element);
            } else if (element && element.type === "AssignmentPattern") {
                const n = contexts.length;
                mark_referenced(element.right, scope, component);
                unpack_destructuring({
                    contexts: contexts,
                    node: element.left,
                    modifier: (node)=>x`${modifier(node)}[${i}]`,
                    default_modifier: (node, to_ctx)=>x`${node} !== undefined ? ${node} : ${update_reference(contexts, n, element.right, to_ctx)}`,
                    scope: scope,
                    component: component,
                    context_rest_properties: context_rest_properties
                });
            } else unpack_destructuring({
                contexts: contexts,
                node: element,
                modifier: (node)=>x`${modifier(node)}[${i}]`,
                default_modifier: default_modifier,
                scope: scope,
                component: component,
                context_rest_properties: context_rest_properties
            });
        });
        else if (node.type === "ObjectPattern") {
            const used_properties = [];
            node.properties.forEach((property)=>{
                if (property.type === "RestElement") {
                    unpack_destructuring({
                        contexts: contexts,
                        node: property.argument,
                        modifier: (node)=>x`@object_without_properties(${modifier(node)}, [${used_properties}])`,
                        default_modifier: default_modifier,
                        scope: scope,
                        component: component,
                        context_rest_properties: context_rest_properties
                    });
                    context_rest_properties.set(property.argument.name, property);
                } else {
                    const key = property.key;
                    const value = property.value;
                    used_properties.push(x`"${key.name}"`);
                    if (value.type === "AssignmentPattern") {
                        const n = contexts.length;
                        mark_referenced(value.right, scope, component);
                        unpack_destructuring({
                            contexts: contexts,
                            node: value.left,
                            modifier: (node)=>x`${modifier(node)}.${key.name}`,
                            default_modifier: (node, to_ctx)=>x`${node} !== undefined ? ${node} : ${update_reference(contexts, n, value.right, to_ctx)}`,
                            scope: scope,
                            component: component,
                            context_rest_properties: context_rest_properties
                        });
                    } else unpack_destructuring({
                        contexts: contexts,
                        node: value,
                        modifier: (node)=>x`${modifier(node)}.${key.name}`,
                        default_modifier: default_modifier,
                        scope: scope,
                        component: component,
                        context_rest_properties: context_rest_properties
                    });
                }
            });
        }
    }
    function update_reference(contexts, n, expression, to_ctx) {
        const find_from_context = (node)=>{
            for(let i = n; i < contexts.length; i++){
                const { key: key } = contexts[i];
                if (node.name === key.name) throw new Error(`Cannot access '${node.name}' before initialization`);
            }
            return to_ctx(node.name);
        };
        if (expression.type === "Identifier") return find_from_context(expression);
        // NOTE: avoid unnecessary deep clone?
        expression = clone(expression);
        walk(expression, {
            enter (node, parent) {
                if (is_reference(node, parent)) {
                    this.replace(find_from_context(node));
                    this.skip();
                }
            }
        });
        return expression;
    }
    function mark_referenced(node, scope, component) {
        walk(node, {
            enter (node, parent) {
                if (is_reference(node, parent)) {
                    const { name: name } = flatten_reference(node);
                    if (!scope.is_let(name) && !scope.names.has(name)) component.add_reference(node, name);
                }
            }
        });
    }
    const allowed_parents = new Set([
        "EachBlock",
        "CatchBlock",
        "ThenBlock",
        "InlineComponent",
        "SlotTemplate",
        "IfBlock",
        "ElseBlock"
    ]);
    class ConstTag extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.contexts = [];
            this.context_rest_properties = new Map();
            this.assignees = new Set();
            this.dependencies = new Set();
            if (!allowed_parents.has(parent.type)) component.error(info, compiler_errors.invalid_const_placement);
            this.node = info;
            this.scope = scope;
            const { assignees: assignees, dependencies: dependencies } = this;
            extract_identifiers(info.expression.left).forEach(({ name: name })=>{
                assignees.add(name);
                const owner = this.scope.get_owner(name);
                if (owner === parent) component.error(info, compiler_errors.invalid_const_declaration(name));
            });
            walk(info.expression.right, {
                enter (node, parent) {
                    if (is_reference(node, parent)) {
                        const identifier = get_object(node);
                        const { name: name } = identifier;
                        dependencies.add(name);
                    }
                }
            });
        }
        parse_expression() {
            unpack_destructuring({
                contexts: this.contexts,
                node: this.node.expression.left,
                scope: this.scope,
                component: this.component,
                context_rest_properties: this.context_rest_properties
            });
            this.expression = new Expression(this.component, this, this.scope, this.node.expression.right);
            this.contexts.forEach((context)=>{
                const owner = this.scope.get_owner(context.key.name);
                if (owner && owner.type === "ConstTag" && owner.parent === this.parent) this.component.error(this.node, compiler_errors.invalid_const_declaration(context.key.name));
                this.scope.add(context.key.name, this.expression.dependencies, this);
            });
        }
    }
    class PendingBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.children = map_children(component, parent, scope, info.children);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    class CatchBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            if (parent.catch_node) parent.catch_contexts.forEach((context)=>{
                this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    class AwaitBlock extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.context_rest_properties = new Map();
            this.expression = new Expression(component, this, scope, info.expression);
            this.then_node = info.value;
            this.catch_node = info.error;
            if (this.then_node) {
                this.then_contexts = [];
                unpack_destructuring({
                    contexts: this.then_contexts,
                    node: info.value,
                    scope: scope,
                    component: component,
                    context_rest_properties: this.context_rest_properties
                });
            }
            if (this.catch_node) {
                this.catch_contexts = [];
                unpack_destructuring({
                    contexts: this.catch_contexts,
                    node: info.error,
                    scope: scope,
                    component: component,
                    context_rest_properties: this.context_rest_properties
                });
            }
            this.pending = new PendingBlock(component, this, scope, info.pending);
            this.then = new ThenBlock(component, this, scope, info.then);
            this.catch = new CatchBlock(component, this, scope, info.catch);
        }
    }
    const regex_contains_term_function_expression$1 = /FunctionExpression/;
    class EventHandler extends Node$1 {
        constructor(component, parent, template_scope, info){
            super(component, parent, template_scope, info);
            this.uses_context = false;
            this.can_make_passive = false;
            this.name = info.name;
            this.modifiers = new Set(info.modifiers);
            if (info.expression) {
                this.expression = new Expression(component, this, template_scope, info.expression);
                this.uses_context = this.expression.uses_context;
                if (regex_contains_term_function_expression$1.test(info.expression.type) && info.expression.params.length === 0) // TODO make this detection more accurate — if `event.preventDefault` isn't called, and
                // `event` is passed to another function, we can make it passive
                this.can_make_passive = true;
                else if (info.expression.type === "Identifier") {
                    let node = component.node_for_declaration.get(info.expression.name);
                    if (node) {
                        if (node.type === "VariableDeclaration") {
                            // for `const handleClick = () => {...}`, we want the [arrow] function expression node
                            const declarator = node.declarations.find((d)=>d.id.name === info.expression.name);
                            node = declarator && declarator.init;
                        }
                        if (node && (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") && node.params.length === 0) this.can_make_passive = true;
                    }
                }
            } else this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
        }
        get reassigned() {
            if (!this.expression) return false;
            const node = this.expression.node;
            if (regex_contains_term_function_expression$1.test(node.type)) return false;
            return this.expression.dynamic_dependencies().length > 0;
        }
    }
    class Action extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            const object = info.name.split(".")[0];
            component.warn_if_undefined(object, info, scope);
            this.name = info.name;
            component.add_reference(this, object);
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
            this.template_scope = scope;
            this.uses_context = this.expression && this.expression.uses_context;
        }
    }
    class Body extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.handlers = [];
            this.actions = [];
            info.attributes.forEach((node)=>{
                if (node.type === "EventHandler") this.handlers.push(new EventHandler(component, this, scope, node));
                else if (node.type === "Action") this.actions.push(new Action(component, this, scope, node));
            });
        }
    }
    class Comment$1 extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.data = info.data;
            this.ignores = info.ignores;
        }
    }
    class ElseBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
            this.warn_if_empty_block();
        }
    }
    class EachBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.has_binding = false;
            this.has_index_binding = false;
            this.expression = new Expression(component, this, scope, info.expression);
            this.context = info.context.name || "each"; // TODO this is used to facilitate binding; currently fails with destructuring
            this.context_node = info.context;
            this.index = info.index;
            this.scope = scope.child();
            this.context_rest_properties = new Map();
            this.contexts = [];
            unpack_destructuring({
                contexts: this.contexts,
                node: info.context,
                scope: scope,
                component: component,
                context_rest_properties: this.context_rest_properties
            });
            this.contexts.forEach((context)=>{
                this.scope.add(context.key.name, this.expression.dependencies, this);
            });
            if (this.index) {
                // index can only change if this is a keyed each block
                const dependencies = info.key ? this.expression.dependencies : new Set([]);
                this.scope.add(this.index, dependencies, this);
            }
            this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
            this.has_animation = false;
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
            if (this.has_animation) {
                this.children = this.children.filter((child)=>!isEmptyNode(child) && !isCommentNode(child));
                if (this.children.length !== 1) {
                    const child = this.children.find((child)=>!!child.animation);
                    component.error(child.animation, compiler_errors.invalid_animation_sole);
                    return;
                }
            }
            this.warn_if_empty_block();
            this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
        }
    }
    function isEmptyNode(node) {
        return node.type === "Text" && node.data.trim() === "";
    }
    function isCommentNode(node) {
        return node.type === "Comment";
    }
    function string_literal(data) {
        return {
            type: "Literal",
            value: data
        };
    }
    const escaped = {
        '"': "&quot;",
        "'": "&#39;",
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
    };
    const regex_html_characters_to_escape = /["'&<>]/g;
    function escape_html(html) {
        return String(html).replace(regex_html_characters_to_escape, (match)=>escaped[match]);
    }
    const regex_template_characters_to_escape = /(\${|`|\\)/g;
    function escape_template(str) {
        return str.replace(regex_template_characters_to_escape, "\\$1");
    }
    function add_to_set(a, b) {
        // @ts-ignore
        b.forEach((item)=>{
            a.add(item);
        });
    }
    class Attribute extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope;
            if (info.type === "Spread") {
                this.name = null;
                this.is_spread = true;
                this.is_true = false;
                this.expression = new Expression(component, this, scope, info.expression);
                this.dependencies = this.expression.dependencies;
                this.chunks = null;
                this.is_static = false;
            } else {
                this.name = info.name;
                this.is_true = info.value === true;
                this.is_static = true;
                this.dependencies = new Set();
                this.chunks = this.is_true ? [] : info.value.map((node)=>{
                    if (node.type === "Text") return node;
                    this.is_static = false;
                    const expression = new Expression(component, this, scope, node.expression);
                    add_to_set(this.dependencies, expression.dependencies);
                    return expression;
                });
            }
        }
        get_dependencies() {
            if (this.is_spread) return this.expression.dynamic_dependencies();
            const dependencies = new Set();
            this.chunks.forEach((chunk)=>{
                if (chunk.type === "Expression") add_to_set(dependencies, chunk.dynamic_dependencies());
            });
            return Array.from(dependencies);
        }
        get_value(block) {
            if (this.is_true) return x`true`;
            if (this.chunks.length === 0) return x`""`;
            if (this.chunks.length === 1) return this.chunks[0].type === "Text" ? string_literal(this.chunks[0].data) : this.chunks[0].manipulate(block);
            let expression = this.chunks.map((chunk)=>chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
            if (this.chunks[0].type !== "Text") expression = x`"" + ${expression}`;
            return expression;
        }
        get_static_value() {
            if (!this.is_static) return null;
            return this.is_true ? true : this.chunks[0] ? this.chunks[0].data : "";
        }
        should_cache() {
            return this.is_static ? false : this.chunks.length === 1 ? this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name) : true;
        }
    }
    // TODO this should live in a specific binding
    const read_only_media_attributes = new Set([
        "duration",
        "buffered",
        "seekable",
        "played",
        "seeking",
        "ended",
        "videoHeight",
        "videoWidth"
    ]);
    class Binding extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
                component.error(info, compiler_errors.invalid_directive_value);
                return;
            }
            this.name = info.name;
            this.expression = new Expression(component, this, scope, info.expression);
            this.raw_expression = clone(info.expression);
            const { name: name } = get_object(this.expression.node);
            this.is_contextual = Array.from(this.expression.references).some((name)=>scope.names.has(name));
            if (this.is_contextual) this.validate_binding_rest_properties(scope);
            // make sure we track this as a mutable ref
            if (scope.is_let(name)) {
                component.error(this, compiler_errors.invalid_binding_let);
                return;
            } else if (scope.names.has(name)) {
                if (scope.is_await(name)) {
                    component.error(this, compiler_errors.invalid_binding_await);
                    return;
                }
                if (scope.is_const(name)) component.error(this, compiler_errors.invalid_binding_const);
                scope.dependencies_for_name.get(name).forEach((name)=>{
                    const variable = component.var_lookup.get(name);
                    if (variable) variable.mutated = true;
                });
            } else {
                const variable = component.var_lookup.get(name);
                if (!variable || variable.global) {
                    component.error(this.expression.node, compiler_errors.binding_undeclared(name));
                    return;
                }
                variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
                if (info.expression.type === "Identifier" && !variable.writable) {
                    component.error(this.expression.node, compiler_errors.invalid_binding_writibale);
                    return;
                }
            }
            const type = parent.get_static_attribute_value("type");
            this.is_readonly = regex_dimensions.test(this.name) || isElement(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file");
        }
        is_readonly_media_attribute() {
            return read_only_media_attributes.has(this.name);
        }
        validate_binding_rest_properties(scope) {
            this.expression.references.forEach((name)=>{
                const each_block = scope.get_owner(name);
                if (each_block && each_block.type === "EachBlock") {
                    const rest_node = each_block.context_rest_properties.get(name);
                    if (rest_node) this.component.warn(rest_node, compiler_warnings.invalid_rest_eachblock_binding(name));
                }
            });
        }
    }
    function isElement(node) {
        return !!node.is_media_node;
    }
    class Transition extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            component.warn_if_undefined(info.name, info, scope);
            this.name = info.name;
            component.add_reference(this, info.name.split(".")[0]);
            this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
            this.is_local = info.modifiers.includes("local");
            if (info.intro && parent.intro || info.outro && parent.outro) {
                const parent_transition = parent.intro || parent.outro;
                component.error(info, compiler_errors.duplicate_transition(this.directive, parent_transition.directive));
                return;
            }
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
        }
    }
    class Animation extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            component.warn_if_undefined(info.name, info, scope);
            this.name = info.name;
            component.add_reference(this, info.name.split(".")[0]);
            if (parent.animation) {
                component.error(this, compiler_errors.duplicate_animation);
                return;
            }
            const block = parent.parent;
            if (!block || block.type !== "EachBlock") {
                // TODO can we relax the 'immediate child' rule?
                component.error(this, compiler_errors.invalid_animation_immediate);
                return;
            }
            if (!block.key) {
                component.error(this, compiler_errors.invalid_animation_key);
                return;
            }
            block.has_animation = true;
            this.expression = info.expression ? new Expression(component, this, scope, info.expression, true) : null;
        }
    }
    class Class extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = info.name;
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
        }
    }
    /**
	 * Transforms a list of Text and MustacheTags into a TemplateLiteral expression.
	 * Start/End positions on the elements of the expression are not set.
	 */ function nodes_to_template_literal(value) {
        const literal = {
            type: "TemplateLiteral",
            expressions: [],
            quasis: []
        };
        let quasi = {
            type: "TemplateElement",
            value: {
                raw: "",
                cooked: null
            },
            tail: false
        };
        value.forEach((node)=>{
            if (node.type === "Text") quasi.value.raw += node.raw;
            else if (node.type === "MustacheTag") {
                literal.quasis.push(quasi);
                literal.expressions.push(node.expression);
                quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: "",
                        cooked: null
                    },
                    tail: false
                };
            }
        });
        quasi.tail = true;
        literal.quasis.push(quasi);
        return literal;
    }
    const valid_modifiers = new Set([
        "important"
    ]);
    class StyleDirective extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = info.name;
            this.modifiers = new Set(info.modifiers);
            for (const modifier of this.modifiers)if (!valid_modifiers.has(modifier)) component.error(this, compiler_errors.invalid_style_directive_modifier(list$1([
                ...valid_modifiers
            ])));
            // Convert the value array to an expression so it's easier to handle
            // the StyleDirective going forward.
            if (info.value === true || info.value.length === 1 && info.value[0].type === "MustacheTag") {
                const identifier = info.value === true ? {
                    type: "Identifier",
                    start: info.end - info.name.length,
                    end: info.end,
                    name: info.name
                } : info.value[0].expression;
                this.expression = new Expression(component, this, scope, identifier);
                this.should_cache = false;
            } else {
                const raw_expression = nodes_to_template_literal(info.value);
                this.expression = new Expression(component, this, scope, raw_expression);
                this.should_cache = raw_expression.expressions.length > 0;
            }
        }
        get important() {
            return this.modifiers.has("important");
        }
    }
    // Whitespace inside one of these elements will not result in
    // a whitespace node being created in any circumstances. (This
    // list is almost certainly very incomplete)
    const elements_without_text = new Set([
        "audio",
        "datalist",
        "dl",
        "optgroup",
        "select",
        "video"
    ]);
    const regex_ends_with_svg = /svg$/;
    class Text extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.data = info.data;
            this.synthetic = info.synthetic || false;
        }
        should_skip() {
            if (regex_non_whitespace_character.test(this.data)) return false;
            const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
            if (!parent_element) return false;
            if (parent_element.type === "Head") return true;
            if (parent_element.type === "InlineComponent") return parent_element.children.length === 1 && this === parent_element.children[0];
            // svg namespace exclusions
            if (regex_ends_with_svg.test(parent_element.namespace)) {
                if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan") return false;
            }
            return parent_element.namespace || elements_without_text.has(parent_element.name);
        }
        keep_space() {
            if (this.component.component_options.preserveWhitespace) return true;
            return this.within_pre();
        }
        within_pre() {
            let node = this.parent;
            while(node){
                if (node.type === "Element" && node.name === "pre") return true;
                node = node.parent;
            }
            return false;
        }
    }
    // The `foreign` namespace covers all DOM implementations that aren't HTML5.
    // It opts out of HTML5-specific a11y checks and case-insensitive attribute names.
    const foreign = "https://svelte.dev/docs#template-syntax-svelte-options";
    const html = "http://www.w3.org/1999/xhtml";
    const mathml = "http://www.w3.org/1998/Math/MathML";
    const svg$1 = "http://www.w3.org/2000/svg";
    const xlink = "http://www.w3.org/1999/xlink";
    const xml = "http://www.w3.org/XML/1998/namespace";
    const xmlns = "http://www.w3.org/2000/xmlns";
    const valid_namespaces = [
        "foreign",
        "html",
        "mathml",
        "svg",
        "xlink",
        "xml",
        "xmlns",
        foreign,
        html,
        mathml,
        svg$1,
        xlink,
        xml,
        xmlns
    ];
    const namespaces = {
        foreign: foreign,
        html: html,
        mathml: mathml,
        svg: svg$1,
        xlink: xlink,
        xml: xml,
        xmlns: xmlns
    };
    const applicable = new Set([
        "Identifier",
        "ObjectExpression",
        "ArrayExpression",
        "Property"
    ]);
    class Let extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.names = [];
            this.name = {
                type: "Identifier",
                name: info.name
            };
            const { names: names } = this;
            if (info.expression) {
                this.value = info.expression;
                walk(info.expression, {
                    enter (node) {
                        if (!applicable.has(node.type)) return component.error(node, compiler_errors.invalid_let);
                        if (node.type === "Identifier") names.push(node.name);
                        // slightly unfortunate hack
                        if (node.type === "ArrayExpression") node.type = "ArrayPattern";
                        if (node.type === "ObjectExpression") node.type = "ObjectPattern";
                    }
                });
            } else names.push(this.name.name);
        }
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof $parcel$global !== "undefined" ? $parcel$global : typeof self !== "undefined" ? self : {};
    function unwrapExports(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function createCommonjsModule(fn, module) {
        return module = {
            exports: {}
        }, fn(module, module.exports), module.exports;
    }
    function getCjsExportFromNamespace(n) {
        return n && n["default"] || n;
    }
    var iteratorProxy_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        function iteratorProxy() {
            var values = this;
            var index = 0;
            var iter = {
                "@@iterator": function iterator() {
                    return iter;
                },
                next: function next() {
                    if (index < values.length) {
                        var value = values[index];
                        index = index + 1;
                        return {
                            done: false,
                            value: value
                        };
                    } else return {
                        done: true
                    };
                }
            };
            return iter;
        }
        var _default = iteratorProxy;
        exports1.default = _default;
    });
    unwrapExports(iteratorProxy_1);
    var iterationDecorator_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = iterationDecorator;
        var _iteratorProxy = _interopRequireDefault(iteratorProxy_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _typeof(obj) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _typeof(obj);
        }
        function iterationDecorator(collection, entries) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") Object.defineProperty(collection, Symbol.iterator, {
                value: _iteratorProxy.default.bind(entries)
            });
            return collection;
        }
    });
    unwrapExports(iterationDecorator_1);
    var ariaPropsMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var properties = [
            [
                "aria-activedescendant",
                {
                    "type": "id"
                }
            ],
            [
                "aria-atomic",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-autocomplete",
                {
                    "type": "token",
                    "values": [
                        "inline",
                        "list",
                        "both",
                        "none"
                    ]
                }
            ],
            [
                "aria-busy",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-checked",
                {
                    "type": "tristate"
                }
            ],
            [
                "aria-colcount",
                {
                    type: "integer"
                }
            ],
            [
                "aria-colindex",
                {
                    type: "integer"
                }
            ],
            [
                "aria-colspan",
                {
                    type: "integer"
                }
            ],
            [
                "aria-controls",
                {
                    "type": "idlist"
                }
            ],
            [
                "aria-current",
                {
                    type: "token",
                    values: [
                        "page",
                        "step",
                        "location",
                        "date",
                        "time",
                        true,
                        false
                    ]
                }
            ],
            [
                "aria-describedby",
                {
                    "type": "idlist"
                }
            ],
            [
                "aria-details",
                {
                    "type": "id"
                }
            ],
            [
                "aria-disabled",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-dropeffect",
                {
                    "type": "tokenlist",
                    "values": [
                        "copy",
                        "execute",
                        "link",
                        "move",
                        "none",
                        "popup"
                    ]
                }
            ],
            [
                "aria-errormessage",
                {
                    "type": "id"
                }
            ],
            [
                "aria-expanded",
                {
                    "type": "boolean",
                    "allowundefined": true
                }
            ],
            [
                "aria-flowto",
                {
                    "type": "idlist"
                }
            ],
            [
                "aria-grabbed",
                {
                    "type": "boolean",
                    "allowundefined": true
                }
            ],
            [
                "aria-haspopup",
                {
                    "type": "token",
                    "values": [
                        false,
                        true,
                        "menu",
                        "listbox",
                        "tree",
                        "grid",
                        "dialog"
                    ]
                }
            ],
            [
                "aria-hidden",
                {
                    "type": "boolean",
                    "allowundefined": true
                }
            ],
            [
                "aria-invalid",
                {
                    "type": "token",
                    "values": [
                        "grammar",
                        false,
                        "spelling",
                        true
                    ]
                }
            ],
            [
                "aria-keyshortcuts",
                {
                    type: "string"
                }
            ],
            [
                "aria-label",
                {
                    "type": "string"
                }
            ],
            [
                "aria-labelledby",
                {
                    "type": "idlist"
                }
            ],
            [
                "aria-level",
                {
                    "type": "integer"
                }
            ],
            [
                "aria-live",
                {
                    "type": "token",
                    "values": [
                        "assertive",
                        "off",
                        "polite"
                    ]
                }
            ],
            [
                "aria-modal",
                {
                    type: "boolean"
                }
            ],
            [
                "aria-multiline",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-multiselectable",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-orientation",
                {
                    "type": "token",
                    "values": [
                        "vertical",
                        "undefined",
                        "horizontal"
                    ]
                }
            ],
            [
                "aria-owns",
                {
                    "type": "idlist"
                }
            ],
            [
                "aria-placeholder",
                {
                    type: "string"
                }
            ],
            [
                "aria-posinset",
                {
                    "type": "integer"
                }
            ],
            [
                "aria-pressed",
                {
                    "type": "tristate"
                }
            ],
            [
                "aria-readonly",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-relevant",
                {
                    "type": "tokenlist",
                    "values": [
                        "additions",
                        "all",
                        "removals",
                        "text"
                    ]
                }
            ],
            [
                "aria-required",
                {
                    "type": "boolean"
                }
            ],
            [
                "aria-roledescription",
                {
                    type: "string"
                }
            ],
            [
                "aria-rowcount",
                {
                    type: "integer"
                }
            ],
            [
                "aria-rowindex",
                {
                    type: "integer"
                }
            ],
            [
                "aria-rowspan",
                {
                    type: "integer"
                }
            ],
            [
                "aria-selected",
                {
                    "type": "boolean",
                    "allowundefined": true
                }
            ],
            [
                "aria-setsize",
                {
                    "type": "integer"
                }
            ],
            [
                "aria-sort",
                {
                    "type": "token",
                    "values": [
                        "ascending",
                        "descending",
                        "none",
                        "other"
                    ]
                }
            ],
            [
                "aria-valuemax",
                {
                    "type": "number"
                }
            ],
            [
                "aria-valuemin",
                {
                    "type": "number"
                }
            ],
            [
                "aria-valuenow",
                {
                    "type": "number"
                }
            ],
            [
                "aria-valuetext",
                {
                    "type": "string"
                }
            ]
        ];
        var ariaPropsMap = {
            entries: function entries() {
                return properties;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator = _createForOfIteratorHelper(properties), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
                        fn.call(thisArg, values, key, properties);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            },
            get: function get(key) {
                var item = properties.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return properties.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return properties.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
        exports1.default = _default;
    });
    unwrapExports(ariaPropsMap_1);
    var domMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var dom = [
            [
                "a",
                {
                    reserved: false
                }
            ],
            [
                "abbr",
                {
                    reserved: false
                }
            ],
            [
                "acronym",
                {
                    reserved: false
                }
            ],
            [
                "address",
                {
                    reserved: false
                }
            ],
            [
                "applet",
                {
                    reserved: false
                }
            ],
            [
                "area",
                {
                    reserved: false
                }
            ],
            [
                "article",
                {
                    reserved: false
                }
            ],
            [
                "aside",
                {
                    reserved: false
                }
            ],
            [
                "audio",
                {
                    reserved: false
                }
            ],
            [
                "b",
                {
                    reserved: false
                }
            ],
            [
                "base",
                {
                    reserved: true
                }
            ],
            [
                "bdi",
                {
                    reserved: false
                }
            ],
            [
                "bdo",
                {
                    reserved: false
                }
            ],
            [
                "big",
                {
                    reserved: false
                }
            ],
            [
                "blink",
                {
                    reserved: false
                }
            ],
            [
                "blockquote",
                {
                    reserved: false
                }
            ],
            [
                "body",
                {
                    reserved: false
                }
            ],
            [
                "br",
                {
                    reserved: false
                }
            ],
            [
                "button",
                {
                    reserved: false
                }
            ],
            [
                "canvas",
                {
                    reserved: false
                }
            ],
            [
                "caption",
                {
                    reserved: false
                }
            ],
            [
                "center",
                {
                    reserved: false
                }
            ],
            [
                "cite",
                {
                    reserved: false
                }
            ],
            [
                "code",
                {
                    reserved: false
                }
            ],
            [
                "col",
                {
                    reserved: true
                }
            ],
            [
                "colgroup",
                {
                    reserved: true
                }
            ],
            [
                "content",
                {
                    reserved: false
                }
            ],
            [
                "data",
                {
                    reserved: false
                }
            ],
            [
                "datalist",
                {
                    reserved: false
                }
            ],
            [
                "dd",
                {
                    reserved: false
                }
            ],
            [
                "del",
                {
                    reserved: false
                }
            ],
            [
                "details",
                {
                    reserved: false
                }
            ],
            [
                "dfn",
                {
                    reserved: false
                }
            ],
            [
                "dialog",
                {
                    reserved: false
                }
            ],
            [
                "dir",
                {
                    reserved: false
                }
            ],
            [
                "div",
                {
                    reserved: false
                }
            ],
            [
                "dl",
                {
                    reserved: false
                }
            ],
            [
                "dt",
                {
                    reserved: false
                }
            ],
            [
                "em",
                {
                    reserved: false
                }
            ],
            [
                "embed",
                {
                    reserved: false
                }
            ],
            [
                "fieldset",
                {
                    reserved: false
                }
            ],
            [
                "figcaption",
                {
                    reserved: false
                }
            ],
            [
                "figure",
                {
                    reserved: false
                }
            ],
            [
                "font",
                {
                    reserved: false
                }
            ],
            [
                "footer",
                {
                    reserved: false
                }
            ],
            [
                "form",
                {
                    reserved: false
                }
            ],
            [
                "frame",
                {
                    reserved: false
                }
            ],
            [
                "frameset",
                {
                    reserved: false
                }
            ],
            [
                "h1",
                {
                    reserved: false
                }
            ],
            [
                "h2",
                {
                    reserved: false
                }
            ],
            [
                "h3",
                {
                    reserved: false
                }
            ],
            [
                "h4",
                {
                    reserved: false
                }
            ],
            [
                "h5",
                {
                    reserved: false
                }
            ],
            [
                "h6",
                {
                    reserved: false
                }
            ],
            [
                "head",
                {
                    reserved: true
                }
            ],
            [
                "header",
                {
                    reserved: false
                }
            ],
            [
                "hgroup",
                {
                    reserved: false
                }
            ],
            [
                "hr",
                {
                    reserved: false
                }
            ],
            [
                "html",
                {
                    reserved: true
                }
            ],
            [
                "i",
                {
                    reserved: false
                }
            ],
            [
                "iframe",
                {
                    reserved: false
                }
            ],
            [
                "img",
                {
                    reserved: false
                }
            ],
            [
                "input",
                {
                    reserved: false
                }
            ],
            [
                "ins",
                {
                    reserved: false
                }
            ],
            [
                "kbd",
                {
                    reserved: false
                }
            ],
            [
                "keygen",
                {
                    reserved: false
                }
            ],
            [
                "label",
                {
                    reserved: false
                }
            ],
            [
                "legend",
                {
                    reserved: false
                }
            ],
            [
                "li",
                {
                    reserved: false
                }
            ],
            [
                "link",
                {
                    reserved: true
                }
            ],
            [
                "main",
                {
                    reserved: false
                }
            ],
            [
                "map",
                {
                    reserved: false
                }
            ],
            [
                "mark",
                {
                    reserved: false
                }
            ],
            [
                "marquee",
                {
                    reserved: false
                }
            ],
            [
                "menu",
                {
                    reserved: false
                }
            ],
            [
                "menuitem",
                {
                    reserved: false
                }
            ],
            [
                "meta",
                {
                    reserved: true
                }
            ],
            [
                "meter",
                {
                    reserved: false
                }
            ],
            [
                "nav",
                {
                    reserved: false
                }
            ],
            [
                "noembed",
                {
                    reserved: true
                }
            ],
            [
                "noscript",
                {
                    reserved: true
                }
            ],
            [
                "object",
                {
                    reserved: false
                }
            ],
            [
                "ol",
                {
                    reserved: false
                }
            ],
            [
                "optgroup",
                {
                    reserved: false
                }
            ],
            [
                "option",
                {
                    reserved: false
                }
            ],
            [
                "output",
                {
                    reserved: false
                }
            ],
            [
                "p",
                {
                    reserved: false
                }
            ],
            [
                "param",
                {
                    reserved: true
                }
            ],
            [
                "picture",
                {
                    reserved: true
                }
            ],
            [
                "pre",
                {
                    reserved: false
                }
            ],
            [
                "progress",
                {
                    reserved: false
                }
            ],
            [
                "q",
                {
                    reserved: false
                }
            ],
            [
                "rp",
                {
                    reserved: false
                }
            ],
            [
                "rt",
                {
                    reserved: false
                }
            ],
            [
                "rtc",
                {
                    reserved: false
                }
            ],
            [
                "ruby",
                {
                    reserved: false
                }
            ],
            [
                "s",
                {
                    reserved: false
                }
            ],
            [
                "samp",
                {
                    reserved: false
                }
            ],
            [
                "script",
                {
                    reserved: true
                }
            ],
            [
                "section",
                {
                    reserved: false
                }
            ],
            [
                "select",
                {
                    reserved: false
                }
            ],
            [
                "small",
                {
                    reserved: false
                }
            ],
            [
                "source",
                {
                    reserved: true
                }
            ],
            [
                "spacer",
                {
                    reserved: false
                }
            ],
            [
                "span",
                {
                    reserved: false
                }
            ],
            [
                "strike",
                {
                    reserved: false
                }
            ],
            [
                "strong",
                {
                    reserved: false
                }
            ],
            [
                "style",
                {
                    reserved: true
                }
            ],
            [
                "sub",
                {
                    reserved: false
                }
            ],
            [
                "summary",
                {
                    reserved: false
                }
            ],
            [
                "sup",
                {
                    reserved: false
                }
            ],
            [
                "table",
                {
                    reserved: false
                }
            ],
            [
                "tbody",
                {
                    reserved: false
                }
            ],
            [
                "td",
                {
                    reserved: false
                }
            ],
            [
                "textarea",
                {
                    reserved: false
                }
            ],
            [
                "tfoot",
                {
                    reserved: false
                }
            ],
            [
                "th",
                {
                    reserved: false
                }
            ],
            [
                "thead",
                {
                    reserved: false
                }
            ],
            [
                "time",
                {
                    reserved: false
                }
            ],
            [
                "title",
                {
                    reserved: true
                }
            ],
            [
                "tr",
                {
                    reserved: false
                }
            ],
            [
                "track",
                {
                    reserved: true
                }
            ],
            [
                "tt",
                {
                    reserved: false
                }
            ],
            [
                "u",
                {
                    reserved: false
                }
            ],
            [
                "ul",
                {
                    reserved: false
                }
            ],
            [
                "var",
                {
                    reserved: false
                }
            ],
            [
                "video",
                {
                    reserved: false
                }
            ],
            [
                "wbr",
                {
                    reserved: false
                }
            ],
            [
                "xmp",
                {
                    reserved: false
                }
            ]
        ];
        var domMap = {
            entries: function entries() {
                return dom;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator = _createForOfIteratorHelper(dom), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
                        fn.call(thisArg, values, key, dom);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            },
            get: function get(key) {
                var item = dom.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return dom.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return dom.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
        exports1.default = _default;
    });
    unwrapExports(domMap_1);
    var commandRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var commandRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "menuitem"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = commandRole;
        exports1.default = _default;
    });
    unwrapExports(commandRole_1);
    var compositeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var compositeRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-activedescendant": null,
                "aria-disabled": null
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = compositeRole;
        exports1.default = _default;
    });
    unwrapExports(compositeRole_1);
    var inputRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var inputRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "input"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = inputRole;
        exports1.default = _default;
    });
    unwrapExports(inputRole_1);
    var landmarkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var landmarkRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = landmarkRole;
        exports1.default = _default;
    });
    unwrapExports(landmarkRole_1);
    var rangeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var rangeRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-valuemax": null,
                "aria-valuemin": null,
                "aria-valuenow": null
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = rangeRole;
        exports1.default = _default;
    });
    unwrapExports(rangeRole_1);
    var roletypeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var roletypeRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [],
            prohibitedProps: [],
            props: {
                "aria-atomic": null,
                "aria-busy": null,
                "aria-controls": null,
                "aria-current": null,
                "aria-describedby": null,
                "aria-details": null,
                "aria-dropeffect": null,
                "aria-flowto": null,
                "aria-grabbed": null,
                "aria-hidden": null,
                "aria-keyshortcuts": null,
                "aria-label": null,
                "aria-labelledby": null,
                "aria-live": null,
                "aria-owns": null,
                "aria-relevant": null,
                "aria-roledescription": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "rel"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "role"
                    },
                    module: "XHTML"
                },
                {
                    concept: {
                        name: "type"
                    },
                    module: "Dublin Core"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: []
        };
        var _default = roletypeRole;
        exports1.default = _default;
    });
    unwrapExports(roletypeRole_1);
    var sectionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var sectionRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "frontmatter"
                    },
                    module: "DTB"
                },
                {
                    concept: {
                        name: "level"
                    },
                    module: "DTB"
                },
                {
                    concept: {
                        name: "level"
                    },
                    module: "SMIL"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = sectionRole;
        exports1.default = _default;
    });
    unwrapExports(sectionRole_1);
    var sectionheadRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var sectionheadRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = sectionheadRole;
        exports1.default = _default;
    });
    unwrapExports(sectionheadRole_1);
    var selectRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var selectRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-orientation": null
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group"
                ]
            ]
        };
        var _default = selectRole;
        exports1.default = _default;
    });
    unwrapExports(selectRole_1);
    var structureRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var structureRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype"
                ]
            ]
        };
        var _default = structureRole;
        exports1.default = _default;
    });
    unwrapExports(structureRole_1);
    var widgetRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var widgetRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype"
                ]
            ]
        };
        var _default = widgetRole;
        exports1.default = _default;
    });
    unwrapExports(widgetRole_1);
    var windowRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var windowRole = {
            abstract: true,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-modal": null
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype"
                ]
            ]
        };
        var _default = windowRole;
        exports1.default = _default;
    });
    unwrapExports(windowRole_1);
    var ariaAbstractRoles_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _commandRole = _interopRequireDefault(commandRole_1);
        var _compositeRole = _interopRequireDefault(compositeRole_1);
        var _inputRole = _interopRequireDefault(inputRole_1);
        var _landmarkRole = _interopRequireDefault(landmarkRole_1);
        var _rangeRole = _interopRequireDefault(rangeRole_1);
        var _roletypeRole = _interopRequireDefault(roletypeRole_1);
        var _sectionRole = _interopRequireDefault(sectionRole_1);
        var _sectionheadRole = _interopRequireDefault(sectionheadRole_1);
        var _selectRole = _interopRequireDefault(selectRole_1);
        var _structureRole = _interopRequireDefault(structureRole_1);
        var _widgetRole = _interopRequireDefault(widgetRole_1);
        var _windowRole = _interopRequireDefault(windowRole_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var ariaAbstractRoles = [
            [
                "command",
                _commandRole.default
            ],
            [
                "composite",
                _compositeRole.default
            ],
            [
                "input",
                _inputRole.default
            ],
            [
                "landmark",
                _landmarkRole.default
            ],
            [
                "range",
                _rangeRole.default
            ],
            [
                "roletype",
                _roletypeRole.default
            ],
            [
                "section",
                _sectionRole.default
            ],
            [
                "sectionhead",
                _sectionheadRole.default
            ],
            [
                "select",
                _selectRole.default
            ],
            [
                "structure",
                _structureRole.default
            ],
            [
                "widget",
                _widgetRole.default
            ],
            [
                "window",
                _windowRole.default
            ]
        ];
        var _default = ariaAbstractRoles;
        exports1.default = _default;
    });
    unwrapExports(ariaAbstractRoles_1);
    var alertRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var alertRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-atomic": "true",
                "aria-live": "assertive"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "alert"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = alertRole;
        exports1.default = _default;
    });
    unwrapExports(alertRole_1);
    var alertdialogRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var alertdialogRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "alert"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "alert"
                ],
                [
                    "roletype",
                    "window",
                    "dialog"
                ]
            ]
        };
        var _default = alertdialogRole;
        exports1.default = _default;
    });
    unwrapExports(alertdialogRole_1);
    var applicationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var applicationRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-activedescendant": null,
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "Device Independence Delivery Unit"
                    }
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = applicationRole;
        exports1.default = _default;
    });
    unwrapExports(applicationRole_1);
    var articleRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var articleRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-posinset": null,
                "aria-setsize": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "article"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "document"
                ]
            ]
        };
        var _default = articleRole;
        exports1.default = _default;
    });
    unwrapExports(articleRole_1);
    var bannerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var bannerRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        constraints: [
                            "direct descendant of document"
                        ],
                        name: "header"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = bannerRole;
        exports1.default = _default;
    });
    unwrapExports(bannerRole_1);
    var blockquoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var blockquoteRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = blockquoteRole;
        exports1.default = _default;
    });
    unwrapExports(blockquoteRole_1);
    var buttonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var buttonRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-pressed": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "aria-pressed"
                            },
                            {
                                name: "type",
                                value: "checkbox"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "aria-expanded",
                                value: "false"
                            }
                        ],
                        name: "summary"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "aria-expanded",
                                value: "true"
                            }
                        ],
                        constraints: [
                            "direct descendant of details element with the open attribute defined"
                        ],
                        name: "summary"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "button"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "image"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "reset"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "submit"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "button"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "trigger"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command"
                ]
            ]
        };
        var _default = buttonRole;
        exports1.default = _default;
    });
    unwrapExports(buttonRole_1);
    var captionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var captionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [
                "figure",
                "grid",
                "table"
            ],
            requiredContextRole: [
                "figure",
                "grid",
                "table"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = captionRole;
        exports1.default = _default;
    });
    unwrapExports(captionRole_1);
    var cellRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var cellRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-colindex": null,
                "aria-colspan": null,
                "aria-rowindex": null,
                "aria-rowspan": null
            },
            relatedConcepts: [
                {
                    concept: {
                        constraints: [
                            "descendant of table"
                        ],
                        name: "td"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "row"
            ],
            requiredContextRole: [
                "row"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = cellRole;
        exports1.default = _default;
    });
    unwrapExports(cellRole_1);
    var checkboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var checkboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-checked": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-required": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "checkbox"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "option"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-checked": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ]
            ]
        };
        var _default = checkboxRole;
        exports1.default = _default;
    });
    unwrapExports(checkboxRole_1);
    var codeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var codeRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = codeRole;
        exports1.default = _default;
    });
    unwrapExports(codeRole_1);
    var columnheaderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var columnheaderRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-sort": null
            },
            relatedConcepts: [
                {
                    attributes: [
                        {
                            name: "scope",
                            value: "col"
                        }
                    ],
                    concept: {
                        name: "th"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "row"
            ],
            requiredContextRole: [
                "row"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "cell"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "cell",
                    "gridcell"
                ],
                [
                    "roletype",
                    "widget",
                    "gridcell"
                ],
                [
                    "roletype",
                    "structure",
                    "sectionhead"
                ]
            ]
        };
        var _default = columnheaderRole;
        exports1.default = _default;
    });
    unwrapExports(columnheaderRole_1);
    var comboboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var comboboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-activedescendant": null,
                "aria-autocomplete": null,
                "aria-errormessage": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-required": null,
                "aria-expanded": "false",
                "aria-haspopup": "listbox"
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "email"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "search"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "tel"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "text"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "url"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "url"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "multiple"
                            },
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "size"
                            }
                        ],
                        name: "select"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "multiple"
                            },
                            {
                                name: "size",
                                value: 1
                            }
                        ],
                        name: "select"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "select"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-controls": null,
                "aria-expanded": "false"
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ]
            ]
        };
        var _default = comboboxRole;
        exports1.default = _default;
    });
    unwrapExports(comboboxRole_1);
    var complementaryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var complementaryRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "aside"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = complementaryRole;
        exports1.default = _default;
    });
    unwrapExports(complementaryRole_1);
    var contentinfoRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var contentinfoRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        constraints: [
                            "direct descendant of document"
                        ],
                        name: "footer"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = contentinfoRole;
        exports1.default = _default;
    });
    unwrapExports(contentinfoRole_1);
    var definitionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var definitionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "dd"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = definitionRole;
        exports1.default = _default;
    });
    unwrapExports(definitionRole_1);
    var deletionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var deletionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = deletionRole;
        exports1.default = _default;
    });
    unwrapExports(deletionRole_1);
    var dialogRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var dialogRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "dialog"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "window"
                ]
            ]
        };
        var _default = dialogRole;
        exports1.default = _default;
    });
    unwrapExports(dialogRole_1);
    var directoryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var directoryRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    module: "DAISY Guide"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "list"
                ]
            ]
        };
        var _default = directoryRole;
        exports1.default = _default;
    });
    unwrapExports(directoryRole_1);
    var documentRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var documentRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "Device Independence Delivery Unit"
                    }
                },
                {
                    concept: {
                        name: "body"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = documentRole;
        exports1.default = _default;
    });
    unwrapExports(documentRole_1);
    var emphasisRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var emphasisRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = emphasisRole;
        exports1.default = _default;
    });
    unwrapExports(emphasisRole_1);
    var feedRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var feedRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "article"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "list"
                ]
            ]
        };
        var _default = feedRole;
        exports1.default = _default;
    });
    unwrapExports(feedRole_1);
    var figureRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var figureRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "figure"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = figureRole;
        exports1.default = _default;
    });
    unwrapExports(figureRole_1);
    var formRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var formRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "aria-label"
                            }
                        ],
                        name: "form"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "aria-labelledby"
                            }
                        ],
                        name: "form"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "name"
                            }
                        ],
                        name: "form"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = formRole;
        exports1.default = _default;
    });
    unwrapExports(formRole_1);
    var genericRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var genericRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "span"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "div"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = genericRole;
        exports1.default = _default;
    });
    unwrapExports(genericRole_1);
    var gridRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var gridRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-multiselectable": null,
                "aria-readonly": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "role",
                                value: "grid"
                            }
                        ],
                        name: "table"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "row"
                ],
                [
                    "row",
                    "rowgroup"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "table"
                ]
            ]
        };
        var _default = gridRole;
        exports1.default = _default;
    });
    unwrapExports(gridRole_1);
    var gridcellRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var gridcellRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-required": null,
                "aria-selected": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "role",
                                value: "gridcell"
                            }
                        ],
                        name: "td"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "row"
            ],
            requiredContextRole: [
                "row"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "cell"
                ],
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = gridcellRole;
        exports1.default = _default;
    });
    unwrapExports(gridcellRole_1);
    var groupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var groupRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-activedescendant": null,
                "aria-disabled": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "details"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "fieldset"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "optgroup"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = groupRole;
        exports1.default = _default;
    });
    unwrapExports(groupRole_1);
    var headingRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var headingRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-level": "2"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "h1"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "h2"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "h3"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "h4"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "h5"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "h6"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-level": "2"
            },
            superClass: [
                [
                    "roletype",
                    "structure",
                    "sectionhead"
                ]
            ]
        };
        var _default = headingRole;
        exports1.default = _default;
    });
    unwrapExports(headingRole_1);
    var imgRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var imgRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "alt"
                            }
                        ],
                        name: "img"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "alt"
                            }
                        ],
                        name: "img"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "imggroup"
                    },
                    module: "DTB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = imgRole;
        exports1.default = _default;
    });
    unwrapExports(imgRole_1);
    var insertionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var insertionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = insertionRole;
        exports1.default = _default;
    });
    unwrapExports(insertionRole_1);
    var linkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var linkRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-expanded": null,
                "aria-haspopup": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "href"
                            }
                        ],
                        name: "a"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "href"
                            }
                        ],
                        name: "area"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "href"
                            }
                        ],
                        name: "link"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command"
                ]
            ]
        };
        var _default = linkRole;
        exports1.default = _default;
    });
    unwrapExports(linkRole_1);
    var listRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var listRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "menu"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "ol"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "ul"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "listitem"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = listRole;
        exports1.default = _default;
    });
    unwrapExports(listRole_1);
    var listboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var listboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-invalid": null,
                "aria-multiselectable": null,
                "aria-readonly": null,
                "aria-required": null,
                "aria-orientation": "vertical"
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    ">1"
                                ],
                                name: "size"
                            },
                            {
                                name: "multiple"
                            }
                        ],
                        name: "select"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    ">1"
                                ],
                                name: "size"
                            }
                        ],
                        name: "select"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "multiple"
                            }
                        ],
                        name: "select"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "datalist"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "list"
                    },
                    module: "ARIA"
                },
                {
                    concept: {
                        name: "select"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "option",
                    "group"
                ],
                [
                    "option"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select"
                ]
            ]
        };
        var _default = listboxRole;
        exports1.default = _default;
    });
    unwrapExports(listboxRole_1);
    var listitemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var listitemRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-level": null,
                "aria-posinset": null,
                "aria-setsize": null
            },
            relatedConcepts: [
                {
                    concept: {
                        constraints: [
                            "direct descendant of ol, ul or menu"
                        ],
                        name: "li"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "item"
                    },
                    module: "XForms"
                }
            ],
            requireContextRole: [
                "directory",
                "list"
            ],
            requiredContextRole: [
                "directory",
                "list"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = listitemRole;
        exports1.default = _default;
    });
    unwrapExports(listitemRole_1);
    var logRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var logRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-live": "polite"
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = logRole;
        exports1.default = _default;
    });
    unwrapExports(logRole_1);
    var mainRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var mainRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "main"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = mainRole;
        exports1.default = _default;
    });
    unwrapExports(mainRole_1);
    var marqueeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var marqueeRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = marqueeRole;
        exports1.default = _default;
    });
    unwrapExports(marqueeRole_1);
    var mathRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var mathRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "math"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = mathRole;
        exports1.default = _default;
    });
    unwrapExports(mathRole_1);
    var menuRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var menuRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-orientation": "vertical"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "MENU"
                    },
                    module: "JAPI"
                },
                {
                    concept: {
                        name: "list"
                    },
                    module: "ARIA"
                },
                {
                    concept: {
                        name: "select"
                    },
                    module: "XForms"
                },
                {
                    concept: {
                        name: "sidebar"
                    },
                    module: "DTB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "menuitem",
                    "group"
                ],
                [
                    "menuitemradio",
                    "group"
                ],
                [
                    "menuitemcheckbox",
                    "group"
                ],
                [
                    "menuitem"
                ],
                [
                    "menuitemcheckbox"
                ],
                [
                    "menuitemradio"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select"
                ]
            ]
        };
        var _default = menuRole;
        exports1.default = _default;
    });
    unwrapExports(menuRole_1);
    var menubarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var menubarRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-orientation": "horizontal"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "toolbar"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "menuitem",
                    "group"
                ],
                [
                    "menuitemradio",
                    "group"
                ],
                [
                    "menuitemcheckbox",
                    "group"
                ],
                [
                    "menuitem"
                ],
                [
                    "menuitemcheckbox"
                ],
                [
                    "menuitemradio"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select",
                    "menu"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select",
                    "menu"
                ]
            ]
        };
        var _default = menubarRole;
        exports1.default = _default;
    });
    unwrapExports(menubarRole_1);
    var menuitemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var menuitemRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-posinset": null,
                "aria-setsize": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "MENU_ITEM"
                    },
                    module: "JAPI"
                },
                {
                    concept: {
                        name: "listitem"
                    },
                    module: "ARIA"
                },
                {
                    concept: {
                        name: "menuitem"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "option"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command"
                ]
            ]
        };
        var _default = menuitemRole;
        exports1.default = _default;
    });
    unwrapExports(menuitemRole_1);
    var menuitemcheckboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var menuitemcheckboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "menuitem"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-checked": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input",
                    "checkbox"
                ],
                [
                    "roletype",
                    "widget",
                    "command",
                    "menuitem"
                ]
            ]
        };
        var _default = menuitemcheckboxRole;
        exports1.default = _default;
    });
    unwrapExports(menuitemcheckboxRole_1);
    var menuitemradioRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var menuitemradioRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "menuitem"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredContextRole: [
                "group",
                "menu",
                "menubar"
            ],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-checked": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input",
                    "checkbox",
                    "menuitemcheckbox"
                ],
                [
                    "roletype",
                    "widget",
                    "command",
                    "menuitem",
                    "menuitemcheckbox"
                ],
                [
                    "roletype",
                    "widget",
                    "input",
                    "radio"
                ]
            ]
        };
        var _default = menuitemradioRole;
        exports1.default = _default;
    });
    unwrapExports(menuitemradioRole_1);
    var meterRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var meterRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-valuetext": null,
                "aria-valuemax": "100",
                "aria-valuemin": "0"
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-valuenow": null
            },
            superClass: [
                [
                    "roletype",
                    "structure",
                    "range"
                ]
            ]
        };
        var _default = meterRole;
        exports1.default = _default;
    });
    unwrapExports(meterRole_1);
    var navigationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var navigationRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "nav"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = navigationRole;
        exports1.default = _default;
    });
    unwrapExports(navigationRole_1);
    var noneRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var noneRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: []
        };
        var _default = noneRole;
        exports1.default = _default;
    });
    unwrapExports(noneRole_1);
    var noteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var noteRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = noteRole;
        exports1.default = _default;
    });
    unwrapExports(noteRole_1);
    var optionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var optionRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-checked": null,
                "aria-posinset": null,
                "aria-setsize": null,
                "aria-selected": "false"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "item"
                    },
                    module: "XForms"
                },
                {
                    concept: {
                        name: "listitem"
                    },
                    module: "ARIA"
                },
                {
                    concept: {
                        name: "option"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-selected": "false"
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ]
            ]
        };
        var _default = optionRole;
        exports1.default = _default;
    });
    unwrapExports(optionRole_1);
    var paragraphRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var paragraphRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = paragraphRole;
        exports1.default = _default;
    });
    unwrapExports(paragraphRole_1);
    var presentationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var presentationRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = presentationRole;
        exports1.default = _default;
    });
    unwrapExports(presentationRole_1);
    var progressbarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var progressbarRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-valuetext": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "progress"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "status"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "range"
                ],
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = progressbarRole;
        exports1.default = _default;
    });
    unwrapExports(progressbarRole_1);
    var radioRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var radioRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-checked": null,
                "aria-posinset": null,
                "aria-setsize": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "radio"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-checked": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ]
            ]
        };
        var _default = radioRole;
        exports1.default = _default;
    });
    unwrapExports(radioRole_1);
    var radiogroupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var radiogroupRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-required": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "list"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "radio"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select"
                ]
            ]
        };
        var _default = radiogroupRole;
        exports1.default = _default;
    });
    unwrapExports(radiogroupRole_1);
    var regionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var regionRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "aria-label"
                            }
                        ],
                        name: "section"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "set"
                                ],
                                name: "aria-labelledby"
                            }
                        ],
                        name: "section"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "Device Independence Glossart perceivable unit"
                    }
                },
                {
                    concept: {
                        name: "frame"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = regionRole;
        exports1.default = _default;
    });
    unwrapExports(regionRole_1);
    var rowRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var rowRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-colindex": null,
                "aria-expanded": null,
                "aria-level": null,
                "aria-posinset": null,
                "aria-rowindex": null,
                "aria-selected": null,
                "aria-setsize": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "tr"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "grid",
                "rowgroup",
                "table",
                "treegrid"
            ],
            requiredContextRole: [
                "grid",
                "rowgroup",
                "table",
                "treegrid"
            ],
            requiredOwnedElements: [
                [
                    "cell"
                ],
                [
                    "columnheader"
                ],
                [
                    "gridcell"
                ],
                [
                    "rowheader"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "group"
                ],
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = rowRole;
        exports1.default = _default;
    });
    unwrapExports(rowRole_1);
    var rowgroupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var rowgroupRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "tbody"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "tfoot"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "thead"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "grid",
                "table",
                "treegrid"
            ],
            requiredContextRole: [
                "grid",
                "table",
                "treegrid"
            ],
            requiredOwnedElements: [
                [
                    "row"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = rowgroupRole;
        exports1.default = _default;
    });
    unwrapExports(rowgroupRole_1);
    var rowheaderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var rowheaderRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-sort": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "scope",
                                value: "row"
                            }
                        ],
                        name: "th"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                name: "scope",
                                value: "rowgroup"
                            }
                        ],
                        name: "th"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [
                "row",
                "rowgroup"
            ],
            requiredContextRole: [
                "row",
                "rowgroup"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "cell"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "cell",
                    "gridcell"
                ],
                [
                    "roletype",
                    "widget",
                    "gridcell"
                ],
                [
                    "roletype",
                    "structure",
                    "sectionhead"
                ]
            ]
        };
        var _default = rowheaderRole;
        exports1.default = _default;
    });
    unwrapExports(rowheaderRole_1);
    var scrollbarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var scrollbarRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-valuetext": null,
                "aria-orientation": "vertical",
                "aria-valuemax": "100",
                "aria-valuemin": "0"
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-controls": null,
                "aria-valuenow": null
            },
            superClass: [
                [
                    "roletype",
                    "structure",
                    "range"
                ],
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = scrollbarRole;
        exports1.default = _default;
    });
    unwrapExports(scrollbarRole_1);
    var searchRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var searchRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = searchRole;
        exports1.default = _default;
    });
    unwrapExports(searchRole_1);
    var searchboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var searchboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "search"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input",
                    "textbox"
                ]
            ]
        };
        var _default = searchboxRole;
        exports1.default = _default;
    });
    unwrapExports(searchboxRole_1);
    var separatorRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var separatorRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-orientation": "horizontal",
                "aria-valuemax": "100",
                "aria-valuemin": "0",
                "aria-valuenow": null,
                "aria-valuetext": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "hr"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure"
                ]
            ]
        };
        var _default = separatorRole;
        exports1.default = _default;
    });
    unwrapExports(separatorRole_1);
    var sliderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var sliderRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-haspopup": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-valuetext": null,
                "aria-orientation": "horizontal",
                "aria-valuemax": "100",
                "aria-valuemin": "0"
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "range"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-valuenow": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ],
                [
                    "roletype",
                    "structure",
                    "range"
                ]
            ]
        };
        var _default = sliderRole;
        exports1.default = _default;
    });
    unwrapExports(sliderRole_1);
    var spinbuttonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var spinbuttonRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null,
                "aria-readonly": null,
                "aria-required": null,
                "aria-valuetext": null,
                "aria-valuenow": "0"
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                name: "type",
                                value: "number"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite"
                ],
                [
                    "roletype",
                    "widget",
                    "input"
                ],
                [
                    "roletype",
                    "structure",
                    "range"
                ]
            ]
        };
        var _default = spinbuttonRole;
        exports1.default = _default;
    });
    unwrapExports(spinbuttonRole_1);
    var statusRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var statusRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-atomic": "true",
                "aria-live": "polite"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "output"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = statusRole;
        exports1.default = _default;
    });
    unwrapExports(statusRole_1);
    var strongRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var strongRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = strongRole;
        exports1.default = _default;
    });
    unwrapExports(strongRole_1);
    var subscriptRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var subscriptRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = subscriptRole;
        exports1.default = _default;
    });
    unwrapExports(subscriptRole_1);
    var superscriptRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var superscriptRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "prohibited"
            ],
            prohibitedProps: [
                "aria-label",
                "aria-labelledby"
            ],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = superscriptRole;
        exports1.default = _default;
    });
    unwrapExports(superscriptRole_1);
    var switchRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var switchRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "button"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-checked": null
            },
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input",
                    "checkbox"
                ]
            ]
        };
        var _default = switchRole;
        exports1.default = _default;
    });
    unwrapExports(switchRole_1);
    var tabRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var tabRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-posinset": null,
                "aria-setsize": null,
                "aria-selected": "false"
            },
            relatedConcepts: [],
            requireContextRole: [
                "tablist"
            ],
            requiredContextRole: [
                "tablist"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "sectionhead"
                ],
                [
                    "roletype",
                    "widget"
                ]
            ]
        };
        var _default = tabRole;
        exports1.default = _default;
    });
    unwrapExports(tabRole_1);
    var tableRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var tableRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-colcount": null,
                "aria-rowcount": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "table"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "row"
                ],
                [
                    "row",
                    "rowgroup"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = tableRole;
        exports1.default = _default;
    });
    unwrapExports(tableRole_1);
    var tablistRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var tablistRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-level": null,
                "aria-multiselectable": null,
                "aria-orientation": "horizontal"
            },
            relatedConcepts: [
                {
                    module: "DAISY",
                    concept: {
                        name: "guide"
                    }
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "tab"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite"
                ]
            ]
        };
        var _default = tablistRole;
        exports1.default = _default;
    });
    unwrapExports(tablistRole_1);
    var tabpanelRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var tabpanelRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = tabpanelRole;
        exports1.default = _default;
    });
    unwrapExports(tabpanelRole_1);
    var termRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var termRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "dfn"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "dt"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = termRole;
        exports1.default = _default;
    });
    unwrapExports(termRole_1);
    var textboxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var textboxRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-activedescendant": null,
                "aria-autocomplete": null,
                "aria-errormessage": null,
                "aria-haspopup": null,
                "aria-invalid": null,
                "aria-multiline": null,
                "aria-placeholder": null,
                "aria-readonly": null,
                "aria-required": null
            },
            relatedConcepts: [
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "type"
                            },
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "email"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "tel"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "text"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        attributes: [
                            {
                                constraints: [
                                    "undefined"
                                ],
                                name: "list"
                            },
                            {
                                name: "type",
                                value: "url"
                            }
                        ],
                        name: "input"
                    },
                    module: "HTML"
                },
                {
                    concept: {
                        name: "input"
                    },
                    module: "XForms"
                },
                {
                    concept: {
                        name: "textarea"
                    },
                    module: "HTML"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "input"
                ]
            ]
        };
        var _default = textboxRole;
        exports1.default = _default;
    });
    unwrapExports(textboxRole_1);
    var timeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var timeRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = timeRole;
        exports1.default = _default;
    });
    unwrapExports(timeRole_1);
    var timerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var timerRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "status"
                ]
            ]
        };
        var _default = timerRole;
        exports1.default = _default;
    });
    unwrapExports(timerRole_1);
    var toolbarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var toolbarRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-orientation": "horizontal"
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "menubar"
                    },
                    module: "ARIA"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "group"
                ]
            ]
        };
        var _default = toolbarRole;
        exports1.default = _default;
    });
    unwrapExports(toolbarRole_1);
    var tooltipRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var tooltipRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = tooltipRole;
        exports1.default = _default;
    });
    unwrapExports(tooltipRole_1);
    var treeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var treeRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null,
                "aria-multiselectable": null,
                "aria-required": null,
                "aria-orientation": "vertical"
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "treeitem",
                    "group"
                ],
                [
                    "treeitem"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select"
                ]
            ]
        };
        var _default = treeRole;
        exports1.default = _default;
    });
    unwrapExports(treeRole_1);
    var treegridRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var treegridRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "row"
                ],
                [
                    "row",
                    "rowgroup"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "composite",
                    "grid"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "table",
                    "grid"
                ],
                [
                    "roletype",
                    "widget",
                    "composite",
                    "select",
                    "tree"
                ],
                [
                    "roletype",
                    "structure",
                    "section",
                    "group",
                    "select",
                    "tree"
                ]
            ]
        };
        var _default = treegridRole;
        exports1.default = _default;
    });
    unwrapExports(treegridRole_1);
    var treeitemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var treeitemRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-expanded": null,
                "aria-haspopup": null
            },
            relatedConcepts: [],
            requireContextRole: [
                "group",
                "tree"
            ],
            requiredContextRole: [
                "group",
                "tree"
            ],
            requiredOwnedElements: [],
            requiredProps: {
                "aria-selected": null
            },
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "listitem"
                ],
                [
                    "roletype",
                    "widget",
                    "input",
                    "option"
                ]
            ]
        };
        var _default = treeitemRole;
        exports1.default = _default;
    });
    unwrapExports(treeitemRole_1);
    var ariaLiteralRoles_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _alertRole = _interopRequireDefault(alertRole_1);
        var _alertdialogRole = _interopRequireDefault(alertdialogRole_1);
        var _applicationRole = _interopRequireDefault(applicationRole_1);
        var _articleRole = _interopRequireDefault(articleRole_1);
        var _bannerRole = _interopRequireDefault(bannerRole_1);
        var _blockquoteRole = _interopRequireDefault(blockquoteRole_1);
        var _buttonRole = _interopRequireDefault(buttonRole_1);
        var _captionRole = _interopRequireDefault(captionRole_1);
        var _cellRole = _interopRequireDefault(cellRole_1);
        var _checkboxRole = _interopRequireDefault(checkboxRole_1);
        var _codeRole = _interopRequireDefault(codeRole_1);
        var _columnheaderRole = _interopRequireDefault(columnheaderRole_1);
        var _comboboxRole = _interopRequireDefault(comboboxRole_1);
        var _complementaryRole = _interopRequireDefault(complementaryRole_1);
        var _contentinfoRole = _interopRequireDefault(contentinfoRole_1);
        var _definitionRole = _interopRequireDefault(definitionRole_1);
        var _deletionRole = _interopRequireDefault(deletionRole_1);
        var _dialogRole = _interopRequireDefault(dialogRole_1);
        var _directoryRole = _interopRequireDefault(directoryRole_1);
        var _documentRole = _interopRequireDefault(documentRole_1);
        var _emphasisRole = _interopRequireDefault(emphasisRole_1);
        var _feedRole = _interopRequireDefault(feedRole_1);
        var _figureRole = _interopRequireDefault(figureRole_1);
        var _formRole = _interopRequireDefault(formRole_1);
        var _genericRole = _interopRequireDefault(genericRole_1);
        var _gridRole = _interopRequireDefault(gridRole_1);
        var _gridcellRole = _interopRequireDefault(gridcellRole_1);
        var _groupRole = _interopRequireDefault(groupRole_1);
        var _headingRole = _interopRequireDefault(headingRole_1);
        var _imgRole = _interopRequireDefault(imgRole_1);
        var _insertionRole = _interopRequireDefault(insertionRole_1);
        var _linkRole = _interopRequireDefault(linkRole_1);
        var _listRole = _interopRequireDefault(listRole_1);
        var _listboxRole = _interopRequireDefault(listboxRole_1);
        var _listitemRole = _interopRequireDefault(listitemRole_1);
        var _logRole = _interopRequireDefault(logRole_1);
        var _mainRole = _interopRequireDefault(mainRole_1);
        var _marqueeRole = _interopRequireDefault(marqueeRole_1);
        var _mathRole = _interopRequireDefault(mathRole_1);
        var _menuRole = _interopRequireDefault(menuRole_1);
        var _menubarRole = _interopRequireDefault(menubarRole_1);
        var _menuitemRole = _interopRequireDefault(menuitemRole_1);
        var _menuitemcheckboxRole = _interopRequireDefault(menuitemcheckboxRole_1);
        var _menuitemradioRole = _interopRequireDefault(menuitemradioRole_1);
        var _meterRole = _interopRequireDefault(meterRole_1);
        var _navigationRole = _interopRequireDefault(navigationRole_1);
        var _noneRole = _interopRequireDefault(noneRole_1);
        var _noteRole = _interopRequireDefault(noteRole_1);
        var _optionRole = _interopRequireDefault(optionRole_1);
        var _paragraphRole = _interopRequireDefault(paragraphRole_1);
        var _presentationRole = _interopRequireDefault(presentationRole_1);
        var _progressbarRole = _interopRequireDefault(progressbarRole_1);
        var _radioRole = _interopRequireDefault(radioRole_1);
        var _radiogroupRole = _interopRequireDefault(radiogroupRole_1);
        var _regionRole = _interopRequireDefault(regionRole_1);
        var _rowRole = _interopRequireDefault(rowRole_1);
        var _rowgroupRole = _interopRequireDefault(rowgroupRole_1);
        var _rowheaderRole = _interopRequireDefault(rowheaderRole_1);
        var _scrollbarRole = _interopRequireDefault(scrollbarRole_1);
        var _searchRole = _interopRequireDefault(searchRole_1);
        var _searchboxRole = _interopRequireDefault(searchboxRole_1);
        var _separatorRole = _interopRequireDefault(separatorRole_1);
        var _sliderRole = _interopRequireDefault(sliderRole_1);
        var _spinbuttonRole = _interopRequireDefault(spinbuttonRole_1);
        var _statusRole = _interopRequireDefault(statusRole_1);
        var _strongRole = _interopRequireDefault(strongRole_1);
        var _subscriptRole = _interopRequireDefault(subscriptRole_1);
        var _superscriptRole = _interopRequireDefault(superscriptRole_1);
        var _switchRole = _interopRequireDefault(switchRole_1);
        var _tabRole = _interopRequireDefault(tabRole_1);
        var _tableRole = _interopRequireDefault(tableRole_1);
        var _tablistRole = _interopRequireDefault(tablistRole_1);
        var _tabpanelRole = _interopRequireDefault(tabpanelRole_1);
        var _termRole = _interopRequireDefault(termRole_1);
        var _textboxRole = _interopRequireDefault(textboxRole_1);
        var _timeRole = _interopRequireDefault(timeRole_1);
        var _timerRole = _interopRequireDefault(timerRole_1);
        var _toolbarRole = _interopRequireDefault(toolbarRole_1);
        var _tooltipRole = _interopRequireDefault(tooltipRole_1);
        var _treeRole = _interopRequireDefault(treeRole_1);
        var _treegridRole = _interopRequireDefault(treegridRole_1);
        var _treeitemRole = _interopRequireDefault(treeitemRole_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var ariaLiteralRoles = [
            [
                "alert",
                _alertRole.default
            ],
            [
                "alertdialog",
                _alertdialogRole.default
            ],
            [
                "application",
                _applicationRole.default
            ],
            [
                "article",
                _articleRole.default
            ],
            [
                "banner",
                _bannerRole.default
            ],
            [
                "blockquote",
                _blockquoteRole.default
            ],
            [
                "button",
                _buttonRole.default
            ],
            [
                "caption",
                _captionRole.default
            ],
            [
                "cell",
                _cellRole.default
            ],
            [
                "checkbox",
                _checkboxRole.default
            ],
            [
                "code",
                _codeRole.default
            ],
            [
                "columnheader",
                _columnheaderRole.default
            ],
            [
                "combobox",
                _comboboxRole.default
            ],
            [
                "complementary",
                _complementaryRole.default
            ],
            [
                "contentinfo",
                _contentinfoRole.default
            ],
            [
                "definition",
                _definitionRole.default
            ],
            [
                "deletion",
                _deletionRole.default
            ],
            [
                "dialog",
                _dialogRole.default
            ],
            [
                "directory",
                _directoryRole.default
            ],
            [
                "document",
                _documentRole.default
            ],
            [
                "emphasis",
                _emphasisRole.default
            ],
            [
                "feed",
                _feedRole.default
            ],
            [
                "figure",
                _figureRole.default
            ],
            [
                "form",
                _formRole.default
            ],
            [
                "generic",
                _genericRole.default
            ],
            [
                "grid",
                _gridRole.default
            ],
            [
                "gridcell",
                _gridcellRole.default
            ],
            [
                "group",
                _groupRole.default
            ],
            [
                "heading",
                _headingRole.default
            ],
            [
                "img",
                _imgRole.default
            ],
            [
                "insertion",
                _insertionRole.default
            ],
            [
                "link",
                _linkRole.default
            ],
            [
                "list",
                _listRole.default
            ],
            [
                "listbox",
                _listboxRole.default
            ],
            [
                "listitem",
                _listitemRole.default
            ],
            [
                "log",
                _logRole.default
            ],
            [
                "main",
                _mainRole.default
            ],
            [
                "marquee",
                _marqueeRole.default
            ],
            [
                "math",
                _mathRole.default
            ],
            [
                "menu",
                _menuRole.default
            ],
            [
                "menubar",
                _menubarRole.default
            ],
            [
                "menuitem",
                _menuitemRole.default
            ],
            [
                "menuitemcheckbox",
                _menuitemcheckboxRole.default
            ],
            [
                "menuitemradio",
                _menuitemradioRole.default
            ],
            [
                "meter",
                _meterRole.default
            ],
            [
                "navigation",
                _navigationRole.default
            ],
            [
                "none",
                _noneRole.default
            ],
            [
                "note",
                _noteRole.default
            ],
            [
                "option",
                _optionRole.default
            ],
            [
                "paragraph",
                _paragraphRole.default
            ],
            [
                "presentation",
                _presentationRole.default
            ],
            [
                "progressbar",
                _progressbarRole.default
            ],
            [
                "radio",
                _radioRole.default
            ],
            [
                "radiogroup",
                _radiogroupRole.default
            ],
            [
                "region",
                _regionRole.default
            ],
            [
                "row",
                _rowRole.default
            ],
            [
                "rowgroup",
                _rowgroupRole.default
            ],
            [
                "rowheader",
                _rowheaderRole.default
            ],
            [
                "scrollbar",
                _scrollbarRole.default
            ],
            [
                "search",
                _searchRole.default
            ],
            [
                "searchbox",
                _searchboxRole.default
            ],
            [
                "separator",
                _separatorRole.default
            ],
            [
                "slider",
                _sliderRole.default
            ],
            [
                "spinbutton",
                _spinbuttonRole.default
            ],
            [
                "status",
                _statusRole.default
            ],
            [
                "strong",
                _strongRole.default
            ],
            [
                "subscript",
                _subscriptRole.default
            ],
            [
                "superscript",
                _superscriptRole.default
            ],
            [
                "switch",
                _switchRole.default
            ],
            [
                "tab",
                _tabRole.default
            ],
            [
                "table",
                _tableRole.default
            ],
            [
                "tablist",
                _tablistRole.default
            ],
            [
                "tabpanel",
                _tabpanelRole.default
            ],
            [
                "term",
                _termRole.default
            ],
            [
                "textbox",
                _textboxRole.default
            ],
            [
                "time",
                _timeRole.default
            ],
            [
                "timer",
                _timerRole.default
            ],
            [
                "toolbar",
                _toolbarRole.default
            ],
            [
                "tooltip",
                _tooltipRole.default
            ],
            [
                "tree",
                _treeRole.default
            ],
            [
                "treegrid",
                _treegridRole.default
            ],
            [
                "treeitem",
                _treeitemRole.default
            ]
        ];
        var _default = ariaLiteralRoles;
        exports1.default = _default;
    });
    unwrapExports(ariaLiteralRoles_1);
    var docAbstractRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docAbstractRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "abstract [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docAbstractRole;
        exports1.default = _default;
    });
    unwrapExports(docAbstractRole_1);
    var docAcknowledgmentsRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docAcknowledgmentsRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "acknowledgments [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docAcknowledgmentsRole;
        exports1.default = _default;
    });
    unwrapExports(docAcknowledgmentsRole_1);
    var docAfterwordRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docAfterwordRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "afterword [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docAfterwordRole;
        exports1.default = _default;
    });
    unwrapExports(docAfterwordRole_1);
    var docAppendixRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docAppendixRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "appendix [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docAppendixRole;
        exports1.default = _default;
    });
    unwrapExports(docAppendixRole_1);
    var docBacklinkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docBacklinkRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "content"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "referrer [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command",
                    "link"
                ]
            ]
        };
        var _default = docBacklinkRole;
        exports1.default = _default;
    });
    unwrapExports(docBacklinkRole_1);
    var docBiblioentryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docBiblioentryRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "EPUB biblioentry [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [
                "doc-bibliography"
            ],
            requiredContextRole: [
                "doc-bibliography"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "listitem"
                ]
            ]
        };
        var _default = docBiblioentryRole;
        exports1.default = _default;
    });
    unwrapExports(docBiblioentryRole_1);
    var docBibliographyRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docBibliographyRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "bibliography [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "doc-biblioentry"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docBibliographyRole;
        exports1.default = _default;
    });
    unwrapExports(docBibliographyRole_1);
    var docBibliorefRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docBibliorefRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "biblioref [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command",
                    "link"
                ]
            ]
        };
        var _default = docBibliorefRole;
        exports1.default = _default;
    });
    unwrapExports(docBibliorefRole_1);
    var docChapterRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docChapterRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "chapter [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docChapterRole;
        exports1.default = _default;
    });
    unwrapExports(docChapterRole_1);
    var docColophonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docColophonRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "colophon [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docColophonRole;
        exports1.default = _default;
    });
    unwrapExports(docColophonRole_1);
    var docConclusionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docConclusionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "conclusion [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docConclusionRole;
        exports1.default = _default;
    });
    unwrapExports(docConclusionRole_1);
    var docCoverRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docCoverRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "cover [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "img"
                ]
            ]
        };
        var _default = docCoverRole;
        exports1.default = _default;
    });
    unwrapExports(docCoverRole_1);
    var docCreditRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docCreditRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "credit [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docCreditRole;
        exports1.default = _default;
    });
    unwrapExports(docCreditRole_1);
    var docCreditsRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docCreditsRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "credits [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docCreditsRole;
        exports1.default = _default;
    });
    unwrapExports(docCreditsRole_1);
    var docDedicationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docDedicationRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "dedication [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docDedicationRole;
        exports1.default = _default;
    });
    unwrapExports(docDedicationRole_1);
    var docEndnoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docEndnoteRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "rearnote [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [
                "doc-endnotes"
            ],
            requiredContextRole: [
                "doc-endnotes"
            ],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "listitem"
                ]
            ]
        };
        var _default = docEndnoteRole;
        exports1.default = _default;
    });
    unwrapExports(docEndnoteRole_1);
    var docEndnotesRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docEndnotesRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "rearnotes [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "doc-endnote"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docEndnotesRole;
        exports1.default = _default;
    });
    unwrapExports(docEndnotesRole_1);
    var docEpigraphRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docEpigraphRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "epigraph [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docEpigraphRole;
        exports1.default = _default;
    });
    unwrapExports(docEpigraphRole_1);
    var docEpilogueRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docEpilogueRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "epilogue [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docEpilogueRole;
        exports1.default = _default;
    });
    unwrapExports(docEpilogueRole_1);
    var docErrataRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docErrataRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "errata [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docErrataRole;
        exports1.default = _default;
    });
    unwrapExports(docErrataRole_1);
    var docExampleRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docExampleRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docExampleRole;
        exports1.default = _default;
    });
    unwrapExports(docExampleRole_1);
    var docFootnoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docFootnoteRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "footnote [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docFootnoteRole;
        exports1.default = _default;
    });
    unwrapExports(docFootnoteRole_1);
    var docForewordRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docForewordRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "foreword [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docForewordRole;
        exports1.default = _default;
    });
    unwrapExports(docForewordRole_1);
    var docGlossaryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docGlossaryRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "glossary [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [
                [
                    "definition"
                ],
                [
                    "term"
                ]
            ],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docGlossaryRole;
        exports1.default = _default;
    });
    unwrapExports(docGlossaryRole_1);
    var docGlossrefRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docGlossrefRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "glossref [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command",
                    "link"
                ]
            ]
        };
        var _default = docGlossrefRole;
        exports1.default = _default;
    });
    unwrapExports(docGlossrefRole_1);
    var docIndexRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docIndexRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "index [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark",
                    "navigation"
                ]
            ]
        };
        var _default = docIndexRole;
        exports1.default = _default;
    });
    unwrapExports(docIndexRole_1);
    var docIntroductionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docIntroductionRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "introduction [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docIntroductionRole;
        exports1.default = _default;
    });
    unwrapExports(docIntroductionRole_1);
    var docNoterefRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docNoterefRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author",
                "contents"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "noteref [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "widget",
                    "command",
                    "link"
                ]
            ]
        };
        var _default = docNoterefRole;
        exports1.default = _default;
    });
    unwrapExports(docNoterefRole_1);
    var docNoticeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docNoticeRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "notice [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "note"
                ]
            ]
        };
        var _default = docNoticeRole;
        exports1.default = _default;
    });
    unwrapExports(docNoticeRole_1);
    var docPagebreakRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPagebreakRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: true,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "pagebreak [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "separator"
                ]
            ]
        };
        var _default = docPagebreakRole;
        exports1.default = _default;
    });
    unwrapExports(docPagebreakRole_1);
    var docPagelistRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPagelistRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "page-list [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark",
                    "navigation"
                ]
            ]
        };
        var _default = docPagelistRole;
        exports1.default = _default;
    });
    unwrapExports(docPagelistRole_1);
    var docPartRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPartRole = {
            abstract: false,
            accessibleNameRequired: true,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "part [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docPartRole;
        exports1.default = _default;
    });
    unwrapExports(docPartRole_1);
    var docPrefaceRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPrefaceRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "preface [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docPrefaceRole;
        exports1.default = _default;
    });
    unwrapExports(docPrefaceRole_1);
    var docPrologueRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPrologueRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "prologue [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark"
                ]
            ]
        };
        var _default = docPrologueRole;
        exports1.default = _default;
    });
    unwrapExports(docPrologueRole_1);
    var docPullquoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docPullquoteRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {},
            relatedConcepts: [
                {
                    concept: {
                        name: "pullquote [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "none"
                ]
            ]
        };
        var _default = docPullquoteRole;
        exports1.default = _default;
    });
    unwrapExports(docPullquoteRole_1);
    var docQnaRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docQnaRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "qna [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section"
                ]
            ]
        };
        var _default = docQnaRole;
        exports1.default = _default;
    });
    unwrapExports(docQnaRole_1);
    var docSubtitleRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docSubtitleRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "subtitle [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "sectionhead"
                ]
            ]
        };
        var _default = docSubtitleRole;
        exports1.default = _default;
    });
    unwrapExports(docSubtitleRole_1);
    var docTipRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docTipRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "help [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "note"
                ]
            ]
        };
        var _default = docTipRole;
        exports1.default = _default;
    });
    unwrapExports(docTipRole_1);
    var docTocRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var docTocRole = {
            abstract: false,
            accessibleNameRequired: false,
            baseConcepts: [],
            childrenPresentational: false,
            nameFrom: [
                "author"
            ],
            prohibitedProps: [],
            props: {
                "aria-disabled": null,
                "aria-errormessage": null,
                "aria-expanded": null,
                "aria-haspopup": null,
                "aria-invalid": null
            },
            relatedConcepts: [
                {
                    concept: {
                        name: "toc [EPUB-SSV]"
                    },
                    module: "EPUB"
                }
            ],
            requireContextRole: [],
            requiredContextRole: [],
            requiredOwnedElements: [],
            requiredProps: {},
            superClass: [
                [
                    "roletype",
                    "structure",
                    "section",
                    "landmark",
                    "navigation"
                ]
            ]
        };
        var _default = docTocRole;
        exports1.default = _default;
    });
    unwrapExports(docTocRole_1);
    var ariaDpubRoles_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _docAbstractRole = _interopRequireDefault(docAbstractRole_1);
        var _docAcknowledgmentsRole = _interopRequireDefault(docAcknowledgmentsRole_1);
        var _docAfterwordRole = _interopRequireDefault(docAfterwordRole_1);
        var _docAppendixRole = _interopRequireDefault(docAppendixRole_1);
        var _docBacklinkRole = _interopRequireDefault(docBacklinkRole_1);
        var _docBiblioentryRole = _interopRequireDefault(docBiblioentryRole_1);
        var _docBibliographyRole = _interopRequireDefault(docBibliographyRole_1);
        var _docBibliorefRole = _interopRequireDefault(docBibliorefRole_1);
        var _docChapterRole = _interopRequireDefault(docChapterRole_1);
        var _docColophonRole = _interopRequireDefault(docColophonRole_1);
        var _docConclusionRole = _interopRequireDefault(docConclusionRole_1);
        var _docCoverRole = _interopRequireDefault(docCoverRole_1);
        var _docCreditRole = _interopRequireDefault(docCreditRole_1);
        var _docCreditsRole = _interopRequireDefault(docCreditsRole_1);
        var _docDedicationRole = _interopRequireDefault(docDedicationRole_1);
        var _docEndnoteRole = _interopRequireDefault(docEndnoteRole_1);
        var _docEndnotesRole = _interopRequireDefault(docEndnotesRole_1);
        var _docEpigraphRole = _interopRequireDefault(docEpigraphRole_1);
        var _docEpilogueRole = _interopRequireDefault(docEpilogueRole_1);
        var _docErrataRole = _interopRequireDefault(docErrataRole_1);
        var _docExampleRole = _interopRequireDefault(docExampleRole_1);
        var _docFootnoteRole = _interopRequireDefault(docFootnoteRole_1);
        var _docForewordRole = _interopRequireDefault(docForewordRole_1);
        var _docGlossaryRole = _interopRequireDefault(docGlossaryRole_1);
        var _docGlossrefRole = _interopRequireDefault(docGlossrefRole_1);
        var _docIndexRole = _interopRequireDefault(docIndexRole_1);
        var _docIntroductionRole = _interopRequireDefault(docIntroductionRole_1);
        var _docNoterefRole = _interopRequireDefault(docNoterefRole_1);
        var _docNoticeRole = _interopRequireDefault(docNoticeRole_1);
        var _docPagebreakRole = _interopRequireDefault(docPagebreakRole_1);
        var _docPagelistRole = _interopRequireDefault(docPagelistRole_1);
        var _docPartRole = _interopRequireDefault(docPartRole_1);
        var _docPrefaceRole = _interopRequireDefault(docPrefaceRole_1);
        var _docPrologueRole = _interopRequireDefault(docPrologueRole_1);
        var _docPullquoteRole = _interopRequireDefault(docPullquoteRole_1);
        var _docQnaRole = _interopRequireDefault(docQnaRole_1);
        var _docSubtitleRole = _interopRequireDefault(docSubtitleRole_1);
        var _docTipRole = _interopRequireDefault(docTipRole_1);
        var _docTocRole = _interopRequireDefault(docTocRole_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var ariaDpubRoles = [
            [
                "doc-abstract",
                _docAbstractRole.default
            ],
            [
                "doc-acknowledgments",
                _docAcknowledgmentsRole.default
            ],
            [
                "doc-afterword",
                _docAfterwordRole.default
            ],
            [
                "doc-appendix",
                _docAppendixRole.default
            ],
            [
                "doc-backlink",
                _docBacklinkRole.default
            ],
            [
                "doc-biblioentry",
                _docBiblioentryRole.default
            ],
            [
                "doc-bibliography",
                _docBibliographyRole.default
            ],
            [
                "doc-biblioref",
                _docBibliorefRole.default
            ],
            [
                "doc-chapter",
                _docChapterRole.default
            ],
            [
                "doc-colophon",
                _docColophonRole.default
            ],
            [
                "doc-conclusion",
                _docConclusionRole.default
            ],
            [
                "doc-cover",
                _docCoverRole.default
            ],
            [
                "doc-credit",
                _docCreditRole.default
            ],
            [
                "doc-credits",
                _docCreditsRole.default
            ],
            [
                "doc-dedication",
                _docDedicationRole.default
            ],
            [
                "doc-endnote",
                _docEndnoteRole.default
            ],
            [
                "doc-endnotes",
                _docEndnotesRole.default
            ],
            [
                "doc-epigraph",
                _docEpigraphRole.default
            ],
            [
                "doc-epilogue",
                _docEpilogueRole.default
            ],
            [
                "doc-errata",
                _docErrataRole.default
            ],
            [
                "doc-example",
                _docExampleRole.default
            ],
            [
                "doc-footnote",
                _docFootnoteRole.default
            ],
            [
                "doc-foreword",
                _docForewordRole.default
            ],
            [
                "doc-glossary",
                _docGlossaryRole.default
            ],
            [
                "doc-glossref",
                _docGlossrefRole.default
            ],
            [
                "doc-index",
                _docIndexRole.default
            ],
            [
                "doc-introduction",
                _docIntroductionRole.default
            ],
            [
                "doc-noteref",
                _docNoterefRole.default
            ],
            [
                "doc-notice",
                _docNoticeRole.default
            ],
            [
                "doc-pagebreak",
                _docPagebreakRole.default
            ],
            [
                "doc-pagelist",
                _docPagelistRole.default
            ],
            [
                "doc-part",
                _docPartRole.default
            ],
            [
                "doc-preface",
                _docPrefaceRole.default
            ],
            [
                "doc-prologue",
                _docPrologueRole.default
            ],
            [
                "doc-pullquote",
                _docPullquoteRole.default
            ],
            [
                "doc-qna",
                _docQnaRole.default
            ],
            [
                "doc-subtitle",
                _docSubtitleRole.default
            ],
            [
                "doc-tip",
                _docTipRole.default
            ],
            [
                "doc-toc",
                _docTocRole.default
            ]
        ];
        var _default = ariaDpubRoles;
        exports1.default = _default;
    });
    unwrapExports(ariaDpubRoles_1);
    var rolesMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _ariaAbstractRoles = _interopRequireDefault(ariaAbstractRoles_1);
        var _ariaLiteralRoles = _interopRequireDefault(ariaLiteralRoles_1);
        var _ariaDpubRoles = _interopRequireDefault(ariaDpubRoles_1);
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default);
        roles.forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
            // Conglomerate the properties
            var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var superClassIter = _step.value;
                    var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
                    try {
                        var _loop = function _loop() {
                            var superClassName = _step2.value;
                            var superClassRoleTuple = roles.find(function(_ref3) {
                                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                                return name === superClassName;
                            });
                            if (superClassRoleTuple) {
                                var superClassDefinition = superClassRoleTuple[1];
                                for(var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++){
                                    var prop = _Object$keys[_i2];
                                    if (!Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)) Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                                }
                            }
                        };
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;)_loop();
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        });
        var rolesMap = {
            entries: function entries() {
                return roles;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator3 = _createForOfIteratorHelper(roles), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
                        fn.call(thisArg, values, key, roles);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
            },
            get: function get(key) {
                var item = roles.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return roles.map(function(_ref5) {
                    var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                    return key;
                });
            },
            values: function values() {
                return roles.map(function(_ref7) {
                    var _ref8 = _slicedToArray(_ref7, 2), values = _ref8[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
        exports1.default = _default;
    });
    unwrapExports(rolesMap_1);
    var toStr = Object.prototype.toString;
    var isArguments = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        return isArgs;
    };
    var keysShim;
    if (!Object.keys) {
        // modified from https://github.com/es-shims/es5-shim
        var has = Object.prototype.hasOwnProperty;
        var toStr$1 = Object.prototype.toString;
        var isArgs = isArguments; // eslint-disable-line global-require
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var hasDontEnumBug = !isEnumerable.call({
            toString: null
        }, "toString");
        var hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
        var dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ];
        var equalsConstructorPrototype = function(o) {
            var ctor = o.constructor;
            return ctor && ctor.prototype === o;
        };
        var excludedKeys = {
            $applicationCache: true,
            $console: true,
            $external: true,
            $frame: true,
            $frameElement: true,
            $frames: true,
            $innerHeight: true,
            $innerWidth: true,
            $onmozfullscreenchange: true,
            $onmozfullscreenerror: true,
            $outerHeight: true,
            $outerWidth: true,
            $pageXOffset: true,
            $pageYOffset: true,
            $parent: true,
            $scrollLeft: true,
            $scrollTop: true,
            $scrollX: true,
            $scrollY: true,
            $self: true,
            $webkitIndexedDB: true,
            $webkitStorageInfo: true,
            $window: true
        };
        var hasAutomationEqualityBug = function() {
            /* global window */ if (typeof window === "undefined") return false;
            for(var k in window)try {
                if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") try {
                    equalsConstructorPrototype(window[k]);
                } catch (e) {
                    return true;
                }
            } catch (e) {
                return true;
            }
            return false;
        }();
        var equalsConstructorPrototypeIfNotBuggy = function(o) {
            /* global window */ if (typeof window === "undefined" || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
            try {
                return equalsConstructorPrototype(o);
            } catch (e) {
                return false;
            }
        };
        keysShim = function keys(object) {
            var isObject = object !== null && typeof object === "object";
            var isFunction = toStr$1.call(object) === "[object Function]";
            var isArguments = isArgs(object);
            var isString = isObject && toStr$1.call(object) === "[object String]";
            var theKeys = [];
            if (!isObject && !isFunction && !isArguments) throw new TypeError("Object.keys called on a non-object");
            var skipProto = hasProtoEnumBug && isFunction;
            if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
            if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
            else {
                for(var name in object)if (!(skipProto && name === "prototype") && has.call(object, name)) theKeys.push(String(name));
            }
            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
            }
            return theKeys;
        };
    }
    var implementation = keysShim;
    var slice = Array.prototype.slice;
    var origKeys = Object.keys;
    var keysShim$1 = origKeys ? function keys(o) {
        return origKeys(o);
    } : implementation;
    var originalKeys = Object.keys;
    keysShim$1.shim = function shimObjectKeys() {
        if (Object.keys) {
            var keysWorksWithArguments = function() {
                // Safari 5.0 bug
                var args = Object.keys(arguments);
                return args && args.length === arguments.length;
            }(1, 2);
            if (!keysWorksWithArguments) Object.keys = function keys(object) {
                if (isArguments(object)) return originalKeys(slice.call(object));
                return originalKeys(object);
            };
        } else Object.keys = keysShim$1;
        return Object.keys || keysShim$1;
    };
    var objectKeys = keysShim$1;
    /* eslint complexity: [2, 18], max-statements: [2, 33] */ var shams = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
        if (typeof Symbol.iterator === "symbol") return true;
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") return false;
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
        // temp disabled per https://github.com/ljharb/object.assign/issues/17
        // if (sym instanceof Symbol) { return false; }
        // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
        // if (!(symObj instanceof Symbol)) { return false; }
        // if (typeof Symbol.prototype.toString !== 'function') { return false; }
        // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
        var symVal = 42;
        obj[sym] = symVal;
        for(sym in obj)return false;
         // eslint-disable-line no-restricted-syntax, no-unreachable-loop
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) return false;
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
        if (typeof Object.getOwnPropertyDescriptor === "function") {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
        }
        return true;
    };
    var shams$1 = function hasToStringTagShams() {
        return shams() && !!Symbol.toStringTag;
    };
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbols = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") return false;
        if (typeof Symbol !== "function") return false;
        if (typeof origSymbol("foo") !== "symbol") return false;
        if (typeof Symbol("bar") !== "symbol") return false;
        return shams();
    };
    /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice$1 = Array.prototype.slice;
    var toStr$2 = Object.prototype.toString;
    var funcType = "[object Function]";
    var implementation$1 = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr$2.call(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
        var args = slice$1.call(arguments, 1);
        var bound;
        var binder = function() {
            if (this instanceof bound) {
                var result = target.apply(this, args.concat(slice$1.call(arguments)));
                if (Object(result) === result) return result;
                return this;
            } else return target.apply(that, args.concat(slice$1.call(arguments)));
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for(var i = 0; i < boundLength; i++)boundArgs.push("$" + i);
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
    var functionBind = Function.prototype.bind || implementation$1;
    var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);
    var undefined$1;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    // eslint-disable-next-line consistent-return
    var getEvalledConstructor = function(expressionSyntax) {
        try {
            return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {}
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) try {
        $gOPD({}, "");
    } catch (e) {
        $gOPD = null; // this is IE 8, which has a broken gOPD
    }
    var throwTypeError = function() {
        throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
        try {
            // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
            arguments.callee; // IE 8 does not throw here
            return throwTypeError;
        } catch (calleeThrows) {
            try {
                // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                return $gOPD(arguments, "callee").get;
            } catch (gOPDthrows) {
                return throwTypeError;
            }
        }
    }() : throwTypeError;
    var hasSymbols$1 = hasSymbols();
    var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
    }; // eslint-disable-line no-proto
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
    var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
    };
    var doEval = function doEval(name) {
        var value;
        if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
        else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
        else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
        else if (name === "%AsyncGenerator%") {
            var fn = doEval("%AsyncGeneratorFunction%");
            if (fn) value = fn.prototype;
        } else if (name === "%AsyncIteratorPrototype%") {
            var gen = doEval("%AsyncGenerator%");
            if (gen) value = getProto(gen.prototype);
        }
        INTRINSICS[name] = value;
        return value;
    };
    var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": [
            "ArrayBuffer",
            "prototype"
        ],
        "%ArrayPrototype%": [
            "Array",
            "prototype"
        ],
        "%ArrayProto_entries%": [
            "Array",
            "prototype",
            "entries"
        ],
        "%ArrayProto_forEach%": [
            "Array",
            "prototype",
            "forEach"
        ],
        "%ArrayProto_keys%": [
            "Array",
            "prototype",
            "keys"
        ],
        "%ArrayProto_values%": [
            "Array",
            "prototype",
            "values"
        ],
        "%AsyncFunctionPrototype%": [
            "AsyncFunction",
            "prototype"
        ],
        "%AsyncGenerator%": [
            "AsyncGeneratorFunction",
            "prototype"
        ],
        "%AsyncGeneratorPrototype%": [
            "AsyncGeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%BooleanPrototype%": [
            "Boolean",
            "prototype"
        ],
        "%DataViewPrototype%": [
            "DataView",
            "prototype"
        ],
        "%DatePrototype%": [
            "Date",
            "prototype"
        ],
        "%ErrorPrototype%": [
            "Error",
            "prototype"
        ],
        "%EvalErrorPrototype%": [
            "EvalError",
            "prototype"
        ],
        "%Float32ArrayPrototype%": [
            "Float32Array",
            "prototype"
        ],
        "%Float64ArrayPrototype%": [
            "Float64Array",
            "prototype"
        ],
        "%FunctionPrototype%": [
            "Function",
            "prototype"
        ],
        "%Generator%": [
            "GeneratorFunction",
            "prototype"
        ],
        "%GeneratorPrototype%": [
            "GeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%Int8ArrayPrototype%": [
            "Int8Array",
            "prototype"
        ],
        "%Int16ArrayPrototype%": [
            "Int16Array",
            "prototype"
        ],
        "%Int32ArrayPrototype%": [
            "Int32Array",
            "prototype"
        ],
        "%JSONParse%": [
            "JSON",
            "parse"
        ],
        "%JSONStringify%": [
            "JSON",
            "stringify"
        ],
        "%MapPrototype%": [
            "Map",
            "prototype"
        ],
        "%NumberPrototype%": [
            "Number",
            "prototype"
        ],
        "%ObjectPrototype%": [
            "Object",
            "prototype"
        ],
        "%ObjProto_toString%": [
            "Object",
            "prototype",
            "toString"
        ],
        "%ObjProto_valueOf%": [
            "Object",
            "prototype",
            "valueOf"
        ],
        "%PromisePrototype%": [
            "Promise",
            "prototype"
        ],
        "%PromiseProto_then%": [
            "Promise",
            "prototype",
            "then"
        ],
        "%Promise_all%": [
            "Promise",
            "all"
        ],
        "%Promise_reject%": [
            "Promise",
            "reject"
        ],
        "%Promise_resolve%": [
            "Promise",
            "resolve"
        ],
        "%RangeErrorPrototype%": [
            "RangeError",
            "prototype"
        ],
        "%ReferenceErrorPrototype%": [
            "ReferenceError",
            "prototype"
        ],
        "%RegExpPrototype%": [
            "RegExp",
            "prototype"
        ],
        "%SetPrototype%": [
            "Set",
            "prototype"
        ],
        "%SharedArrayBufferPrototype%": [
            "SharedArrayBuffer",
            "prototype"
        ],
        "%StringPrototype%": [
            "String",
            "prototype"
        ],
        "%SymbolPrototype%": [
            "Symbol",
            "prototype"
        ],
        "%SyntaxErrorPrototype%": [
            "SyntaxError",
            "prototype"
        ],
        "%TypedArrayPrototype%": [
            "TypedArray",
            "prototype"
        ],
        "%TypeErrorPrototype%": [
            "TypeError",
            "prototype"
        ],
        "%Uint8ArrayPrototype%": [
            "Uint8Array",
            "prototype"
        ],
        "%Uint8ClampedArrayPrototype%": [
            "Uint8ClampedArray",
            "prototype"
        ],
        "%Uint16ArrayPrototype%": [
            "Uint16Array",
            "prototype"
        ],
        "%Uint32ArrayPrototype%": [
            "Uint32Array",
            "prototype"
        ],
        "%URIErrorPrototype%": [
            "URIError",
            "prototype"
        ],
        "%WeakMapPrototype%": [
            "WeakMap",
            "prototype"
        ],
        "%WeakSetPrototype%": [
            "WeakSet",
            "prototype"
        ]
    };
    var $concat = functionBind.call(Function.call, Array.prototype.concat);
    var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
    var $replace = functionBind.call(Function.call, String.prototype.replace);
    var $strSlice = functionBind.call(Function.call, String.prototype.slice);
    var $exec = functionBind.call(Function.call, RegExp.prototype.exec);
    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
    var stringToPath = function stringToPath(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        else if (last === "%" && first !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
            result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
    };
    /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (src(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = "%" + alias[0] + "%";
        }
        if (src(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) value = doEval(intrinsicName);
            if (typeof value === "undefined" && !allowMissing) throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
            return {
                alias: alias,
                name: intrinsicName,
                value: value
            };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    var getIntrinsic = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) throw new $TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError('"allowMissing" argument must be a boolean');
        if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat([
                0,
                1
            ], alias));
        }
        for(var i = 1, isOwn = true; i < parts.length; i += 1){
            var part = parts[i];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
            if (part === "constructor" || !isOwn) skipFurtherCaching = true;
            intrinsicBaseName += "." + part;
            intrinsicRealName = "%" + intrinsicBaseName + "%";
            if (src(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
            else if (value != null) {
                if (!(part in value)) {
                    if (!allowMissing) throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                    return void 0;
                }
                if ($gOPD && i + 1 >= parts.length) {
                    var desc = $gOPD(value, part);
                    isOwn = !!desc;
                    // By convention, when a data property is converted to an accessor
                    // property to emulate a data property that does not suffer from
                    // the override mistake, that accessor's getter is marked with
                    // an `originalValue` property. Here, when we detect this, we
                    // uphold the illusion by pretending to see that original data
                    // property, i.e., returning the value rather than the getter
                    // itself.
                    if (isOwn && "get" in desc && !("originalValue" in desc.get)) value = desc.get;
                    else value = value[part];
                } else {
                    isOwn = src(value, part);
                    value = value[part];
                }
                if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
            }
        }
        return value;
    };
    var callBind = createCommonjsModule(function(module) {
        var $apply = getIntrinsic("%Function.prototype.apply%");
        var $call = getIntrinsic("%Function.prototype.call%");
        var $reflectApply = getIntrinsic("%Reflect.apply%", true) || functionBind.call($call, $apply);
        var $gOPD = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
        var $defineProperty = getIntrinsic("%Object.defineProperty%", true);
        var $max = getIntrinsic("%Math.max%");
        if ($defineProperty) try {
            $defineProperty({}, "a", {
                value: 1
            });
        } catch (e) {
            // IE 8 has a broken defineProperty
            $defineProperty = null;
        }
        module.exports = function callBind(originalFunction) {
            var func = $reflectApply(functionBind, $call, arguments);
            if ($gOPD && $defineProperty) {
                var desc = $gOPD(func, "length");
                if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(func, "length", {
                    value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                });
            }
            return func;
        };
        var applyBind = function applyBind() {
            return $reflectApply(functionBind, $apply, arguments);
        };
        if ($defineProperty) $defineProperty(module.exports, "apply", {
            value: applyBind
        });
        else module.exports.apply = applyBind;
    });
    var callBind_1 = callBind.apply;
    var $indexOf = callBind(getIntrinsic("String.prototype.indexOf"));
    var callBound = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = getIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBind(intrinsic);
        return intrinsic;
    };
    var hasToStringTag = shams$1();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) return false;
        return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) return true;
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
    var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    var $defineProperty = getIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors() {
        if ($defineProperty) try {
            $defineProperty({}, "a", {
                value: 1
            });
            return true;
        } catch (e) {
            // IE 8 has a broken defineProperty
            return false;
        }
        return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        // node v0.6 has a bug where array lengths can be Set but not Defined
        if (!hasPropertyDescriptors()) return null;
        try {
            return $defineProperty([], "length", {
                value: 1
            }).length !== 1;
        } catch (e) {
            // In Firefox 4-22, defining length on an array throws an exception.
            return true;
        }
    };
    var hasPropertyDescriptors_1 = hasPropertyDescriptors;
    var hasSymbols$2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr$3 = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
        return typeof fn === "function" && toStr$3.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors$1 = hasPropertyDescriptors_1();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors$1;
    var defineProperty = function(object, name, value, predicate) {
        if (name in object && (!isFunction(predicate) || !predicate())) return;
        if (supportsDescriptors) origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value: value,
            writable: true
        });
        else object[name] = value; // eslint-disable-line no-param-reassign
    };
    var defineProperties = function(object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = objectKeys(map);
        if (hasSymbols$2) props = concat.call(props, Object.getOwnPropertySymbols(map));
        for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    var defineProperties_1 = defineProperties;
    var numberIsNaN = function(value) {
        return value !== value;
    };
    var implementation$2 = function is(a, b) {
        if (a === 0 && b === 0) return 1 / a === 1 / b;
        if (a === b) return true;
        if (numberIsNaN(a) && numberIsNaN(b)) return true;
        return false;
    };
    var polyfill = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation$2;
    };
    var shim = function shimObjectIs() {
        var polyfill$1 = polyfill();
        defineProperties_1(Object, {
            is: polyfill$1
        }, {
            is: function testObjectIs() {
                return Object.is !== polyfill$1;
            }
        });
        return polyfill$1;
    };
    var polyfill$1 = callBind(polyfill(), Object);
    defineProperties_1(polyfill$1, {
        getPolyfill: polyfill,
        implementation: implementation$2,
        shim: shim
    });
    var objectIs = polyfill$1;
    var hasToStringTag$1 = shams$1();
    var has$1;
    var $exec$1;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag$1) {
        has$1 = callBound("Object.prototype.hasOwnProperty");
        $exec$1 = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        var throwRegexMarker = function() {
            throw isRegexMarker;
        };
        badStringifier = {
            toString: throwRegexMarker,
            valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    var $toString$1 = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    var isRegex = hasToStringTag$1 ? function isRegex(value) {
        if (!value || typeof value !== "object") return false;
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
        if (!hasLastIndexDataProperty) return false;
        try {
            $exec$1(value, badStringifier);
        } catch (e) {
            return e === isRegexMarker;
        }
    } : function isRegex(value) {
        // In older browsers, typeof regex incorrectly returns 'function'
        if (!value || typeof value !== "object" && typeof value !== "function") return false;
        return $toString$1(value) === regexClass;
    };
    var functionsHaveNames = function functionsHaveNames() {
        return typeof (function f() {}).name === "string";
    };
    var gOPD$1 = Object.getOwnPropertyDescriptor;
    if (gOPD$1) try {
        gOPD$1([], "length");
    } catch (e) {
        // IE 8 has a broken gOPD
        gOPD$1 = null;
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD$1) return false;
        var desc = gOPD$1(function() {}, "name");
        return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && (function f() {}).bind().name !== "";
    };
    var functionsHaveNames_1 = functionsHaveNames;
    var implementation$3 = createCommonjsModule(function(module) {
        var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();
        var $Object = Object;
        var $TypeError = TypeError;
        module.exports = function flags() {
            if (this != null && this !== $Object(this)) throw new $TypeError("RegExp.prototype.flags getter called on non-object");
            var result = "";
            if (this.hasIndices) result += "d";
            if (this.global) result += "g";
            if (this.ignoreCase) result += "i";
            if (this.multiline) result += "m";
            if (this.dotAll) result += "s";
            if (this.unicode) result += "u";
            if (this.sticky) result += "y";
            return result;
        };
        if (functionsHaveConfigurableNames && Object.defineProperty) Object.defineProperty(module.exports, "name", {
            value: "get flags"
        });
    });
    var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
    var $gOPD$1 = Object.getOwnPropertyDescriptor;
    var polyfill$2 = function getPolyfill() {
        if (supportsDescriptors$1 && /a/mig.flags === "gim") {
            var descriptor = $gOPD$1(RegExp.prototype, "flags");
            if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
                /* eslint getter-return: 0 */ var calls = "";
                var o = {};
                Object.defineProperty(o, "hasIndices", {
                    get: function() {
                        calls += "d";
                    }
                });
                Object.defineProperty(o, "sticky", {
                    get: function() {
                        calls += "y";
                    }
                });
                if (calls === "dy") return descriptor.get;
            }
        }
        return implementation$3;
    };
    var supportsDescriptors$2 = defineProperties_1.supportsDescriptors;
    var gOPD$2 = Object.getOwnPropertyDescriptor;
    var defineProperty$1 = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto$1 = Object.getPrototypeOf;
    var regex = /a/;
    var shim$1 = function shimFlags() {
        if (!supportsDescriptors$2 || !getProto$1) throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        var polyfill = polyfill$2();
        var proto = getProto$1(regex);
        var descriptor = gOPD$2(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) defineProperty$1(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
        });
        return polyfill;
    };
    var flagsBound = callBind(polyfill$2());
    defineProperties_1(flagsBound, {
        getPolyfill: polyfill$2,
        implementation: implementation$3,
        shim: shim$1
    });
    var regexp_prototype_flags = flagsBound;
    var toString$1 = {}.toString;
    var isarray = Array.isArray || function(arr) {
        return toString$1.call(arr) == "[object Array]";
    };
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
        try {
            getDay.call(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    var toStr$4 = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag$2 = shams$1();
    var isDateObject = function isDateObject(value) {
        if (typeof value !== "object" || value === null) return false;
        return hasToStringTag$2 ? tryDateObject(value) : toStr$4.call(value) === dateClass;
    };
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject(value) {
        try {
            strValue.call(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    var toStr$5 = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag$3 = shams$1();
    var isString = function isString(value) {
        if (typeof value === "string") return true;
        if (typeof value !== "object") return false;
        return hasToStringTag$3 ? tryStringObject(value) : toStr$5.call(value) === strClass;
    };
    var numToStr = Number.prototype.toString;
    var tryNumberObject = function tryNumberObject(value) {
        try {
            numToStr.call(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    var toStr$6 = Object.prototype.toString;
    var numClass = "[object Number]";
    var hasToStringTag$4 = shams$1();
    var isNumberObject = function isNumberObject(value) {
        if (typeof value === "number") return true;
        if (typeof value !== "object") return false;
        return hasToStringTag$4 ? tryNumberObject(value) : toStr$6.call(value) === numClass;
    };
    var $boolToStr = callBound("Boolean.prototype.toString");
    var $toString$2 = callBound("Object.prototype.toString");
    var tryBooleanObject = function booleanBrandCheck(value) {
        try {
            $boolToStr(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    var boolClass = "[object Boolean]";
    var hasToStringTag$5 = shams$1();
    var isBooleanObject = function isBoolean(value) {
        if (typeof value === "boolean") return true;
        if (value === null || typeof value !== "object") return false;
        return hasToStringTag$5 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$2(value) === boolClass;
    };
    var isSymbol = createCommonjsModule(function(module) {
        var toStr = Object.prototype.toString;
        var hasSymbols$1 = hasSymbols();
        if (hasSymbols$1) {
            var symToStr = Symbol.prototype.toString;
            var symStringRegex = /^Symbol\(.*\)$/;
            var isSymbolObject = function isRealSymbolObject(value) {
                if (typeof value.valueOf() !== "symbol") return false;
                return symStringRegex.test(symToStr.call(value));
            };
            module.exports = function isSymbol(value) {
                if (typeof value === "symbol") return true;
                if (toStr.call(value) !== "[object Symbol]") return false;
                try {
                    return isSymbolObject(value);
                } catch (e) {
                    return false;
                }
            };
        } else module.exports = function isSymbol(value) {
            // this environment does not support Symbols.
            return false;
        };
    });
    var $BigInt = typeof BigInt !== "undefined" && BigInt;
    var hasBigints = function hasNativeBigInts() {
        return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" // eslint-disable-line no-magic-numbers
         && typeof BigInt(42) === "bigint"; // eslint-disable-line no-magic-numbers
    };
    var isBigint = createCommonjsModule(function(module) {
        var hasBigInts = hasBigints();
        if (hasBigInts) {
            var bigIntValueOf = BigInt.prototype.valueOf;
            var tryBigInt = function tryBigIntObject(value) {
                try {
                    bigIntValueOf.call(value);
                    return true;
                } catch (e) {}
                return false;
            };
            module.exports = function isBigInt(value) {
                if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") return false;
                if (typeof value === "bigint") return true;
                return tryBigInt(value);
            };
        } else module.exports = function isBigInt(value) {
            return false;
        };
    });
    // eslint-disable-next-line consistent-return
    var whichBoxedPrimitive = function whichBoxedPrimitive(value) {
        // eslint-disable-next-line eqeqeq
        if (value == null || typeof value !== "object" && typeof value !== "function") return null;
        if (isString(value)) return "String";
        if (isNumberObject(value)) return "Number";
        if (isBooleanObject(value)) return "Boolean";
        if (isSymbol(value)) return "Symbol";
        if (isBigint(value)) return "BigInt";
    };
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) // eslint-disable-next-line no-unused-vars
    exported = function isMap(x) {
        // `Map` is not present in this environment.
        return false;
    };
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) // eslint-disable-next-line no-unused-vars
    exported = function isMap(x) {
        // `Map` does not have a `has` method
        return false;
    };
    var isMap = exported || function isMap(x) {
        if (!x || typeof x !== "object") return false;
        try {
            $mapHas.call(x);
            if ($setHas) try {
                $setHas.call(x);
            } catch (e) {
                return true;
            }
            return x instanceof $Map; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    };
    var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
    var exported$1;
    if (!$Set$1) // eslint-disable-next-line no-unused-vars
    exported$1 = function isSet(x) {
        // `Set` is not present in this environment.
        return false;
    };
    var $mapHas$1 = $Map$1 ? Map.prototype.has : null;
    var $setHas$1 = $Set$1 ? Set.prototype.has : null;
    if (!exported$1 && !$setHas$1) // eslint-disable-next-line no-unused-vars
    exported$1 = function isSet(x) {
        // `Set` does not have a `has` method
        return false;
    };
    var isSet = exported$1 || function isSet(x) {
        if (!x || typeof x !== "object") return false;
        try {
            $setHas$1.call(x);
            if ($mapHas$1) try {
                $mapHas$1.call(x);
            } catch (e) {
                return true;
            }
            return x instanceof $Set$1; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    };
    var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
    var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
    var exported$2;
    if (!$WeakMap) // eslint-disable-next-line no-unused-vars
    exported$2 = function isWeakMap(x) {
        // `WeakMap` is not present in this environment.
        return false;
    };
    var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
    var $setHas$2 = $WeakSet ? $WeakSet.prototype.has : null;
    if (!exported$2 && !$mapHas$2) // eslint-disable-next-line no-unused-vars
    exported$2 = function isWeakMap(x) {
        // `WeakMap` does not have a `has` method
        return false;
    };
    var isWeakmap = exported$2 || function isWeakMap(x) {
        if (!x || typeof x !== "object") return false;
        try {
            $mapHas$2.call(x, $mapHas$2);
            if ($setHas$2) try {
                $setHas$2.call(x, $setHas$2);
            } catch (e) {
                return true;
            }
            return x instanceof $WeakMap; // core-js workaround, pre-v3
        } catch (e) {}
        return false;
    };
    var isWeakset = createCommonjsModule(function(module) {
        var $WeakSet = getIntrinsic("%WeakSet%", true);
        var $setHas = callBound("WeakSet.prototype.has", true);
        if ($setHas) {
            var $mapHas = callBound("WeakMap.prototype.has", true);
            module.exports = function isWeakSet(x) {
                if (!x || typeof x !== "object") return false;
                try {
                    $setHas(x, $setHas);
                    if ($mapHas) try {
                        $mapHas(x, $mapHas);
                    } catch (e) {
                        return true;
                    }
                    return x instanceof $WeakSet; // core-js workaround, pre-v3
                } catch (e) {}
                return false;
            };
        } else // eslint-disable-next-line no-unused-vars
        module.exports = function isWeakSet(x) {
            // `WeakSet` does not exist, or does not have a `has` method
            return false;
        };
    });
    var whichCollection = function whichCollection(value) {
        if (value && typeof value === "object") {
            if (isMap(value)) return "Map";
            if (isSet(value)) return "Set";
            if (isWeakmap(value)) return "WeakMap";
            if (isWeakset(value)) return "WeakSet";
        }
        return false;
    };
    // this should only run in node >= 13.7, so it
    // does not need any of the intense fallbacks that old node/browsers do
    var $iterator = Symbol.iterator;
    function getIterator(iterable) {
        // alternatively, `iterable[$iterator]?.()`
        if (iterable != null && iterable[$iterator] !== undefined) return iterable[$iterator]();
    }
    var node$1 = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        "default": getIterator
    });
    var toStr$7 = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag$6 = shams$1();
    var getProto$2 = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
        if (!hasToStringTag$6) return false;
        try {
            return Function("return function*() {}")();
        } catch (e) {}
    };
    var GeneratorFunction;
    var isGeneratorFunction = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") return false;
        if (isFnRegex.test(fnToStr.call(fn))) return true;
        if (!hasToStringTag$6) {
            var str = toStr$7.call(fn);
            return str === "[object GeneratorFunction]";
        }
        if (!getProto$2) return false;
        if (typeof GeneratorFunction === "undefined") {
            var generatorFunc = getGeneratorFunc();
            GeneratorFunction = generatorFunc ? getProto$2(generatorFunc) : false;
        }
        return getProto$2(fn) === GeneratorFunction;
    };
    var fnToStr$1 = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") try {
        badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
                throw isCallableMarker;
            }
        });
        isCallableMarker = {};
        // eslint-disable-next-line no-throw-literal
        reflectApply(function() {
            throw 42;
        }, null, badArrayLike);
    } catch (_) {
        if (_ !== isCallableMarker) reflectApply = null;
    }
    else reflectApply = null;
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
        try {
            var fnStr = fnToStr$1.call(value);
            return constructorRegex.test(fnStr);
        } catch (e) {
            return false; // not a function
        }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
        try {
            if (isES6ClassFn(value)) return false;
            fnToStr$1.call(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    var toStr$8 = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]"; // IE 11
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]"; // IE 9-10
    var hasToStringTag$7 = typeof Symbol === "function" && !!Symbol.toStringTag; // better: use `has-tostringtag`
    var isIE68 = !(0 in [
        , 
    ]); // eslint-disable-line no-sparse-arrays, comma-spacing
    var isDDA = function isDocumentDotAll() {
        return false;
    };
    if (typeof document === "object") {
        // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
        var all = document.all;
        if (toStr$8.call(all) === toStr$8.call(document.all)) isDDA = function isDocumentDotAll(value) {
            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) try {
                var str = toStr$8.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                 || str === objectClass // IE 6-8
                ) && value("") == null; // eslint-disable-line eqeqeq
            } catch (e) {}
            return false;
        };
    }
    var isCallable = reflectApply ? function isCallable(value) {
        if (isDDA(value)) return true;
        if (!value) return false;
        if (typeof value !== "function" && typeof value !== "object") return false;
        try {
            reflectApply(value, null, badArrayLike);
        } catch (e) {
            if (e !== isCallableMarker) return false;
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
        if (isDDA(value)) return true;
        if (!value) return false;
        if (typeof value !== "function" && typeof value !== "object") return false;
        if (hasToStringTag$7) return tryFunctionObject(value);
        if (isES6ClassFn(value)) return false;
        var strClass = toStr$8.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) return false;
        return tryFunctionObject(value);
    };
    var toStr$9 = Object.prototype.toString;
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray(array, iterator, receiver) {
        for(var i = 0, len = array.length; i < len; i++)if (hasOwnProperty$2.call(array, i)) {
            if (receiver == null) iterator(array[i], i, array);
            else iterator.call(receiver, array[i], i, array);
        }
    };
    var forEachString = function forEachString(string, iterator, receiver) {
        for(var i = 0, len = string.length; i < len; i++)// no such thing as a sparse string.
        if (receiver == null) iterator(string.charAt(i), i, string);
        else iterator.call(receiver, string.charAt(i), i, string);
    };
    var forEachObject = function forEachObject(object, iterator, receiver) {
        for(var k in object)if (hasOwnProperty$2.call(object, k)) {
            if (receiver == null) iterator(object[k], k, object);
            else iterator.call(receiver, object[k], k, object);
        }
    };
    var forEach = function forEach(list, iterator, thisArg) {
        if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
        var receiver;
        if (arguments.length >= 3) receiver = thisArg;
        if (toStr$9.call(list) === "[object Array]") forEachArray(list, iterator, receiver);
        else if (typeof list === "string") forEachString(list, iterator, receiver);
        else forEachObject(list, iterator, receiver);
    };
    var forEach_1 = forEach;
    var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var availableTypedArrays = function availableTypedArrays() {
        var out = [];
        for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === "function") out[out.length] = possibleNames[i];
        return out;
    };
    var $gOPD$2 = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD$2) try {
        $gOPD$2([], "length");
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD$2 = null;
    }
    var getOwnPropertyDescriptor = $gOPD$2;
    var $toString$3 = callBound("Object.prototype.toString");
    var hasToStringTag$8 = shams$1();
    var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf$1 = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for(var i = 0; i < array.length; i += 1){
            if (array[i] === value) return i;
        }
        return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
    if (hasToStringTag$8 && getOwnPropertyDescriptor && getPrototypeOf) forEach_1(typedArrays, function(typedArray) {
        var arr = new g$1[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
        }
    });
    var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach_1(toStrTags, function(getter, typedArray) {
            if (!anyTrue) try {
                anyTrue = getter.call(value) === typedArray;
            } catch (e) {}
        });
        return anyTrue;
    };
    var isTypedArray = function isTypedArray(value) {
        if (!value || typeof value !== "object") return false;
        if (!hasToStringTag$8 || !(Symbol.toStringTag in value)) {
            var tag = $slice($toString$3(value), 8, -1);
            return $indexOf$1(typedArrays, tag) > -1;
        }
        if (!getOwnPropertyDescriptor) return false;
        return tryTypedArrays(value);
    };
    var $toString$4 = callBound("Object.prototype.toString");
    var hasToStringTag$9 = shams$1();
    var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
    var typedArrays$1 = availableTypedArrays();
    var $slice$1 = callBound("String.prototype.slice");
    var toStrTags$1 = {};
    var getPrototypeOf$1 = Object.getPrototypeOf; // require('getprototypeof');
    if (hasToStringTag$9 && getOwnPropertyDescriptor && getPrototypeOf$1) forEach_1(typedArrays$1, function(typedArray) {
        if (typeof g$2[typedArray] === "function") {
            var arr = new g$2[typedArray]();
            if (Symbol.toStringTag in arr) {
                var proto = getPrototypeOf$1(arr);
                var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);
                if (!descriptor) {
                    var superProto = getPrototypeOf$1(proto);
                    descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
                }
                toStrTags$1[typedArray] = descriptor.get;
            }
        }
    });
    var tryTypedArrays$1 = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach_1(toStrTags$1, function(getter, typedArray) {
            if (!foundName) try {
                var name = getter.call(value);
                if (name === typedArray) foundName = name;
            } catch (e) {}
        });
        return foundName;
    };
    var whichTypedArray = function whichTypedArray(value) {
        if (!isTypedArray(value)) return false;
        if (!hasToStringTag$9 || !(Symbol.toStringTag in value)) return $slice$1($toString$4(value), 8, -1);
        return tryTypedArrays$1(value);
    };
    var types$2 = createCommonjsModule(function(module, exports1) {
        function uncurryThis(f) {
            return f.call.bind(f);
        }
        var BigIntSupported = typeof BigInt !== "undefined";
        var SymbolSupported = typeof Symbol !== "undefined";
        var ObjectToString = uncurryThis(Object.prototype.toString);
        var numberValue = uncurryThis(Number.prototype.valueOf);
        var stringValue = uncurryThis(String.prototype.valueOf);
        var booleanValue = uncurryThis(Boolean.prototype.valueOf);
        if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
        if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
        function checkBoxedPrimitive(value, prototypeValueOf) {
            if (typeof value !== "object") return false;
            try {
                prototypeValueOf(value);
                return true;
            } catch (e) {
                return false;
            }
        }
        exports1.isArgumentsObject = isArguments$1;
        exports1.isGeneratorFunction = isGeneratorFunction;
        exports1.isTypedArray = isTypedArray;
        // Taken from here and modified for better browser support
        // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
        function isPromise(input) {
            return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
        }
        exports1.isPromise = isPromise;
        function isArrayBufferView(value) {
            if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) return ArrayBuffer.isView(value);
            return isTypedArray(value) || isDataView(value);
        }
        exports1.isArrayBufferView = isArrayBufferView;
        function isUint8Array(value) {
            return whichTypedArray(value) === "Uint8Array";
        }
        exports1.isUint8Array = isUint8Array;
        function isUint8ClampedArray(value) {
            return whichTypedArray(value) === "Uint8ClampedArray";
        }
        exports1.isUint8ClampedArray = isUint8ClampedArray;
        function isUint16Array(value) {
            return whichTypedArray(value) === "Uint16Array";
        }
        exports1.isUint16Array = isUint16Array;
        function isUint32Array(value) {
            return whichTypedArray(value) === "Uint32Array";
        }
        exports1.isUint32Array = isUint32Array;
        function isInt8Array(value) {
            return whichTypedArray(value) === "Int8Array";
        }
        exports1.isInt8Array = isInt8Array;
        function isInt16Array(value) {
            return whichTypedArray(value) === "Int16Array";
        }
        exports1.isInt16Array = isInt16Array;
        function isInt32Array(value) {
            return whichTypedArray(value) === "Int32Array";
        }
        exports1.isInt32Array = isInt32Array;
        function isFloat32Array(value) {
            return whichTypedArray(value) === "Float32Array";
        }
        exports1.isFloat32Array = isFloat32Array;
        function isFloat64Array(value) {
            return whichTypedArray(value) === "Float64Array";
        }
        exports1.isFloat64Array = isFloat64Array;
        function isBigInt64Array(value) {
            return whichTypedArray(value) === "BigInt64Array";
        }
        exports1.isBigInt64Array = isBigInt64Array;
        function isBigUint64Array(value) {
            return whichTypedArray(value) === "BigUint64Array";
        }
        exports1.isBigUint64Array = isBigUint64Array;
        function isMapToString(value) {
            return ObjectToString(value) === "[object Map]";
        }
        isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
        function isMap(value) {
            if (typeof Map === "undefined") return false;
            return isMapToString.working ? isMapToString(value) : value instanceof Map;
        }
        exports1.isMap = isMap;
        function isSetToString(value) {
            return ObjectToString(value) === "[object Set]";
        }
        isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
        function isSet(value) {
            if (typeof Set === "undefined") return false;
            return isSetToString.working ? isSetToString(value) : value instanceof Set;
        }
        exports1.isSet = isSet;
        function isWeakMapToString(value) {
            return ObjectToString(value) === "[object WeakMap]";
        }
        isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
        function isWeakMap(value) {
            if (typeof WeakMap === "undefined") return false;
            return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
        }
        exports1.isWeakMap = isWeakMap;
        function isWeakSetToString(value) {
            return ObjectToString(value) === "[object WeakSet]";
        }
        isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
        function isWeakSet(value) {
            return isWeakSetToString(value);
        }
        exports1.isWeakSet = isWeakSet;
        function isArrayBufferToString(value) {
            return ObjectToString(value) === "[object ArrayBuffer]";
        }
        isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
        function isArrayBuffer(value) {
            if (typeof ArrayBuffer === "undefined") return false;
            return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
        }
        exports1.isArrayBuffer = isArrayBuffer;
        function isDataViewToString(value) {
            return ObjectToString(value) === "[object DataView]";
        }
        isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
        function isDataView(value) {
            if (typeof DataView === "undefined") return false;
            return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
        }
        exports1.isDataView = isDataView;
        // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
        var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : undefined;
        function isSharedArrayBufferToString(value) {
            return ObjectToString(value) === "[object SharedArrayBuffer]";
        }
        function isSharedArrayBuffer(value) {
            if (typeof SharedArrayBufferCopy === "undefined") return false;
            if (typeof isSharedArrayBufferToString.working === "undefined") isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
            return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
        }
        exports1.isSharedArrayBuffer = isSharedArrayBuffer;
        function isAsyncFunction(value) {
            return ObjectToString(value) === "[object AsyncFunction]";
        }
        exports1.isAsyncFunction = isAsyncFunction;
        function isMapIterator(value) {
            return ObjectToString(value) === "[object Map Iterator]";
        }
        exports1.isMapIterator = isMapIterator;
        function isSetIterator(value) {
            return ObjectToString(value) === "[object Set Iterator]";
        }
        exports1.isSetIterator = isSetIterator;
        function isGeneratorObject(value) {
            return ObjectToString(value) === "[object Generator]";
        }
        exports1.isGeneratorObject = isGeneratorObject;
        function isWebAssemblyCompiledModule(value) {
            return ObjectToString(value) === "[object WebAssembly.Module]";
        }
        exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
        function isNumberObject(value) {
            return checkBoxedPrimitive(value, numberValue);
        }
        exports1.isNumberObject = isNumberObject;
        function isStringObject(value) {
            return checkBoxedPrimitive(value, stringValue);
        }
        exports1.isStringObject = isStringObject;
        function isBooleanObject(value) {
            return checkBoxedPrimitive(value, booleanValue);
        }
        exports1.isBooleanObject = isBooleanObject;
        function isBigIntObject(value) {
            return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
        }
        exports1.isBigIntObject = isBigIntObject;
        function isSymbolObject(value) {
            return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
        }
        exports1.isSymbolObject = isSymbolObject;
        function isBoxedPrimitive(value) {
            return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
        }
        exports1.isBoxedPrimitive = isBoxedPrimitive;
        function isAnyArrayBuffer(value) {
            return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
        }
        exports1.isAnyArrayBuffer = isAnyArrayBuffer;
        [
            "isProxy",
            "isExternal",
            "isModuleNamespaceObject"
        ].forEach(function(method) {
            Object.defineProperty(exports1, method, {
                enumerable: false,
                value: function() {
                    throw new Error(method + " is not supported in userland");
                }
            });
        });
    });
    var types_1 = types$2.isArgumentsObject;
    var types_2 = types$2.isGeneratorFunction;
    var types_3 = types$2.isTypedArray;
    var types_4 = types$2.isPromise;
    var types_5 = types$2.isArrayBufferView;
    var types_6 = types$2.isUint8Array;
    var types_7 = types$2.isUint8ClampedArray;
    var types_8 = types$2.isUint16Array;
    var types_9 = types$2.isUint32Array;
    var types_10 = types$2.isInt8Array;
    var types_11 = types$2.isInt16Array;
    var types_12 = types$2.isInt32Array;
    var types_13 = types$2.isFloat32Array;
    var types_14 = types$2.isFloat64Array;
    var types_15 = types$2.isBigInt64Array;
    var types_16 = types$2.isBigUint64Array;
    var types_17 = types$2.isMap;
    var types_18 = types$2.isSet;
    var types_19 = types$2.isWeakMap;
    var types_20 = types$2.isWeakSet;
    var types_21 = types$2.isArrayBuffer;
    var types_22 = types$2.isDataView;
    var types_23 = types$2.isSharedArrayBuffer;
    var types_24 = types$2.isAsyncFunction;
    var types_25 = types$2.isMapIterator;
    var types_26 = types$2.isSetIterator;
    var types_27 = types$2.isGeneratorObject;
    var types_28 = types$2.isWebAssemblyCompiledModule;
    var types_29 = types$2.isNumberObject;
    var types_30 = types$2.isStringObject;
    var types_31 = types$2.isBooleanObject;
    var types_32 = types$2.isBigIntObject;
    var types_33 = types$2.isSymbolObject;
    var types_34 = types$2.isBoxedPrimitive;
    var types_35 = types$2.isAnyArrayBuffer;
    var isBuffer = function isBuffer(arg) {
        return arg instanceof Buffer;
    };
    var inherits_browser = createCommonjsModule(function(module) {
        if (typeof Object.create === "function") // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
        };
        else // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
        };
    });
    var inherits = createCommonjsModule(function(module) {
        try {
            var util$1 = util;
            /* istanbul ignore next */ if (typeof util$1.inherits !== "function") throw "";
            module.exports = util$1.inherits;
        } catch (e) {
            /* istanbul ignore next */ module.exports = inherits_browser;
        }
    });
    var util = createCommonjsModule(function(module, exports1) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
            var keys = Object.keys(obj);
            var descriptors = {};
            for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
            return descriptors;
        };
        var formatRegExp = /%[sdj%]/g;
        exports1.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
                return objects.join(" ");
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === "%%") return "%";
                if (i >= len) return x;
                switch(x){
                    case "%s":
                        return String(args[i++]);
                    case "%d":
                        return Number(args[i++]);
                    case "%j":
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return "[Circular]";
                        }
                    default:
                        return x;
                }
            });
            for(var x = args[i]; i < len; x = args[++i])if (isNull(x) || !isObject(x)) str += " " + x;
            else str += " " + inspect(x);
            return str;
        };
        // Mark that a method should not be used.
        // Returns a modified function which warns once by default.
        // If --no-deprecation is set, then it is a no-op.
        exports1.deprecate = function(fn, msg) {
            if (typeof process !== "undefined" && process.noDeprecation === true) return fn;
            // Allow for deprecating things in the process of starting up.
            if (typeof process === "undefined") return function() {
                return exports1.deprecate(fn, msg).apply(this, arguments);
            };
            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) throw new Error(msg);
                    else if (process.traceDeprecation) console.trace(msg);
                    else console.error(msg);
                    warned = true;
                }
                return fn.apply(this, arguments);
            }
            return deprecated;
        };
        var debugs = {};
        var debugEnvRegex = /^$/;
        exports1.debuglog = function(set) {
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (debugEnvRegex.test(set)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports1.format.apply(exports1, arguments);
                        console.error("%s %d: %s", set, pid, msg);
                    };
                } else debugs[set] = function() {};
            }
            return debugs[set];
        };
        /**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) // legacy...
            ctx.showHidden = opts;
            else if (opts) // got an "options" object
            exports1._extend(ctx, opts);
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports1.inspect = inspect;
        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            "bold": [
                1,
                22
            ],
            "italic": [
                3,
                23
            ],
            "underline": [
                4,
                24
            ],
            "inverse": [
                7,
                27
            ],
            "white": [
                37,
                39
            ],
            "grey": [
                90,
                39
            ],
            "black": [
                30,
                39
            ],
            "blue": [
                34,
                39
            ],
            "cyan": [
                36,
                39
            ],
            "green": [
                32,
                39
            ],
            "magenta": [
                35,
                39
            ],
            "red": [
                31,
                39
            ],
            "yellow": [
                33,
                39
            ]
        };
        // Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            "special": "cyan",
            "number": "yellow",
            "boolean": "yellow",
            "undefined": "grey",
            "null": "bold",
            "string": "green",
            "date": "magenta",
            // "name": intentionally not styling
            "regexp": "red"
        };
        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) return "\x1b[" + inspect.colors[style][0] + "m" + str + "\x1b[" + inspect.colors[style][1] + "m";
            else return str;
        }
        function stylizeNoColor(str, styleType) {
            return str;
        }
        function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
                hash[val] = true;
            });
            return hash;
        }
        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
            value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
                return ret;
            }
            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) return primitive;
            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                if (isError(value)) return formatError(value);
            }
            var base = "", array = false, braces = [
                "{",
                "}"
            ];
            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = [
                    "[",
                    "]"
                ];
            }
            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base = " [Function" + n + "]";
            }
            // Make RegExps say that they are RegExps
            if (isRegExp(value)) base = " " + RegExp.prototype.toString.call(value);
            // Make dates with properties first say the date
            if (isDate(value)) base = " " + Date.prototype.toUTCString.call(value);
            // Make error with message first say the error
            if (isError(value)) base = " " + formatError(value);
            if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
            if (recurseTimes < 0) {
                if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                else return ctx.stylize("[Object]", "special");
            }
            ctx.seen.push(value);
            var output;
            if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            else output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
            }
            if (isNumber(value)) return ctx.stylize("" + value, "number");
            if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
            // For some reason typeof null is "object", so special case here.
            if (isNull(value)) return ctx.stylize("null", "null");
        }
        function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty1(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
            else output.push("");
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
            });
            return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
            };
            if (desc.get) {
                if (desc.set) str = ctx.stylize("[Getter/Setter]", "special");
                else str = ctx.stylize("[Getter]", "special");
            } else if (desc.set) str = ctx.stylize("[Setter]", "special");
            if (!hasOwnProperty1(visibleKeys, key)) name = "[" + key + "]";
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
                    else str = formatValue(ctx, desc.value, recurseTimes - 1);
                    if (str.indexOf("\n") > -1) {
                        if (array) str = str.split("\n").map(function(line) {
                            return "  " + line;
                        }).join("\n").slice(2);
                        else str = "\n" + str.split("\n").map(function(line) {
                            return "   " + line;
                        }).join("\n");
                    }
                } else str = ctx.stylize("[Circular]", "special");
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) return str;
                name = JSON.stringify("" + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.slice(1, -1);
                    name = ctx.stylize(name, "name");
                } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                }
            }
            return name + ": " + str;
        }
        function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function(prev, cur) {
                cur.indexOf("\n");
                return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }
        // NOTE: These type checking functions intentionally don't use `instanceof`
        // because it is fragile and can be easily faked with `Object.create()`.
        exports1.types = types$2;
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports1.isArray = isArray;
        function isBoolean(arg) {
            return typeof arg === "boolean";
        }
        exports1.isBoolean = isBoolean;
        function isNull(arg) {
            return arg === null;
        }
        exports1.isNull = isNull;
        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports1.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
            return typeof arg === "number";
        }
        exports1.isNumber = isNumber;
        function isString(arg) {
            return typeof arg === "string";
        }
        exports1.isString = isString;
        function isSymbol(arg) {
            return typeof arg === "symbol";
        }
        exports1.isSymbol = isSymbol;
        function isUndefined(arg) {
            return arg === void 0;
        }
        exports1.isUndefined = isUndefined;
        function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
        }
        exports1.isRegExp = isRegExp;
        exports1.types.isRegExp = isRegExp;
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        exports1.isObject = isObject;
        function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
        }
        exports1.isDate = isDate;
        exports1.types.isDate = isDate;
        function isError(e) {
            return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        exports1.isError = isError;
        exports1.types.isNativeError = isError;
        function isFunction(arg) {
            return typeof arg === "function";
        }
        exports1.isFunction = isFunction;
        function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
            typeof arg === "undefined";
        }
        exports1.isPrimitive = isPrimitive;
        exports1.isBuffer = isBuffer;
        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }
        function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }
        var months = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ];
        // 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
            ].join(":");
            return [
                d.getDate(),
                months[d.getMonth()],
                time
            ].join(" ");
        }
        // log is just a thin wrapper to console.log that prepends a timestamp
        exports1.log = function() {
            console.log("%s - %s", timestamp(), exports1.format.apply(exports1, arguments));
        };
        /**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */ exports1.inherits = inherits;
        exports1._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while(i--)origin[keys[i]] = add[keys[i]];
            return origin;
        };
        function hasOwnProperty1(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : undefined;
        exports1.promisify = function promisify(original) {
            if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
            if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                var fn = original[kCustomPromisifiedSymbol];
                if (typeof fn !== "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                });
                return fn;
            }
            function fn() {
                var promiseResolve, promiseReject;
                var promise = new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                });
                var args = [];
                for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
                args.push(function(err, value) {
                    if (err) promiseReject(err);
                    else promiseResolve(value);
                });
                try {
                    original.apply(this, args);
                } catch (err) {
                    promiseReject(err);
                }
                return promise;
            }
            Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
            if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true
            });
            return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
        };
        exports1.promisify.custom = kCustomPromisifiedSymbol;
        function callbackifyOnRejected(reason, cb) {
            // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
            // Because `null` is a special error value in callbacks which means "no error
            // occurred", we error-wrap so the callback consumer can distinguish between
            // "the promise rejected with null" or "the promise fulfilled with undefined".
            if (!reason) {
                var newReason = new Error("Promise was rejected with a falsy value");
                newReason.reason = reason;
                reason = newReason;
            }
            return cb(reason);
        }
        function callbackify(original) {
            if (typeof original !== "function") throw new TypeError('The "original" argument must be of type Function');
            // We DO NOT return the promise as it gives the user a false sense that
            // the promise is actually somehow related to the callback's execution
            // and that the callback throwing will reject the promise.
            function callbackified() {
                var args = [];
                for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
                var maybeCb = args.pop();
                if (typeof maybeCb !== "function") throw new TypeError("The last argument must be of type Function");
                var self1 = this;
                var cb = function() {
                    return maybeCb.apply(self1, arguments);
                };
                // In true node style we process the callback on `nextTick` with all the
                // implications (stack, `uncaughtException`, `async_hooks`)
                original.apply(this, args).then(function(ret) {
                    process.nextTick(cb.bind(null, null, ret));
                }, function(rej) {
                    process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                });
            }
            Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
            Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
            return callbackified;
        }
        exports1.callbackify = callbackify;
    });
    var util_1 = util.format;
    var util_2 = util.deprecate;
    var util_3 = util.debuglog;
    var util_4 = util.inspect;
    var util_5 = util.types;
    var util_6 = util.isArray;
    var util_7 = util.isBoolean;
    var util_8 = util.isNull;
    var util_9 = util.isNullOrUndefined;
    var util_10 = util.isNumber;
    var util_11 = util.isString;
    var util_12 = util.isSymbol;
    var util_13 = util.isUndefined;
    var util_14 = util.isRegExp;
    var util_15 = util.isObject;
    var util_16 = util.isDate;
    var util_17 = util.isError;
    var util_18 = util.isFunction;
    var util_19 = util.isPrimitive;
    var util_20 = util.isBuffer;
    var util_21 = util.log;
    var util_22 = util.inherits;
    var util_23 = util._extend;
    var util_24 = util.promisify;
    var util_25 = util.callbackify;
    var util_inspect = util.inspect;
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice$2 = String.prototype.slice;
    var $replace$1 = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat$1 = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    // ie, `has-tostringtag/shams
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
     ? function(O) {
        return O.__proto__; // eslint-disable-line no-proto
    } : null);
    function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) return str;
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
            var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
            if (int !== num) {
                var intStr = String(int);
                var dec = $slice$2.call(str, intStr.length + 1);
                return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
            }
        }
        return $replace$1.call(str, sepRegex, "$&_");
    }
    var inspectCustom = util_inspect.custom;
    var inspectSymbol = isSymbol$1(inspectCustom) ? inspectCustom : null;
    var objectInspect = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has$2(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (has$2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var customInspect = has$2(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (has$2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (has$2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") return "undefined";
        if (obj === null) return "null";
        if (typeof obj === "boolean") return obj ? "true" : "false";
        if (typeof obj === "string") return inspectString(obj, opts);
        if (typeof obj === "number") {
            if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
            var str = String(obj);
            return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
            var bigIntStr = String(obj) + "n";
            return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") depth = 0;
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray$1(obj) ? "[Array]" : "[Object]";
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") seen = [];
        else if (indexOf(seen, obj) >= 0) return "[Circular]";
        function inspect(value, from, noIndent) {
            if (from) {
                seen = $arrSlice.call(seen);
                seen.push(from);
            }
            if (noIndent) {
                var newOpts = {
                    depth: opts.depth
                };
                if (has$2(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
                return inspect_(value, newOpts, depth + 1, seen);
            }
            return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function" && !isRegExp(obj)) {
            var name = nameOf(obj);
            var keys = arrObjKeys(obj, inspect);
            return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
        }
        if (isSymbol$1(obj)) {
            var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
            return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement$1(obj)) {
            var s = "<" + $toLowerCase.call(String(obj.nodeName));
            var attrs = obj.attributes || [];
            for(var i = 0; i < attrs.length; i++)s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
            s += ">";
            if (obj.childNodes && obj.childNodes.length) s += "...";
            s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
            return s;
        }
        if (isArray$1(obj)) {
            if (obj.length === 0) return "[]";
            var xs = arrObjKeys(obj, inspect);
            if (indent && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent) + "]";
            return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
            var parts = arrObjKeys(obj, inspect);
            if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable$1.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
            if (parts.length === 0) return "[" + String(obj) + "]";
            return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
            if (inspectSymbol && typeof obj[inspectSymbol] === "function" && util_inspect) return util_inspect(obj, {
                depth: maxDepth - depth
            });
            else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
        }
        if (isMap$1(obj)) {
            var mapParts = [];
            mapForEach.call(obj, function(value, key) {
                mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
            });
            return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet$1(obj)) {
            var setParts = [];
            setForEach.call(obj, function(value) {
                setParts.push(inspect(value, obj));
            });
            return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
        if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
        if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
        if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
        if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
        if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
        if (isString$1(obj)) return markBoxed(inspect(String(obj)));
        if (!isDate(obj) && !isRegExp(obj)) {
            var ys = arrObjKeys(obj, inspect);
            var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
            var protoTag = obj instanceof Object ? "" : "null prototype";
            var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$2.call(toStr$a(obj), 8, -1) : protoTag ? "Object" : "";
            var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
            var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
            if (ys.length === 0) return tag + "{}";
            if (indent) return tag + "{" + indentedJoin(ys, indent) + "}";
            return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s + quoteChar;
    }
    function quote(s) {
        return $replace$1.call(String(s), /"/g, "&quot;");
    }
    function isArray$1(obj) {
        return toStr$a(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
        return toStr$a(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
        return toStr$a(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
        return toStr$a(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString$1(obj) {
        return toStr$a(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
        return toStr$a(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
        return toStr$a(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
    function isSymbol$1(obj) {
        if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
        if (typeof obj === "symbol") return true;
        if (!obj || typeof obj !== "object" || !symToString) return false;
        try {
            symToString.call(obj);
            return true;
        } catch (e) {}
        return false;
    }
    function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
        try {
            bigIntValueOf.call(obj);
            return true;
        } catch (e) {}
        return false;
    }
    var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
        return key in this;
    };
    function has$2(obj, key) {
        return hasOwn$1.call(obj, key);
    }
    function toStr$a(obj) {
        return objectToString.call(obj);
    }
    function nameOf(f) {
        if (f.name) return f.name;
        var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
        if (m) return m[1];
        return null;
    }
    function indexOf(xs, x) {
        if (xs.indexOf) return xs.indexOf(x);
        for(var i = 0, l = xs.length; i < l; i++){
            if (xs[i] === x) return i;
        }
        return -1;
    }
    function isMap$1(x) {
        if (!mapSize || !x || typeof x !== "object") return false;
        try {
            mapSize.call(x);
            try {
                setSize.call(x);
            } catch (s) {
                return true;
            }
            return x instanceof Map; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    }
    function isWeakMap(x) {
        if (!weakMapHas || !x || typeof x !== "object") return false;
        try {
            weakMapHas.call(x, weakMapHas);
            try {
                weakSetHas.call(x, weakSetHas);
            } catch (s) {
                return true;
            }
            return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    }
    function isWeakRef(x) {
        if (!weakRefDeref || !x || typeof x !== "object") return false;
        try {
            weakRefDeref.call(x);
            return true;
        } catch (e) {}
        return false;
    }
    function isSet$1(x) {
        if (!setSize || !x || typeof x !== "object") return false;
        try {
            setSize.call(x);
            try {
                mapSize.call(x);
            } catch (m) {
                return true;
            }
            return x instanceof Set; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    }
    function isWeakSet(x) {
        if (!weakSetHas || !x || typeof x !== "object") return false;
        try {
            weakSetHas.call(x, weakSetHas);
            try {
                weakMapHas.call(x, weakMapHas);
            } catch (s) {
                return true;
            }
            return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
    }
    function isElement$1(x) {
        if (!x || typeof x !== "object") return false;
        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
        return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
            var remaining = str.length - opts.maxStringLength;
            var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
            return inspectString($slice$2.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        // eslint-disable-next-line no-control-regex
        var s = $replace$1.call($replace$1.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
        var n = c.charCodeAt(0);
        var x = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[n];
        if (x) return "\\" + x;
        return "\\x" + (n < 0x10 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
        return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
        return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
        for(var i = 0; i < xs.length; i++){
            if (indexOf(xs[i], "\n") >= 0) return false;
        }
        return true;
    }
    function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") baseIndent = "	";
        else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
        else return null;
        return {
            base: baseIndent,
            prev: $join.call(Array(depth + 1), baseIndent)
        };
    }
    function indentedJoin(xs, indent) {
        if (xs.length === 0) return "";
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
        var isArr = isArray$1(obj);
        var xs = [];
        if (isArr) {
            xs.length = obj.length;
            for(var i = 0; i < obj.length; i++)xs[i] = has$2(obj, i) ? inspect(obj[i], obj) : "";
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
            symMap = {};
            for(var k = 0; k < syms.length; k++)symMap["$" + syms[k]] = syms[k];
        }
        for(var key in obj){
            if (!has$2(obj, key)) continue;
             // eslint-disable-line no-restricted-syntax, no-continue
            if (isArr && String(Number(key)) === key && key < obj.length) continue;
             // eslint-disable-line no-restricted-syntax, no-continue
            if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) continue; // eslint-disable-line no-restricted-syntax, no-continue
            else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
            else xs.push(key + ": " + inspect(obj[key], obj));
        }
        if (typeof gOPS === "function") {
            for(var j = 0; j < syms.length; j++)if (isEnumerable$1.call(obj, syms[j])) xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
        return xs;
    }
    var $TypeError$1 = getIntrinsic("%TypeError%");
    var $WeakMap$1 = getIntrinsic("%WeakMap%", true);
    var $Map$2 = getIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas$3 = callBound("Map.prototype.has", true);
    /*
	 * This function traverses the list returning the node corresponding to the
	 * given key.
	 *
	 * That node is also moved to the head of the list, so that if it's accessed
	 * again we don't need to traverse the whole list. By doing so, all the recently
	 * used nodes can be accessed relatively quickly.
	 */ var listGetNode = function(list, key) {
        for(var prev = list, curr; (curr = prev.next) !== null; prev = curr)if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr; // eslint-disable-line no-param-reassign
            return curr;
        }
    };
    var listGet = function(objects, key) {
        var node = listGetNode(objects, key);
        return node && node.value;
    };
    var listSet = function(objects, key, value) {
        var node = listGetNode(objects, key);
        if (node) node.value = value;
        else // Prepend the new node to the beginning of the list
        objects.next = {
            key: key,
            next: objects.next,
            value: value
        };
    };
    var listHas = function(objects, key) {
        return !!listGetNode(objects, key);
    };
    var sideChannel = function getSideChannel() {
        var $wm;
        var $m;
        var $o;
        var channel = {
            assert: function(key) {
                if (!channel.has(key)) throw new $TypeError$1("Side channel does not contain " + objectInspect(key));
            },
            get: function(key) {
                if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
                    if ($wm) return $weakMapGet($wm, key);
                } else if ($Map$2) {
                    if ($m) return $mapGet($m, key);
                } else {
                    if ($o) return listGet($o, key);
                }
            },
            has: function(key) {
                if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
                    if ($wm) return $weakMapHas($wm, key);
                } else if ($Map$2) {
                    if ($m) return $mapHas$3($m, key);
                } else {
                    if ($o) return listHas($o, key);
                }
                return false;
            },
            set: function(key, value) {
                if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
                    if (!$wm) $wm = new $WeakMap$1();
                    $weakMapSet($wm, key, value);
                } else if ($Map$2) {
                    if (!$m) $m = new $Map$2();
                    $mapSet($m, key, value);
                } else {
                    if (!$o) /*
						 * Initialize the linked list as an empty node, so that we don't have
						 * to special-case handling of the first node: we can always refer to
						 * it as (previous node).next, instead of something like (list).head
						 */ $o = {
                        key: {},
                        next: null
                    };
                    listSet($o, key, value);
                }
            }
        };
        return channel;
    };
    // modified from https://github.com/es-shims/es6-shim
    var hasSymbols$3 = shams();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols$3 ? Object.getOwnPropertySymbols : null;
    // eslint-disable-next-line no-unused-vars
    var implementation$4 = function assign(target, source1) {
        if (target == null) throw new TypeError("target must be an object");
        var to = toObject(target); // step 1
        if (arguments.length === 1) return to; // step 2
        for(var s = 1; s < arguments.length; ++s){
            var from = toObject(arguments[s]); // step 3.a.i
            // step 3.a.ii:
            var keys = objectKeys(from);
            var getSymbols = hasSymbols$3 && (Object.getOwnPropertySymbols || originalGetSymbols);
            if (getSymbols) {
                var syms = getSymbols(from);
                for(var j = 0; j < syms.length; ++j){
                    var key = syms[j];
                    if ($propIsEnumerable(from, key)) $push(keys, key);
                }
            }
            // step 3.a.iii:
            for(var i = 0; i < keys.length; ++i){
                var nextKey = keys[i];
                if ($propIsEnumerable(from, nextKey)) {
                    var propValue = from[nextKey]; // step 3.a.iii.2.a
                    to[nextKey] = propValue; // step 3.a.iii.2.b
                }
            }
        }
        return to; // step 4
    };
    var lacksProperEnumerationOrder = function() {
        if (!Object.assign) return false;
        /*
		 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
		 * note: this does not detect the bug unless there's 20 characters
		 */ var str = "abcdefghijklmnopqrst";
        var letters = str.split("");
        var map = {};
        for(var i = 0; i < letters.length; ++i)map[letters[i]] = letters[i];
        var obj = Object.assign({}, map);
        var actual = "";
        for(var k in obj)actual += k;
        return str !== actual;
    };
    var assignHasPendingExceptions = function() {
        if (!Object.assign || !Object.preventExtensions) return false;
        /*
		 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		 * which is 72% slower than our shim, and Firefox 40's native implementation.
		 */ var thrower = Object.preventExtensions({
            1: 2
        });
        try {
            Object.assign(thrower, "xy");
        } catch (e) {
            return thrower[1] === "y";
        }
        return false;
    };
    var polyfill$3 = function getPolyfill() {
        if (!Object.assign) return implementation$4;
        if (lacksProperEnumerationOrder()) return implementation$4;
        if (assignHasPendingExceptions()) return implementation$4;
        return Object.assign;
    };
    var shim$2 = function shimAssign() {
        var polyfill = polyfill$3();
        defineProperties_1(Object, {
            assign: polyfill
        }, {
            assign: function() {
                return Object.assign !== polyfill;
            }
        });
        return polyfill;
    };
    var polyfill$4 = callBind.apply(polyfill$3());
    // eslint-disable-next-line no-unused-vars
    var bound = function assign(target, source1) {
        return polyfill$4(Object, arguments);
    };
    defineProperties_1(bound, {
        getPolyfill: polyfill$3,
        implementation: implementation$4,
        shim: shim$2
    });
    var object_assign = bound;
    var getIterator$1 = getCjsExportFromNamespace(node$1);
    var $getTime = callBound("Date.prototype.getTime");
    var gPO$1 = Object.getPrototypeOf;
    var $objToString = callBound("Object.prototype.toString");
    var $Set$2 = getIntrinsic("%Set%", true);
    var $mapHas$4 = callBound("Map.prototype.has", true);
    var $mapGet$1 = callBound("Map.prototype.get", true);
    var $mapSize = callBound("Map.prototype.size", true);
    var $setAdd = callBound("Set.prototype.add", true);
    var $setDelete = callBound("Set.prototype.delete", true);
    var $setHas$3 = callBound("Set.prototype.has", true);
    var $setSize = callBound("Set.prototype.size", true);
    // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
    function setHasEqualElement(set, val1, opts, channel) {
        var i = getIterator$1(set);
        var result;
        while((result = i.next()) && !result.done)if (internalDeepEqual(val1, result.value, opts, channel)) {
            // Remove the matching element to make sure we do not check that again.
            $setDelete(set, result.value);
            return true;
        }
        return false;
    }
    // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
    function findLooseMatchingPrimitives(prim) {
        if (typeof prim === "undefined") return null;
        if (typeof prim === "object") return void 0;
        if (typeof prim === "symbol") return false;
        if (typeof prim === "string" || typeof prim === "number") // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
        return +prim === +prim; // eslint-disable-line no-implicit-coercion
        return true;
    }
    // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
    function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) return altValue;
        var curB = $mapGet$1(b, altValue);
        var looseOpts = object_assign({}, opts, {
            strict: false
        });
        if (typeof curB === "undefined" && !$mapHas$4(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) return false;
        // eslint-disable-next-line no-use-before-define
        return !$mapHas$4(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
    }
    // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
    function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) return altValue;
        return $setHas$3(b, altValue) && !$setHas$3(a, altValue);
    }
    // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
    function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
        var i = getIterator$1(set);
        var result;
        var key2;
        while((result = i.next()) && !result.done){
            key2 = result.value;
            if (// eslint-disable-next-line no-use-before-define
            internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet$1(map, key2), opts, channel)) {
                $setDelete(set, key2);
                return true;
            }
        }
        return false;
    }
    function internalDeepEqual(actual, expected, options, channel) {
        var opts = options || {};
        // 7.1. All identical values are equivalent, as determined by ===.
        if (opts.strict ? objectIs(actual, expected) : actual === expected) return true;
        var actualBoxed = whichBoxedPrimitive(actual);
        var expectedBoxed = whichBoxedPrimitive(expected);
        if (actualBoxed !== expectedBoxed) return false;
        // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") return opts.strict ? objectIs(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
        /*
	   * 7.4. For all other Object pairs, including Array objects, equivalence is
	   * determined by having the same number of owned properties (as verified
	   * with Object.prototype.hasOwnProperty.call), the same set of keys
	   * (although not necessarily the same order), equivalent values for every
	   * corresponding key, and an identical 'prototype' property. Note: this
	   * accounts for both named and indexed properties on Arrays.
	   */ // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration
        var hasActual = channel.has(actual);
        var hasExpected = channel.has(expected);
        var sentinel;
        if (hasActual && hasExpected) {
            if (channel.get(actual) === channel.get(expected)) return true;
        } else sentinel = {};
        if (!hasActual) channel.set(actual, sentinel);
        if (!hasExpected) channel.set(expected, sentinel);
        // eslint-disable-next-line no-use-before-define
        return objEquiv(actual, expected, opts, channel);
    }
    function isBuffer$1(x) {
        if (!x || typeof x !== "object" || typeof x.length !== "number") return false;
        if (typeof x.copy !== "function" || typeof x.slice !== "function") return false;
        if (x.length > 0 && typeof x[0] !== "number") return false;
        return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
    }
    function setEquiv(a, b, opts, channel) {
        if ($setSize(a) !== $setSize(b)) return false;
        var iA = getIterator$1(a);
        var iB = getIterator$1(b);
        var resultA;
        var resultB;
        var set;
        while((resultA = iA.next()) && !resultA.done){
            if (resultA.value && typeof resultA.value === "object") {
                if (!set) set = new $Set$2();
                $setAdd(set, resultA.value);
            } else if (!$setHas$3(b, resultA.value)) {
                if (opts.strict) return false;
                if (!setMightHaveLoosePrim(a, b, resultA.value)) return false;
                if (!set) set = new $Set$2();
                $setAdd(set, resultA.value);
            }
        }
        if (set) {
            while((resultB = iB.next()) && !resultB.done){
                // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
                if (resultB.value && typeof resultB.value === "object") {
                    if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) return false;
                } else if (!opts.strict && !$setHas$3(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) return false;
            }
            return $setSize(set) === 0;
        }
        return true;
    }
    function mapEquiv(a, b, opts, channel) {
        if ($mapSize(a) !== $mapSize(b)) return false;
        var iA = getIterator$1(a);
        var iB = getIterator$1(b);
        var resultA;
        var resultB;
        var set;
        var key;
        var item1;
        var item2;
        while((resultA = iA.next()) && !resultA.done){
            key = resultA.value[0];
            item1 = resultA.value[1];
            if (key && typeof key === "object") {
                if (!set) set = new $Set$2();
                $setAdd(set, key);
            } else {
                item2 = $mapGet$1(b, key);
                if (typeof item2 === "undefined" && !$mapHas$4(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
                    if (opts.strict) return false;
                    if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) return false;
                    if (!set) set = new $Set$2();
                    $setAdd(set, key);
                }
            }
        }
        if (set) {
            while((resultB = iB.next()) && !resultB.done){
                key = resultB.value[0];
                item2 = resultB.value[1];
                if (key && typeof key === "object") {
                    if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) return false;
                } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet$1(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, object_assign({}, opts, {
                    strict: false
                }), channel)) return false;
            }
            return $setSize(set) === 0;
        }
        return true;
    }
    function objEquiv(a, b, opts, channel) {
        /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */ var i, key;
        if (typeof a !== typeof b) return false;
        if (a == null || b == null) return false;
        if ($objToString(a) !== $objToString(b)) return false;
        if (isArguments$1(a) !== isArguments$1(b)) return false;
        var aIsArray = isarray(a);
        var bIsArray = isarray(b);
        if (aIsArray !== bIsArray) return false;
        // TODO: replace when a cross-realm brand check is available
        var aIsError = a instanceof Error;
        var bIsError = b instanceof Error;
        if (aIsError !== bIsError) return false;
        if (aIsError || bIsError) {
            if (a.name !== b.name || a.message !== b.message) return false;
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) return false;
        if ((aIsRegex || bIsRegex) && (a.source !== b.source || regexp_prototype_flags(a) !== regexp_prototype_flags(b))) return false;
        var aIsDate = isDateObject(a);
        var bIsDate = isDateObject(b);
        if (aIsDate !== bIsDate) return false;
        if (aIsDate || bIsDate) {
            if ($getTime(a) !== $getTime(b)) return false;
        }
        if (opts.strict && gPO$1 && gPO$1(a) !== gPO$1(b)) return false;
        if (whichTypedArray(a) !== whichTypedArray(b)) return false;
        var aIsBuffer = isBuffer$1(a);
        var bIsBuffer = isBuffer$1(b);
        if (aIsBuffer !== bIsBuffer) return false;
        if (aIsBuffer || bIsBuffer) {
            if (a.length !== b.length) return false;
            for(i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        if (typeof a !== typeof b) return false;
        var ka = objectKeys(a);
        var kb = objectKeys(b);
        // having the same number of owned properties (keys incorporates hasOwnProperty)
        if (ka.length !== kb.length) return false;
        // the same set of keys (although not necessarily the same order),
        ka.sort();
        kb.sort();
        // ~~~cheap key test
        for(i = ka.length - 1; i >= 0; i--){
            if (ka[i] != kb[i]) return false;
             // eslint-disable-line eqeqeq
        }
        // equivalent values for every corresponding key, and ~~~possibly expensive deep test
        for(i = ka.length - 1; i >= 0; i--){
            key = ka[i];
            if (!internalDeepEqual(a[key], b[key], opts, channel)) return false;
        }
        var aCollection = whichCollection(a);
        var bCollection = whichCollection(b);
        if (aCollection !== bCollection) return false;
        if (aCollection === "Set" || bCollection === "Set") return setEquiv(a, b, opts, channel);
        if (aCollection === "Map") return mapEquiv(a, b, opts, channel);
        return true;
    }
    var deepEqual = function deepEqual(a, b, opts) {
        return internalDeepEqual(a, b, opts, sideChannel());
    };
    var elementRoleMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _deepEqual = _interopRequireDefault(deepEqual);
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
        var _rolesMap = _interopRequireDefault(rolesMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var elementRoles = [];
        var keys = _rolesMap.default.keys();
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var role = _rolesMap.default.get(key);
            if (role) {
                var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
                for(var k = 0; k < concepts.length; k++){
                    var relation = concepts[k];
                    if (relation.module === "HTML") {
                        var concept = relation.concept;
                        if (concept) (function() {
                            var conceptStr = JSON.stringify(concept);
                            var elementRoleRelation = elementRoles.find(function(relation) {
                                return JSON.stringify(relation[0]) === conceptStr;
                            });
                            var roles = void 0;
                            if (elementRoleRelation) roles = elementRoleRelation[1];
                            else roles = [];
                            var isUnique = true;
                            for(var _i = 0; _i < roles.length; _i++)if (roles[_i] === key) {
                                isUnique = false;
                                break;
                            }
                            if (isUnique) roles.push(key);
                            elementRoles.push([
                                concept,
                                roles
                            ]);
                        })();
                    }
                }
            }
        }
        var elementRoleMap = {
            entries: function entries() {
                return elementRoles;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator = _createForOfIteratorHelper(elementRoles), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
                        fn.call(thisArg, values, _key, elementRoles);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            },
            get: function get(key) {
                var item = elementRoles.find(function(tuple) {
                    return (0, _deepEqual.default)(key, tuple[0]);
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return elementRoles.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return elementRoles.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
        exports1.default = _default;
    });
    unwrapExports(elementRoleMap_1);
    var roleElementMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
        var _rolesMap = _interopRequireDefault(rolesMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var roleElement = [];
        var keys = _rolesMap.default.keys();
        var _loop = function _loop(i) {
            var key = keys[i];
            var role = _rolesMap.default.get(key);
            if (role) {
                var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
                for(var k = 0; k < concepts.length; k++){
                    var relation = concepts[k];
                    if (relation.module === "HTML") {
                        var concept = relation.concept;
                        if (concept) {
                            var roleElementRelation = roleElement.find(function(item) {
                                return item[0] === key;
                            });
                            var relationConcepts = void 0;
                            if (roleElementRelation) relationConcepts = roleElementRelation[1];
                            else relationConcepts = [];
                            relationConcepts.push(concept);
                            roleElement.push([
                                key,
                                relationConcepts
                            ]);
                        }
                    }
                }
            }
        };
        for(var i = 0; i < keys.length; i++)_loop(i);
        var roleElementMap = {
            entries: function entries() {
                return roleElement;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator = _createForOfIteratorHelper(roleElement), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
                        fn.call(thisArg, values, key, roleElement);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            },
            get: function get(key) {
                var item = roleElement.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return roleElement.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return roleElement.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
        exports1.default = _default;
    });
    unwrapExports(roleElementMap_1);
    var lib = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.roles = exports1.roleElements = exports1.elementRoles = exports1.dom = exports1.aria = void 0;
        var _ariaPropsMap = _interopRequireDefault(ariaPropsMap_1);
        var _domMap = _interopRequireDefault(domMap_1);
        var _rolesMap = _interopRequireDefault(rolesMap_1);
        var _elementRoleMap = _interopRequireDefault(elementRoleMap_1);
        var _roleElementMap = _interopRequireDefault(roleElementMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var aria = _ariaPropsMap.default;
        exports1.aria = aria;
        var dom = _domMap.default;
        exports1.dom = dom;
        var roles = _rolesMap.default;
        exports1.roles = roles;
        var elementRoles = _elementRoleMap.default;
        exports1.elementRoles = elementRoles;
        var roleElements = _roleElementMap.default;
        exports1.roleElements = roleElements;
    });
    unwrapExports(lib);
    var lib_1 = lib.roles;
    var lib_2 = lib.roleElements;
    var lib_3 = lib.elementRoles;
    var lib_4 = lib.dom;
    var lib_5 = lib.aria;
    var iteratorProxy_1$1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        function iteratorProxy() {
            var values = this;
            var index = 0;
            var iter = {
                "@@iterator": function iterator() {
                    return iter;
                },
                next: function next() {
                    if (index < values.length) {
                        var value = values[index];
                        index = index + 1;
                        return {
                            done: false,
                            value: value
                        };
                    } else return {
                        done: true
                    };
                }
            };
            return iter;
        }
        var _default = iteratorProxy;
        exports1.default = _default;
    });
    unwrapExports(iteratorProxy_1$1);
    var iterationDecorator_1$1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = iterationDecorator;
        var _iteratorProxy = _interopRequireDefault(iteratorProxy_1$1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _typeof(obj) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _typeof(obj);
        }
        function iterationDecorator(collection, entries) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") Object.defineProperty(collection, Symbol.iterator, {
                value: _iteratorProxy.default.bind(entries)
            });
            return collection;
        }
    });
    unwrapExports(iterationDecorator_1$1);
    var AbbrRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var AbbrRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "abbr"
                    }
                }
            ],
            type: "structure"
        };
        var _default = AbbrRole;
        exports1.default = _default;
    });
    unwrapExports(AbbrRole_1);
    var AlertDialogRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var AlertDialogRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "alertdialog"
                    }
                }
            ],
            type: "window"
        };
        var _default = AlertDialogRole;
        exports1.default = _default;
    });
    unwrapExports(AlertDialogRole_1);
    var AlertRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var AlertRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "alert"
                    }
                }
            ],
            type: "structure"
        };
        var _default = AlertRole;
        exports1.default = _default;
    });
    unwrapExports(AlertRole_1);
    var AnnotationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var AnnotationRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = AnnotationRole;
        exports1.default = _default;
    });
    unwrapExports(AnnotationRole_1);
    var ApplicationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ApplicationRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "application"
                    }
                }
            ],
            type: "window"
        };
        var _default = ApplicationRole;
        exports1.default = _default;
    });
    unwrapExports(ApplicationRole_1);
    var ArticleRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ArticleRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "article"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "article"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ArticleRole;
        exports1.default = _default;
    });
    unwrapExports(ArticleRole_1);
    var AudioRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var AudioRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "audio"
                    }
                }
            ],
            type: "widget"
        };
        var _default = AudioRole;
        exports1.default = _default;
    });
    unwrapExports(AudioRole_1);
    var BannerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var BannerRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "banner"
                    }
                }
            ],
            type: "structure"
        };
        var _default = BannerRole;
        exports1.default = _default;
    });
    unwrapExports(BannerRole_1);
    var BlockquoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var BlockquoteRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "blockquote"
                    }
                }
            ],
            type: "structure"
        };
        var _default = BlockquoteRole;
        exports1.default = _default;
    });
    unwrapExports(BlockquoteRole_1);
    var BusyIndicatorRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var BusyIndicatorRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        attributes: [
                            {
                                name: "aria-busy",
                                value: "true"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = BusyIndicatorRole;
        exports1.default = _default;
    });
    unwrapExports(BusyIndicatorRole_1);
    var ButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ButtonRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "button"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "button"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ButtonRole;
        exports1.default = _default;
    });
    unwrapExports(ButtonRole_1);
    var CanvasRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var CanvasRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "canvas"
                    }
                }
            ],
            type: "widget"
        };
        var _default = CanvasRole;
        exports1.default = _default;
    });
    unwrapExports(CanvasRole_1);
    var CaptionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var CaptionRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "caption"
                    }
                }
            ],
            type: "structure"
        };
        var _default = CaptionRole;
        exports1.default = _default;
    });
    unwrapExports(CaptionRole_1);
    var CellRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var CellRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "cell"
                    }
                },
                {
                    module: "ARIA",
                    concept: {
                        name: "gridcell"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "td"
                    }
                }
            ],
            type: "widget"
        };
        var _default = CellRole;
        exports1.default = _default;
    });
    unwrapExports(CellRole_1);
    var CheckBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var CheckBoxRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "checkbox"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "checkbox"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = CheckBoxRole;
        exports1.default = _default;
    });
    unwrapExports(CheckBoxRole_1);
    var ColorWellRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ColorWellRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "color"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = ColorWellRole;
        exports1.default = _default;
    });
    unwrapExports(ColorWellRole_1);
    var ColumnHeaderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ColumnHeaderRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "columnheader"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "th"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ColumnHeaderRole;
        exports1.default = _default;
    });
    unwrapExports(ColumnHeaderRole_1);
    var ColumnRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ColumnRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = ColumnRole;
        exports1.default = _default;
    });
    unwrapExports(ColumnRole_1);
    var ComboBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ComboBoxRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "combobox"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "select"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ComboBoxRole;
        exports1.default = _default;
    });
    unwrapExports(ComboBoxRole_1);
    var ComplementaryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ComplementaryRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "complementary"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ComplementaryRole;
        exports1.default = _default;
    });
    unwrapExports(ComplementaryRole_1);
    var ContentInfoRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ContentInfoRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "structureinfo"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ContentInfoRole;
        exports1.default = _default;
    });
    unwrapExports(ContentInfoRole_1);
    var DateRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DateRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "date"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = DateRole;
        exports1.default = _default;
    });
    unwrapExports(DateRole_1);
    var DateTimeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DateTimeRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "datetime"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = DateTimeRole;
        exports1.default = _default;
    });
    unwrapExports(DateTimeRole_1);
    var DefinitionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DefinitionRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "dfn"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DefinitionRole;
        exports1.default = _default;
    });
    unwrapExports(DefinitionRole_1);
    var DescriptionListDetailRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DescriptionListDetailRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "dd"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DescriptionListDetailRole;
        exports1.default = _default;
    });
    unwrapExports(DescriptionListDetailRole_1);
    var DescriptionListRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DescriptionListRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "dl"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DescriptionListRole;
        exports1.default = _default;
    });
    unwrapExports(DescriptionListRole_1);
    var DescriptionListTermRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DescriptionListTermRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "dt"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DescriptionListTermRole;
        exports1.default = _default;
    });
    unwrapExports(DescriptionListTermRole_1);
    var DetailsRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DetailsRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "details"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DetailsRole;
        exports1.default = _default;
    });
    unwrapExports(DetailsRole_1);
    var DialogRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DialogRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "dialog"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "dialog"
                    }
                }
            ],
            type: "window"
        };
        var _default = DialogRole;
        exports1.default = _default;
    });
    unwrapExports(DialogRole_1);
    var DirectoryRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DirectoryRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "directory"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "dir"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DirectoryRole;
        exports1.default = _default;
    });
    unwrapExports(DirectoryRole_1);
    var DisclosureTriangleRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DisclosureTriangleRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "summary"
                    }
                }
            ],
            type: "widget"
        };
        var _default = DisclosureTriangleRole;
        exports1.default = _default;
    });
    unwrapExports(DisclosureTriangleRole_1);
    var DivRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DivRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "div"
                    }
                }
            ],
            type: "generic"
        };
        var _default = DivRole;
        exports1.default = _default;
    });
    unwrapExports(DivRole_1);
    var DocumentRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var DocumentRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "document"
                    }
                }
            ],
            type: "structure"
        };
        var _default = DocumentRole;
        exports1.default = _default;
    });
    unwrapExports(DocumentRole_1);
    var EmbeddedObjectRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var EmbeddedObjectRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "embed"
                    }
                }
            ],
            type: "widget"
        };
        var _default = EmbeddedObjectRole;
        exports1.default = _default;
    });
    unwrapExports(EmbeddedObjectRole_1);
    var FeedRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var FeedRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "feed"
                    }
                }
            ],
            type: "structure"
        };
        var _default = FeedRole;
        exports1.default = _default;
    });
    unwrapExports(FeedRole_1);
    var FigcaptionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var FigcaptionRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "figcaption"
                    }
                }
            ],
            type: "structure"
        };
        var _default = FigcaptionRole;
        exports1.default = _default;
    });
    unwrapExports(FigcaptionRole_1);
    var FigureRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var FigureRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "figure"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "figure"
                    }
                }
            ],
            type: "structure"
        };
        var _default = FigureRole;
        exports1.default = _default;
    });
    unwrapExports(FigureRole_1);
    var FooterRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var FooterRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "footer"
                    }
                }
            ],
            type: "structure"
        };
        var _default = FooterRole;
        exports1.default = _default;
    });
    unwrapExports(FooterRole_1);
    var FormRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var FormRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "form"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "form"
                    }
                }
            ],
            type: "structure"
        };
        var _default = FormRole;
        exports1.default = _default;
    });
    unwrapExports(FormRole_1);
    var GridRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var GridRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "grid"
                    }
                }
            ],
            type: "widget"
        };
        var _default = GridRole;
        exports1.default = _default;
    });
    unwrapExports(GridRole_1);
    var GroupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var GroupRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "group"
                    }
                }
            ],
            type: "structure"
        };
        var _default = GroupRole;
        exports1.default = _default;
    });
    unwrapExports(GroupRole_1);
    var HeadingRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var HeadingRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "heading"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h1"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h2"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h3"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h4"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h5"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "h6"
                    }
                }
            ],
            type: "structure"
        };
        var _default = HeadingRole;
        exports1.default = _default;
    });
    unwrapExports(HeadingRole_1);
    var IframePresentationalRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var IframePresentationalRole = {
            relatedConcepts: [],
            type: "window"
        };
        var _default = IframePresentationalRole;
        exports1.default = _default;
    });
    unwrapExports(IframePresentationalRole_1);
    var IframeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var IframeRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "iframe"
                    }
                }
            ],
            type: "window"
        };
        var _default = IframeRole;
        exports1.default = _default;
    });
    unwrapExports(IframeRole_1);
    var IgnoredRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var IgnoredRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = IgnoredRole;
        exports1.default = _default;
    });
    unwrapExports(IgnoredRole_1);
    var ImageMapLinkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ImageMapLinkRole = {
            relatedConcepts: [],
            type: "widget"
        };
        var _default = ImageMapLinkRole;
        exports1.default = _default;
    });
    unwrapExports(ImageMapLinkRole_1);
    var ImageMapRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ImageMapRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "img",
                        attributes: [
                            {
                                name: "usemap"
                            }
                        ]
                    }
                }
            ],
            type: "structure"
        };
        var _default = ImageMapRole;
        exports1.default = _default;
    });
    unwrapExports(ImageMapRole_1);
    var ImageRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ImageRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "img"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "img"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ImageRole;
        exports1.default = _default;
    });
    unwrapExports(ImageRole_1);
    var InlineTextBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var InlineTextBoxRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "input"
                    }
                }
            ],
            type: "widget"
        };
        var _default = InlineTextBoxRole;
        exports1.default = _default;
    });
    unwrapExports(InlineTextBoxRole_1);
    var InputTimeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var InputTimeRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "time"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = InputTimeRole;
        exports1.default = _default;
    });
    unwrapExports(InputTimeRole_1);
    var LabelRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var LabelRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "label"
                    }
                }
            ],
            type: "structure"
        };
        var _default = LabelRole;
        exports1.default = _default;
    });
    unwrapExports(LabelRole_1);
    var LegendRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var LegendRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "legend"
                    }
                }
            ],
            type: "structure"
        };
        var _default = LegendRole;
        exports1.default = _default;
    });
    unwrapExports(LegendRole_1);
    var LineBreakRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var LineBreakRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "br"
                    }
                }
            ],
            type: "structure"
        };
        var _default = LineBreakRole;
        exports1.default = _default;
    });
    unwrapExports(LineBreakRole_1);
    var LinkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var LinkRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "link"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "a",
                        attributes: [
                            {
                                name: "href"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = LinkRole;
        exports1.default = _default;
    });
    unwrapExports(LinkRole_1);
    var ListBoxOptionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ListBoxOptionRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "option"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "option"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ListBoxOptionRole;
        exports1.default = _default;
    });
    unwrapExports(ListBoxOptionRole_1);
    var ListBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ListBoxRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "listbox"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "datalist"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "select"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ListBoxRole;
        exports1.default = _default;
    });
    unwrapExports(ListBoxRole_1);
    var ListItemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ListItemRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "listitem"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "li"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ListItemRole;
        exports1.default = _default;
    });
    unwrapExports(ListItemRole_1);
    var ListMarkerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ListMarkerRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = ListMarkerRole;
        exports1.default = _default;
    });
    unwrapExports(ListMarkerRole_1);
    var ListRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ListRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "list"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "ul"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "ol"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ListRole;
        exports1.default = _default;
    });
    unwrapExports(ListRole_1);
    var LogRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var LogRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "log"
                    }
                }
            ],
            type: "structure"
        };
        var _default = LogRole;
        exports1.default = _default;
    });
    unwrapExports(LogRole_1);
    var MainRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MainRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "main"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "main"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MainRole;
        exports1.default = _default;
    });
    unwrapExports(MainRole_1);
    var MarkRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MarkRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "mark"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MarkRole;
        exports1.default = _default;
    });
    unwrapExports(MarkRole_1);
    var MarqueeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MarqueeRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "marquee"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "marquee"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MarqueeRole;
        exports1.default = _default;
    });
    unwrapExports(MarqueeRole_1);
    var MathRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MathRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "math"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MathRole;
        exports1.default = _default;
    });
    unwrapExports(MathRole_1);
    var MenuBarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuBarRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "menubar"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MenuBarRole;
        exports1.default = _default;
    });
    unwrapExports(MenuBarRole_1);
    var MenuButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuButtonRole = {
            relatedConcepts: [],
            type: "widget"
        };
        var _default = MenuButtonRole;
        exports1.default = _default;
    });
    unwrapExports(MenuButtonRole_1);
    var MenuItemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuItemRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "menuitem"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "menuitem"
                    }
                }
            ],
            type: "widget"
        };
        var _default = MenuItemRole;
        exports1.default = _default;
    });
    unwrapExports(MenuItemRole_1);
    var MenuItemCheckBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuItemCheckBoxRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "menuitemcheckbox"
                    }
                }
            ],
            type: "widget"
        };
        var _default = MenuItemCheckBoxRole;
        exports1.default = _default;
    });
    unwrapExports(MenuItemCheckBoxRole_1);
    var MenuItemRadioRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuItemRadioRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "menuitemradio"
                    }
                }
            ],
            type: "widget"
        };
        var _default = MenuItemRadioRole;
        exports1.default = _default;
    });
    unwrapExports(MenuItemRadioRole_1);
    var MenuListOptionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuListOptionRole = {
            relatedConcepts: [],
            type: "widget"
        };
        var _default = MenuListOptionRole;
        exports1.default = _default;
    });
    unwrapExports(MenuListOptionRole_1);
    var MenuListPopupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuListPopupRole = {
            relatedConcepts: [],
            type: "widget"
        };
        var _default = MenuListPopupRole;
        exports1.default = _default;
    });
    unwrapExports(MenuListPopupRole_1);
    var MenuRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MenuRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "menu"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "menu"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MenuRole;
        exports1.default = _default;
    });
    unwrapExports(MenuRole_1);
    var MeterRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var MeterRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "meter"
                    }
                }
            ],
            type: "structure"
        };
        var _default = MeterRole;
        exports1.default = _default;
    });
    unwrapExports(MeterRole_1);
    var NavigationRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var NavigationRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "navigation"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "nav"
                    }
                }
            ],
            type: "structure"
        };
        var _default = NavigationRole;
        exports1.default = _default;
    });
    unwrapExports(NavigationRole_1);
    var NoneRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var NoneRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "none"
                    }
                }
            ],
            type: "structure"
        };
        var _default = NoneRole;
        exports1.default = _default;
    });
    unwrapExports(NoneRole_1);
    var NoteRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var NoteRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "note"
                    }
                }
            ],
            type: "structure"
        };
        var _default = NoteRole;
        exports1.default = _default;
    });
    unwrapExports(NoteRole_1);
    var OutlineRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var OutlineRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = OutlineRole;
        exports1.default = _default;
    });
    unwrapExports(OutlineRole_1);
    var ParagraphRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ParagraphRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "p"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ParagraphRole;
        exports1.default = _default;
    });
    unwrapExports(ParagraphRole_1);
    var PopUpButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var PopUpButtonRole = {
            relatedConcepts: [],
            type: "widget"
        };
        var _default = PopUpButtonRole;
        exports1.default = _default;
    });
    unwrapExports(PopUpButtonRole_1);
    var PreRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var PreRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "pre"
                    }
                }
            ],
            type: "structure"
        };
        var _default = PreRole;
        exports1.default = _default;
    });
    unwrapExports(PreRole_1);
    var PresentationalRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var PresentationalRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "presentation"
                    }
                }
            ],
            type: "structure"
        };
        var _default = PresentationalRole;
        exports1.default = _default;
    });
    unwrapExports(PresentationalRole_1);
    var ProgressIndicatorRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ProgressIndicatorRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "progressbar"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "progress"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ProgressIndicatorRole;
        exports1.default = _default;
    });
    unwrapExports(ProgressIndicatorRole_1);
    var RadioButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RadioButtonRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "radio"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "radio"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = RadioButtonRole;
        exports1.default = _default;
    });
    unwrapExports(RadioButtonRole_1);
    var RadioGroupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RadioGroupRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "radiogroup"
                    }
                }
            ],
            type: "structure"
        };
        var _default = RadioGroupRole;
        exports1.default = _default;
    });
    unwrapExports(RadioGroupRole_1);
    var RegionRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RegionRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "region"
                    }
                }
            ],
            type: "structure"
        };
        var _default = RegionRole;
        exports1.default = _default;
    });
    unwrapExports(RegionRole_1);
    var RootWebAreaRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RootWebAreaRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = RootWebAreaRole;
        exports1.default = _default;
    });
    unwrapExports(RootWebAreaRole_1);
    var RowHeaderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RowHeaderRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "rowheader"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "th",
                        attributes: [
                            {
                                name: "scope",
                                value: "row"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = RowHeaderRole;
        exports1.default = _default;
    });
    unwrapExports(RowHeaderRole_1);
    var RowRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RowRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "row"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "tr"
                    }
                }
            ],
            type: "structure"
        };
        var _default = RowRole;
        exports1.default = _default;
    });
    unwrapExports(RowRole_1);
    var RubyRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RubyRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "ruby"
                    }
                }
            ],
            type: "structure"
        };
        var _default = RubyRole;
        exports1.default = _default;
    });
    unwrapExports(RubyRole_1);
    var RulerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var RulerRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = RulerRole;
        exports1.default = _default;
    });
    unwrapExports(RulerRole_1);
    var ScrollAreaRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ScrollAreaRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = ScrollAreaRole;
        exports1.default = _default;
    });
    unwrapExports(ScrollAreaRole_1);
    var ScrollBarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ScrollBarRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "scrollbar"
                    }
                }
            ],
            type: "widget"
        };
        var _default = ScrollBarRole;
        exports1.default = _default;
    });
    unwrapExports(ScrollBarRole_1);
    var SeamlessWebAreaRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SeamlessWebAreaRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = SeamlessWebAreaRole;
        exports1.default = _default;
    });
    unwrapExports(SeamlessWebAreaRole_1);
    var SearchRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SearchRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "search"
                    }
                }
            ],
            type: "structure"
        };
        var _default = SearchRole;
        exports1.default = _default;
    });
    unwrapExports(SearchRole_1);
    var SearchBoxRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SearchBoxRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "searchbox"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "search"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = SearchBoxRole;
        exports1.default = _default;
    });
    unwrapExports(SearchBoxRole_1);
    var SliderRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SliderRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "slider"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "range"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = SliderRole;
        exports1.default = _default;
    });
    unwrapExports(SliderRole_1);
    var SliderThumbRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SliderThumbRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = SliderThumbRole;
        exports1.default = _default;
    });
    unwrapExports(SliderThumbRole_1);
    var SpinButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SpinButtonRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "spinbutton"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "number"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = SpinButtonRole;
        exports1.default = _default;
    });
    unwrapExports(SpinButtonRole_1);
    var SpinButtonPartRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SpinButtonPartRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = SpinButtonPartRole;
        exports1.default = _default;
    });
    unwrapExports(SpinButtonPartRole_1);
    var SplitterRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SplitterRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "separator"
                    }
                }
            ],
            type: "widget"
        };
        var _default = SplitterRole;
        exports1.default = _default;
    });
    unwrapExports(SplitterRole_1);
    var StaticTextRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var StaticTextRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = StaticTextRole;
        exports1.default = _default;
    });
    unwrapExports(StaticTextRole_1);
    var StatusRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var StatusRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "status"
                    }
                }
            ],
            type: "structure"
        };
        var _default = StatusRole;
        exports1.default = _default;
    });
    unwrapExports(StatusRole_1);
    var SVGRootRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SVGRootRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = SVGRootRole;
        exports1.default = _default;
    });
    unwrapExports(SVGRootRole_1);
    var SwitchRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var SwitchRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "switch"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "checkbox"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = SwitchRole;
        exports1.default = _default;
    });
    unwrapExports(SwitchRole_1);
    var TabGroupRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TabGroupRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tablist"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TabGroupRole;
        exports1.default = _default;
    });
    unwrapExports(TabGroupRole_1);
    var TabRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TabRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tab"
                    }
                }
            ],
            type: "widget"
        };
        var _default = TabRole;
        exports1.default = _default;
    });
    unwrapExports(TabRole_1);
    var TableHeaderContainerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TableHeaderContainerRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = TableHeaderContainerRole;
        exports1.default = _default;
    });
    unwrapExports(TableHeaderContainerRole_1);
    var TableRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TableRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "table"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "table"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TableRole;
        exports1.default = _default;
    });
    unwrapExports(TableRole_1);
    var TabListRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TabListRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tablist"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TabListRole;
        exports1.default = _default;
    });
    unwrapExports(TabListRole_1);
    var TabPanelRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TabPanelRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tabpanel"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TabPanelRole;
        exports1.default = _default;
    });
    unwrapExports(TabPanelRole_1);
    var TermRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TermRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "term"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TermRole;
        exports1.default = _default;
    });
    unwrapExports(TermRole_1);
    var TextFieldRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TextFieldRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "textbox"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input"
                    }
                },
                {
                    module: "HTML",
                    concept: {
                        name: "input",
                        attributes: [
                            {
                                name: "type",
                                value: "text"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = TextFieldRole;
        exports1.default = _default;
    });
    unwrapExports(TextFieldRole_1);
    var TimeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TimeRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "time"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TimeRole;
        exports1.default = _default;
    });
    unwrapExports(TimeRole_1);
    var TimerRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TimerRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "timer"
                    }
                }
            ],
            type: "structure"
        };
        var _default = TimerRole;
        exports1.default = _default;
    });
    unwrapExports(TimerRole_1);
    var ToggleButtonRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ToggleButtonRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        attributes: [
                            {
                                name: "aria-pressed"
                            }
                        ]
                    }
                }
            ],
            type: "widget"
        };
        var _default = ToggleButtonRole;
        exports1.default = _default;
    });
    unwrapExports(ToggleButtonRole_1);
    var ToolbarRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var ToolbarRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "toolbar"
                    }
                }
            ],
            type: "structure"
        };
        var _default = ToolbarRole;
        exports1.default = _default;
    });
    unwrapExports(ToolbarRole_1);
    var TreeRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TreeRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tree"
                    }
                }
            ],
            type: "widget"
        };
        var _default = TreeRole;
        exports1.default = _default;
    });
    unwrapExports(TreeRole_1);
    var TreeGridRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TreeGridRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "treegrid"
                    }
                }
            ],
            type: "widget"
        };
        var _default = TreeGridRole;
        exports1.default = _default;
    });
    unwrapExports(TreeGridRole_1);
    var TreeItemRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var TreeItemRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "treeitem"
                    }
                }
            ],
            type: "widget"
        };
        var _default = TreeItemRole;
        exports1.default = _default;
    });
    unwrapExports(TreeItemRole_1);
    var UserInterfaceTooltipRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var UserInterfaceTooltipRole = {
            relatedConcepts: [
                {
                    module: "ARIA",
                    concept: {
                        name: "tooltip"
                    }
                }
            ],
            type: "structure"
        };
        var _default = UserInterfaceTooltipRole;
        exports1.default = _default;
    });
    unwrapExports(UserInterfaceTooltipRole_1);
    var VideoRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var VideoRole = {
            relatedConcepts: [
                {
                    module: "HTML",
                    concept: {
                        name: "video"
                    }
                }
            ],
            type: "widget"
        };
        var _default = VideoRole;
        exports1.default = _default;
    });
    unwrapExports(VideoRole_1);
    var WebAreaRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var WebAreaRole = {
            relatedConcepts: [],
            type: "structure"
        };
        var _default = WebAreaRole;
        exports1.default = _default;
    });
    unwrapExports(WebAreaRole_1);
    var WindowRole_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var WindowRole = {
            relatedConcepts: [],
            type: "window"
        };
        var _default = WindowRole;
        exports1.default = _default;
    });
    unwrapExports(WindowRole_1);
    var AXObjectsMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
        var _AbbrRole = _interopRequireDefault(AbbrRole_1);
        var _AlertDialogRole = _interopRequireDefault(AlertDialogRole_1);
        var _AlertRole = _interopRequireDefault(AlertRole_1);
        var _AnnotationRole = _interopRequireDefault(AnnotationRole_1);
        var _ApplicationRole = _interopRequireDefault(ApplicationRole_1);
        var _ArticleRole = _interopRequireDefault(ArticleRole_1);
        var _AudioRole = _interopRequireDefault(AudioRole_1);
        var _BannerRole = _interopRequireDefault(BannerRole_1);
        var _BlockquoteRole = _interopRequireDefault(BlockquoteRole_1);
        var _BusyIndicatorRole = _interopRequireDefault(BusyIndicatorRole_1);
        var _ButtonRole = _interopRequireDefault(ButtonRole_1);
        var _CanvasRole = _interopRequireDefault(CanvasRole_1);
        var _CaptionRole = _interopRequireDefault(CaptionRole_1);
        var _CellRole = _interopRequireDefault(CellRole_1);
        var _CheckBoxRole = _interopRequireDefault(CheckBoxRole_1);
        var _ColorWellRole = _interopRequireDefault(ColorWellRole_1);
        var _ColumnHeaderRole = _interopRequireDefault(ColumnHeaderRole_1);
        var _ColumnRole = _interopRequireDefault(ColumnRole_1);
        var _ComboBoxRole = _interopRequireDefault(ComboBoxRole_1);
        var _ComplementaryRole = _interopRequireDefault(ComplementaryRole_1);
        var _ContentInfoRole = _interopRequireDefault(ContentInfoRole_1);
        var _DateRole = _interopRequireDefault(DateRole_1);
        var _DateTimeRole = _interopRequireDefault(DateTimeRole_1);
        var _DefinitionRole = _interopRequireDefault(DefinitionRole_1);
        var _DescriptionListDetailRole = _interopRequireDefault(DescriptionListDetailRole_1);
        var _DescriptionListRole = _interopRequireDefault(DescriptionListRole_1);
        var _DescriptionListTermRole = _interopRequireDefault(DescriptionListTermRole_1);
        var _DetailsRole = _interopRequireDefault(DetailsRole_1);
        var _DialogRole = _interopRequireDefault(DialogRole_1);
        var _DirectoryRole = _interopRequireDefault(DirectoryRole_1);
        var _DisclosureTriangleRole = _interopRequireDefault(DisclosureTriangleRole_1);
        var _DivRole = _interopRequireDefault(DivRole_1);
        var _DocumentRole = _interopRequireDefault(DocumentRole_1);
        var _EmbeddedObjectRole = _interopRequireDefault(EmbeddedObjectRole_1);
        var _FeedRole = _interopRequireDefault(FeedRole_1);
        var _FigcaptionRole = _interopRequireDefault(FigcaptionRole_1);
        var _FigureRole = _interopRequireDefault(FigureRole_1);
        var _FooterRole = _interopRequireDefault(FooterRole_1);
        var _FormRole = _interopRequireDefault(FormRole_1);
        var _GridRole = _interopRequireDefault(GridRole_1);
        var _GroupRole = _interopRequireDefault(GroupRole_1);
        var _HeadingRole = _interopRequireDefault(HeadingRole_1);
        var _IframePresentationalRole = _interopRequireDefault(IframePresentationalRole_1);
        var _IframeRole = _interopRequireDefault(IframeRole_1);
        var _IgnoredRole = _interopRequireDefault(IgnoredRole_1);
        var _ImageMapLinkRole = _interopRequireDefault(ImageMapLinkRole_1);
        var _ImageMapRole = _interopRequireDefault(ImageMapRole_1);
        var _ImageRole = _interopRequireDefault(ImageRole_1);
        var _InlineTextBoxRole = _interopRequireDefault(InlineTextBoxRole_1);
        var _InputTimeRole = _interopRequireDefault(InputTimeRole_1);
        var _LabelRole = _interopRequireDefault(LabelRole_1);
        var _LegendRole = _interopRequireDefault(LegendRole_1);
        var _LineBreakRole = _interopRequireDefault(LineBreakRole_1);
        var _LinkRole = _interopRequireDefault(LinkRole_1);
        var _ListBoxOptionRole = _interopRequireDefault(ListBoxOptionRole_1);
        var _ListBoxRole = _interopRequireDefault(ListBoxRole_1);
        var _ListItemRole = _interopRequireDefault(ListItemRole_1);
        var _ListMarkerRole = _interopRequireDefault(ListMarkerRole_1);
        var _ListRole = _interopRequireDefault(ListRole_1);
        var _LogRole = _interopRequireDefault(LogRole_1);
        var _MainRole = _interopRequireDefault(MainRole_1);
        var _MarkRole = _interopRequireDefault(MarkRole_1);
        var _MarqueeRole = _interopRequireDefault(MarqueeRole_1);
        var _MathRole = _interopRequireDefault(MathRole_1);
        var _MenuBarRole = _interopRequireDefault(MenuBarRole_1);
        var _MenuButtonRole = _interopRequireDefault(MenuButtonRole_1);
        var _MenuItemRole = _interopRequireDefault(MenuItemRole_1);
        var _MenuItemCheckBoxRole = _interopRequireDefault(MenuItemCheckBoxRole_1);
        var _MenuItemRadioRole = _interopRequireDefault(MenuItemRadioRole_1);
        var _MenuListOptionRole = _interopRequireDefault(MenuListOptionRole_1);
        var _MenuListPopupRole = _interopRequireDefault(MenuListPopupRole_1);
        var _MenuRole = _interopRequireDefault(MenuRole_1);
        var _MeterRole = _interopRequireDefault(MeterRole_1);
        var _NavigationRole = _interopRequireDefault(NavigationRole_1);
        var _NoneRole = _interopRequireDefault(NoneRole_1);
        var _NoteRole = _interopRequireDefault(NoteRole_1);
        var _OutlineRole = _interopRequireDefault(OutlineRole_1);
        var _ParagraphRole = _interopRequireDefault(ParagraphRole_1);
        var _PopUpButtonRole = _interopRequireDefault(PopUpButtonRole_1);
        var _PreRole = _interopRequireDefault(PreRole_1);
        var _PresentationalRole = _interopRequireDefault(PresentationalRole_1);
        var _ProgressIndicatorRole = _interopRequireDefault(ProgressIndicatorRole_1);
        var _RadioButtonRole = _interopRequireDefault(RadioButtonRole_1);
        var _RadioGroupRole = _interopRequireDefault(RadioGroupRole_1);
        var _RegionRole = _interopRequireDefault(RegionRole_1);
        var _RootWebAreaRole = _interopRequireDefault(RootWebAreaRole_1);
        var _RowHeaderRole = _interopRequireDefault(RowHeaderRole_1);
        var _RowRole = _interopRequireDefault(RowRole_1);
        var _RubyRole = _interopRequireDefault(RubyRole_1);
        var _RulerRole = _interopRequireDefault(RulerRole_1);
        var _ScrollAreaRole = _interopRequireDefault(ScrollAreaRole_1);
        var _ScrollBarRole = _interopRequireDefault(ScrollBarRole_1);
        var _SeamlessWebAreaRole = _interopRequireDefault(SeamlessWebAreaRole_1);
        var _SearchRole = _interopRequireDefault(SearchRole_1);
        var _SearchBoxRole = _interopRequireDefault(SearchBoxRole_1);
        var _SliderRole = _interopRequireDefault(SliderRole_1);
        var _SliderThumbRole = _interopRequireDefault(SliderThumbRole_1);
        var _SpinButtonRole = _interopRequireDefault(SpinButtonRole_1);
        var _SpinButtonPartRole = _interopRequireDefault(SpinButtonPartRole_1);
        var _SplitterRole = _interopRequireDefault(SplitterRole_1);
        var _StaticTextRole = _interopRequireDefault(StaticTextRole_1);
        var _StatusRole = _interopRequireDefault(StatusRole_1);
        var _SVGRootRole = _interopRequireDefault(SVGRootRole_1);
        var _SwitchRole = _interopRequireDefault(SwitchRole_1);
        var _TabGroupRole = _interopRequireDefault(TabGroupRole_1);
        var _TabRole = _interopRequireDefault(TabRole_1);
        var _TableHeaderContainerRole = _interopRequireDefault(TableHeaderContainerRole_1);
        var _TableRole = _interopRequireDefault(TableRole_1);
        var _TabListRole = _interopRequireDefault(TabListRole_1);
        var _TabPanelRole = _interopRequireDefault(TabPanelRole_1);
        var _TermRole = _interopRequireDefault(TermRole_1);
        var _TextFieldRole = _interopRequireDefault(TextFieldRole_1);
        var _TimeRole = _interopRequireDefault(TimeRole_1);
        var _TimerRole = _interopRequireDefault(TimerRole_1);
        var _ToggleButtonRole = _interopRequireDefault(ToggleButtonRole_1);
        var _ToolbarRole = _interopRequireDefault(ToolbarRole_1);
        var _TreeRole = _interopRequireDefault(TreeRole_1);
        var _TreeGridRole = _interopRequireDefault(TreeGridRole_1);
        var _TreeItemRole = _interopRequireDefault(TreeItemRole_1);
        var _UserInterfaceTooltipRole = _interopRequireDefault(UserInterfaceTooltipRole_1);
        var _VideoRole = _interopRequireDefault(VideoRole_1);
        var _WebAreaRole = _interopRequireDefault(WebAreaRole_1);
        var _WindowRole = _interopRequireDefault(WindowRole_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var AXObjects = [
            [
                "AbbrRole",
                _AbbrRole.default
            ],
            [
                "AlertDialogRole",
                _AlertDialogRole.default
            ],
            [
                "AlertRole",
                _AlertRole.default
            ],
            [
                "AnnotationRole",
                _AnnotationRole.default
            ],
            [
                "ApplicationRole",
                _ApplicationRole.default
            ],
            [
                "ArticleRole",
                _ArticleRole.default
            ],
            [
                "AudioRole",
                _AudioRole.default
            ],
            [
                "BannerRole",
                _BannerRole.default
            ],
            [
                "BlockquoteRole",
                _BlockquoteRole.default
            ],
            [
                "BusyIndicatorRole",
                _BusyIndicatorRole.default
            ],
            [
                "ButtonRole",
                _ButtonRole.default
            ],
            [
                "CanvasRole",
                _CanvasRole.default
            ],
            [
                "CaptionRole",
                _CaptionRole.default
            ],
            [
                "CellRole",
                _CellRole.default
            ],
            [
                "CheckBoxRole",
                _CheckBoxRole.default
            ],
            [
                "ColorWellRole",
                _ColorWellRole.default
            ],
            [
                "ColumnHeaderRole",
                _ColumnHeaderRole.default
            ],
            [
                "ColumnRole",
                _ColumnRole.default
            ],
            [
                "ComboBoxRole",
                _ComboBoxRole.default
            ],
            [
                "ComplementaryRole",
                _ComplementaryRole.default
            ],
            [
                "ContentInfoRole",
                _ContentInfoRole.default
            ],
            [
                "DateRole",
                _DateRole.default
            ],
            [
                "DateTimeRole",
                _DateTimeRole.default
            ],
            [
                "DefinitionRole",
                _DefinitionRole.default
            ],
            [
                "DescriptionListDetailRole",
                _DescriptionListDetailRole.default
            ],
            [
                "DescriptionListRole",
                _DescriptionListRole.default
            ],
            [
                "DescriptionListTermRole",
                _DescriptionListTermRole.default
            ],
            [
                "DetailsRole",
                _DetailsRole.default
            ],
            [
                "DialogRole",
                _DialogRole.default
            ],
            [
                "DirectoryRole",
                _DirectoryRole.default
            ],
            [
                "DisclosureTriangleRole",
                _DisclosureTriangleRole.default
            ],
            [
                "DivRole",
                _DivRole.default
            ],
            [
                "DocumentRole",
                _DocumentRole.default
            ],
            [
                "EmbeddedObjectRole",
                _EmbeddedObjectRole.default
            ],
            [
                "FeedRole",
                _FeedRole.default
            ],
            [
                "FigcaptionRole",
                _FigcaptionRole.default
            ],
            [
                "FigureRole",
                _FigureRole.default
            ],
            [
                "FooterRole",
                _FooterRole.default
            ],
            [
                "FormRole",
                _FormRole.default
            ],
            [
                "GridRole",
                _GridRole.default
            ],
            [
                "GroupRole",
                _GroupRole.default
            ],
            [
                "HeadingRole",
                _HeadingRole.default
            ],
            [
                "IframePresentationalRole",
                _IframePresentationalRole.default
            ],
            [
                "IframeRole",
                _IframeRole.default
            ],
            [
                "IgnoredRole",
                _IgnoredRole.default
            ],
            [
                "ImageMapLinkRole",
                _ImageMapLinkRole.default
            ],
            [
                "ImageMapRole",
                _ImageMapRole.default
            ],
            [
                "ImageRole",
                _ImageRole.default
            ],
            [
                "InlineTextBoxRole",
                _InlineTextBoxRole.default
            ],
            [
                "InputTimeRole",
                _InputTimeRole.default
            ],
            [
                "LabelRole",
                _LabelRole.default
            ],
            [
                "LegendRole",
                _LegendRole.default
            ],
            [
                "LineBreakRole",
                _LineBreakRole.default
            ],
            [
                "LinkRole",
                _LinkRole.default
            ],
            [
                "ListBoxOptionRole",
                _ListBoxOptionRole.default
            ],
            [
                "ListBoxRole",
                _ListBoxRole.default
            ],
            [
                "ListItemRole",
                _ListItemRole.default
            ],
            [
                "ListMarkerRole",
                _ListMarkerRole.default
            ],
            [
                "ListRole",
                _ListRole.default
            ],
            [
                "LogRole",
                _LogRole.default
            ],
            [
                "MainRole",
                _MainRole.default
            ],
            [
                "MarkRole",
                _MarkRole.default
            ],
            [
                "MarqueeRole",
                _MarqueeRole.default
            ],
            [
                "MathRole",
                _MathRole.default
            ],
            [
                "MenuBarRole",
                _MenuBarRole.default
            ],
            [
                "MenuButtonRole",
                _MenuButtonRole.default
            ],
            [
                "MenuItemRole",
                _MenuItemRole.default
            ],
            [
                "MenuItemCheckBoxRole",
                _MenuItemCheckBoxRole.default
            ],
            [
                "MenuItemRadioRole",
                _MenuItemRadioRole.default
            ],
            [
                "MenuListOptionRole",
                _MenuListOptionRole.default
            ],
            [
                "MenuListPopupRole",
                _MenuListPopupRole.default
            ],
            [
                "MenuRole",
                _MenuRole.default
            ],
            [
                "MeterRole",
                _MeterRole.default
            ],
            [
                "NavigationRole",
                _NavigationRole.default
            ],
            [
                "NoneRole",
                _NoneRole.default
            ],
            [
                "NoteRole",
                _NoteRole.default
            ],
            [
                "OutlineRole",
                _OutlineRole.default
            ],
            [
                "ParagraphRole",
                _ParagraphRole.default
            ],
            [
                "PopUpButtonRole",
                _PopUpButtonRole.default
            ],
            [
                "PreRole",
                _PreRole.default
            ],
            [
                "PresentationalRole",
                _PresentationalRole.default
            ],
            [
                "ProgressIndicatorRole",
                _ProgressIndicatorRole.default
            ],
            [
                "RadioButtonRole",
                _RadioButtonRole.default
            ],
            [
                "RadioGroupRole",
                _RadioGroupRole.default
            ],
            [
                "RegionRole",
                _RegionRole.default
            ],
            [
                "RootWebAreaRole",
                _RootWebAreaRole.default
            ],
            [
                "RowHeaderRole",
                _RowHeaderRole.default
            ],
            [
                "RowRole",
                _RowRole.default
            ],
            [
                "RubyRole",
                _RubyRole.default
            ],
            [
                "RulerRole",
                _RulerRole.default
            ],
            [
                "ScrollAreaRole",
                _ScrollAreaRole.default
            ],
            [
                "ScrollBarRole",
                _ScrollBarRole.default
            ],
            [
                "SeamlessWebAreaRole",
                _SeamlessWebAreaRole.default
            ],
            [
                "SearchRole",
                _SearchRole.default
            ],
            [
                "SearchBoxRole",
                _SearchBoxRole.default
            ],
            [
                "SliderRole",
                _SliderRole.default
            ],
            [
                "SliderThumbRole",
                _SliderThumbRole.default
            ],
            [
                "SpinButtonRole",
                _SpinButtonRole.default
            ],
            [
                "SpinButtonPartRole",
                _SpinButtonPartRole.default
            ],
            [
                "SplitterRole",
                _SplitterRole.default
            ],
            [
                "StaticTextRole",
                _StaticTextRole.default
            ],
            [
                "StatusRole",
                _StatusRole.default
            ],
            [
                "SVGRootRole",
                _SVGRootRole.default
            ],
            [
                "SwitchRole",
                _SwitchRole.default
            ],
            [
                "TabGroupRole",
                _TabGroupRole.default
            ],
            [
                "TabRole",
                _TabRole.default
            ],
            [
                "TableHeaderContainerRole",
                _TableHeaderContainerRole.default
            ],
            [
                "TableRole",
                _TableRole.default
            ],
            [
                "TabListRole",
                _TabListRole.default
            ],
            [
                "TabPanelRole",
                _TabPanelRole.default
            ],
            [
                "TermRole",
                _TermRole.default
            ],
            [
                "TextFieldRole",
                _TextFieldRole.default
            ],
            [
                "TimeRole",
                _TimeRole.default
            ],
            [
                "TimerRole",
                _TimerRole.default
            ],
            [
                "ToggleButtonRole",
                _ToggleButtonRole.default
            ],
            [
                "ToolbarRole",
                _ToolbarRole.default
            ],
            [
                "TreeRole",
                _TreeRole.default
            ],
            [
                "TreeGridRole",
                _TreeGridRole.default
            ],
            [
                "TreeItemRole",
                _TreeItemRole.default
            ],
            [
                "UserInterfaceTooltipRole",
                _UserInterfaceTooltipRole.default
            ],
            [
                "VideoRole",
                _VideoRole.default
            ],
            [
                "WebAreaRole",
                _WebAreaRole.default
            ],
            [
                "WindowRole",
                _WindowRole.default
            ]
        ];
        var AXObjectsMap = {
            entries: function entries() {
                return AXObjects;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator = _createForOfIteratorHelper(AXObjects), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
                        fn.call(thisArg, values, key, AXObjects);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            },
            get: function get(key) {
                var item = AXObjects.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return AXObjects.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return AXObjects.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
        exports1.default = _default;
    });
    unwrapExports(AXObjectsMap_1);
    var AXObjectElementMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
        var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var AXObjectElements = [];
        var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
        try {
            var _loop = function _loop() {
                var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
                var relatedConcepts = def.relatedConcepts;
                if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                    if (relation.module === "HTML") {
                        var concept = relation.concept;
                        if (concept) {
                            var index = AXObjectElements.findIndex(function(_ref5) {
                                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                                return key === name;
                            });
                            if (index === -1) {
                                AXObjectElements.push([
                                    name,
                                    []
                                ]);
                                index = AXObjectElements.length - 1;
                            }
                            AXObjectElements[index][1].push(concept);
                        }
                    }
                });
            };
            for(_iterator.s(); !(_step = _iterator.n()).done;)_loop();
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        var AXObjectElementMap = {
            entries: function entries() {
                return AXObjectElements;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator2 = _createForOfIteratorHelper(AXObjectElements), _step2;
                try {
                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                        var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                        fn.call(thisArg, values, key, AXObjectElements);
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally{
                    _iterator2.f();
                }
            },
            get: function get(key) {
                var item = AXObjectElements.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return AXObjectElements.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return AXObjectElements.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
        exports1.default = _default;
    });
    unwrapExports(AXObjectElementMap_1);
    var AXObjectRoleMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
        var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var AXObjectRoleElements = [];
        var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
        try {
            var _loop = function _loop() {
                var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
                var relatedConcepts = def.relatedConcepts;
                if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                    if (relation.module === "ARIA") {
                        var concept = relation.concept;
                        if (concept) {
                            var index = AXObjectRoleElements.findIndex(function(_ref5) {
                                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                                return key === name;
                            });
                            if (index === -1) {
                                AXObjectRoleElements.push([
                                    name,
                                    []
                                ]);
                                index = AXObjectRoleElements.length - 1;
                            }
                            AXObjectRoleElements[index][1].push(concept);
                        }
                    }
                });
            };
            for(_iterator.s(); !(_step = _iterator.n()).done;)_loop();
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        var AXObjectRoleMap = {
            entries: function entries() {
                return AXObjectRoleElements;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements), _step2;
                try {
                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                        var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                        fn.call(thisArg, values, key, AXObjectRoleElements);
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally{
                    _iterator2.f();
                }
            },
            get: function get(key) {
                var item = AXObjectRoleElements.find(function(tuple) {
                    return tuple[0] === key ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return AXObjectRoleElements.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return AXObjectRoleElements.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
        exports1.default = _default;
    });
    unwrapExports(AXObjectRoleMap_1);
    var elementAXObjectMap_1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.default = void 0;
        var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
        var _deepEqual = _interopRequireDefault(deepEqual);
        var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null) return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
                for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally{
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally{
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
            if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e2) {
                            throw _e2;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = it.call(o);
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e3) {
                    didErr = true;
                    err = _e3;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it.return != null) it.return();
                    } finally{
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
            return arr2;
        }
        var elementAXObjects = [];
        var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
        try {
            var _loop = function _loop() {
                var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
                var relatedConcepts = def.relatedConcepts;
                if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                    if (relation.module === "HTML") {
                        var concept = relation.concept;
                        if (concept != null) {
                            var conceptStr = JSON.stringify(concept);
                            var axObjects;
                            var index = 0;
                            for(; index < elementAXObjects.length; index++){
                                var key = elementAXObjects[index][0];
                                if (JSON.stringify(key) === conceptStr) {
                                    axObjects = elementAXObjects[index][1];
                                    break;
                                }
                            }
                            if (!Array.isArray(axObjects)) axObjects = [];
                            var loc = axObjects.findIndex(function(item) {
                                return item === name;
                            });
                            if (loc === -1) axObjects.push(name);
                            if (index < elementAXObjects.length) elementAXObjects.splice(index, 1, [
                                concept,
                                axObjects
                            ]);
                            else elementAXObjects.push([
                                concept,
                                axObjects
                            ]);
                        }
                    }
                });
            };
            for(_iterator.s(); !(_step = _iterator.n()).done;)_loop();
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        var elementAXObjectMap = {
            entries: function entries() {
                return elementAXObjects;
            },
            forEach: function forEach(fn) {
                var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var _iterator2 = _createForOfIteratorHelper(elementAXObjects), _step2;
                try {
                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                        var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                        fn.call(thisArg, values, key, elementAXObjects);
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally{
                    _iterator2.f();
                }
            },
            get: function get(key) {
                var item = elementAXObjects.find(function(tuple) {
                    return (0, _deepEqual.default)(key, tuple[0]) ? true : false;
                });
                return item && item[1];
            },
            has: function has(key) {
                return !!this.get(key);
            },
            keys: function keys() {
                return elementAXObjects.map(function(_ref) {
                    var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                    return key;
                });
            },
            values: function values() {
                return elementAXObjects.map(function(_ref3) {
                    var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                    return values;
                });
            }
        };
        var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
        exports1.default = _default;
    });
    unwrapExports(elementAXObjectMap_1);
    var lib$1 = createCommonjsModule(function(module, exports1) {
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.elementAXObjects = exports1.AXObjects = exports1.AXObjectRoles = exports1.AXObjectElements = void 0;
        var _AXObjectElementMap = _interopRequireDefault(AXObjectElementMap_1);
        var _AXObjectRoleMap = _interopRequireDefault(AXObjectRoleMap_1);
        var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
        var _elementAXObjectMap = _interopRequireDefault(elementAXObjectMap_1);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var AXObjectElements = _AXObjectElementMap.default;
        exports1.AXObjectElements = AXObjectElements;
        var AXObjectRoles = _AXObjectRoleMap.default;
        exports1.AXObjectRoles = AXObjectRoles;
        var AXObjects = _AXObjectsMap.default;
        exports1.AXObjects = AXObjects;
        var elementAXObjects = _elementAXObjectMap.default;
        exports1.elementAXObjects = elementAXObjects;
    });
    unwrapExports(lib$1);
    var lib_1$1 = lib$1.elementAXObjects;
    var lib_2$1 = lib$1.AXObjects;
    var lib_3$1 = lib$1.AXObjectRoles;
    var lib_4$1 = lib$1.AXObjectElements;
    const non_abstract_roles = [
        ...lib_1.keys()
    ].filter((name)=>!lib_1.get(name).abstract);
    const non_interactive_roles = new Set(non_abstract_roles.filter((name)=>{
        const role = lib_1.get(name);
        return(// 'toolbar' does not descend from widget, but it does support
        // aria-activedescendant, thus in practice we treat it as a widget.
        // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
        ![
            "toolbar",
            "tabpanel"
        ].includes(name) && !role.superClass.some((classes)=>classes.includes("widget")));
    }).concat(// The `progressbar` is descended from `widget`, but in practice, its
    // value is always `readonly`, so we treat it as a non-interactive role.
    "progressbar"));
    const interactive_roles = new Set(non_abstract_roles.filter((name)=>!non_interactive_roles.has(name)));
    function is_non_interactive_roles(role) {
        return non_interactive_roles.has(role);
    }
    function is_interactive_roles(role) {
        return interactive_roles.has(role);
    }
    const presentation_roles = new Set([
        "presentation",
        "none"
    ]);
    function is_presentation_role(role) {
        return presentation_roles.has(role);
    }
    function is_hidden_from_screen_reader(tag_name, attribute_map) {
        var _a;
        if (tag_name === "input") {
            const type = (_a = attribute_map.get("type")) === null || _a === void 0 ? void 0 : _a.get_static_value();
            if (type && type === "hidden") return true;
        }
        const aria_hidden = attribute_map.get("aria-hidden");
        if (!aria_hidden) return false;
        if (!aria_hidden.is_static) return true;
        const aria_hidden_value = aria_hidden.get_static_value();
        return aria_hidden_value === true || aria_hidden_value === "true";
    }
    const non_interactive_element_role_schemas = [];
    lib_3.entries().forEach(([schema, roles])=>{
        if ([
            ...roles
        ].every((role)=>non_interactive_roles.has(role))) non_interactive_element_role_schemas.push(schema);
    });
    const interactive_element_role_schemas = [];
    lib_3.entries().forEach(([schema, roles])=>{
        if ([
            ...roles
        ].every((role)=>interactive_roles.has(role))) interactive_element_role_schemas.push(schema);
    });
    const interactive_ax_objects = new Set([
        ...lib_2$1.keys()
    ].filter((name)=>lib_2$1.get(name).type === "widget"));
    const interactive_element_ax_object_schemas = [];
    lib_1$1.entries().forEach(([schema, ax_object])=>{
        if ([
            ...ax_object
        ].every((role)=>interactive_ax_objects.has(role))) interactive_element_ax_object_schemas.push(schema);
    });
    function match_schema(schema, tag_name, attribute_map) {
        if (schema.name !== tag_name) return false;
        if (!schema.attributes) return true;
        return schema.attributes.every((schema_attribute)=>{
            const attribute = attribute_map.get(schema_attribute.name);
            if (!attribute) return false;
            if (schema_attribute.value && schema_attribute.value !== attribute.get_static_value()) return false;
            return true;
        });
    }
    function is_interactive_element(tag_name, attribute_map) {
        if (interactive_element_role_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return true;
        if (non_interactive_element_role_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return false;
        if (interactive_element_ax_object_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return true;
        return false;
    }
    function is_semantic_role_element(role, tag_name, attribute_map) {
        for (const [schema, ax_object] of lib_1$1.entries()){
            if (schema.name === tag_name && (!schema.attributes || schema.attributes.every((attr)=>attribute_map.has(attr.name) && attribute_map.get(attr.name).get_static_value() === attr.value))) for (const name of ax_object){
                const roles = lib_3$1.get(name);
                if (roles) for (const { name: name } of roles){
                    if (name === role) return true;
                }
            }
        }
        return false;
    }
    const aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
    const aria_attribute_set = new Set(aria_attributes);
    const aria_roles = lib_1.keys();
    const aria_role_set = new Set(aria_roles);
    const aria_role_abstract_set = new Set(lib_1.keys().filter((role)=>lib_1.get(role).abstract));
    const a11y_required_attributes = {
        a: [
            "href"
        ],
        area: [
            "alt",
            "aria-label",
            "aria-labelledby"
        ],
        // html-has-lang
        html: [
            "lang"
        ],
        // iframe-has-title
        iframe: [
            "title"
        ],
        img: [
            "alt"
        ],
        object: [
            "title",
            "aria-label",
            "aria-labelledby"
        ]
    };
    const a11y_distracting_elements = new Set([
        "blink",
        "marquee"
    ]);
    const a11y_required_content = new Set([
        // anchor-has-content
        "a",
        // heading-has-content
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
    ]);
    const a11y_labelable = new Set([
        "button",
        "input",
        "keygen",
        "meter",
        "output",
        "progress",
        "select",
        "textarea"
    ]);
    const a11y_nested_implicit_semantics = new Map([
        [
            "header",
            "banner"
        ],
        [
            "footer",
            "contentinfo"
        ]
    ]);
    const a11y_implicit_semantics = new Map([
        [
            "a",
            "link"
        ],
        [
            "aside",
            "complementary"
        ],
        [
            "body",
            "document"
        ],
        [
            "datalist",
            "listbox"
        ],
        [
            "dd",
            "definition"
        ],
        [
            "dfn",
            "term"
        ],
        [
            "details",
            "group"
        ],
        [
            "dt",
            "term"
        ],
        [
            "fieldset",
            "group"
        ],
        [
            "form",
            "form"
        ],
        [
            "h1",
            "heading"
        ],
        [
            "h2",
            "heading"
        ],
        [
            "h3",
            "heading"
        ],
        [
            "h4",
            "heading"
        ],
        [
            "h5",
            "heading"
        ],
        [
            "h6",
            "heading"
        ],
        [
            "hr",
            "separator"
        ],
        [
            "li",
            "listitem"
        ],
        [
            "menu",
            "list"
        ],
        [
            "nav",
            "navigation"
        ],
        [
            "ol",
            "list"
        ],
        [
            "optgroup",
            "group"
        ],
        [
            "output",
            "status"
        ],
        [
            "progress",
            "progressbar"
        ],
        [
            "section",
            "region"
        ],
        [
            "summary",
            "button"
        ],
        [
            "tbody",
            "rowgroup"
        ],
        [
            "textarea",
            "textbox"
        ],
        [
            "tfoot",
            "rowgroup"
        ],
        [
            "thead",
            "rowgroup"
        ],
        [
            "tr",
            "row"
        ],
        [
            "ul",
            "list"
        ]
    ]);
    const invisible_elements = new Set([
        "meta",
        "html",
        "script",
        "style"
    ]);
    const valid_modifiers$1 = new Set([
        "preventDefault",
        "stopPropagation",
        "capture",
        "once",
        "passive",
        "nonpassive",
        "self",
        "trusted"
    ]);
    const passive_events = new Set([
        "wheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel"
    ]);
    const react_attributes = new Map([
        [
            "className",
            "class"
        ],
        [
            "htmlFor",
            "for"
        ]
    ]);
    const attributes_to_compact_whitespace = [
        "class",
        "style"
    ];
    function is_parent(parent, elements) {
        let check = false;
        while(parent){
            const parent_name = parent.name;
            if (elements.includes(parent_name)) {
                check = true;
                break;
            }
            if (parent.type === "Element") break;
            parent = parent.parent;
        }
        return check;
    }
    function get_namespace(parent, element, explicit_namespace) {
        const parent_element = parent.find_nearest(/^Element/);
        if (!parent_element) return explicit_namespace || (is_svg(element.name) ? namespaces.svg : null);
        if (parent_element.namespace !== namespaces.foreign) {
            if (is_svg(element.name.toLowerCase())) return namespaces.svg;
            if (parent_element.name.toLowerCase() === "foreignobject") return null;
        }
        return parent_element.namespace;
    }
    function is_valid_aria_attribute_value(schema, value) {
        switch(schema.type){
            case "boolean":
                return typeof value === "boolean";
            case "string":
            case "id":
                return typeof value === "string";
            case "tristate":
                return typeof value === "boolean" || value === "mixed";
            case "integer":
            case "number":
                return typeof value !== "boolean" && isNaN(Number(value)) === false;
            case "token":
                return (schema.values || []).indexOf(typeof value === "string" ? value.toLowerCase() : value) > -1;
            case "idlist":
                return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((id)=>typeof id === "string");
            case "tokenlist":
                return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((token)=>(schema.values || []).indexOf(token.toLowerCase()) > -1);
            default:
                return false;
        }
    }
    const regex_any_repeated_whitespaces = /[\s]+/g;
    const regex_heading_tags = /^h[1-6]$/;
    const regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
    class Element extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.attributes = [];
            this.actions = [];
            this.bindings = [];
            this.classes = [];
            this.styles = [];
            this.handlers = [];
            this.lets = [];
            this.intro = null;
            this.outro = null;
            this.animation = null;
            this.name = info.name;
            if (info.name === "svelte:element") {
                if (typeof info.tag !== "string") this.tag_expr = new Expression(component, this, scope, info.tag);
                else this.tag_expr = new Expression(component, this, scope, string_literal(info.tag));
            } else this.tag_expr = new Expression(component, this, scope, string_literal(this.name));
            this.namespace = get_namespace(parent, this, component.namespace);
            if (this.namespace !== namespaces.foreign) {
                if (this.name === "pre" || this.name === "textarea") {
                    const first = info.children[0];
                    if (first && first.type === "Text") // The leading newline character needs to be stripped because of a quirk,
                    // it is ignored by browsers if the tag and its contents are set through
                    // innerHTML (NOT if set through the innerHTML of the tag or dynamically).
                    // Therefore strip it here but add it back in the appropriate
                    // places if there's another newline afterwards.
                    // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                    // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                    first.data = first.data.replace(regex_starts_with_newline, "");
                }
                if (this.name === "textarea") {
                    if (info.children.length > 0) {
                        const value_attribute = info.attributes.find((node)=>node.name === "value");
                        if (value_attribute) {
                            component.error(value_attribute, compiler_errors.textarea_duplicate_value);
                            return;
                        }
                        // this is an egregious hack, but it's the easiest way to get <textarea>
                        // children treated the same way as a value attribute
                        info.attributes.push({
                            type: "Attribute",
                            name: "value",
                            value: info.children
                        });
                        info.children = [];
                    }
                }
                if (this.name === "option") {
                    // Special case — treat these the same way:
                    //   <option>{foo}</option>
                    //   <option value={foo}>{foo}</option>
                    const value_attribute = info.attributes.find((attribute)=>attribute.name === "value");
                    if (!value_attribute) info.attributes.push({
                        type: "Attribute",
                        name: "value",
                        value: info.children,
                        synthetic: true
                    });
                }
            }
            const has_let = info.attributes.some((node)=>node.type === "Let");
            if (has_let) scope = scope.child();
            // Binding relies on Attribute, defer its evaluation
            const order = [
                "Binding"
            ]; // everything else is -1
            info.attributes.sort((a, b)=>order.indexOf(a.type) - order.indexOf(b.type));
            info.attributes.forEach((node)=>{
                switch(node.type){
                    case "Action":
                        this.actions.push(new Action(component, this, scope, node));
                        break;
                    case "Attribute":
                    case "Spread":
                        // special case
                        if (node.name === "xmlns") this.namespace = node.value[0].data;
                        this.attributes.push(new Attribute(component, this, scope, node));
                        break;
                    case "Binding":
                        this.bindings.push(new Binding(component, this, scope, node));
                        break;
                    case "Class":
                        this.classes.push(new Class(component, this, scope, node));
                        break;
                    case "StyleDirective":
                        this.styles.push(new StyleDirective(component, this, scope, node));
                        break;
                    case "EventHandler":
                        this.handlers.push(new EventHandler(component, this, scope, node));
                        break;
                    case "Let":
                        {
                            const l = new Let(component, this, scope, node);
                            this.lets.push(l);
                            const dependencies = new Set([
                                l.name.name
                            ]);
                            l.names.forEach((name)=>{
                                scope.add(name, dependencies, this);
                            });
                            break;
                        }
                    case "Transition":
                        {
                            const transition = new Transition(component, this, scope, node);
                            if (node.intro) this.intro = transition;
                            if (node.outro) this.outro = transition;
                            break;
                        }
                    case "Animation":
                        this.animation = new Animation(component, this, scope, node);
                        break;
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            });
            this.scope = scope;
            this.children = map_children(component, this, this.scope, info.children);
            this.validate();
            this.optimise();
            component.apply_stylesheet(this);
        }
        get is_dynamic_element() {
            return this.name === "svelte:element";
        }
        validate() {
            if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported && !is_svg(this.name) && !is_html(this.name)) this.component.warn(this, compiler_warnings.component_name_lowercase(this.name));
            this.validate_attributes();
            this.validate_event_handlers();
            if (this.namespace === namespaces.foreign) this.validate_bindings_foreign();
            else {
                this.validate_attributes_a11y();
                this.validate_special_cases();
                this.validate_bindings();
                this.validate_content();
            }
        }
        validate_attributes() {
            const { component: component, parent: parent } = this;
            this.attributes.forEach((attribute)=>{
                if (attribute.is_spread) return;
                const name = attribute.name.toLowerCase();
                // Errors
                if (regex_illegal_attribute_character.test(name)) return component.error(attribute, compiler_errors.illegal_attribute(name));
                if (name === "slot") {
                    if (!attribute.is_static) return component.error(attribute, compiler_errors.invalid_slot_attribute);
                    if (component.slot_outlets.has(name)) return component.error(attribute, compiler_errors.duplicate_slot_attribute(name));
                    if (!(parent.type === "SlotTemplate" || within_custom_element(parent))) return component.error(attribute, compiler_errors.invalid_slotted_content);
                }
                // Warnings
                if (this.namespace !== namespaces.foreign) {
                    if (name === "is") component.warn(attribute, compiler_warnings.avoid_is);
                    if (react_attributes.has(attribute.name)) component.warn(attribute, compiler_warnings.invalid_html_attribute(attribute.name, react_attributes.get(attribute.name)));
                }
            });
        }
        validate_attributes_a11y() {
            var _a;
            const { component: component, attributes: attributes, handlers: handlers } = this;
            const attribute_map = new Map();
            const handlers_map = new Map();
            attributes.forEach((attribute)=>attribute_map.set(attribute.name, attribute));
            handlers.forEach((handler)=>handlers_map.set(handler.name, handler));
            attributes.forEach((attribute)=>{
                if (attribute.is_spread) return;
                const name = attribute.name.toLowerCase();
                // aria-props
                if (name.startsWith("aria-")) {
                    if (invisible_elements.has(this.name)) // aria-unsupported-elements
                    component.warn(attribute, compiler_warnings.a11y_aria_attributes(this.name));
                    const type = name.slice(5);
                    if (!aria_attribute_set.has(type)) {
                        const match = fuzzymatch(type, aria_attributes);
                        component.warn(attribute, compiler_warnings.a11y_unknown_aria_attribute(type, match));
                    }
                    if (name === "aria-hidden" && regex_heading_tags.test(this.name)) component.warn(attribute, compiler_warnings.a11y_hidden(this.name));
                    // aria-proptypes
                    let value = attribute.get_static_value();
                    if (value === "true") value = true;
                    if (value === "false") value = false;
                    if (value !== null && value !== undefined && lib_5.has(name)) {
                        const schema = lib_5.get(name);
                        if (!is_valid_aria_attribute_value(schema, value)) component.warn(attribute, compiler_warnings.a11y_incorrect_attribute_type(schema, name));
                    }
                }
                // aria-role
                if (name === "role") {
                    if (invisible_elements.has(this.name)) // aria-unsupported-elements
                    component.warn(attribute, compiler_warnings.a11y_misplaced_role(this.name));
                    const value = attribute.get_static_value();
                    if (typeof value === "string") value.split(regex_any_repeated_whitespaces).forEach((current_role)=>{
                        if (current_role && aria_role_abstract_set.has(current_role)) component.warn(attribute, compiler_warnings.a11y_no_abstract_role(current_role));
                        else if (current_role && !aria_role_set.has(current_role)) {
                            const match = fuzzymatch(current_role, aria_roles);
                            component.warn(attribute, compiler_warnings.a11y_unknown_role(current_role, match));
                        }
                        // no-redundant-roles
                        const has_redundant_role = current_role === a11y_implicit_semantics.get(this.name);
                        if (this.name === current_role || has_redundant_role) component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
                        // Footers and headers are special cases, and should not have redundant roles unless they are the children of sections or articles.
                        const is_parent_section_or_article = is_parent(this.parent, [
                            "section",
                            "article"
                        ]);
                        if (!is_parent_section_or_article) {
                            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(this.name);
                            if (has_nested_redundant_role) component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
                        }
                        // role-has-required-aria-props
                        if (!is_semantic_role_element(current_role, this.name, attribute_map)) {
                            const role = lib_1.get(current_role);
                            if (role) {
                                const required_role_props = Object.keys(role.requiredProps);
                                const has_missing_props = required_role_props.some((prop)=>!attributes.find((a)=>a.name === prop));
                                if (has_missing_props) component.warn(attribute, compiler_warnings.a11y_role_has_required_aria_props(current_role, required_role_props));
                            }
                        }
                        // no-interactive-element-to-noninteractive-role
                        if (is_interactive_element(this.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) component.warn(this, compiler_warnings.a11y_no_interactive_element_to_noninteractive_role(current_role, this.name));
                    });
                }
                // no-access-key
                if (name === "accesskey") component.warn(attribute, compiler_warnings.a11y_accesskey);
                // no-autofocus
                if (name === "autofocus") component.warn(attribute, compiler_warnings.a11y_autofocus);
                // scope
                if (name === "scope" && this.name !== "th") component.warn(attribute, compiler_warnings.a11y_misplaced_scope);
                // tabindex-no-positive
                if (name === "tabindex") {
                    const value = attribute.get_static_value();
                    // @ts-ignore todo is tabindex=true correct case?
                    if (!isNaN(value) && +value > 0) component.warn(attribute, compiler_warnings.a11y_positive_tabindex);
                }
            });
            // click-events-have-key-events
            if (handlers_map.has("click")) {
                const role = attribute_map.get("role");
                const is_non_presentation_role = (role === null || role === void 0 ? void 0 : role.is_static) && !is_presentation_role(role.get_static_value());
                if (!is_hidden_from_screen_reader(this.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(this.name, attribute_map) && !this.attributes.find((attr)=>attr.is_spread)) {
                    const has_key_event = handlers_map.has("keydown") || handlers_map.has("keyup") || handlers_map.has("keypress");
                    if (!has_key_event) component.warn(this, compiler_warnings.a11y_click_events_have_key_events());
                }
            }
            // no-noninteractive-tabindex
            if (!is_interactive_element(this.name, attribute_map) && !is_interactive_roles((_a = attribute_map.get("role")) === null || _a === void 0 ? void 0 : _a.get_static_value())) {
                const tab_index = attribute_map.get("tabindex");
                if (tab_index && (!tab_index.is_static || Number(tab_index.get_static_value()) >= 0)) component.warn(this, compiler_warnings.a11y_no_noninteractive_tabindex);
            }
        }
        validate_special_cases() {
            const { component: component, attributes: attributes, handlers: handlers } = this;
            const attribute_map = new Map();
            const handlers_map = new Map();
            attributes.forEach((attribute)=>attribute_map.set(attribute.name, attribute));
            handlers.forEach((handler)=>handlers_map.set(handler.name, handler));
            if (this.name === "a") {
                const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
                const id_attribute = attribute_map.get("id");
                const name_attribute = attribute_map.get("name");
                const target_attribute = attribute_map.get("target");
                if (target_attribute && target_attribute.get_static_value() === "_blank" && href_attribute) {
                    const href_static_value = href_attribute.get_static_value() ? href_attribute.get_static_value().toLowerCase() : null;
                    if (href_static_value === null || href_static_value.match(/^(https?:)?\/\//i)) {
                        const rel = attribute_map.get("rel");
                        if (rel == null || rel.is_static) {
                            const rel_values = rel ? rel.get_static_value().split(regex_any_repeated_whitespaces) : [];
                            const expected_values = [
                                "noreferrer"
                            ];
                            expected_values.forEach((expected_value)=>{
                                if (!rel || rel && rel_values.indexOf(expected_value) < 0) component.warn(this, {
                                    code: `security-anchor-rel-${expected_value}`,
                                    message: `Security: Anchor with "target=_blank" should have rel attribute containing the value "${expected_value}"`
                                });
                            });
                        }
                    }
                }
                if (href_attribute) {
                    const href_value = href_attribute.get_static_value();
                    if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) component.warn(href_attribute, compiler_warnings.a11y_invalid_attribute(href_attribute.name, href_value));
                } else {
                    const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
                    const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
                    if (!id_attribute_valid && !name_attribute_valid) component.warn(this, compiler_warnings.a11y_missing_attribute("a", "an", "href"));
                }
            } else {
                const required_attributes = a11y_required_attributes[this.name];
                if (required_attributes) {
                    const has_attribute = required_attributes.some((name)=>attribute_map.has(name));
                    if (!has_attribute) should_have_attribute(this, required_attributes);
                }
            }
            if (this.name === "input") {
                const type = attribute_map.get("type");
                if (type && type.get_static_value() === "image") {
                    const required_attributes = [
                        "alt",
                        "aria-label",
                        "aria-labelledby"
                    ];
                    const has_attribute = required_attributes.some((name)=>attribute_map.has(name));
                    if (!has_attribute) should_have_attribute(this, required_attributes, 'input type="image"');
                }
            }
            if (this.name === "img") {
                const alt_attribute = attribute_map.get("alt");
                const aria_hidden_attribute = attribute_map.get("aria-hidden");
                const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
                if (alt_attribute && !aria_hidden_exist) {
                    const alt_value = alt_attribute.get_static_value();
                    if (/\b(image|picture|photo)\b/i.test(alt_value)) component.warn(this, compiler_warnings.a11y_img_redundant_alt);
                }
            }
            if (this.name === "label") {
                const has_input_child = (children)=>{
                    if (children.some((child)=>child instanceof Element && (a11y_labelable.has(child.name) || child.name === "slot"))) return true;
                    for (const child of children){
                        if (!("children" in child) || child.children.length === 0) continue;
                        if (has_input_child(child.children)) return true;
                    }
                    return false;
                };
                if (!attribute_map.has("for") && !has_input_child(this.children)) component.warn(this, compiler_warnings.a11y_label_has_associated_control);
            }
            if (this.name === "video") {
                if (attribute_map.has("muted")) return;
                let has_caption;
                const track = this.children.find((i)=>i.name === "track");
                if (track) has_caption = track.attributes.find((a)=>a.name === "kind" && a.get_static_value() === "captions");
                if (!has_caption) component.warn(this, compiler_warnings.a11y_media_has_caption);
            }
            if (a11y_distracting_elements.has(this.name)) // no-distracting-elements
            component.warn(this, compiler_warnings.a11y_distracting_elements(this.name));
            if (this.name === "figcaption") {
                let { parent: parent } = this;
                let is_figure_parent = false;
                while(parent){
                    if (parent.name === "figure") {
                        is_figure_parent = true;
                        break;
                    }
                    if (parent.type === "Element") break;
                    parent = parent.parent;
                }
                if (!is_figure_parent) component.warn(this, compiler_warnings.a11y_structure_immediate);
            }
            if (this.name === "figure") {
                const children = this.children.filter((node)=>{
                    if (node.type === "Comment") return false;
                    if (node.type === "Text") return regex_non_whitespace_character.test(node.data);
                    return true;
                });
                const index = children.findIndex((child)=>child.name === "figcaption");
                if (index !== -1 && index !== 0 && index !== children.length - 1) component.warn(children[index], compiler_warnings.a11y_structure_first_or_last);
            }
            if (handlers_map.has("mouseover") && !handlers_map.has("focus")) component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseover", "focus"));
            if (handlers_map.has("mouseout") && !handlers_map.has("blur")) component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseout", "blur"));
        }
        validate_bindings_foreign() {
            this.bindings.forEach((binding)=>{
                if (binding.name !== "this") return this.component.error(binding, compiler_errors.invalid_binding_foreign(binding.name));
            });
        }
        validate_bindings() {
            const { component: component } = this;
            const check_type_attribute = ()=>{
                const attribute = this.attributes.find((attribute)=>attribute.name === "type");
                if (!attribute) return null;
                if (!attribute.is_static) return component.error(attribute, compiler_errors.invalid_type);
                const value = attribute.get_static_value();
                if (value === true) return component.error(attribute, compiler_errors.missing_type);
                return value;
            };
            this.bindings.forEach((binding)=>{
                const { name: name } = binding;
                if (name === "value") {
                    if (this.name !== "input" && this.name !== "textarea" && this.name !== "select") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "value"));
                    if (this.name === "select") {
                        const attribute = this.attributes.find((attribute)=>attribute.name === "multiple");
                        if (attribute && !attribute.is_static) return component.error(attribute, compiler_errors.dynamic_multiple_attribute);
                    } else check_type_attribute();
                } else if (name === "checked" || name === "indeterminate") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, name));
                    const type = check_type_attribute();
                    if (type !== "checkbox") return component.error(binding, compiler_errors.invalid_binding_no_checkbox(name, type === "radio"));
                } else if (name === "group") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "group"));
                    const type = check_type_attribute();
                    if (type !== "checkbox" && type !== "radio") return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="checkbox"> or <input type="radio">', "group"));
                } else if (name === "files") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "files"));
                    const type = check_type_attribute();
                    if (type !== "file") return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="file">', "files"));
                } else if (name === "open") {
                    if (this.name !== "details") return component.error(binding, compiler_errors.invalid_binding_element_with("<details>", name));
                } else if (name === "currentTime" || name === "duration" || name === "paused" || name === "buffered" || name === "seekable" || name === "played" || name === "volume" || name === "muted" || name === "playbackRate" || name === "seeking" || name === "ended") {
                    if (this.name !== "audio" && this.name !== "video") return component.error(binding, compiler_errors.invalid_binding_element_with("audio> or <video>", name));
                } else if (name === "videoHeight" || name === "videoWidth") {
                    if (this.name !== "video") return component.error(binding, compiler_errors.invalid_binding_element_with("<video>", name));
                } else if (regex_dimensions.test(name)) {
                    if (this.name === "svg" && (name === "offsetWidth" || name === "offsetHeight")) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `<svg>. Use '${name.replace("offset", "client")}' instead`));
                    else if (is_svg(this.name)) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, "SVG elements"));
                    else if (is_void(this.name)) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `void elements like <${this.name}>. Use a wrapper element instead`));
                } else if (name === "textContent" || name === "innerHTML") {
                    const contenteditable = this.attributes.find((attribute)=>attribute.name === "contenteditable");
                    if (!contenteditable) return component.error(binding, compiler_errors.missing_contenteditable_attribute);
                    else if (contenteditable && !contenteditable.is_static) return component.error(contenteditable, compiler_errors.dynamic_contenteditable_attribute);
                } else if (name !== "this") return component.error(binding, compiler_errors.invalid_binding(binding.name));
            });
        }
        validate_content() {
            if (!a11y_required_content.has(this.name)) return;
            if (this.bindings.some((binding)=>[
                    "textContent",
                    "innerHTML"
                ].includes(binding.name))) return;
            if (this.children.length === 0) this.component.warn(this, compiler_warnings.a11y_missing_content(this.name));
        }
        validate_event_handlers() {
            const { component: component } = this;
            this.handlers.forEach((handler)=>{
                if (handler.modifiers.has("passive") && handler.modifiers.has("preventDefault")) return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "preventDefault"));
                if (handler.modifiers.has("passive") && handler.modifiers.has("nonpassive")) return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "nonpassive"));
                handler.modifiers.forEach((modifier)=>{
                    if (!valid_modifiers$1.has(modifier)) return component.error(handler, compiler_errors.invalid_event_modifier(list$1(Array.from(valid_modifiers$1))));
                    if (modifier === "passive") {
                        if (passive_events.has(handler.name)) {
                            if (handler.can_make_passive) component.warn(handler, compiler_warnings.redundant_event_modifier_for_touch);
                        } else component.warn(handler, compiler_warnings.redundant_event_modifier_passive);
                    }
                    if (component.compile_options.legacy && (modifier === "once" || modifier === "passive")) // TODO this could be supported, but it would need a few changes to
                    // how event listeners work
                    return component.error(handler, compiler_errors.invalid_event_modifier_legacy(modifier));
                });
                if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has("preventDefault") && !handler.modifiers.has("nonpassive")) // touch/wheel events should be passive by default
                handler.modifiers.add("passive");
            });
        }
        is_media_node() {
            return this.name === "audio" || this.name === "video";
        }
        add_css_class() {
            if (this.attributes.some((attr)=>attr.is_spread)) {
                this.needs_manual_style_scoping = true;
                return;
            }
            const { id: id } = this.component.stylesheet;
            const class_attribute = this.attributes.find((a)=>a.name === "class");
            if (class_attribute && !class_attribute.is_true) {
                if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text") class_attribute.chunks[0].data += ` ${id}`;
                else class_attribute.chunks.push(new Text(this.component, this, this.scope, {
                    type: "Text",
                    data: ` ${id}`,
                    synthetic: true
                }));
            } else this.attributes.push(new Attribute(this.component, this, this.scope, {
                type: "Attribute",
                name: "class",
                value: [
                    {
                        type: "Text",
                        data: id,
                        synthetic: true
                    }
                ]
            }));
        }
        get slot_template_name() {
            return this.attributes.find((attribute)=>attribute.name === "slot").get_static_value();
        }
        optimise() {
            attributes_to_compact_whitespace.forEach((attribute_name)=>{
                const attribute = this.attributes.find((a)=>a.name === attribute_name);
                if (attribute && !attribute.is_true) attribute.chunks.forEach((chunk, index)=>{
                    if (chunk.type === "Text") {
                        let data = chunk.data.replace(regex_any_repeated_whitespaces, " ");
                        if (index === 0) data = data.trimLeft();
                        else if (index === attribute.chunks.length - 1) data = data.trimRight();
                        chunk.data = data;
                    }
                });
            });
        }
    }
    const regex_starts_with_vovel = /^[aeiou]/;
    function should_have_attribute(node, attributes, name = node.name) {
        const article = regex_starts_with_vovel.test(attributes[0]) ? "an" : "a";
        const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
        node.component.warn(node, compiler_warnings.a11y_missing_attribute(name, article, sequence));
    }
    const regex_minus_sign = /-/;
    function within_custom_element(parent) {
        while(parent){
            if (parent.type === "InlineComponent") return false;
            if (parent.type === "Element" && regex_minus_sign.test(parent.name)) return true;
            parent = parent.parent;
        }
        return false;
    }
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    const regex_return_characters = /\r/g;
    function hash(str) {
        str = str.replace(regex_return_characters, "");
        let hash = 5381;
        let i = str.length;
        while(i--)hash = (hash << 5) - hash ^ str.charCodeAt(i);
        return (hash >>> 0).toString(36);
    }
    class Head extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            if (info.attributes.length) {
                component.error(info.attributes[0], compiler_errors.invalid_attribute_head);
                return;
            }
            this.children = map_children(component, parent, scope, info.children.filter((child)=>{
                return child.type !== "Text" || regex_non_whitespace_character.test(child.data);
            }));
            if (this.children.length > 0) this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
        }
    }
    class IfBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            this.expression = new Expression(component, this, this.scope, info.expression);
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
            this.else = info.else ? new ElseBlock(component, this, scope, info.else) : null;
            this.warn_if_empty_block();
        }
    }
    class InlineComponent extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.attributes = [];
            this.bindings = [];
            this.handlers = [];
            this.lets = [];
            this.css_custom_properties = [];
            if (info.name !== "svelte:component" && info.name !== "svelte:self") {
                const name = info.name.split(".")[0]; // accommodate namespaces
                component.warn_if_undefined(name, info, scope);
                component.add_reference(this, name);
            }
            this.name = info.name;
            this.namespace = get_namespace$1(parent, component.namespace);
            this.expression = this.name === "svelte:component" ? new Expression(component, this, scope, info.expression) : null;
            info.attributes.forEach((node)=>{
                /* eslint-disable no-fallthrough */ switch(node.type){
                    case "Action":
                        return component.error(node, compiler_errors.invalid_action);
                    case "Attribute":
                        if (node.name.startsWith("--")) {
                            this.css_custom_properties.push(new Attribute(component, this, scope, node));
                            break;
                        }
                    // fallthrough
                    case "Spread":
                        this.attributes.push(new Attribute(component, this, scope, node));
                        break;
                    case "Binding":
                        this.bindings.push(new Binding(component, this, scope, node));
                        break;
                    case "Class":
                        return component.error(node, compiler_errors.invalid_class);
                    case "EventHandler":
                        this.handlers.push(new EventHandler(component, this, scope, node));
                        break;
                    case "Let":
                        this.lets.push(new Let(component, this, scope, node));
                        break;
                    case "Transition":
                        return component.error(node, compiler_errors.invalid_transition);
                    case "StyleDirective":
                        return component.error(node, compiler_errors.invalid_component_style_directive);
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            /* eslint-enable no-fallthrough */ });
            if (this.lets.length > 0) {
                this.scope = scope.child();
                this.lets.forEach((l)=>{
                    const dependencies = new Set([
                        l.name.name
                    ]);
                    l.names.forEach((name)=>{
                        this.scope.add(name, dependencies, this);
                    });
                });
            } else this.scope = scope;
            this.handlers.forEach((handler)=>{
                handler.modifiers.forEach((modifier)=>{
                    if (modifier !== "once") return component.error(handler, compiler_errors.invalid_event_modifier_component);
                });
            });
            const children = [];
            for(let i = info.children.length - 1; i >= 0; i--){
                const child = info.children[i];
                if (child.type === "SlotTemplate") {
                    children.push(child);
                    info.children.splice(i, 1);
                } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute)=>attribute.name === "slot")) {
                    const slot_template = {
                        start: child.start,
                        end: child.end,
                        type: "SlotTemplate",
                        name: "svelte:fragment",
                        attributes: [],
                        children: [
                            child
                        ]
                    };
                    // transfer attributes
                    for(let i = child.attributes.length - 1; i >= 0; i--){
                        const attribute = child.attributes[i];
                        if (attribute.type === "Let") {
                            slot_template.attributes.push(attribute);
                            child.attributes.splice(i, 1);
                        } else if (attribute.type === "Attribute" && attribute.name === "slot") slot_template.attributes.push(attribute);
                    }
                    // transfer const
                    for(let i = child.children.length - 1; i >= 0; i--){
                        const child_child = child.children[i];
                        if (child_child.type === "ConstTag") {
                            slot_template.children.push(child_child);
                            child.children.splice(i, 1);
                        }
                    }
                    children.push(slot_template);
                    info.children.splice(i, 1);
                }
            }
            if (info.children.some((node)=>not_whitespace_text(node))) children.push({
                start: info.start,
                end: info.end,
                type: "SlotTemplate",
                name: "svelte:fragment",
                attributes: [],
                children: info.children
            });
            this.children = map_children(component, this, this.scope, children);
        }
        get slot_template_name() {
            return this.attributes.find((attribute)=>attribute.name === "slot").get_static_value();
        }
    }
    function not_whitespace_text(node) {
        return !(node.type === "Text" && regex_only_whitespaces.test(node.data));
    }
    function get_namespace$1(parent, explicit_namespace) {
        const parent_element = parent.find_nearest(/^Element/);
        if (!parent_element) return explicit_namespace;
        return parent_element.namespace;
    }
    class KeyBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.expression = new Expression(component, this, scope, info.expression);
            this.children = map_children(component, this, scope, info.children);
            this.warn_if_empty_block();
        }
    }
    class Tag extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.expression = new Expression(component, this, scope, info.expression);
            this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope.names.has(info.expression.name);
        }
    }
    class MustacheTag extends Tag {
    }
    class Options extends Node$1 {
    }
    class RawMustacheTag extends Tag {
    }
    class DebugTag extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.expressions = info.identifiers.map((node)=>{
                return new Expression(component, parent, scope, node);
            });
        }
    }
    class Slot extends Element {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.values = new Map();
            info.attributes.forEach((attr)=>{
                if (attr.type !== "Attribute" && attr.type !== "Spread") return component.error(attr, compiler_errors.invalid_slot_directive);
                if (attr.name === "name") {
                    if (attr.value.length !== 1 || attr.value[0].type !== "Text") return component.error(attr, compiler_errors.dynamic_slot_name);
                    this.slot_name = attr.value[0].data;
                    if (this.slot_name === "default") return component.error(attr, compiler_errors.invalid_slot_name);
                }
                this.values.set(attr.name, new Attribute(component, this, scope, attr));
            });
            if (!this.slot_name) this.slot_name = "default";
            if (this.slot_name === "default") // if this is the default slot, add our dependencies to any
            // other slots (which inherit our slot values) that were
            // previously encountered
            component.slots.forEach((slot)=>{
                this.values.forEach((attribute, name)=>{
                    if (!slot.values.has(name)) slot.values.set(name, attribute);
                });
            });
            else if (component.slots.has("default")) {
                // otherwise, go the other way — inherit values from
                // a previously encountered default slot
                const default_slot = component.slots.get("default");
                default_slot.values.forEach((attribute, name)=>{
                    if (!this.values.has(name)) this.values.set(name, attribute);
                });
            }
            component.slots.set(this.slot_name, this);
        }
    }
    class SlotTemplate extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.lets = [];
            this.slot_template_name = "default";
            this.validate_slot_template_placement();
            scope = scope.child();
            info.attributes.forEach((node)=>{
                switch(node.type){
                    case "Let":
                        {
                            const l = new Let(component, this, scope, node);
                            this.lets.push(l);
                            const dependencies = new Set([
                                l.name.name
                            ]);
                            l.names.forEach((name)=>{
                                scope.add(name, dependencies, this);
                            });
                            break;
                        }
                    case "Attribute":
                        if (node.name === "slot") {
                            this.slot_attribute = new Attribute(component, this, scope, node);
                            if (!this.slot_attribute.is_static) return component.error(node, compiler_errors.invalid_slot_attribute);
                            const value = this.slot_attribute.get_static_value();
                            if (typeof value === "boolean") return component.error(node, compiler_errors.invalid_slot_attribute_value_missing);
                            this.slot_template_name = value;
                            break;
                        }
                        throw new Error(`Invalid attribute '${node.name}' in <svelte:fragment>`);
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            });
            this.scope = scope;
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
        }
        validate_slot_template_placement() {
            if (this.parent.type !== "InlineComponent") return this.component.error(this, compiler_errors.invalid_slotted_content_fragment);
        }
    }
    class Title extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.children = map_children(component, parent, scope, info.children);
            if (info.attributes.length > 0) {
                component.error(info.attributes[0], compiler_errors.illegal_attribute_title);
                return;
            }
            info.children.forEach((child)=>{
                if (child.type !== "Text" && child.type !== "MustacheTag") return component.error(child, compiler_errors.illegal_structure_title);
            });
            this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope.names.has(info.children[0].name) : true;
        }
    }
    const valid_bindings = [
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "scrollX",
        "scrollY",
        "online"
    ];
    class Window extends Node$1 {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.handlers = [];
            this.bindings = [];
            this.actions = [];
            info.attributes.forEach((node)=>{
                if (node.type === "EventHandler") this.handlers.push(new EventHandler(component, this, scope, node));
                else if (node.type === "Binding") {
                    if (node.expression.type !== "Identifier") {
                        const { parts: parts } = flatten_reference(node.expression);
                        // TODO is this constraint necessary?
                        return component.error(node.expression, compiler_errors.invalid_binding_window(parts));
                    }
                    if (!~valid_bindings.indexOf(node.name)) {
                        const match = node.name === "width" ? "innerWidth" : node.name === "height" ? "innerHeight" : fuzzymatch(node.name, valid_bindings);
                        if (match) return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:window>", ` (did you mean '${match}'?)`));
                        else return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:window>", ` \u{2014} valid bindings are ${list$1(valid_bindings)}`));
                    }
                    this.bindings.push(new Binding(component, this, scope, node));
                } else if (node.type === "Action") this.actions.push(new Action(component, this, scope, node));
            });
        }
    }
    /**
	 * Pushes all `items` into `array` using `push`, therefore mutating the array.
	 * We do this for memory and perf reasons, and because `array.push(...items)` would
	 * run into a "max call stack size exceeded" error with too many items (~65k).
	 * @param array
	 * @param items
	 */ function push_array$1(array, items) {
        for(let i = 0; i < items.length; i++)array.push(items[i]);
    }
    function get_constructor(type) {
        switch(type){
            case "AwaitBlock":
                return AwaitBlock;
            case "Body":
                return Body;
            case "Comment":
                return Comment$1;
            case "ConstTag":
                return ConstTag;
            case "EachBlock":
                return EachBlock;
            case "Element":
                return Element;
            case "Head":
                return Head;
            case "IfBlock":
                return IfBlock;
            case "InlineComponent":
                return InlineComponent;
            case "KeyBlock":
                return KeyBlock;
            case "MustacheTag":
                return MustacheTag;
            case "Options":
                return Options;
            case "RawMustacheTag":
                return RawMustacheTag;
            case "DebugTag":
                return DebugTag;
            case "Slot":
                return Slot;
            case "SlotTemplate":
                return SlotTemplate;
            case "Text":
                return Text;
            case "Title":
                return Title;
            case "Window":
                return Window;
            default:
                throw new Error(`Not implemented: ${type}`);
        }
    }
    function map_children(component, parent, scope, children) {
        let last = null;
        let ignores = [];
        return children.map((child)=>{
            const constructor = get_constructor(child.type);
            const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
            if (use_ignores) component.push_ignores(ignores);
            const node = new constructor(component, parent, scope, child);
            if (use_ignores) component.pop_ignores(), ignores = [];
            if (node.type === "Comment" && node.ignores.length) push_array$1(ignores, node.ignores);
            if (last) last.next = node;
            node.prev = last;
            last = node;
            return node;
        });
    }
    function check_graph_for_cycles(edges) {
        const graph = edges.reduce((g, edge)=>{
            const [u, v] = edge;
            if (!g.has(u)) g.set(u, []);
            if (!g.has(v)) g.set(v, []);
            g.get(u).push(v);
            return g;
        }, new Map());
        const visited = new Set();
        const on_stack = new Set();
        const cycles = [];
        function visit(v) {
            visited.add(v);
            on_stack.add(v);
            graph.get(v).forEach((w)=>{
                if (!visited.has(w)) visit(w);
                else if (on_stack.has(w)) cycles.push([
                    ...on_stack,
                    w
                ]);
            });
            on_stack.delete(v);
        }
        graph.forEach((_, v)=>{
            if (!visited.has(v)) visit(v);
        });
        return cycles[0];
    }
    function get_const_tags(children, component, node, parent) {
        const const_tags = [];
        const others = [];
        for (const child of children)if (child.type === "ConstTag") const_tags.push(child);
        else others.push(child);
        const consts_nodes = const_tags.map((tag)=>new ConstTag(component, node, node.scope, tag));
        const sorted_consts_nodes = sort_consts_nodes(consts_nodes, component);
        sorted_consts_nodes.forEach((node)=>node.parse_expression());
        const children_nodes = map_children(component, parent, node.scope, others);
        return [
            sorted_consts_nodes,
            children_nodes
        ];
    }
    function sort_consts_nodes(consts_nodes, component) {
        const sorted_consts_nodes = [];
        const unsorted_consts_nodes = consts_nodes.map((node)=>{
            return {
                assignees: node.assignees,
                dependencies: node.dependencies,
                node: node
            };
        });
        const lookup = new Map();
        unsorted_consts_nodes.forEach((node)=>{
            node.assignees.forEach((name)=>{
                if (!lookup.has(name)) lookup.set(name, []);
                lookup.get(name).push(node);
            });
        });
        const cycle = check_graph_for_cycles(unsorted_consts_nodes.reduce((acc, node)=>{
            node.assignees.forEach((v)=>{
                node.dependencies.forEach((w)=>{
                    if (!node.assignees.has(w)) acc.push([
                        v,
                        w
                    ]);
                });
            });
            return acc;
        }, []));
        if (cycle && cycle.length) {
            const nodeList = lookup.get(cycle[0]);
            const node = nodeList[0];
            component.error(node.node, compiler_errors.cyclical_const_tags(cycle));
        }
        const add_node = (node)=>{
            if (sorted_consts_nodes.includes(node)) return;
            node.dependencies.forEach((name)=>{
                if (node.assignees.has(name)) return;
                const earlier_nodes = lookup.get(name);
                if (earlier_nodes) earlier_nodes.forEach(add_node);
            });
            sorted_consts_nodes.push(node);
        };
        unsorted_consts_nodes.forEach(add_node);
        return sorted_consts_nodes.map((node)=>node.node);
    }
    class ThenBlock extends AbstractBlock {
        constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            if (parent.then_node) parent.then_contexts.forEach((context)=>{
                this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
            [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    function add_const_tags(block, const_tags, ctx) {
        const const_tags_props = [];
        const_tags.forEach((const_tag, i)=>{
            const name = `#constants_${i}`;
            const_tags_props.push(b`const ${name} = ${const_tag.expression.manipulate(block, ctx)}`);
            const_tag.contexts.forEach((context)=>{
                const_tags_props.push(b`${ctx}[${block.renderer.context_lookup.get(context.key.name).index}] = ${context.default_modifier(context.modifier({
                    type: "Identifier",
                    name: name
                }), (name)=>block.renderer.context_lookup.has(name) ? x`${ctx}[${block.renderer.context_lookup.get(name).index}]` : {
                        type: "Identifier",
                        name: name
                    })};`);
            });
        });
        return const_tags_props;
    }
    function add_const_tags_context(renderer, const_tags) {
        const_tags.forEach((const_tag)=>{
            const_tag.contexts.forEach((context)=>{
                renderer.add_to_context(context.key.name, true);
            });
        });
    }
    class AwaitBlockBranch extends Wrapper {
        constructor(status, renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = null;
            this.status = status;
            this.block = block.child({
                comment: create_debugging_comment(node, this.renderer.component),
                name: this.renderer.component.get_unique_name(`create_${status}_block`),
                type: status
            });
            this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
            this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
        }
        add_context(node, contexts) {
            if (!node) return;
            if (node.type === "Identifier") {
                this.value = node.name;
                this.renderer.add_to_context(this.value, true);
            } else {
                contexts.forEach((context)=>{
                    this.renderer.add_to_context(context.key.name, true);
                });
                this.value = this.block.parent.get_unique_name("value").name;
                this.value_contexts = contexts;
                this.renderer.add_to_context(this.value, true);
                this.is_destructured = true;
            }
            this.value_index = this.renderer.context_lookup.get(this.value).index;
            if (this.has_consts(this.node)) add_const_tags_context(this.renderer, this.node.const_tags);
        }
        has_consts(node) {
            return node instanceof ThenBlock || node instanceof CatchBlock;
        }
        render(block, parent_node, parent_nodes) {
            this.fragment.render(block, parent_node, parent_nodes);
            if (this.is_destructured || this.has_consts(this.node) && this.node.const_tags.length > 0) this.render_get_context();
        }
        render_get_context() {
            const props = this.is_destructured ? this.value_contexts.map((prop)=>b`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`#ctx[${this.value_index}]`), (name)=>this.renderer.reference(name))};`) : null;
            const const_tags_props = this.has_consts(this.node) ? add_const_tags(this.block, this.node.const_tags, "#ctx") : null;
            const get_context = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
            this.block.renderer.blocks.push(b`
			function ${get_context}(#ctx) {
				${props}
				${const_tags_props}
			}
		`);
            this.block.chunks.declarations.push(b`${get_context}(#ctx)`);
            if (this.block.has_update_method) this.block.chunks.update.unshift(b`${get_context}(#ctx)`);
        }
    }
    class AwaitBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = {
                type: "Identifier",
                name: "await_block"
            };
            this.cannot_use_innerhtml();
            this.not_static_content();
            block.add_dependencies(this.node.expression.dependencies);
            let is_dynamic = false;
            let has_intros = false;
            let has_outros = false;
            [
                "pending",
                "then",
                "catch"
            ].forEach((status)=>{
                const child = this.node[status];
                const branch = new AwaitBlockBranch(status, renderer, block, this, child, strip_whitespace, next_sibling);
                renderer.blocks.push(branch.block);
                if (branch.is_dynamic) {
                    is_dynamic = true;
                    // TODO should blocks update their own parents?
                    block.add_dependencies(branch.block.dependencies);
                }
                if (branch.block.has_intros) has_intros = true;
                if (branch.block.has_outros) has_outros = true;
                this[status] = branch;
            });
            [
                "pending",
                "then",
                "catch"
            ].forEach((status)=>{
                this[status].block.has_update_method = is_dynamic;
                this[status].block.has_intro_method = has_intros;
                this[status].block.has_outro_method = has_outros;
            });
            if (has_outros) block.add_outro();
        }
        render(block, parent_node, parent_nodes) {
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const update_mount_node = this.get_update_mount_node(anchor);
            const snippet = this.node.expression.manipulate(block);
            const info = block.get_unique_name("info");
            const promise = block.get_unique_name("promise");
            block.add_variable(promise);
            block.maintain_context = true;
            const info_props = x`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x`[,,,]`}
		}`;
            block.chunks.init.push(b`
			let ${info} = ${info_props};
		`);
            block.chunks.init.push(b`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
            block.chunks.create.push(b`
			${info}.block.c();
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b`
				${info}.block.l(${parent_nodes});
			`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
            block.chunks.mount.push(b`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
            if (has_transitions) block.chunks.intro.push(b`@transition_in(${info}.block);`);
            const dependencies = this.node.expression.dynamic_dependencies();
            const update_await_block_branch = b`@update_await_block_branch(${info}, #ctx, #dirty)`;
            if (dependencies.length > 0) {
                const condition = x`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
                block.chunks.update.push(b`${info}.ctx = #ctx;`);
                if (this.pending.block.has_update_method) block.chunks.update.push(b`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
                else block.chunks.update.push(b`
					${condition}
				`);
            } else if (this.pending.block.has_update_method) block.chunks.update.push(b`
					${update_await_block_branch}
				`);
            if (this.pending.block.has_outro_method) block.chunks.outro.push(b`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
            block.chunks.destroy.push(b`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
            [
                this.pending,
                this.then,
                this.catch
            ].forEach((branch)=>{
                branch.render(branch.block, null, x`#nodes`);
            });
        }
    }
    const TRUE = x`true`;
    const FALSE = x`false`;
    class EventHandlerWrapper {
        constructor(node, parent){
            this.node = node;
            this.parent = parent;
            if (!node.expression) {
                this.parent.renderer.add_to_context(node.handler_name.name);
                this.parent.renderer.component.partly_hoisted.push(b`
				function ${node.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
            }
        }
        get_snippet(block) {
            const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
            if (this.node.reassigned) {
                block.maintain_context = true;
                return x`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
            }
            return snippet;
        }
        render(block, target) {
            let snippet = this.get_snippet(block);
            if (this.node.modifiers.has("preventDefault")) snippet = x`@prevent_default(${snippet})`;
            if (this.node.modifiers.has("stopPropagation")) snippet = x`@stop_propagation(${snippet})`;
            if (this.node.modifiers.has("self")) snippet = x`@self(${snippet})`;
            if (this.node.modifiers.has("trusted")) snippet = x`@trusted(${snippet})`;
            const args = [];
            const opts = [
                "nonpassive",
                "passive",
                "once",
                "capture"
            ].filter((mod)=>this.node.modifiers.has(mod));
            if (opts.length) {
                if (opts.length === 1 && opts[0] === "capture") args.push(TRUE);
                else args.push(x`{ ${opts.map((opt)=>opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`);
            } else if (block.renderer.options.dev) args.push(FALSE);
            if (block.renderer.options.dev) {
                args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
                args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
            }
            block.event_listeners.push(x`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
        }
    }
    function add_event_handlers(block, target, handlers) {
        handlers.forEach((handler)=>add_event_handler(block, target, handler));
    }
    function add_event_handler(block, target, handler) {
        handler.render(block, target);
    }
    function add_actions(block, target, actions) {
        actions.forEach((action)=>add_action(block, target, action));
    }
    const regex_invalid_variable_identifier_characters = /[^a-zA-Z0-9_$]/g;
    function add_action(block, target, action) {
        const { expression: expression, template_scope: template_scope } = action;
        let snippet;
        let dependencies;
        if (expression) {
            snippet = expression.manipulate(block);
            dependencies = expression.dynamic_dependencies();
        }
        const id = block.get_unique_name(`${action.name.replace(regex_invalid_variable_identifier_characters, "_")}_action`);
        block.add_variable(id);
        const [obj, ...properties] = action.name.split(".");
        const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
        if (properties.length) {
            const member_expression = properties.reduce((lhs, rhs)=>x`${lhs}.${rhs}`, fn);
            block.event_listeners.push(x`@action_destroyer(${id} = ${member_expression}(${target}, ${snippet}))`);
        } else block.event_listeners.push(x`@action_destroyer(${id} = ${fn}.call(null, ${target}, ${snippet}))`);
        if (dependencies && dependencies.length > 0) {
            let condition = x`${id} && @is_function(${id}.update)`;
            if (dependencies.length > 0) condition = x`${condition} && ${block.renderer.dirty(dependencies)}`;
            block.chunks.update.push(b`if (${condition}) ${id}.update.call(null, ${snippet});`);
        }
    }
    class BodyWrapper extends Wrapper {
        constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.handlers = this.node.handlers.map((handler)=>new EventHandlerWrapper(handler, this));
        }
        render(block, _parent_node, _parent_nodes) {
            add_event_handlers(block, x`@_document.body`, this.handlers);
            add_actions(block, x`@_document.body`, this.node.actions);
        }
    }
    class DebugTagWrapper extends Wrapper {
        constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling){
            super(renderer, block, parent, node);
        }
        render(block, _parent_node, _parent_nodes) {
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            if (!renderer.options.dev) return;
            const { var_lookup: var_lookup } = component;
            const start = component.locate(this.node.start + 1);
            const end = {
                line: start.line,
                column: start.column + 6
            };
            const loc = {
                start: start,
                end: end
            };
            const debug = {
                type: "DebuggerStatement",
                loc: loc
            };
            if (this.node.expressions.length === 0) {
                // Debug all
                block.chunks.create.push(debug);
                block.chunks.update.push(debug);
            } else {
                const log = {
                    type: "Identifier",
                    name: "log",
                    loc: loc
                };
                const dependencies = new Set();
                this.node.expressions.forEach((expression)=>{
                    add_to_set(dependencies, expression.dependencies);
                });
                const contextual_identifiers = this.node.expressions.filter((e)=>{
                    const variable = var_lookup.get(e.node.name);
                    return !(variable && variable.hoistable);
                }).map((e)=>e.node.name);
                const logged_identifiers = this.node.expressions.map((e)=>p`${e.node.name}`);
                const debug_statements = b`
				${contextual_identifiers.map((name)=>b`const ${name} = ${renderer.reference(name)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
                if (dependencies.size) {
                    const condition = renderer.dirty(Array.from(dependencies));
                    block.chunks.update.push(b`
					if (${condition}) {
						${debug_statements}
					}
				`);
                }
                block.chunks.create.push(b`{
				${debug_statements}
			}`);
            }
        }
    }
    class ElseBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = null;
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(node, this.renderer.component),
                name: this.renderer.component.get_unique_name("create_else_block"),
                type: "else"
            });
            this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
        }
    }
    class EachBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.updates = [];
            this.var = {
                type: "Identifier",
                name: "each"
            };
            this.cannot_use_innerhtml();
            this.not_static_content();
            const { dependencies: dependencies } = node.expression;
            block.add_dependencies(dependencies);
            this.node.contexts.forEach((context)=>{
                renderer.add_to_context(context.key.name, true);
            });
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(this.node, this.renderer.component),
                name: renderer.component.get_unique_name("create_each_block"),
                type: "each",
                // @ts-ignore todo: probably error
                key: node.key,
                bindings: new Map(block.bindings)
            });
            // TODO this seems messy
            this.block.has_animation = this.node.has_animation;
            this.index_name = this.node.index ? {
                type: "Identifier",
                name: this.node.index
            } : renderer.component.get_unique_name(`${this.node.context}_index`);
            const fixed_length = node.expression.node.type === "ArrayExpression" && node.expression.node.elements.every((element)=>element.type !== "SpreadElement") ? node.expression.node.elements.length : null;
            // hack the sourcemap, so that if data is missing the bug
            // is easy to find
            let c = this.node.start + 2;
            while(renderer.component.source[c] !== "e")c += 1;
            const start = renderer.component.locate(c);
            const end = {
                line: start.line,
                column: start.column + 4
            };
            const length = {
                type: "Identifier",
                name: "length",
                loc: {
                    start: start,
                    end: end
                }
            };
            const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
            const iterations = block.get_unique_name(`${this.var.name}_blocks`);
            renderer.add_to_context(each_block_value.name, true);
            renderer.add_to_context(this.index_name.name, true);
            this.vars = {
                create_each_block: this.block.name,
                each_block_value: each_block_value,
                get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
                iterations: iterations,
                fixed_length: // optimisation for array literal
                fixed_length,
                data_length: fixed_length === null ? x`${each_block_value}.${length}` : fixed_length,
                view_length: fixed_length === null ? x`${iterations}.length` : fixed_length
            };
            const object = get_object(node.expression.node);
            const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
            node.contexts.forEach((prop)=>{
                this.block.bindings.set(prop.key.name, {
                    object: this.vars.each_block_value,
                    property: this.index_name,
                    modifier: prop.modifier,
                    snippet: prop.modifier(x`${this.vars.each_block_value}[${this.index_name}]`),
                    store: store
                });
            });
            if (this.node.index) this.block.get_unique_name(this.node.index); // this prevents name collisions (#1254)
            renderer.blocks.push(this.block);
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, this, strip_whitespace, next_sibling);
            if (this.node.else) {
                this.else = new ElseBlockWrapper(renderer, block, this, this.node.else, strip_whitespace, next_sibling);
                renderer.blocks.push(this.else.block);
                if (this.else.is_dynamic) this.block.add_dependencies(this.else.block.dependencies);
            }
            block.add_dependencies(this.block.dependencies);
            if (this.block.has_outros || this.else && this.else.block.has_outros) block.add_outro();
        }
        render(block, parent_node, parent_nodes) {
            if (this.fragment.nodes.length === 0) return;
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const snippet = this.node.expression.manipulate(block);
            block.chunks.init.push(b`let ${this.vars.each_block_value} = ${snippet};`);
            if (this.renderer.options.dev) block.chunks.init.push(b`@validate_each_argument(${this.vars.each_block_value});`);
            const initial_anchor_node = {
                type: "Identifier",
                name: parent_node ? "null" : "#anchor"
            };
            const initial_mount_node = parent_node || {
                type: "Identifier",
                name: "#target"
            };
            const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
                type: "Identifier",
                name: "null"
            };
            const update_mount_node = this.get_update_mount_node(update_anchor_node);
            const args = {
                block: block,
                parent_node: parent_node,
                parent_nodes: parent_nodes,
                snippet: snippet,
                initial_anchor_node: initial_anchor_node,
                initial_mount_node: initial_mount_node,
                update_anchor_node: update_anchor_node,
                update_mount_node: update_mount_node
            };
            const all_dependencies = new Set(this.block.dependencies); // TODO should be dynamic deps only
            this.node.expression.dynamic_dependencies().forEach((dependency)=>{
                all_dependencies.add(dependency);
            });
            if (this.node.key) this.node.key.dynamic_dependencies().forEach((dependency)=>{
                all_dependencies.add(dependency);
            });
            this.dependencies = all_dependencies;
            if (this.node.key) this.render_keyed(args);
            else this.render_unkeyed(args);
            if (this.block.has_intro_method || this.block.has_outro_method) block.chunks.intro.push(b`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
            if (needs_anchor) block.add_element(update_anchor_node, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
            if (this.else) {
                let else_ctx = x`#ctx`;
                if (this.else.node.const_tags.length > 0) {
                    const get_ctx_name = this.renderer.component.get_unique_name("get_else_ctx");
                    this.renderer.blocks.push(b`
					function ${get_ctx_name}(#ctx) {
						const child_ctx = #ctx.slice();
						${add_const_tags(block, this.else.node.const_tags, "child_ctx")}
						return child_ctx;
					}
				`);
                    else_ctx = x`${get_ctx_name}(#ctx)`;
                }
                const each_block_else = component.get_unique_name(`${this.var.name}_else`);
                block.chunks.init.push(b`let ${each_block_else} = null;`);
                // TODO neaten this up... will end up with an empty line in the block
                block.chunks.init.push(b`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(${else_ctx});
				}
			`);
                block.chunks.create.push(b`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
                if (this.renderer.options.hydratable) block.chunks.claim.push(b`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
                block.chunks.mount.push(b`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
                const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
                const destroy_block_else = this.else.block.has_outro_method ? b`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
                if (this.else.block.has_update_method) this.updates.push(b`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(${else_ctx}, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
                else this.updates.push(b`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
                block.chunks.destroy.push(b`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
            }
            if (this.updates.length) block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
            this.fragment.render(this.block, null, x`#nodes`);
            if (this.else) this.else.fragment.render(this.else.block, null, x`#nodes`);
            this.context_props = this.node.contexts.map((prop)=>b`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`list[i]`), (name)=>renderer.context_lookup.has(name) ? x`child_ctx[${renderer.context_lookup.get(name).index}]` : {
                        type: "Identifier",
                        name: name
                    })};`);
            if (this.node.has_binding) this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`);
            if (this.node.has_binding || this.node.has_index_binding || this.node.index) this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`);
            // TODO which is better — Object.create(array) or array.slice()?
            renderer.blocks.push(b`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				${add_const_tags(this.block, this.node.const_tags, "child_ctx")}
				return child_ctx;
			}
		`);
        }
        render_keyed({ block: block, parent_node: parent_node, parent_nodes: parent_nodes, snippet: snippet, initial_anchor_node: initial_anchor_node, initial_mount_node: initial_mount_node, update_anchor_node: update_anchor_node, update_mount_node: update_mount_node }) {
            const { create_each_block: create_each_block, iterations: iterations, data_length: data_length, view_length: view_length } = this.vars;
            const get_key = block.get_unique_name("get_key");
            const lookup = block.get_unique_name(`${this.var.name}_lookup`);
            block.add_variable(iterations, x`[]`);
            block.add_variable(lookup, x`new @_Map()`);
            if (this.fragment.nodes[0].is_dom_node()) this.block.first = this.fragment.nodes[0].var;
            else {
                this.block.first = this.block.get_unique_name("first");
                this.block.add_element(this.block.first, x`@empty()`, parent_nodes && x`@empty()`, null);
            }
            block.chunks.init.push(b`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
            block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
            block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
            const dynamic = this.block.has_update_method;
            const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
            if (this.dependencies.size) {
                this.block.maintain_context = true;
                this.updates.push(b`
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				${this.block.has_outros && b`@group_outros();`}
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b`@check_outros();`}
			`);
            }
            if (this.block.has_outros) block.chunks.outro.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
            block.chunks.destroy.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
        }
        render_unkeyed({ block: block, parent_nodes: parent_nodes, snippet: snippet, initial_anchor_node: initial_anchor_node, initial_mount_node: initial_mount_node, update_anchor_node: update_anchor_node, update_mount_node: update_mount_node }) {
            const { create_each_block: create_each_block, iterations: iterations, fixed_length: fixed_length, data_length: data_length, view_length: view_length } = this.vars;
            block.chunks.init.push(b`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
            block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
            block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
            if (this.dependencies.size) {
                const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
                const for_loop_body = this.block.has_update_method ? b`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
                const start = this.block.has_update_method ? 0 : "#old_length";
                let remove_old_blocks;
                if (this.block.has_outros) {
                    const out = block.get_unique_name("out");
                    block.chunks.init.push(b`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
                    remove_old_blocks = b`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
                } else remove_old_blocks = b`
					for (${this.block.has_update_method ? null : x`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b`${view_length} = ${data_length};`}
				`;
                // We declare `i` as block scoped here, as the `remove_old_blocks` code
                // may rely on continuing where this iteration stopped.
                const update = b`
				${!this.block.has_update_method && b`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
                this.updates.push(update);
            }
            if (this.block.has_outros) block.chunks.outro.push(b`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
            block.chunks.destroy.push(b`@destroy_each(${iterations}, detaching);`);
        }
    }
    const regex_non_whitespace_characters$1 = /[\S\u00A0]/;
    class TextWrapper extends Wrapper {
        constructor(renderer, block, parent, node, data){
            super(renderer, block, parent, node);
            this.skip = this.node.should_skip();
            this.data = data;
            this.var = this.skip ? null : x`t`;
        }
        use_space() {
            if (this.renderer.component.component_options.preserveWhitespace) return false;
            if (regex_non_whitespace_characters$1.test(this.data)) return false;
            return !this.node.within_pre();
        }
        render(block, parent_node, parent_nodes) {
            if (this.skip) return;
            const use_space = this.use_space();
            const string_literal = {
                type: "Literal",
                value: this.data,
                loc: {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                }
            };
            block.add_element(this.var, use_space ? x`@space()` : x`@text(${string_literal})`, parent_nodes && (use_space ? x`@claim_space(${parent_nodes})` : x`@claim_text(${parent_nodes}, ${string_literal})`), parent_node);
        }
    }
    const svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
    const svg_attribute_lookup = new Map();
    svg_attributes.forEach((name)=>{
        svg_attribute_lookup.set(name.toLowerCase(), name);
    });
    function fix_attribute_casing(name) {
        name = name.toLowerCase();
        return svg_attribute_lookup.get(name) || name;
    }
    function handle_select_value_binding(attr, dependencies) {
        const { parent: parent } = attr;
        if (parent.node.name === "select") {
            parent.select_binding_dependencies = dependencies;
            dependencies.forEach((prop)=>{
                parent.renderer.component.indirect_dependencies.set(prop, new Set());
            });
        }
    }
    // source: https://html.spec.whatwg.org/multipage/indices.html
    const boolean_attributes = new Set([
        "allowfullscreen",
        "allowpaymentrequest",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "default",
        "defer",
        "disabled",
        "formnovalidate",
        "hidden",
        "inert",
        "ismap",
        "itemscope",
        "loop",
        "multiple",
        "muted",
        "nomodule",
        "novalidate",
        "open",
        "playsinline",
        "readonly",
        "required",
        "reversed",
        "selected"
    ]);
    const non_textlike_input_types = new Set([
        "button",
        "checkbox",
        "color",
        "date",
        "datetime-local",
        "file",
        "hidden",
        "image",
        "radio",
        "range",
        "reset",
        "submit"
    ]);
    class BaseAttributeWrapper {
        constructor(parent, block, node){
            this.node = node;
            this.parent = parent;
            if (node.dependencies.size > 0) {
                parent.cannot_use_innerhtml();
                parent.not_static_content();
                block.add_dependencies(node.dependencies);
            }
        }
        render(_block) {}
    }
    const regex_minus_sign$1 = /-/;
    const regex_invalid_variable_identifier_characters$1 = /[^a-zA-Z_$]/g;
    class AttributeWrapper extends BaseAttributeWrapper {
        constructor(parent, block, node){
            super(parent, block, node);
            if (node.dependencies.size > 0) {
                // special case — <option value={foo}> — see below
                if (this.parent.node.name === "option" && node.name === "value") {
                    let select = this.parent;
                    while(select && (select.node.type !== "Element" || select.node.name !== "select"))// @ts-ignore todo: doublecheck this, but looks to be correct
                    select = select.parent;
                    if (select && select.select_binding_dependencies) select.select_binding_dependencies.forEach((prop)=>{
                        this.node.dependencies.forEach((dependency)=>{
                            this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
                        });
                    });
                }
                if (node.name === "value") handle_select_value_binding(this, node.dependencies);
            }
            if (this.parent.node.namespace == namespaces.foreign) {
                // leave attribute case alone for elements in the "foreign" namespace
                this.name = this.node.name;
                this.metadata = this.get_metadata();
                this.is_indirectly_bound_value = false;
                this.property_name = null;
                this.is_select_value_attribute = false;
                this.is_input_value = false;
            } else {
                this.name = fix_attribute_casing(this.node.name);
                this.metadata = this.get_metadata();
                this.is_indirectly_bound_value = is_indirectly_bound_value(this);
                this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
                this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
                this.is_input_value = this.name === "value" && this.parent.node.name === "input";
            }
            // TODO retire this exception in favour of https://github.com/sveltejs/svelte/issues/3750
            this.is_src = this.name === "src" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
            this.should_cache = should_cache(this);
        }
        render(block) {
            const element = this.parent;
            const { name: name, property_name: property_name, should_cache: should_cache, is_indirectly_bound_value: is_indirectly_bound_value } = this;
            // xlink is a special case... we could maybe extend this to generic
            // namespaced attributes but I'm not sure that's applicable in
            // HTML5?
            const method = regex_minus_sign$1.test(element.node.name) ? "@set_custom_element_data" : name.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
            const is_legacy_input_type = element.renderer.component.compile_options.legacy && name === "type" && this.parent.node.name === "input";
            const dependencies = this.get_dependencies();
            const value = this.get_value(block);
            let updater;
            const init = this.get_init(block, value);
            if (is_legacy_input_type) {
                block.chunks.hydrate.push(b`@set_input_type(${element.var}, ${init});`);
                updater = b`@set_input_type(${element.var}, ${should_cache ? this.last : value});`;
            } else if (this.is_select_value_attribute) {
                // annoying special case
                const is_multiple_select = element.node.get_static_attribute_value("multiple");
                if (is_multiple_select) updater = b`@select_options(${element.var}, ${value});`;
                else updater = b`@select_option(${element.var}, ${value});`;
                block.chunks.mount.push(b`
				${updater}
			`);
            } else if (this.is_src) {
                block.chunks.hydrate.push(b`if (!@src_url_equal(${element.var}.src, ${init})) ${method}(${element.var}, "${name}", ${this.last});`);
                updater = b`${method}(${element.var}, "${name}", ${should_cache ? this.last : value});`;
            } else if (property_name) {
                block.chunks.hydrate.push(b`${element.var}.${property_name} = ${init};`);
                updater = block.renderer.options.dev ? b`@prop_dev(${element.var}, "${property_name}", ${should_cache ? this.last : value});` : b`${element.var}.${property_name} = ${should_cache ? this.last : value};`;
            } else {
                block.chunks.hydrate.push(b`${method}(${element.var}, "${name}", ${init});`);
                updater = b`${method}(${element.var}, "${name}", ${should_cache ? this.last : value});`;
            }
            if (is_indirectly_bound_value) {
                const update_value = b`${element.var}.value = ${element.var}.__value;`;
                block.chunks.hydrate.push(update_value);
                updater = b`
				${updater}
				${update_value};
			`;
            }
            if (dependencies.length > 0) {
                const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
                block.chunks.update.push(b`
				if (${condition}) {
					${updater}
				}`);
            }
            // special case – autofocus. has to be handled in a bit of a weird way
            if (name === "autofocus") block.autofocus = {
                element_var: element.var,
                condition_expression: this.node.is_true ? undefined : value
            };
        }
        get_init(block, value) {
            this.last = this.should_cache && block.get_unique_name(`${this.parent.var.name}_${this.name.replace(regex_invalid_variable_identifier_characters$1, "_")}_value`);
            if (this.should_cache) block.add_variable(this.last);
            return this.should_cache ? x`${this.last} = ${value}` : value;
        }
        get_dom_update_conditions(block, dependency_condition) {
            const { property_name: property_name, should_cache: should_cache, last: last } = this;
            const element = this.parent;
            const value = this.get_value(block);
            let condition = dependency_condition;
            if (should_cache) condition = this.is_src ? x`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value})))` : x`${condition} && (${last} !== (${last} = ${value}))`;
            if (this.is_input_value) {
                const type = element.node.get_static_attribute_value("type");
                if (type !== true && !non_textlike_input_types.has(type)) condition = x`${condition} && ${element.var}.${property_name} !== ${should_cache ? last : value}`;
            }
            if (block.has_outros) condition = x`!#current || ${condition}`;
            return condition;
        }
        get_dependencies() {
            const node_dependencies = this.node.get_dependencies();
            const dependencies = new Set(node_dependencies);
            node_dependencies.forEach((prop)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    dependencies.add(indirect_dependency);
                });
            });
            return Array.from(dependencies);
        }
        get_metadata() {
            if (this.parent.node.namespace) return null;
            const metadata = attribute_lookup[this.name];
            if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name)) return null;
            return metadata;
        }
        get_value(block) {
            if (this.node.is_true) {
                if (this.metadata && boolean_attributes.has(this.metadata.property_name.toLowerCase())) return x`true`;
                return x`""`;
            }
            if (this.node.chunks.length === 0) return x`""`;
            // TODO some of this code is repeated in Tag.ts — would be good to
            // DRY it out if that's possible without introducing crazy indirection
            if (this.node.chunks.length === 1) return this.node.chunks[0].type === "Text" ? string_literal(this.node.chunks[0].data) : this.node.chunks[0].manipulate(block);
            let value = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
            // '{foo} {bar}' — treat as string concatenation
            if (this.node.chunks[0].type !== "Text") value = x`"" + ${value}`;
            return value;
        }
        get_class_name_text(block) {
            const scoped_css = this.node.chunks.some((chunk)=>chunk.synthetic);
            const rendered = this.render_chunks(block);
            if (scoped_css && rendered.length === 2) // we have a situation like class={possiblyUndefined}
            rendered[0] = x`@null_to_empty(${rendered[0]})`;
            return rendered.reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
        }
        render_chunks(block) {
            return this.node.chunks.map((chunk)=>{
                if (chunk.type === "Text") return string_literal(chunk.data);
                return chunk.manipulate(block);
            });
        }
        stringify() {
            if (this.node.is_true) return "";
            const value = this.node.chunks;
            if (value.length === 0) return '=""';
            return `="${value.map((chunk)=>{
                return chunk.type === "Text" ? chunk.data.replace(regex_double_quotes, '\\"') : `\${${chunk.manipulate()}}`;
            }).join("")}"`;
        }
    }
    // source: https://html.spec.whatwg.org/multipage/indices.html
    const attribute_lookup = {
        allowfullscreen: {
            property_name: "allowFullscreen",
            applies_to: [
                "iframe"
            ]
        },
        allowpaymentrequest: {
            property_name: "allowPaymentRequest",
            applies_to: [
                "iframe"
            ]
        },
        async: {
            applies_to: [
                "script"
            ]
        },
        autofocus: {
            applies_to: [
                "button",
                "input",
                "keygen",
                "select",
                "textarea"
            ]
        },
        autoplay: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        checked: {
            applies_to: [
                "input"
            ]
        },
        controls: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        default: {
            applies_to: [
                "track"
            ]
        },
        defer: {
            applies_to: [
                "script"
            ]
        },
        disabled: {
            applies_to: [
                "button",
                "fieldset",
                "input",
                "keygen",
                "optgroup",
                "option",
                "select",
                "textarea"
            ]
        },
        formnovalidate: {
            property_name: "formNoValidate",
            applies_to: [
                "button",
                "input"
            ]
        },
        hidden: {},
        indeterminate: {
            applies_to: [
                "input"
            ]
        },
        ismap: {
            property_name: "isMap",
            applies_to: [
                "img"
            ]
        },
        loop: {
            applies_to: [
                "audio",
                "bgsound",
                "video"
            ]
        },
        multiple: {
            applies_to: [
                "input",
                "select"
            ]
        },
        muted: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        nomodule: {
            property_name: "noModule",
            applies_to: [
                "script"
            ]
        },
        novalidate: {
            property_name: "noValidate",
            applies_to: [
                "form"
            ]
        },
        open: {
            applies_to: [
                "details",
                "dialog"
            ]
        },
        playsinline: {
            property_name: "playsInline",
            applies_to: [
                "video"
            ]
        },
        readonly: {
            property_name: "readOnly",
            applies_to: [
                "input",
                "textarea"
            ]
        },
        required: {
            applies_to: [
                "input",
                "select",
                "textarea"
            ]
        },
        reversed: {
            applies_to: [
                "ol"
            ]
        },
        selected: {
            applies_to: [
                "option"
            ]
        },
        value: {
            applies_to: [
                "button",
                "option",
                "input",
                "li",
                "meter",
                "progress",
                "param",
                "select",
                "textarea"
            ]
        }
    };
    Object.keys(attribute_lookup).forEach((name)=>{
        const metadata = attribute_lookup[name];
        if (!metadata.property_name) metadata.property_name = name;
    });
    function should_cache(attribute) {
        return attribute.is_src || attribute.node.should_cache();
    }
    const regex_contains_checked_or_group = /checked|group/;
    function is_indirectly_bound_value(attribute) {
        const element = attribute.parent;
        return attribute.name === "value" && (element.node.name === "option" || // TODO check it's actually bound
        element.node.name === "input" && element.node.bindings.some((binding)=>regex_contains_checked_or_group.test(binding.name)));
    }
    class StyleAttributeWrapper extends AttributeWrapper {
        render(block) {
            const style_props = optimize_style(this.node.chunks);
            if (!style_props) return super.render(block);
            style_props.forEach((prop)=>{
                let value;
                if (is_dynamic$1(prop.value)) {
                    const prop_dependencies = new Set();
                    value = prop.value.map((chunk)=>{
                        if (chunk.type === "Text") return string_literal(chunk.data);
                        else {
                            add_to_set(prop_dependencies, chunk.dynamic_dependencies());
                            return chunk.manipulate(block);
                        }
                    }).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
                    // TODO is this necessary? style.setProperty always treats value as string, no?
                    // if (prop.value.length === 1 || prop.value[0].type !== 'Text') {
                    // 	value = x`"" + ${value}`;
                    // }
                    if (prop_dependencies.size) {
                        let condition = block.renderer.dirty(Array.from(prop_dependencies));
                        if (block.has_outros) condition = x`!#current || ${condition}`;
                        const update = b`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});
						}`;
                        block.chunks.update.push(update);
                    }
                } else value = string_literal(prop.value[0].data);
                block.chunks.hydrate.push(b`@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});`);
            });
        }
    }
    const regex_style_prop_key = /^\s*([\w-]+):\s*/;
    function optimize_style(value) {
        const props = [];
        let chunks = value.slice();
        while(chunks.length){
            const chunk = chunks[0];
            if (chunk.type !== "Text") return null;
            const key_match = regex_style_prop_key.exec(chunk.data);
            if (!key_match) return null;
            const key = key_match[1];
            const offset = key_match.index + key_match[0].length;
            const remaining_data = chunk.data.slice(offset);
            if (remaining_data) chunks[0] = {
                start: chunk.start + offset,
                end: chunk.end,
                type: "Text",
                data: remaining_data
            };
            else chunks.shift();
            const result = get_style_value(chunks);
            props.push({
                key: key,
                value: result.value,
                important: result.important
            });
            chunks = result.chunks;
        }
        return props;
    }
    const regex_important_flag = /\s*!important\s*$/;
    const regex_semicolon_or_whitespace = /[;\s]/;
    function get_style_value(chunks) {
        const value = [];
        let in_url = false;
        let quote_mark = null;
        let escaped = false;
        let closed = false;
        while(chunks.length && !closed){
            const chunk = chunks.shift();
            if (chunk.type === "Text") {
                let c = 0;
                while(c < chunk.data.length){
                    const char = chunk.data[c];
                    if (escaped) escaped = false;
                    else if (char === "\\") escaped = true;
                    else if (char === quote_mark) quote_mark = null;
                    else if (char === '"' || char === "'") quote_mark = char;
                    else if (char === ")" && in_url) in_url = false;
                    else if (char === "u" && chunk.data.slice(c, c + 4) === "url(") in_url = true;
                    else if (char === ";" && !in_url && !quote_mark) {
                        closed = true;
                        break;
                    }
                    c += 1;
                }
                if (c > 0) value.push({
                    type: "Text",
                    start: chunk.start,
                    end: chunk.start + c,
                    data: chunk.data.slice(0, c)
                });
                while(regex_semicolon_or_whitespace.test(chunk.data[c]))c += 1;
                const remaining_data = chunk.data.slice(c);
                if (remaining_data) {
                    chunks.unshift({
                        start: chunk.start + c,
                        end: chunk.end,
                        type: "Text",
                        data: remaining_data
                    });
                    break;
                }
            } else value.push(chunk);
        }
        let important = false;
        const last_chunk = value[value.length - 1];
        if (last_chunk && last_chunk.type === "Text" && regex_important_flag.test(last_chunk.data)) {
            important = true;
            last_chunk.data = last_chunk.data.replace(regex_important_flag, "");
            if (!last_chunk.data) value.pop();
        }
        return {
            chunks: chunks,
            value: value,
            important: important
        };
    }
    function is_dynamic$1(value) {
        return value.length > 1 || value[0].type !== "Text";
    }
    class SpreadAttributeWrapper extends BaseAttributeWrapper {
    }
    function mark_each_block_bindings(parent, binding) {
        // we need to ensure that the each block creates a context including
        // the list and the index, if they're not otherwise referenced
        binding.expression.references.forEach((name)=>{
            const each_block = parent.node.scope.get_owner(name);
            if (each_block) each_block.has_binding = true;
        });
        if (binding.name === "group") {
            const add_index_binding = (name)=>{
                const each_block = parent.node.scope.get_owner(name);
                if (each_block.type === "EachBlock") {
                    each_block.has_index_binding = true;
                    for (const dep of each_block.expression.contextual_dependencies)add_index_binding(dep);
                }
            };
            // for `<input bind:group={} >`, we make sure that all the each blocks creates context with `index`
            for (const name of binding.expression.contextual_dependencies)add_index_binding(name);
        }
    }
    class BindingWrapper {
        constructor(block, node, parent){
            this.node = node;
            this.parent = parent;
            const { dependencies: dependencies } = this.node.expression;
            block.add_dependencies(dependencies);
            // TODO does this also apply to e.g. `<input type='checkbox' bind:group='foo'>`?
            handle_select_value_binding(this, dependencies);
            if (node.is_contextual) mark_each_block_bindings(this.parent, this.node);
            this.object = get_object(this.node.expression.node).name;
            // view to model
            this.handler = get_event_handler(this, parent.renderer, block, this.object, this.node.raw_expression);
            this.snippet = this.node.expression.manipulate(block);
            this.is_readonly = this.node.is_readonly;
            this.needs_lock = this.node.name === "currentTime"; // TODO others?
        }
        get_dependencies() {
            const dependencies = new Set(this.node.expression.dependencies);
            this.node.expression.dependencies.forEach((prop)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    dependencies.add(indirect_dependency);
                });
            });
            return dependencies;
        }
        get_update_dependencies() {
            const object = this.object;
            const dependencies = new Set();
            if (this.node.expression.template_scope.names.has(object)) this.node.expression.template_scope.dependencies_for_name.get(object).forEach((name)=>dependencies.add(name));
            else dependencies.add(object);
            const result = new Set(dependencies);
            dependencies.forEach((dependency)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(dependency);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    result.add(indirect_dependency);
                });
            });
            return result;
        }
        is_readonly_media_attribute() {
            return this.node.is_readonly_media_attribute();
        }
        render(block, lock) {
            if (this.is_readonly) return;
            const { parent: parent } = this;
            const update_conditions = this.needs_lock ? [
                x`!${lock}`
            ] : [];
            const mount_conditions = [];
            const dependency_array = Array.from(this.get_dependencies());
            if (dependency_array.length > 0) update_conditions.push(block.renderer.dirty(dependency_array));
            if (parent.node.name === "input") {
                const type = parent.node.get_static_attribute_value("type");
                if (type === null || type === "" || type === "text" || type === "email" || type === "password") update_conditions.push(x`${parent.var}.${this.node.name} !== ${this.snippet}`);
                else if (type === "number") update_conditions.push(x`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
            }
            // model to view
            let update_dom = get_dom_updater(parent, this);
            let mount_dom = update_dom;
            // special cases
            switch(this.node.name){
                case "group":
                    {
                        const { binding_group: binding_group, is_context: is_context, contexts: contexts, index: index, keypath: keypath } = get_binding_group(parent.renderer, this.node, block);
                        block.renderer.add_to_context("$$binding_groups");
                        if (is_context && !block.binding_group_initialised.has(keypath)) {
                            if (contexts.length > 1) {
                                let binding_group = x`${block.renderer.reference("$$binding_groups")}[${index}]`;
                                for (const name of contexts.slice(0, -1)){
                                    binding_group = x`${binding_group}[${block.renderer.reference(name)}]`;
                                    block.chunks.init.push(b`${binding_group} = ${binding_group} || [];`);
                                }
                            }
                            block.chunks.init.push(b`${binding_group(true)} = [];`);
                            block.binding_group_initialised.add(keypath);
                        }
                        block.chunks.hydrate.push(b`${binding_group(true)}.push(${parent.var});`);
                        block.chunks.destroy.push(b`${binding_group(true)}.splice(${binding_group(true)}.indexOf(${parent.var}), 1);`);
                        break;
                    }
                case "textContent":
                    update_conditions.push(x`${this.snippet} !== ${parent.var}.textContent`);
                    mount_conditions.push(x`${this.snippet} !== void 0`);
                    break;
                case "innerHTML":
                    update_conditions.push(x`${this.snippet} !== ${parent.var}.innerHTML`);
                    mount_conditions.push(x`${this.snippet} !== void 0`);
                    break;
                case "currentTime":
                    update_conditions.push(x`!@_isNaN(${this.snippet})`);
                    mount_dom = null;
                    break;
                case "playbackRate":
                case "volume":
                    update_conditions.push(x`!@_isNaN(${this.snippet})`);
                    mount_conditions.push(x`!@_isNaN(${this.snippet})`);
                    break;
                case "paused":
                    {
                        // this is necessary to prevent audio restarting by itself
                        const last = block.get_unique_name(`${parent.var.name}_is_paused`);
                        block.add_variable(last, x`true`);
                        update_conditions.push(x`${last} !== (${last} = ${this.snippet})`);
                        update_dom = b`${parent.var}[${last} ? "pause" : "play"]();`;
                        mount_dom = null;
                        break;
                    }
                case "value":
                    if (parent.node.get_static_attribute_value("type") === "file") {
                        update_dom = null;
                        mount_dom = null;
                    }
            }
            if (update_dom) {
                if (update_conditions.length > 0) {
                    const condition = update_conditions.reduce((lhs, rhs)=>x`${lhs} && ${rhs}`);
                    block.chunks.update.push(b`
					if (${condition}) {
						${update_dom}
					}
				`);
                } else block.chunks.update.push(update_dom);
            }
            if (mount_dom) {
                if (mount_conditions.length > 0) {
                    const condition = mount_conditions.reduce((lhs, rhs)=>x`${lhs} && ${rhs}`);
                    block.chunks.mount.push(b`
					if (${condition}) {
						${mount_dom}
					}
				`);
                } else block.chunks.mount.push(mount_dom);
            }
        }
    }
    function get_dom_updater(element, binding) {
        const { node: node } = element;
        if (binding.is_readonly_media_attribute()) return null;
        if (binding.node.name === "this") return null;
        if (node.name === "select") return node.get_static_attribute_value("multiple") === true ? b`@select_options(${element.var}, ${binding.snippet})` : b`@select_option(${element.var}, ${binding.snippet})`;
        if (binding.node.name === "group") {
            const type = node.get_static_attribute_value("type");
            const condition = type === "checkbox" ? x`~${binding.snippet}.indexOf(${element.var}.__value)` : x`${element.var}.__value === ${binding.snippet}`;
            return b`${element.var}.checked = ${condition};`;
        }
        if (binding.node.name === "value") return b`@set_input_value(${element.var}, ${binding.snippet});`;
        return b`${element.var}.${binding.node.name} = ${binding.snippet};`;
    }
    function get_binding_group(renderer, value, block) {
        const { parts: parts } = flatten_reference(value.raw_expression);
        let keypath = parts.join(".");
        const contexts = [];
        const contextual_dependencies = new Set();
        const { template_scope: template_scope } = value.expression;
        const add_contextual_dependency = (dep)=>{
            contextual_dependencies.add(dep);
            const owner = template_scope.get_owner(dep);
            if (owner.type === "EachBlock") for (const dep of owner.expression.contextual_dependencies)add_contextual_dependency(dep);
        };
        for (const dep of value.expression.contextual_dependencies)add_contextual_dependency(dep);
        for (const dep of contextual_dependencies){
            const context = block.bindings.get(dep);
            let key;
            let name;
            if (context) {
                key = context.object.name;
                name = context.property.name;
            } else {
                key = dep;
                name = dep;
            }
            keypath = `${key}@${keypath}`;
            contexts.push(name);
        }
        if (!renderer.binding_groups.has(keypath)) {
            const index = renderer.binding_groups.size;
            contexts.forEach((context)=>{
                renderer.add_to_context(context, true);
            });
            renderer.binding_groups.set(keypath, {
                binding_group: (to_reference = false)=>{
                    let binding_group = "$$binding_groups";
                    let _secondary_indexes = contexts;
                    if (to_reference) {
                        binding_group = block.renderer.reference(binding_group);
                        _secondary_indexes = _secondary_indexes.map((name)=>block.renderer.reference(name));
                    }
                    if (_secondary_indexes.length > 0) {
                        let obj = x`${binding_group}[${index}]`;
                        _secondary_indexes.forEach((secondary_index)=>{
                            obj = x`${obj}[${secondary_index}]`;
                        });
                        return obj;
                    } else return x`${binding_group}[${index}]`;
                },
                is_context: contexts.length > 0,
                contexts: contexts,
                index: index,
                keypath: keypath
            });
        }
        return renderer.binding_groups.get(keypath);
    }
    function get_event_handler(binding, renderer, block, name, lhs) {
        const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
        const context = block.bindings.get(name);
        let set_store;
        if (context) {
            const { object: object, property: property, store: store, snippet: snippet } = context;
            lhs = replace_object(lhs, snippet);
            contextual_dependencies.add(object.name);
            contextual_dependencies.add(property.name);
            contextual_dependencies.delete(name);
            if (store) set_store = b`${store}.set(${`$${store}`});`;
        } else {
            const object = get_object(lhs);
            if (object.name[0] === "$") {
                const store = object.name.slice(1);
                set_store = b`${store}.set(${object.name});`;
            }
        }
        const value = get_value_from_dom(renderer, binding.parent, binding, block, contextual_dependencies);
        const mutation = b`
		${lhs} = ${value};
		${set_store}
	`;
        return {
            uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
            mutation: mutation,
            contextual_dependencies: contextual_dependencies,
            lhs: lhs
        };
    }
    function get_value_from_dom(renderer, element, binding, block, contextual_dependencies) {
        const { node: node } = element;
        const { name: name } = binding.node;
        if (name === "this") return x`$$value`;
        // <select bind:value='selected>
        if (node.name === "select") return node.get_static_attribute_value("multiple") === true ? x`@select_multiple_value(this)` : x`@select_value(this)`;
        const type = node.get_static_attribute_value("type");
        // <input type='checkbox' bind:group='foo'>
        if (name === "group") {
            if (type === "checkbox") {
                const { binding_group: binding_group, contexts: contexts } = get_binding_group(renderer, binding.node, block);
                add_to_set(contextual_dependencies, contexts);
                return x`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
            }
            return x`this.__value`;
        }
        // <input type='range|number' bind:value>
        if (type === "range" || type === "number") return x`@to_number(this.${name})`;
        if (name === "buffered" || name === "seekable" || name === "played") return x`@time_ranges_to_array(this.${name})`;
        // everything else
        return x`this.${name}`;
    }
    function compare_node(a, b) {
        if (a === b) return true;
        if (!a || !b) return false;
        if (a.type !== b.type) return false;
        switch(a.type){
            case "Identifier":
                return a.name === b.name;
            case "MemberExpression":
                return compare_node(a.object, b.object) && compare_node(a.property, b.property) && a.computed === b.computed;
            case "Literal":
                return a.value === b.value;
        }
    }
    function bind_this(component, block, binding, variable) {
        const fn = component.get_unique_name(`${variable.name}_binding`);
        block.renderer.add_to_context(fn.name);
        const callee = block.renderer.reference(fn.name);
        const { contextual_dependencies: contextual_dependencies, mutation: mutation } = binding.handler;
        const dependencies = binding.get_update_dependencies();
        const body = b`
		${mutation}
		${Array.from(dependencies).filter((dep)=>dep[0] !== "$").filter((dep)=>!contextual_dependencies.has(dep)).map((dep)=>b`${block.renderer.invalidate(dep)};`)}
	`;
        if (contextual_dependencies.size) {
            const params = Array.from(contextual_dependencies).map((name)=>({
                    type: "Identifier",
                    name: name
                }));
            component.partly_hoisted.push(b`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
            const alias_map = new Map();
            const args = [];
            for (let id of params){
                const value = block.renderer.reference(id.name);
                let found = false;
                if (block.variables.has(id.name)) {
                    let alias = id.name;
                    for(let i = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value); alias = `${id.name}_${i++}`);
                    alias_map.set(alias, id.name);
                    id = {
                        type: "Identifier",
                        name: alias
                    };
                    found = block.variables.has(alias);
                }
                args.push(id);
                if (!found) block.add_variable(id, value);
            }
            const assign = block.get_unique_name(`assign_${variable.name}`);
            const unassign = block.get_unique_name(`unassign_${variable.name}`);
            block.chunks.init.push(b`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
            const condition = Array.from(args).map((name)=>x`${name} !== ${block.renderer.reference(alias_map.get(name.name) || name.name)}`).reduce((lhs, rhs)=>x`${lhs} || ${rhs}`);
            // we push unassign and unshift assign so that references are
            // nulled out before they're created, to avoid glitches
            // with shifting indices
            block.chunks.update.push(b`
			if (${condition}) {
				${unassign}();
				${args.map((a)=>b`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
            block.chunks.destroy.push(b`${unassign}();`);
            return b`${assign}();`;
        }
        component.partly_hoisted.push(b`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
        block.chunks.destroy.push(b`${callee}(null);`);
        return b`${callee}(${variable});`;
    }
    class Tag$1 extends Wrapper {
        constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.cannot_use_innerhtml();
            if (!this.is_dependencies_static()) this.not_static_content();
            block.add_dependencies(node.expression.dependencies);
        }
        is_dependencies_static() {
            return this.node.expression.contextual_dependencies.size === 0 && this.node.expression.dynamic_dependencies().length === 0;
        }
        rename_this_method(block, update) {
            const dependencies = this.node.expression.dynamic_dependencies();
            let snippet = this.node.expression.manipulate(block);
            const value = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
            const content = this.node.should_cache ? value : snippet;
            snippet = x`${snippet} + ""`;
            if (this.node.should_cache) block.add_variable(value, snippet); // TODO may need to coerce snippet to string
            if (dependencies.length > 0) {
                let condition = block.renderer.dirty(dependencies);
                if (block.has_outros) condition = x`!#current || ${condition}`;
                const update_cached_value = x`${value} !== (${value} = ${snippet})`;
                if (this.node.should_cache) condition = x`${condition} && ${update_cached_value}`;
                block.chunks.update.push(b`if (${condition}) ${update(content)}`);
            }
            return {
                init: content
            };
        }
    }
    class MustacheTagWrapper extends Tag$1 {
        constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.var = {
                type: "Identifier",
                name: "t"
            };
        }
        render(block, parent_node, parent_nodes) {
            const { init: init } = this.rename_this_method(block, (value)=>x`@set_data(${this.var}, ${value})`);
            block.add_element(this.var, x`@text(${init})`, parent_nodes && x`@claim_text(${parent_nodes}, ${init})`, parent_node);
        }
    }
    class RawMustacheTagWrapper extends Tag$1 {
        constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.var = {
                type: "Identifier",
                name: "raw"
            };
            this.cannot_use_innerhtml();
            this.not_static_content();
        }
        render(block, parent_node, _parent_nodes) {
            const in_head = is_head(parent_node);
            const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
            if (can_use_innerhtml) {
                const insert = (content)=>b`${parent_node}.innerHTML = ${content};`[0];
                const { init: init } = this.rename_this_method(block, (content)=>insert(content));
                block.chunks.mount.push(insert(init));
            } else {
                const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
                const html_tag = block.get_unique_name("html_tag");
                const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
                block.add_variable(html_tag);
                const { init: init } = this.rename_this_method(block, (content)=>x`${html_tag}.p(${content})`);
                const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
                const parent_element = this.node.find_nearest(/^Element/);
                const is_svg = parent_element && parent_element.namespace === namespaces.svg;
                block.chunks.create.push(b`${html_tag} = new @HtmlTag(${is_svg ? "true" : "false"});`);
                if (this.renderer.options.hydratable) block.chunks.claim.push(b`${html_tag} = @claim_html_tag(${_parent_nodes}, ${is_svg ? "true" : "false"});`);
                block.chunks.hydrate.push(b`${html_tag}.a = ${update_anchor};`);
                block.chunks.mount.push(b`${html_tag}.m(${init}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`);
                if (needs_anchor) block.add_element(html_anchor, x`@empty()`, x`@empty()`, parent_node);
                if (!parent_node || in_head) block.chunks.destroy.push(b`if (detaching) ${html_tag}.d();`);
            }
        }
    }
    const regex_contains_radio_or_checkbox_or_file = /radio|checkbox|file/;
    const regex_contains_radio_or_checkbox_or_range_or_file = /radio|checkbox|range|file/;
    const events = [
        {
            event_names: [
                "input"
            ],
            filter: (node, _name)=>node.name === "textarea" || node.name === "input" && !regex_contains_radio_or_checkbox_or_range_or_file.test(node.get_static_attribute_value("type"))
        },
        {
            event_names: [
                "input"
            ],
            filter: (node, name)=>(name === "textContent" || name === "innerHTML") && node.attributes.some((attribute)=>attribute.name === "contenteditable")
        },
        {
            event_names: [
                "change"
            ],
            filter: (node, _name)=>node.name === "select" || node.name === "input" && regex_contains_radio_or_checkbox_or_file.test(node.get_static_attribute_value("type"))
        },
        {
            event_names: [
                "change",
                "input"
            ],
            filter: (node, _name)=>node.name === "input" && node.get_static_attribute_value("type") === "range"
        },
        {
            event_names: [
                "elementresize"
            ],
            filter: (_node, name)=>regex_dimensions.test(name)
        },
        // media events
        {
            event_names: [
                "timeupdate"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "currentTime" || name === "played" || name === "ended")
        },
        {
            event_names: [
                "durationchange"
            ],
            filter: (node, name)=>node.is_media_node() && name === "duration"
        },
        {
            event_names: [
                "play",
                "pause"
            ],
            filter: (node, name)=>node.is_media_node() && name === "paused"
        },
        {
            event_names: [
                "progress"
            ],
            filter: (node, name)=>node.is_media_node() && name === "buffered"
        },
        {
            event_names: [
                "loadedmetadata"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "buffered" || name === "seekable")
        },
        {
            event_names: [
                "volumechange"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "volume" || name === "muted")
        },
        {
            event_names: [
                "ratechange"
            ],
            filter: (node, name)=>node.is_media_node() && name === "playbackRate"
        },
        {
            event_names: [
                "seeking",
                "seeked"
            ],
            filter: (node, name)=>node.is_media_node() && name === "seeking"
        },
        {
            event_names: [
                "ended"
            ],
            filter: (node, name)=>node.is_media_node() && name === "ended"
        },
        {
            event_names: [
                "resize"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "videoHeight" || name === "videoWidth")
        },
        // details event
        {
            event_names: [
                "toggle"
            ],
            filter: (node, _name)=>node.name === "details"
        }
    ];
    const CHILD_DYNAMIC_ELEMENT_BLOCK = "child_dynamic_element";
    const regex_invalid_variable_identifier_characters$2 = /[^a-zA-Z0-9_$]/g;
    const regex_minus_signs = /-/g;
    class ElementWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.child_dynamic_element_block = null;
            this.child_dynamic_element = null;
            if (node.is_dynamic_element && block.type !== CHILD_DYNAMIC_ELEMENT_BLOCK) {
                this.child_dynamic_element_block = block.child({
                    comment: create_debugging_comment(node, renderer.component),
                    name: renderer.component.get_unique_name("create_dynamic_element"),
                    type: CHILD_DYNAMIC_ELEMENT_BLOCK
                });
                renderer.blocks.push(this.child_dynamic_element_block);
                this.child_dynamic_element = new ElementWrapper(renderer, this.child_dynamic_element_block, parent, node, strip_whitespace, next_sibling);
            }
            this.var = {
                type: "Identifier",
                name: node.name.replace(regex_invalid_variable_identifier_characters$2, "_")
            };
            this.void = is_void(node.name);
            this.class_dependencies = [];
            if (this.node.children.length) this.node.lets.forEach((l)=>{
                extract_names(l.value || l.name).forEach((name)=>{
                    renderer.add_to_context(name, true);
                });
            });
            this.attributes = this.node.attributes.map((attribute)=>{
                if (attribute.name === "style") return new StyleAttributeWrapper(this, block, attribute);
                if (attribute.type === "Spread") return new SpreadAttributeWrapper(this, block, attribute);
                return new AttributeWrapper(this, block, attribute);
            });
            // ordinarily, there'll only be one... but we need to handle
            // the rare case where an element can have multiple bindings,
            // e.g. <audio bind:paused bind:currentTime>
            this.bindings = this.node.bindings.map((binding)=>new BindingWrapper(block, binding, this));
            this.event_handlers = this.node.handlers.map((event_handler)=>new EventHandlerWrapper(event_handler, this));
            if (node.intro || node.outro) {
                if (node.intro) block.add_intro(node.intro.is_local);
                if (node.outro) block.add_outro(node.outro.is_local);
            }
            if (node.animation) block.add_animation();
            block.add_dependencies(node.tag_expr.dependencies);
            // add directive and handler dependencies
            [
                node.animation,
                node.outro,
                ...node.actions,
                ...node.classes,
                ...node.styles
            ].forEach((directive)=>{
                if (directive && directive.expression) block.add_dependencies(directive.expression.dependencies);
            });
            node.handlers.forEach((handler)=>{
                if (handler.expression) block.add_dependencies(handler.expression.dependencies);
            });
            if (this.parent) {
                if (node.actions.length > 0 || node.animation || node.bindings.length > 0 || node.classes.length > 0 || node.intro || node.outro || node.handlers.length > 0 || node.styles.length > 0 || this.node.name === "option" || node.tag_expr.dynamic_dependencies().length || renderer.options.dev) {
                    this.parent.cannot_use_innerhtml(); // need to use add_location
                    this.parent.not_static_content();
                }
            }
            this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);
        }
        render(block, parent_node, parent_nodes) {
            if (this.child_dynamic_element) this.render_dynamic_element(block, parent_node, parent_nodes);
            else this.render_element(block, parent_node, parent_nodes);
        }
        render_dynamic_element(block, parent_node, parent_nodes) {
            this.child_dynamic_element.render(this.child_dynamic_element_block, null, x`#nodes`);
            const previous_tag = block.get_unique_name("previous_tag");
            const tag = this.node.tag_expr.manipulate(block);
            block.add_variable(previous_tag, tag);
            block.chunks.init.push(b`
			${this.renderer.options.dev && b`@validate_dynamic_element(${tag});`}
			${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag});`}
			let ${this.var} = ${tag} && ${this.child_dynamic_element_block.name}(#ctx);
		`);
            block.chunks.create.push(b`
			if (${this.var}) ${this.var}.c();
		`);
            if (this.renderer.options.hydratable) block.chunks.claim.push(b`
				if (${this.var}) ${this.var}.l(${parent_nodes});
			`);
            block.chunks.mount.push(b`
			if (${this.var}) ${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
		`);
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const has_transitions = !!(this.node.intro || this.node.outro);
            const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
            block.chunks.update.push(b`
			if (${tag}) {
				if (!${previous_tag}) {
					${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
					${this.var}.c();
					${has_transitions && b`@transition_in(${this.var})`}
					${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
				} else if (${not_equal}(${previous_tag}, ${tag})) {
					${this.var}.d(1);
					${this.renderer.options.dev && b`@validate_dynamic_element(${tag});`}
					${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag});`}
					${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
					${this.var}.c();
					${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			} else if (${previous_tag}) {
				${has_transitions ? b`
							@group_outros();
							@transition_out(${this.var}, 1, 1, () => {
								${this.var} = null;
							});
							@check_outros();
						` : b`
							${this.var}.d(1);
							${this.var} = null;
						`}
			}
			${previous_tag} = ${tag};
		`);
            if (this.child_dynamic_element_block.has_intros) block.chunks.intro.push(b`@transition_in(${this.var});`);
            if (this.child_dynamic_element_block.has_outros) block.chunks.outro.push(b`@transition_out(${this.var});`);
            block.chunks.destroy.push(b`if (${this.var}) ${this.var}.d(detaching)`);
            if (this.node.animation) {
                const measurements = block.get_unique_name("measurements");
                block.add_variable(measurements);
                block.chunks.measure.push(b`${measurements} = ${this.var}.r()`);
                block.chunks.fix.push(b`${this.var}.f();`);
                block.chunks.animate.push(b`
				${this.var}.s(${measurements});
				${this.var}.a()
			`);
            }
        }
        is_dom_node() {
            return super.is_dom_node() && !this.child_dynamic_element;
        }
        render_element(block, parent_node, parent_nodes) {
            const { renderer: renderer } = this;
            if (this.node.name === "noscript") return;
            const node = this.var;
            const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`); // if we're in unclaimable territory, i.e. <head>, parent_nodes is null
            const children = x`@children(${this.node.name === "template" ? x`${node}.content` : node})`;
            block.add_variable(node);
            const render_statement = this.get_render_statement(block);
            block.chunks.create.push(b`${node} = ${render_statement};`);
            if (renderer.options.hydratable) {
                if (parent_nodes) {
                    block.chunks.claim.push(b`
					${node} = ${this.get_claim_statement(block, parent_nodes)};
				`);
                    if (!this.void && this.node.children.length > 0) block.chunks.claim.push(b`
						var ${nodes} = ${children};
					`);
                } else block.chunks.claim.push(b`${node} = ${render_statement};`);
            }
            if (parent_node) {
                const append = b`@append(${parent_node}, ${node});`;
                append[0].expression.callee.loc = {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                };
                block.chunks.mount.push(append);
                if (is_head(parent_node)) block.chunks.destroy.push(b`@detach(${node});`);
            } else {
                const insert = b`@insert(#target, ${node}, #anchor);`;
                insert[0].expression.callee.loc = {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                };
                block.chunks.mount.push(insert);
                // TODO we eventually need to consider what happens to elements
                // that belong to the same outgroup as an outroing element...
                block.chunks.destroy.push(b`if (detaching) @detach(${node});`);
            }
            // insert static children with textContent or innerHTML
            // skip textcontent for <template>.  append nodes to TemplateElement.content instead
            const can_use_textcontent = this.can_use_textcontent();
            const is_template = this.node.name === "template";
            const is_template_with_text_content = is_template && can_use_textcontent;
            if (!is_template_with_text_content && !this.node.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.fragment.nodes.length > 0) {
                if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text") block.chunks.create.push(b`${node}.textContent = ${string_literal(this.fragment.nodes[0].data)};`);
                else {
                    const state = {
                        quasi: {
                            type: "TemplateElement",
                            value: {
                                raw: ""
                            }
                        }
                    };
                    const literal = {
                        type: "TemplateLiteral",
                        expressions: [],
                        quasis: []
                    };
                    const can_use_raw_text = !this.can_use_innerhtml && can_use_textcontent;
                    to_html(this.fragment.nodes, block, literal, state, can_use_raw_text);
                    literal.quasis.push(state.quasi);
                    block.chunks.create.push(b`${node}.${this.can_use_innerhtml ? "innerHTML" : "textContent"} = ${literal};`);
                }
            } else this.fragment.nodes.forEach((child)=>{
                child.render(block, is_template ? x`${node}.content` : node, nodes);
            });
            const event_handler_or_binding_uses_context = this.bindings.some((binding)=>binding.handler.uses_context) || this.node.handlers.some((handler)=>handler.uses_context) || this.node.actions.some((action)=>action.uses_context);
            if (event_handler_or_binding_uses_context) block.maintain_context = true;
            this.add_attributes(block);
            this.add_directives_in_order(block);
            this.add_transitions(block);
            this.add_animation(block);
            this.add_classes(block);
            this.add_styles(block);
            this.add_manual_style_scoping(block);
            if (nodes && this.renderer.options.hydratable && !this.void) block.chunks.claim.push(b`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`);
            if (renderer.options.dev) {
                const loc = renderer.locate(this.node.start);
                block.chunks.hydrate.push(b`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${this.node.start});`);
            }
            block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
        }
        can_use_textcontent() {
            return this.is_static_content && this.fragment.nodes.every((node)=>node.node.type === "Text" || node.node.type === "MustacheTag");
        }
        get_render_statement(block) {
            const { name: name, namespace: namespace, tag_expr: tag_expr } = this.node;
            const reference = tag_expr.manipulate(block);
            if (namespace === namespaces.svg) return x`@svg_element(${reference})`;
            if (namespace) return x`@_document.createElementNS("${namespace}", "${name}")`;
            const is = this.attributes.find((attr)=>attr.node.name === "is");
            if (is) return x`@element_is("${name}", ${is.render_chunks(block).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`)})`;
            return x`@element(${reference})`;
        }
        get_claim_statement(block, nodes) {
            const attributes = this.attributes.filter((attr)=>!(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map((attr)=>p`${attr.name}: true`);
            let reference;
            if (this.node.tag_expr.node.type === "Literal") {
                if (this.node.namespace) reference = `"${this.node.tag_expr.node.value}"`;
                else reference = `"${(this.node.tag_expr.node.value || "").toUpperCase()}"`;
            } else if (this.node.namespace) reference = x`${this.node.tag_expr.manipulate(block)}`;
            else reference = x`(${this.node.tag_expr.manipulate(block)} || 'null').toUpperCase()`;
            if (this.node.namespace === namespaces.svg) return x`@claim_svg_element(${nodes}, ${reference}, { ${attributes} })`;
            else return x`@claim_element(${nodes}, ${reference}, { ${attributes} })`;
        }
        add_directives_in_order(block) {
            const binding_groups = events.map((event)=>({
                    events: event.event_names,
                    bindings: this.bindings.filter((binding)=>binding.node.name !== "this").filter((binding)=>event.filter(this.node, binding.node.name))
                })).filter((group)=>group.bindings.length);
            const this_binding = this.bindings.find((b)=>b.node.name === "this");
            function getOrder(item) {
                if (item instanceof EventHandlerWrapper) return item.node.start;
                else if (item instanceof BindingWrapper) return item.node.start;
                else if (item instanceof Action) return item.start;
                else return item.bindings[0].node.start;
            }
            [
                ...binding_groups,
                ...this.event_handlers,
                this_binding,
                ...this.node.actions
            ].filter(Boolean).sort((a, b)=>getOrder(a) - getOrder(b)).forEach((item)=>{
                if (item instanceof EventHandlerWrapper) add_event_handler(block, this.var, item);
                else if (item instanceof BindingWrapper) this.add_this_binding(block, item);
                else if (item instanceof Action) add_action(block, this.var, item);
                else this.add_bindings(block, item);
            });
        }
        add_bindings(block, binding_group) {
            const { renderer: renderer } = this;
            if (binding_group.bindings.length === 0) return;
            renderer.component.has_reactive_assignments = true;
            const lock = binding_group.bindings.some((binding)=>binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
            if (lock) block.add_variable(lock, x`false`);
            const handler = renderer.component.get_unique_name(`${this.var.name}_${binding_group.events.join("_")}_handler`);
            renderer.add_to_context(handler.name);
            // TODO figure out how to handle locks
            const needs_lock = binding_group.bindings.some((binding)=>binding.needs_lock);
            const dependencies = new Set();
            const contextual_dependencies = new Set();
            binding_group.bindings.forEach((binding)=>{
                // TODO this is a mess
                add_to_set(dependencies, binding.get_update_dependencies());
                add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
                binding.render(block, lock);
            });
            // media bindings — awkward special case. The native timeupdate events
            // fire too infrequently, so we need to take matters into our
            // own hands
            let animation_frame;
            if (binding_group.events[0] === "timeupdate") {
                animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
                block.add_variable(animation_frame);
            }
            const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
            let callee = renderer.reference(handler);
            // TODO dry this out — similar code for event handlers and component bindings
            if (has_local_function) {
                const args = Array.from(contextual_dependencies).map((name)=>renderer.reference(name));
                // need to create a block-local function that calls an instance-level function
                if (animation_frame) block.chunks.init.push(b`
					function ${handler}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler});
							${needs_lock && b`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
                else block.chunks.init.push(b`
					function ${handler}() {
						${needs_lock && b`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
                callee = handler;
            }
            const params = Array.from(contextual_dependencies).map((name)=>({
                    type: "Identifier",
                    name: name
                }));
            this.renderer.component.partly_hoisted.push(b`
			function ${handler}(${params}) {
				${binding_group.bindings.map((b)=>b.handler.mutation)}
				${Array.from(dependencies).filter((dep)=>dep[0] !== "$").filter((dep)=>!contextual_dependencies.has(dep)).map((dep)=>b`${this.renderer.invalidate(dep)};`)}
			}
		`);
            binding_group.events.forEach((name)=>{
                if (name === "elementresize") {
                    // special case
                    const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
                    block.add_variable(resize_listener);
                    block.chunks.mount.push(b`${resize_listener} = @add_resize_listener(${this.var}, ${callee}.bind(${this.var}));`);
                    block.chunks.destroy.push(b`${resize_listener}();`);
                } else block.event_listeners.push(x`@listen(${this.var}, "${name}", ${callee})`);
            });
            const some_initial_state_is_undefined = binding_group.bindings.map((binding)=>x`${binding.snippet} === void 0`).reduce((lhs, rhs)=>x`${lhs} || ${rhs}`);
            const should_initialise = this.node.name === "select" || binding_group.bindings.find((binding)=>{
                return binding.node.name === "indeterminate" || binding.node.name === "textContent" || binding.node.name === "innerHTML" || binding.is_readonly_media_attribute();
            });
            if (should_initialise) {
                const callback = has_local_function ? handler : x`() => ${callee}.call(${this.var})`;
                block.chunks.hydrate.push(b`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`);
            }
            if (binding_group.events[0] === "elementresize") block.chunks.hydrate.push(b`@add_render_callback(() => ${callee}.call(${this.var}));`);
            if (lock) block.chunks.update.push(b`${lock} = false;`);
        }
        add_this_binding(block, this_binding) {
            const { renderer: renderer } = this;
            renderer.component.has_reactive_assignments = true;
            const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
            block.chunks.mount.push(binding_callback);
        }
        add_attributes(block) {
            // Get all the class dependencies first
            this.attributes.forEach((attribute)=>{
                if (attribute.node.name === "class") {
                    const dependencies = attribute.node.get_dependencies();
                    push_array$1(this.class_dependencies, dependencies);
                }
            });
            if (this.node.attributes.some((attr)=>attr.is_spread) || this.node.is_dynamic_element) {
                this.add_spread_attributes(block);
                return;
            }
            this.attributes.forEach((attribute)=>{
                attribute.render(block);
            });
        }
        add_spread_attributes(block) {
            const levels = block.get_unique_name(`${this.var.name}_levels`);
            const data = block.get_unique_name(`${this.var.name}_data`);
            const initial_props = [];
            const updates = [];
            this.attributes.forEach((attr)=>{
                const dependencies = attr.node.get_dependencies();
                const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
                if (attr instanceof SpreadAttributeWrapper) {
                    const snippet = attr.node.expression.manipulate(block);
                    initial_props.push(snippet);
                    updates.push(condition ? x`${condition} && ${snippet}` : snippet);
                } else {
                    const name = attr.property_name || attr.name;
                    initial_props.push(x`{ ${name}: ${attr.get_init(block, attr.get_value(block))} }`);
                    const snippet = x`{ ${name}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
                    updates.push(condition ? x`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet);
                }
            });
            block.chunks.init.push(b`
			let ${levels} = [${initial_props}];

			let ${data} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${data} = @assign(${data}, ${levels}[#i]);
			}
		`);
            const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : x`@set_attributes`;
            if (this.node.is_dynamic_element) {
                // call attribute bindings for custom element if tag is custom element
                const tag = this.node.tag_expr.manipulate(block);
                const attr_update = this.node.namespace === namespaces.svg ? b`${fn}(${this.var}, ${data});` : b`
					if (/-/.test(${tag})) {
						@set_custom_element_data_map(${this.var}, ${data});
					} else {
						${fn}(${this.var}, ${data});
					}`;
                block.chunks.hydrate.push(attr_update);
                block.chunks.update.push(b`
				${data} = @get_spread_update(${levels}, [${updates}]);
				${attr_update}`);
            } else {
                block.chunks.hydrate.push(b`${fn}(${this.var}, ${data});`);
                block.chunks.update.push(b`
				${fn}(${this.var}, ${data} = @get_spread_update(${levels}, [
					${updates}
				]));
			`);
            }
            // handle edge cases for elements
            if (this.node.name === "select") {
                const dependencies = new Set();
                for (const attr of this.attributes)for (const dep of attr.node.dependencies)dependencies.add(dep);
                block.chunks.mount.push(b`
				(${data}.multiple ? @select_options : @select_option)(${this.var}, ${data}.value);
			`);
                block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(dependencies))} && 'value' in ${data}) (${data}.multiple ? @select_options : @select_option)(${this.var}, ${data}.value);
			`);
            } else if (this.node.name === "input" && this.attributes.find((attr)=>attr.node.name === "value")) {
                const type = this.node.get_static_attribute_value("type");
                if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
                    block.chunks.mount.push(b`
					${this.var}.value = ${data}.value;
				`);
                    block.chunks.update.push(b`
					if ('value' in ${data}) {
						${this.var}.value = ${data}.value;
					}
				`);
                }
            }
            if ([
                "button",
                "input",
                "keygen",
                "select",
                "textarea"
            ].includes(this.node.name)) block.chunks.mount.push(b`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
        }
        add_transitions(block) {
            const { intro: intro, outro: outro } = this.node;
            if (!intro && !outro) return;
            if (intro === outro) {
                // bidirectional transition
                const name = block.get_unique_name(`${this.var.name}_transition`);
                const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
                block.add_variable(name);
                const fn = this.renderer.reference(intro.name);
                const intro_block = b`
				@add_render_callback(() => {
					if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name}.run(1);
				});
			`;
                const outro_block = b`
				if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name}.run(0);
			`;
                if (intro.is_local) {
                    block.chunks.intro.push(b`
					if (#local) {
						${intro_block}
					}
				`);
                    block.chunks.outro.push(b`
					if (#local) {
						${outro_block}
					}
				`);
                } else {
                    block.chunks.intro.push(intro_block);
                    block.chunks.outro.push(outro_block);
                }
                block.chunks.destroy.push(b`if (detaching && ${name}) ${name}.end();`);
            } else {
                const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
                const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
                if (intro) {
                    block.add_variable(intro_name);
                    const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
                    const fn = this.renderer.reference(intro.name);
                    let intro_block;
                    if (outro) {
                        intro_block = b`
						@add_render_callback(() => {
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
                        block.chunks.outro.push(b`if (${intro_name}) ${intro_name}.invalidate();`);
                    } else intro_block = b`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
                    if (intro.is_local) intro_block = b`
						if (#local) {
							${intro_block}
						}
					`;
                    block.chunks.intro.push(intro_block);
                }
                if (outro) {
                    block.add_variable(outro_name);
                    const snippet = outro.expression ? outro.expression.manipulate(block) : x`{}`;
                    const fn = this.renderer.reference(outro.name);
                    if (!intro) block.chunks.intro.push(b`
						if (${outro_name}) ${outro_name}.end(1);
					`);
                    // TODO hide elements that have outro'd (unless they belong to a still-outroing
                    // group) prior to their removal from the DOM
                    let outro_block = b`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
                    if (outro.is_local) outro_block = b`
						if (#local) {
							${outro_block}
						}
					`;
                    block.chunks.outro.push(outro_block);
                    block.chunks.destroy.push(b`if (detaching && ${outro_name}) ${outro_name}.end();`);
                }
            }
            if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size) block.maintain_context = true;
        }
        add_animation(block) {
            if (!this.node.animation) return;
            const { outro: outro } = this.node;
            const rect = block.get_unique_name("rect");
            const stop_animation = block.get_unique_name("stop_animation");
            block.add_variable(rect);
            block.add_variable(stop_animation, x`@noop`);
            block.chunks.measure.push(b`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
            if (block.type === CHILD_DYNAMIC_ELEMENT_BLOCK) {
                block.chunks.measure.push(b`return ${rect}`);
                block.chunks.restore_measurements.push(b`${rect} = #measurement;`);
            }
            block.chunks.fix.push(b`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b`@add_transform(${this.var}, ${rect});`}
		`);
            let params;
            if (this.node.animation.expression) {
                params = this.node.animation.expression.manipulate(block);
                if (this.node.animation.expression.dynamic_dependencies().length) {
                    // if `params` is dynamic, calculate params ahead of time in the `.r()` method
                    const params_var = block.get_unique_name("params");
                    block.add_variable(params_var);
                    block.chunks.measure.push(b`${params_var} = ${params};`);
                    params = params_var;
                }
            } else params = x`{}`;
            const name = this.renderer.reference(this.node.animation.name);
            block.chunks.animate.push(b`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name}, ${params});
		`);
        }
        add_classes(block) {
            const has_spread = this.node.attributes.some((attr)=>attr.is_spread);
            this.node.classes.forEach((class_directive)=>{
                const { expression: expression, name: name } = class_directive;
                let snippet;
                let dependencies;
                if (expression) {
                    snippet = expression.manipulate(block);
                    dependencies = expression.dependencies;
                } else {
                    snippet = name;
                    dependencies = new Set([
                        name
                    ]);
                }
                const updater = b`@toggle_class(${this.var}, "${name}", ${snippet});`;
                block.chunks.hydrate.push(updater);
                if (has_spread || this.node.is_dynamic_element) block.chunks.update.push(updater);
                else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
                    const all_dependencies = this.class_dependencies.concat(...dependencies);
                    let condition = block.renderer.dirty(all_dependencies);
                    if (block.has_outros) condition = x`!#current || ${condition}`;
                    // If all of the dependencies are non-dynamic (don't get updated) then there is no reason
                    // to add an updater for this.
                    const any_dynamic_dependencies = all_dependencies.some((dep)=>{
                        const variable = this.renderer.component.var_lookup.get(dep);
                        return !variable || is_dynamic(variable);
                    });
                    if (any_dynamic_dependencies) block.chunks.update.push(b`
						if (${condition}) {
							${updater}
						}
					`);
                }
            });
        }
        add_styles(block) {
            const has_spread = this.node.attributes.some((attr)=>attr.is_spread);
            this.node.styles.forEach((style_directive)=>{
                const { name: name, expression: expression, should_cache: should_cache, important: important } = style_directive;
                const snippet = expression.manipulate(block);
                let cached_snippet;
                if (should_cache) {
                    cached_snippet = block.get_unique_name(`style_${name.replace(regex_minus_signs, "_")}`);
                    block.add_variable(cached_snippet, snippet);
                }
                const updater = b`@set_style(${this.var}, "${name}", ${should_cache ? cached_snippet : snippet}, ${important ? 1 : null})`;
                block.chunks.hydrate.push(updater);
                const dependencies = expression.dynamic_dependencies();
                if (has_spread) block.chunks.update.push(updater);
                else if (dependencies.length > 0) {
                    if (should_cache) block.chunks.update.push(b`
							if (${block.renderer.dirty(dependencies)} && (${cached_snippet} !== (${cached_snippet} = ${snippet}))) {
								${updater}
							}
					`);
                    else block.chunks.update.push(b`
						if (${block.renderer.dirty(dependencies)}) {
							${updater}
						}
					`);
                }
            });
        }
        add_manual_style_scoping(block) {
            if (this.node.needs_manual_style_scoping) {
                const updater = b`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
                block.chunks.hydrate.push(updater);
                block.chunks.update.push(updater);
            }
        }
    }
    const regex_backticks = /`/g;
    const regex_dollar_signs = /\$/g;
    function to_html(wrappers, block, literal, state, can_use_raw_text) {
        wrappers.forEach((wrapper)=>{
            if (wrapper instanceof TextWrapper) {
                // Don't add the <pre>/<textarea> newline logic here because pre/textarea.innerHTML
                // would keep the leading newline, too, only someParent.innerHTML = '..<pre/textarea>..' won't
                if (wrapper.use_space()) state.quasi.value.raw += " ";
                const parent = wrapper.node.parent;
                const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
                state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(regex_backslashes, "\\\\").replace(regex_backticks, "\\`").replace(regex_dollar_signs, "\\$");
            } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
                literal.quasis.push(state.quasi);
                literal.expressions.push(wrapper.node.expression.manipulate(block));
                state.quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: ""
                    }
                };
            } else if (wrapper.node.name === "noscript") ;
            else {
                // element
                state.quasi.value.raw += `<${wrapper.node.name}`;
                const is_empty_textarea = wrapper.node.name === "textarea" && wrapper.fragment.nodes.length === 0;
                wrapper.attributes.forEach((attr)=>{
                    if (is_empty_textarea && attr.node.name === "value") // The value attribute of <textarea> renders as content.
                    return;
                    state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
                    to_html_for_attr_value(attr, block, literal, state);
                    state.quasi.value.raw += '"';
                });
                if (!wrapper.void) {
                    state.quasi.value.raw += ">";
                    if (wrapper.node.name === "pre") {
                        // Two or more leading newlines are required to restore the leading newline immediately after `<pre>`.
                        // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                        const first = wrapper.fragment.nodes[0];
                        if (first && first.node.type === "Text" && regex_starts_with_newline.test(first.node.data)) state.quasi.value.raw += "\n";
                    }
                    if (is_empty_textarea) {
                        // The <textarea> renders the value attribute as content because the content is stored in the value attribute.
                        const value_attribute = wrapper.attributes.find((attr)=>attr.node.name === "value");
                        if (value_attribute) {
                            // Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`.
                            // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                            const first = value_attribute.node.chunks[0];
                            if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) state.quasi.value.raw += "\n";
                            to_html_for_attr_value(value_attribute, block, literal, state);
                        }
                    }
                    to_html(wrapper.fragment.nodes, block, literal, state);
                    state.quasi.value.raw += `</${wrapper.node.name}>`;
                } else state.quasi.value.raw += "/>";
            }
        });
    }
    function to_html_for_attr_value(attr, block, literal, state) {
        attr.node.chunks.forEach((chunk)=>{
            if (chunk.type === "Text") state.quasi.value.raw += escape_html(chunk.data);
            else {
                literal.quasis.push(state.quasi);
                literal.expressions.push(chunk.manipulate(block));
                state.quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: ""
                    }
                };
            }
        });
    }
    class HeadWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.can_use_innerhtml = false;
            this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);
        }
        render(block, _parent_node, _parent_nodes) {
            let nodes;
            if (this.renderer.options.hydratable && this.fragment.nodes.length) {
                nodes = block.get_unique_name("head_nodes");
                block.chunks.claim.push(b`const ${nodes} = @head_selector('${this.node.id}', @_document.head);`);
            }
            this.fragment.render(block, x`@_document.head`, nodes);
            if (nodes && this.renderer.options.hydratable) block.chunks.claim.push(b`${nodes}.forEach(@detach);`);
        }
    }
    function is_else_if(node) {
        return node && node.children.length === 1 && node.children[0].type === "IfBlock";
    }
    class IfBlockBranch extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = null;
            const { expression: expression } = node;
            const is_else = !expression;
            if (expression) {
                this.dependencies = expression.dynamic_dependencies();
                // TODO is this the right rule? or should any non-reference count?
                // const should_cache = !is_reference(expression.node, null) && dependencies.length > 0;
                let should_cache = false;
                walk(expression.node, {
                    enter (node) {
                        if (node.type === "CallExpression" || node.type === "NewExpression") should_cache = true;
                    }
                });
                if (should_cache) {
                    this.condition = block.get_unique_name("show_if");
                    this.snippet = expression.manipulate(block);
                } else this.condition = expression.manipulate(block);
            }
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(node, parent.renderer.component),
                name: parent.renderer.component.get_unique_name(is_else ? "create_else_block" : "create_if_block"),
                type: node.expression ? "if" : "else"
            });
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
            if (node.const_tags.length > 0) this.get_ctx_name = parent.renderer.component.get_unique_name(is_else ? "get_else_ctx" : "get_if_ctx");
        }
    }
    class IfBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.needs_update = false;
            this.var = {
                type: "Identifier",
                name: "if_block"
            };
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.branches = [];
            const blocks = [];
            let is_dynamic = false;
            let has_intros = false;
            let has_outros = false;
            const create_branches = (node)=>{
                const branch = new IfBlockBranch(renderer, block, this, node, strip_whitespace, next_sibling);
                this.branches.push(branch);
                blocks.push(branch.block);
                block.add_dependencies(node.expression.dependencies);
                if (branch.block.dependencies.size > 0) {
                    // the condition, or its contents, is dynamic
                    is_dynamic = true;
                    block.add_dependencies(branch.block.dependencies);
                }
                if (branch.dependencies && branch.dependencies.length > 0) // the condition itself is dynamic
                this.needs_update = true;
                if (branch.block.has_intros) has_intros = true;
                if (branch.block.has_outros) has_outros = true;
                if (is_else_if(node.else)) create_branches(node.else.children[0]);
                else if (node.else) {
                    const branch = new IfBlockBranch(renderer, block, this, node.else, strip_whitespace, next_sibling);
                    this.branches.push(branch);
                    blocks.push(branch.block);
                    if (branch.block.dependencies.size > 0) {
                        is_dynamic = true;
                        block.add_dependencies(branch.block.dependencies);
                    }
                    if (branch.block.has_intros) has_intros = true;
                    if (branch.block.has_outros) has_outros = true;
                }
            };
            create_branches(this.node);
            blocks.forEach((block)=>{
                block.has_update_method = is_dynamic;
                block.has_intro_method = has_intros;
                block.has_outro_method = has_outros;
            });
            push_array$1(renderer.blocks, blocks);
        }
        render(block, parent_node, parent_nodes) {
            const name = this.var;
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
            const has_else = !this.branches[this.branches.length - 1].condition;
            const if_exists_condition = has_else ? null : name;
            const dynamic = this.branches[0].block.has_update_method; // can use [0] as proxy for all, since they necessarily have the same value
            const has_intros = this.branches[0].block.has_intro_method;
            const has_outros = this.branches[0].block.has_outro_method;
            const has_transitions = has_intros || has_outros;
            this.branches.forEach((branch)=>{
                if (branch.get_ctx_name) this.renderer.blocks.push(b`
				function ${branch.get_ctx_name}(#ctx) {
					const child_ctx = #ctx.slice();
					${add_const_tags(block, branch.node.const_tags, "child_ctx")}
					return child_ctx;
				}
				`);
            });
            const vars = {
                name: name,
                anchor: anchor,
                if_exists_condition: if_exists_condition,
                has_else: has_else,
                has_transitions: has_transitions
            };
            const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
            if (this.node.else) {
                this.branches.forEach((branch)=>{
                    if (branch.snippet) block.add_variable(branch.condition);
                });
                if (has_outros) {
                    this.render_compound_with_outros(block, parent_node, parent_nodes, dynamic, vars, detaching);
                    block.chunks.outro.push(b`@transition_out(${name});`);
                } else this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
            } else {
                this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
                if (has_outros) block.chunks.outro.push(b`@transition_out(${name});`);
            }
            if (if_exists_condition) block.chunks.create.push(b`if (${if_exists_condition}) ${name}.c();`);
            else block.chunks.create.push(b`${name}.c();`);
            if (parent_nodes && this.renderer.options.hydratable) {
                if (if_exists_condition) block.chunks.claim.push(b`if (${if_exists_condition}) ${name}.l(${parent_nodes});`);
                else block.chunks.claim.push(b`${name}.l(${parent_nodes});`);
            }
            if (has_intros || has_outros) block.chunks.intro.push(b`@transition_in(${name});`);
            if (needs_anchor) block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
            this.branches.forEach((branch)=>{
                branch.fragment.render(branch.block, null, x`#nodes`);
            });
        }
        render_compound(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, has_else: has_else, if_exists_condition: if_exists_condition, has_transitions: has_transitions }, detaching) {
            const select_block_type = this.renderer.component.get_unique_name("select_block_type");
            const current_block_type = block.get_unique_name("current_block_type");
            const need_select_block_ctx = this.branches.some((branch)=>branch.get_ctx_name);
            const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
            const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type})` : x`#ctx`;
            const get_block = has_else ? x`${current_block_type}(${if_ctx})` : x`${current_block_type} && ${current_block_type}(${if_ctx})`;
            if (this.needs_update) block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies: dependencies, condition: condition, snippet: snippet })=>{
                return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
            })}
					${this.branches.map(({ condition: condition, snippet: snippet, block: block })=>condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${block.name};` : b`return ${block.name};`)}
				}
			`);
            else block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ condition: condition, snippet: snippet, block: block })=>condition ? b`if (${snippet || condition}) return ${block.name};` : b`return ${block.name};`)}
				}
			`);
            if (need_select_block_ctx) {
                // if all branches needs create a context
                if (this.branches.every((branch)=>branch.get_ctx_name)) block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ condition: condition, get_ctx_name: get_ctx_name, block: block })=>{
                    return condition ? b`if (#type === ${block.name}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
                }).filter(Boolean)}
					}
				`);
                else // when not all branches need to create a new context,
                // this code is simpler
                block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ get_ctx_name: get_ctx_name, block: block })=>{
                    return get_ctx_name ? b`if (#type === ${block.name}) return ${get_ctx_name}(#ctx);` : null;
                }).filter(Boolean)}
						return #ctx;
					}
				`);
            }
            block.chunks.init.push(b`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name} = ${get_block};
		`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            if (if_exists_condition) block.chunks.mount.push(b`if (${if_exists_condition}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
            else block.chunks.mount.push(b`${name}.m(${initial_mount_node}, ${anchor_node});`);
            if (this.needs_update) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const change_block = b`
				${if_exists_condition ? b`if (${if_exists_condition}) ${name}.d(1)` : b`${name}.d(1)`};
				${name} = ${get_block};
				if (${name}) {
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
                if (dynamic) block.chunks.update.push(b`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name}) {
						${name}.p(${if_ctx}, #dirty);
					} else {
						${change_block}
					}
				`);
                else block.chunks.update.push(b`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
            } else if (dynamic) {
                if (if_exists_condition) block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
                else block.chunks.update.push(b`${name}.p(${if_ctx}, #dirty);`);
            }
            if (if_exists_condition) block.chunks.destroy.push(b`
				if (${if_exists_condition}) {
					${name}.d(${detaching});
				}
			`);
            else block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
        }
        // if any of the siblings have outros, we need to keep references to the blocks
        // (TODO does this only apply to bidi transitions?)
        render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, has_else: has_else, has_transitions: has_transitions, if_exists_condition: if_exists_condition }, detaching) {
            const select_block_type = this.renderer.component.get_unique_name("select_block_type");
            const current_block_type_index = block.get_unique_name("current_block_type_index");
            const previous_block_index = block.get_unique_name("previous_block_index");
            const if_block_creators = block.get_unique_name("if_block_creators");
            const if_blocks = block.get_unique_name("if_blocks");
            const need_select_block_ctx = this.branches.some((branch)=>branch.get_ctx_name);
            const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
            const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type_index})` : x`#ctx`;
            const if_current_block_type_index = has_else ? (nodes)=>nodes : (nodes)=>b`if (~${current_block_type_index}) { ${nodes} }`;
            block.add_variable(current_block_type_index);
            block.add_variable(name);
            block.chunks.init.push(b`
			const ${if_block_creators} = [
				${this.branches.map((branch)=>branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies: dependencies, condition: condition, snippet: snippet })=>{
                return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
            })}
						${this.branches.map(({ condition: condition, snippet: snippet }, i)=>condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${i};` : b`return ${i};`)}
								${!has_else && b`return -1;`}
							}
						` : b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ condition: condition, snippet: snippet }, i)=>condition ? b`if (${snippet || condition}) return ${i};` : b`return ${i};`)}
						${!has_else && b`return -1;`}
					}
				`}
		`);
            if (need_select_block_ctx) {
                // if all branches needs create a context
                if (this.branches.every((branch)=>branch.get_ctx_name)) block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ condition: condition, get_ctx_name: get_ctx_name }, i)=>{
                    return condition ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
                }).filter(Boolean)}
					}
				`);
                else // when not all branches need to create a new context,
                // this code is simpler
                block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ get_ctx_name: get_ctx_name }, i)=>{
                    return get_ctx_name ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : null;
                }).filter(Boolean)}
						return #ctx;
					}
				`);
            }
            if (has_else) block.chunks.init.push(b`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
			`);
            else block.chunks.init.push(b`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
				}
			`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            block.chunks.mount.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`));
            if (this.needs_update) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const destroy_old_block = b`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
                const create_new_block = b`
				${name} = ${if_blocks}[${current_block_type_index}];
				if (!${name}) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
					${name}.c();
				} else {
					${dynamic && b`${name}.p(${if_ctx}, #dirty);`}
				}
				${has_transitions && b`@transition_in(${name}, 1);`}
				${name}.m(${update_mount_node}, ${anchor});
			`;
                const change_block = has_else ? b`
					${destroy_old_block}

					${create_new_block}
				` : b`
					if (${name}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name} = null;
					}
				`;
                block.chunks.update.push(b`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
                if (dynamic) block.chunks.update.push(b`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].p(${if_ctx}, #dirty);`)}
					} else {
						${change_block}
					}
				`);
                else block.chunks.update.push(b`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
            } else if (dynamic) {
                if (if_exists_condition) block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
                else block.chunks.update.push(b`${name}.p(${if_ctx}, #dirty);`);
            }
            block.chunks.destroy.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].d(${detaching});`));
        }
        render_simple(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, if_exists_condition: if_exists_condition, has_transitions: has_transitions }, detaching) {
            const branch = this.branches[0];
            const if_ctx = branch.get_ctx_name ? x`${branch.get_ctx_name}(#ctx)` : x`#ctx`;
            if (branch.snippet) block.add_variable(branch.condition, branch.snippet);
            block.chunks.init.push(b`
			let ${name} = ${branch.condition} && ${branch.block.name}(${if_ctx});
		`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            block.chunks.mount.push(b`if (${name}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
            if (branch.dependencies.length > 0) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const enter = b`
				if (${name}) {
					${dynamic && b`${name}.p(${if_ctx}, #dirty);`}
					${has_transitions && b`if (${block.renderer.dirty(branch.dependencies)}) {
									@transition_in(${name}, 1);
								}`}
				} else {
					${name} = ${branch.block.name}(${if_ctx});
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
                if (branch.snippet) block.chunks.update.push(b`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`);
                // no `p()` here — we don't want to update outroing nodes,
                // as that will typically result in glitching
                if (branch.block.has_outro_method) block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						@group_outros();
						@transition_out(${name}, 1, 1, () => {
							${name} = null;
						});
						@check_outros();
					}
				`);
                else block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						${name}.d(1);
						${name} = null;
					}
				`);
            } else if (dynamic) block.chunks.update.push(b`
				if (${branch.condition}) ${name}.p(${if_ctx}, #dirty);
			`);
            if (if_exists_condition) block.chunks.destroy.push(b`
				if (${if_exists_condition}) ${name}.d(${detaching});
			`);
            else block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
        }
    }
    class KeyBlockWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = {
                type: "Identifier",
                name: "key_block"
            };
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.dependencies = node.expression.dynamic_dependencies();
            if (this.dependencies.length) {
                block = block.child({
                    comment: create_debugging_comment(node, renderer.component),
                    name: renderer.component.get_unique_name("create_key_block"),
                    type: "key"
                });
                block.add_dependencies(node.expression.dependencies);
                renderer.blocks.push(block);
            }
            this.block = block;
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, this, strip_whitespace, next_sibling);
        }
        render(block, parent_node, parent_nodes) {
            if (this.dependencies.length === 0) this.render_static_key(block, parent_node, parent_nodes);
            else this.render_dynamic_key(block, parent_node, parent_nodes);
        }
        render_static_key(_block, parent_node, parent_nodes) {
            this.fragment.render(this.block, parent_node, parent_nodes);
        }
        render_dynamic_key(block, parent_node, parent_nodes) {
            this.fragment.render(this.block, null, x`#nodes`);
            const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
            const dynamic = this.block.has_update_method;
            const previous_key = block.get_unique_name("previous_key");
            const snippet = this.node.expression.manipulate(block);
            block.add_variable(previous_key, snippet);
            const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
            const condition = x`${this.renderer.dirty(this.dependencies)} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
            block.chunks.init.push(b`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
            block.chunks.create.push(b`${this.var}.c();`);
            if (this.renderer.options.hydratable) block.chunks.claim.push(b`${this.var}.l(${parent_nodes});`);
            block.chunks.mount.push(b`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`);
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const body = b`
			${has_transitions ? b`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b`@transition_in(${this.var}, 1)`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
            if (dynamic) block.chunks.update.push(b`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
            else block.chunks.update.push(b`
				if (${condition}) {
					${body}
				}
			`);
            if (has_transitions) {
                block.chunks.intro.push(b`@transition_in(${this.var})`);
                block.chunks.outro.push(b`@transition_out(${this.var})`);
            }
            block.chunks.destroy.push(b`${this.var}.d(detaching)`);
        }
    }
    function get_slot_definition(block, scope, lets) {
        if (lets.length === 0) return {
            block: block,
            scope: scope
        };
        const context_input = {
            type: "ObjectPattern",
            properties: lets.map((l)=>({
                    type: "Property",
                    kind: "init",
                    key: l.name,
                    value: l.value || l.name
                }))
        };
        const properties = [];
        const value_map = new Map();
        lets.forEach((l)=>{
            let value;
            if (l.names.length > 1) {
                // more than one, probably destructuring
                const unique_name = block.get_unique_name(l.names.join("_")).name;
                value_map.set(l.value, unique_name);
                value = {
                    type: "Identifier",
                    name: unique_name
                };
            } else value = l.value || l.name;
            properties.push({
                type: "Property",
                kind: "init",
                key: l.name,
                value: value
            });
        });
        const changes_input = {
            type: "ObjectPattern",
            properties: properties
        };
        const names = new Set();
        const names_lookup = new Map();
        lets.forEach((l)=>{
            l.names.forEach((name)=>{
                names.add(name);
                if (value_map.has(l.value)) names_lookup.set(name, value_map.get(l.value));
            });
        });
        const context = {
            type: "ObjectExpression",
            properties: Array.from(names).map((name)=>p`${block.renderer.context_lookup.get(name).index}: ${name}`)
        };
        const { context_lookup: context_lookup } = block.renderer;
        // i am well aware that this code is gross
        // TODO: context-overflow make it less gross
        const changes = {
            type: "ParenthesizedExpression",
            get expression () {
                if (block.renderer.context_overflow) {
                    const grouped = [];
                    Array.from(names).forEach((name)=>{
                        const i = context_lookup.get(name).index.value;
                        const g = Math.floor(i / 31);
                        const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
                        if (!grouped[g]) grouped[g] = [];
                        grouped[g].push({
                            name: lookup_name,
                            n: i % 31
                        });
                    });
                    const elements = [];
                    for(let g = 0; g < grouped.length; g += 1)elements[g] = grouped[g] ? grouped[g].map(({ name: name, n: n })=>x`${name} ? ${1 << n} : 0`).reduce((lhs, rhs)=>x`${lhs} | ${rhs}`) : x`0`;
                    return {
                        type: "ArrayExpression",
                        elements: elements
                    };
                }
                return Array.from(names).map((name)=>{
                    const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
                    const i = context_lookup.get(name).index.value;
                    return x`${lookup_name} ? ${1 << i} : 0`;
                }).reduce((lhs, rhs)=>x`${lhs} | ${rhs}`);
            }
        };
        return {
            block: block,
            scope: scope,
            get_context: x`${context_input} => ${context}`,
            get_changes: x`${changes_input} => ${changes}`
        };
    }
    class SlotTemplateWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            const { scope: scope, lets: lets, const_tags: const_tags, slot_template_name: slot_template_name } = this.node;
            lets.forEach((l)=>{
                extract_names(l.value || l.name).forEach((name)=>{
                    renderer.add_to_context(name, true);
                });
            });
            add_const_tags_context(renderer, const_tags);
            this.block = block.child({
                comment: create_debugging_comment(this.node, this.renderer.component),
                name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
                type: "slot"
            });
            this.renderer.blocks.push(this.block);
            const seen = new Set(lets.map((l)=>l.name.name));
            this.parent.node.lets.forEach((l)=>{
                if (!seen.has(l.name.name)) lets.push(l);
            });
            this.parent.set_slot(slot_template_name, get_slot_definition(this.block, scope, lets));
            this.fragment = new FragmentWrapper(renderer, this.block, node.type === "SlotTemplate" ? node.children : [
                node
            ], this, strip_whitespace, next_sibling);
            this.block.parent.add_dependencies(this.block.dependencies);
        }
        render() {
            this.fragment.render(this.block, null, x`#nodes`);
            if (this.node.const_tags.length > 0) this.render_get_context();
        }
        render_get_context() {
            const get_context = this.block.renderer.component.get_unique_name("get_context");
            this.block.renderer.blocks.push(b`
			function ${get_context}(#ctx) {
				${add_const_tags(this.block, this.node.const_tags, "#ctx")}
			}
		`);
            this.block.chunks.declarations.push(b`${get_context}(#ctx)`);
            if (this.block.has_update_method) this.block.chunks.update.unshift(b`${get_context}(#ctx)`);
        }
    }
    function string_to_member_expression(name) {
        const parts = name.split(".");
        let node = {
            type: "Identifier",
            name: parts[0]
        };
        for(let i = 1; i < parts.length; i++)node = {
            type: "MemberExpression",
            object: node,
            property: {
                type: "Identifier",
                name: parts[i]
            }
        };
        return node;
    }
    const regex_invalid_variable_identifier_characters$3 = /[^a-zA-Z_$]/g;
    class InlineComponentWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.slots = new Map();
            this.children = [];
            this.cannot_use_innerhtml();
            this.not_static_content();
            if (this.node.expression) block.add_dependencies(this.node.expression.dependencies);
            this.node.attributes.forEach((attr)=>{
                block.add_dependencies(attr.dependencies);
            });
            this.node.bindings.forEach((binding)=>{
                if (binding.is_contextual) mark_each_block_bindings(this, binding);
                block.add_dependencies(binding.expression.dependencies);
            });
            this.node.handlers.forEach((handler)=>{
                if (handler.expression) block.add_dependencies(handler.expression.dependencies);
            });
            this.node.css_custom_properties.forEach((attr)=>{
                block.add_dependencies(attr.dependencies);
            });
            this.var = {
                type: "Identifier",
                name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
            };
            if (this.node.children.length) {
                this.node.lets.forEach((l)=>{
                    extract_names(l.value || l.name).forEach((name)=>{
                        renderer.add_to_context(name, true);
                    });
                });
                this.children = this.node.children.map((child)=>new SlotTemplateWrapper(renderer, block, this, child, strip_whitespace, next_sibling));
            }
            block.add_outro();
        }
        set_slot(name, slot_definition) {
            if (this.slots.has(name)) {
                if (name === "default") throw new Error('Found elements without slot attribute when using slot="default"');
                throw new Error(`Duplicate slot name "${name}" in <${this.node.name}>`);
            }
            this.slots.set(name, slot_definition);
        }
        warn_if_reactive() {
            const { name: name } = this.node;
            const variable = this.renderer.component.var_lookup.get(name);
            if (!variable) return;
            if (variable.reassigned || variable.export_name || variable.is_reactive_dependency) this.renderer.component.warn(this.node, compiler_warnings.reactive_component(name));
        }
        render(block, parent_node, parent_nodes) {
            this.warn_if_reactive();
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            const name = this.var;
            block.add_variable(name);
            const component_opts = x`{}`;
            const statements = [];
            const updates = [];
            this.children.forEach((child)=>{
                this.renderer.add_to_context("$$scope", true);
                child.render(block, null, x`#nodes`);
            });
            let props;
            const name_changes = block.get_unique_name(`${name.name}_changes`);
            const uses_spread = !!this.node.attributes.find((a)=>a.is_spread);
            // removing empty slot
            for (const slot of this.slots.keys())if (!this.slots.get(slot).block.has_content()) {
                this.renderer.remove_block(this.slots.get(slot).block);
                this.slots.delete(slot);
            }
            const has_css_custom_properties = this.node.css_custom_properties.length > 0;
            const is_svg_namespace = this.node.namespace === namespaces.svg;
            const css_custom_properties_wrapper_element = is_svg_namespace ? "g" : "div";
            const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name(css_custom_properties_wrapper_element) : null;
            if (has_css_custom_properties) block.add_variable(css_custom_properties_wrapper);
            const initial_props = this.slots.size > 0 ? [
                p`$$slots: {
					${Array.from(this.slots).map(([name, slot])=>{
                    return p`${name}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
                })}
				}`,
                p`$$scope: {
					ctx: #ctx
				}`
            ] : [];
            const attribute_object = uses_spread ? x`{ ${initial_props} }` : x`{
				${this.node.attributes.map((attr)=>p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
            if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
                if (!uses_spread && this.node.bindings.length === 0) component_opts.properties.push(p`props: ${attribute_object}`);
                else {
                    props = block.get_unique_name(`${name.name}_props`);
                    component_opts.properties.push(p`props: ${props}`);
                }
            }
            if (component.compile_options.dev) // TODO this is a terrible hack, but without it the component
            // will complain that options.target is missing. This would
            // work better if components had separate public and private
            // APIs
            component_opts.properties.push(p`$$inline: true`);
            const fragment_dependencies = new Set(this.slots.size ? [
                "$$scope"
            ] : []);
            this.slots.forEach((slot)=>{
                slot.block.dependencies.forEach((name)=>{
                    const is_let = slot.scope.is_let(name);
                    const variable = renderer.component.var_lookup.get(name);
                    if (is_let || is_dynamic(variable)) fragment_dependencies.add(name);
                });
            });
            const dynamic_attributes = this.node.attributes.filter((a)=>a.get_dependencies().length > 0);
            if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) updates.push(b`const ${name_changes} = {};`);
            if (this.node.attributes.length) {
                if (uses_spread) {
                    const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
                    const initial_props = [];
                    const changes = [];
                    const all_dependencies = new Set();
                    this.node.attributes.forEach((attr)=>{
                        add_to_set(all_dependencies, attr.dependencies);
                    });
                    this.node.attributes.forEach((attr, i)=>{
                        const { name: name, dependencies: dependencies } = attr;
                        const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
                        const unchanged = dependencies.size === 0;
                        let change_object;
                        if (attr.is_spread) {
                            const value = attr.expression.manipulate(block);
                            initial_props.push(value);
                            let value_object = value;
                            if (attr.expression.node.type !== "ObjectExpression") value_object = x`@get_spread_object(${value})`;
                            change_object = value_object;
                        } else {
                            const obj = x`{ ${name}: ${attr.get_value(block)} }`;
                            initial_props.push(obj);
                            change_object = obj;
                        }
                        changes.push(unchanged ? x`${levels}[${i}]` : condition ? x`${condition} && ${change_object}` : change_object);
                    });
                    block.chunks.init.push(b`
					const ${levels} = [
						${initial_props}
					];
				`);
                    statements.push(b`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
                    if (all_dependencies.size) {
                        const condition = renderer.dirty(Array.from(all_dependencies));
                        updates.push(b`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
                    } else updates.push(b`
						const ${name_changes} = {};
					`);
                } else dynamic_attributes.forEach((attribute)=>{
                    const dependencies = attribute.get_dependencies();
                    if (dependencies.length > 0) {
                        const condition = renderer.dirty(dependencies);
                        updates.push(b`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
                    }
                });
            }
            if (fragment_dependencies.size > 0) updates.push(b`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
            const munged_bindings = this.node.bindings.map((binding)=>{
                component.has_reactive_assignments = true;
                if (binding.name === "this") return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
                const id = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
                renderer.add_to_context(id.name);
                const callee = renderer.reference(id);
                const updating = block.get_unique_name(`updating_${binding.name}`);
                block.add_variable(updating);
                const snippet = binding.expression.manipulate(block);
                statements.push(b`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
                updates.push(b`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
                const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
                const dependencies = Array.from(binding.expression.dependencies);
                let lhs = binding.raw_expression;
                if (binding.is_contextual && binding.expression.node.type === "Identifier") {
                    // bind:x={y} — we can't just do `y = x`, we need to
                    // to `array[index] = x;
                    const { name: name } = binding.expression.node;
                    const { object: object, property: property, snippet: snippet } = block.bindings.get(name);
                    lhs = snippet;
                    contextual_dependencies.push(object.name, property.name);
                }
                const params = [
                    x`#value`
                ];
                const args = [
                    x`#value`
                ];
                if (contextual_dependencies.length > 0) {
                    contextual_dependencies.forEach((name)=>{
                        params.push({
                            type: "Identifier",
                            name: name
                        });
                        renderer.add_to_context(name, true);
                        args.push(renderer.reference(name));
                    });
                    block.maintain_context = true; // TODO put this somewhere more logical
                }
                block.chunks.init.push(b`
				function ${id}(#value) {
					${callee}(${args});
				}
			`);
                let invalidate_binding = b`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
                if (binding.expression.node.type === "MemberExpression") invalidate_binding = b`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
                const body = b`
				function ${id}(${params}) {
					${invalidate_binding}
				}
			`;
                component.partly_hoisted.push(body);
                return b`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id}, ${snippet}));`;
            });
            const munged_handlers = this.node.handlers.map((handler)=>{
                const event_handler = new EventHandlerWrapper(handler, this);
                let snippet = event_handler.get_snippet(block);
                if (handler.modifiers.has("once")) snippet = x`@once(${snippet})`;
                return b`${name}.$on("${handler.name}", ${snippet});`;
            });
            const mount_target = has_css_custom_properties ? css_custom_properties_wrapper : parent_node || "#target";
            const mount_anchor = has_css_custom_properties ? "null" : parent_node ? "null" : "#anchor";
            const to_claim = parent_nodes && this.renderer.options.hydratable;
            let claim_nodes = parent_nodes;
            if (this.node.name === "svelte:component") {
                const switch_value = block.get_unique_name("switch_value");
                const switch_props = block.get_unique_name("switch_props");
                const snippet = this.node.expression.manipulate(block);
                if (has_css_custom_properties) this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                block.chunks.init.push(b`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
					${props && b`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
                block.chunks.create.push(b`if (${name}) @create_component(${name}.$$.fragment);`);
                if (css_custom_properties_wrapper) this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
                block.chunks.mount.push(b`if (${name}) @mount_component(${name}, ${mount_target}, ${mount_anchor});`);
                if (to_claim) {
                    if (css_custom_properties_wrapper) claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                    block.chunks.claim.push(b`if (${name}) @claim_component(${name}.$$.fragment, ${claim_nodes});`);
                }
                if (updates.length) block.chunks.update.push(b`
					${updates}
				`);
                const tmp_anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
                const anchor = has_css_custom_properties ? "null" : tmp_anchor;
                const update_mount_node = has_css_custom_properties ? css_custom_properties_wrapper : this.get_update_mount_node(tmp_anchor);
                const update_insert = css_custom_properties_wrapper && (tmp_anchor.name !== "null" ? b`@insert(${tmp_anchor}.parentNode, ${css_custom_properties_wrapper}, ${tmp_anchor});` : b`@insert(${parent_node}, ${css_custom_properties_wrapper}, ${tmp_anchor});`);
                block.chunks.update.push(b`
				if (${switch_value} !== (${switch_value} = ${snippet})) {
					if (${name}) {
						@group_outros();
						const old_component = ${name};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
							${has_css_custom_properties ? b`@detach(${update_mount_node})` : null}
						});
						@check_outros();
					}

					if (${switch_value}) {
						${update_insert}
						${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name}.$$.fragment);
						@transition_in(${name}.$$.fragment, 1);
						@mount_component(${name}, ${update_mount_node}, ${anchor});
					} else {
						${name} = null;
					}
				} else if (${switch_value}) {
					${updates.length > 0 && b`${name}.$set(${name_changes});`}
				}
			`);
                block.chunks.intro.push(b`
				if (${name}) @transition_in(${name}.$$.fragment, #local);
			`);
                block.chunks.outro.push(b`if (${name}) @transition_out(${name}.$$.fragment, #local);`);
                block.chunks.destroy.push(b`if (${name}) @destroy_component(${name}, ${parent_node ? null : "detaching"});`);
            } else {
                const expression = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
                block.chunks.init.push(b`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
				${props && b`let ${props} = ${attribute_object};`}`}
				${statements}
				${name} = new ${expression}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
                if (has_css_custom_properties) this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                block.chunks.create.push(b`@create_component(${name}.$$.fragment);`);
                if (css_custom_properties_wrapper) this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
                block.chunks.mount.push(b`@mount_component(${name}, ${mount_target}, ${mount_anchor});`);
                if (to_claim) {
                    if (css_custom_properties_wrapper) claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                    block.chunks.claim.push(b`@claim_component(${name}.$$.fragment, ${claim_nodes});`);
                }
                block.chunks.intro.push(b`
				@transition_in(${name}.$$.fragment, #local);
			`);
                if (updates.length) block.chunks.update.push(b`
					${updates}
					${name}.$set(${name_changes});
				`);
                block.chunks.destroy.push(b`
				@destroy_component(${name}, ${parent_node ? null : "detaching"});
			`);
                block.chunks.outro.push(b`@transition_out(${name}.$$.fragment, #local);`);
            }
        }
        create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper) {
            if (parent_node) {
                block.chunks.mount.push(b`@append(${parent_node}, ${css_custom_properties_wrapper})`);
                if (is_head(parent_node)) block.chunks.destroy.push(b`@detach(${css_custom_properties_wrapper});`);
            } else {
                block.chunks.mount.push(b`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
                // TODO we eventually need to consider what happens to elements
                // that belong to the same outgroup as an outroing element...
                block.chunks.destroy.push(b`if (detaching && ${this.var}) @detach(${css_custom_properties_wrapper});`);
            }
        }
        create_css_custom_properties_wrapper_claim_chunk(block, parent_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
            const nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
            const claim_element = is_svg_namespace ? x`@claim_svg_element` : x`@claim_element`;
            block.chunks.claim.push(b`
			${css_custom_properties_wrapper} = ${claim_element}(${parent_nodes}, "${css_custom_properties_wrapper_element.toUpperCase()}", { style: true })
			var ${nodes} = @children(${css_custom_properties_wrapper});
		`);
            return nodes;
        }
        set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
            const element = is_svg_namespace ? x`@svg_element` : x`@element`;
            block.chunks.create.push(b`${css_custom_properties_wrapper} = ${element}("${css_custom_properties_wrapper_element}");`);
            if (!is_svg_namespace) block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "display", "contents");`);
            this.node.css_custom_properties.forEach((attr)=>{
                const dependencies = attr.get_dependencies();
                const should_cache = attr.should_cache();
                const last = should_cache && block.get_unique_name(`${attr.name.replace(regex_invalid_variable_identifier_characters$3, "_")}_last`);
                if (should_cache) block.add_variable(last);
                const value = attr.get_value(block);
                const init = should_cache ? x`${last} = ${value}` : value;
                block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init});`);
                if (dependencies.length > 0) {
                    let condition = block.renderer.dirty(dependencies);
                    if (should_cache) condition = x`${condition} && (${last} !== (${last} = ${value}))`;
                    block.chunks.update.push(b`
					if (${condition}) {
						@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache ? last : value});
					}
				`);
                }
            });
        }
    }
    function get_slot_data(values, block = null) {
        return {
            type: "ObjectExpression",
            properties: Array.from(values.values()).filter((attribute)=>attribute.name !== "name").map((attribute)=>{
                if (attribute.is_spread) {
                    const argument = get_spread_value(block, attribute);
                    return {
                        type: "SpreadElement",
                        argument: argument
                    };
                }
                const value = get_value(block, attribute);
                return p`${attribute.name}: ${value}`;
            })
        };
    }
    function get_value(block, attribute) {
        if (attribute.is_true) return x`true`;
        if (attribute.chunks.length === 0) return x`""`;
        let value = attribute.chunks.map((chunk)=>chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
        if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text") value = x`"" + ${value}`;
        return value;
    }
    function get_spread_value(block, attribute) {
        return block ? attribute.expression.manipulate(block) : attribute.expression.node;
    }
    class SlotWrapper extends Wrapper {
        constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.fallback = null;
            this.var = {
                type: "Identifier",
                name: "slot"
            };
            this.dependencies = new Set([
                "$$scope"
            ]);
            this.cannot_use_innerhtml();
            this.not_static_content();
            if (this.node.children.length) {
                this.fallback = block.child({
                    comment: create_debugging_comment(this.node.children[0], this.renderer.component),
                    name: this.renderer.component.get_unique_name("fallback_block"),
                    type: "fallback"
                });
                renderer.blocks.push(this.fallback);
            }
            this.fragment = new FragmentWrapper(renderer, this.fallback, node.children, this, strip_whitespace, next_sibling);
            this.node.values.forEach((attribute)=>{
                add_to_set(this.dependencies, attribute.dependencies);
            });
            block.add_dependencies(this.dependencies);
            // we have to do this, just in case
            block.add_intro();
            block.add_outro();
        }
        render(block, parent_node, parent_nodes) {
            const { renderer: renderer } = this;
            const { slot_name: slot_name } = this.node;
            if (this.slot_block) block = this.slot_block;
            let get_slot_changes_fn;
            let get_slot_spread_changes_fn;
            let get_slot_context_fn;
            if (this.node.values.size > 0) {
                get_slot_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_changes`);
                get_slot_context_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_context`);
                const changes = x`{}`;
                const spread_dynamic_dependencies = new Set();
                this.node.values.forEach((attribute)=>{
                    if (attribute.type === "Spread") add_to_set(spread_dynamic_dependencies, Array.from(attribute.dependencies).filter((name)=>this.is_dependency_dynamic(name)));
                    else {
                        const dynamic_dependencies = Array.from(attribute.dependencies).filter((name)=>this.is_dependency_dynamic(name));
                        if (dynamic_dependencies.length > 0) changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies)}`);
                    }
                });
                renderer.blocks.push(b`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
                if (spread_dynamic_dependencies.size) {
                    get_slot_spread_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_spread_changes`);
                    renderer.blocks.push(b`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(Array.from(spread_dynamic_dependencies))};
				`);
                }
            } else {
                get_slot_changes_fn = "null";
                get_slot_context_fn = "null";
            }
            let has_fallback = !!this.fallback;
            if (this.fallback) {
                this.fragment.render(this.fallback, null, x`#nodes`);
                has_fallback = this.fallback.has_content();
                if (!has_fallback) renderer.remove_block(this.fallback);
            }
            const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
            const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
            const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
            block.chunks.init.push(b`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${get_slot_context_fn});
			${has_fallback ? b`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
            block.chunks.create.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
            if (renderer.options.hydratable) block.chunks.claim.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
            block.chunks.mount.push(b`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
            block.chunks.intro.push(b`@transition_in(${slot_or_fallback}, #local);`);
            block.chunks.outro.push(b`@transition_out(${slot_or_fallback}, #local);`);
            const dynamic_dependencies = Array.from(this.dependencies).filter((name)=>this.is_dependency_dynamic(name));
            const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name)=>this.is_dependency_dynamic(name)) : [];
            let condition = renderer.dirty(dynamic_dependencies);
            if (block.has_outros) condition = x`!#current || ${condition}`;
            // conditions to treat everything as dirty
            const all_dirty_conditions = [
                get_slot_spread_changes_fn ? x`${get_slot_spread_changes_fn}(#dirty)` : null,
                block.has_outros ? x`!#current` : null
            ].filter(Boolean);
            const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2)=>x`${condition1} || ${condition2}`) : null;
            let slot_update;
            if (all_dirty_condition) {
                const dirty = x`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference("$$scope")}) : @get_slot_changes(${slot_definition}, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn})`;
                slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${dirty}, ${get_slot_context_fn});
				}
			`;
            } else slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
            let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
            let fallback_dirty = x`#dirty`;
            if (block.has_outros) {
                fallback_condition = x`!#current || ${fallback_condition}`;
                fallback_dirty = x`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
            }
            const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
            if (fallback_update) block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
            else block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				}
			`);
            block.chunks.destroy.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
        }
        is_dependency_dynamic(name) {
            if (name === "$$scope") return true;
            if (this.node.scope.is_let(name)) return true;
            if (is_reserved_keyword(name)) return true;
            const variable = this.renderer.component.var_lookup.get(name);
            return is_dynamic(variable);
        }
    }
    class TitleWrapper extends Wrapper {
        constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling){
            super(renderer, block, parent, node);
        }
        render(block, _parent_node, _parent_nodes) {
            const is_dynamic = !!this.node.children.find((node)=>node.type !== "Text");
            if (is_dynamic) {
                let value;
                const all_dependencies = new Set();
                // TODO some of this code is repeated in Tag.ts — would be good to
                // DRY it out if that's possible without introducing crazy indirection
                if (this.node.children.length === 1) {
                    // single {tag} — may be a non-string
                    // @ts-ignore todo: check this
                    const { expression: expression } = this.node.children[0];
                    value = expression.manipulate(block);
                    add_to_set(all_dependencies, expression.dependencies);
                } else {
                    // '{foo} {bar}' — treat as string concatenation
                    value = this.node.children.map((chunk)=>{
                        if (chunk.type === "Text") return string_literal(chunk.data);
                        chunk.expression.dependencies.forEach((d)=>{
                            all_dependencies.add(d);
                        });
                        return chunk.expression.manipulate(block);
                    }).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
                    if (this.node.children[0].type !== "Text") value = x`"" + ${value}`;
                }
                const last = this.node.should_cache && block.get_unique_name("title_value");
                if (this.node.should_cache) block.add_variable(last);
                const init = this.node.should_cache ? x`${last} = ${value}` : value;
                block.chunks.init.push(b`@_document.title = ${init};`);
                const updater = b`@_document.title = ${this.node.should_cache ? last : value};`;
                if (all_dependencies.size) {
                    const dependencies = Array.from(all_dependencies);
                    let condition = block.renderer.dirty(dependencies);
                    if (block.has_outros) condition = x`!#current || ${condition}`;
                    if (this.node.should_cache) condition = x`${condition} && (${last} !== (${last} = ${value}))`;
                    block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}`);
                }
            } else {
                const value = this.node.children.length > 0 ? string_literal(this.node.children[0].data) : x`""`;
                block.chunks.hydrate.push(b`@_document.title = ${value};`);
            }
        }
    }
    const associated_events = {
        innerWidth: "resize",
        innerHeight: "resize",
        outerWidth: "resize",
        outerHeight: "resize",
        scrollX: "scroll",
        scrollY: "scroll"
    };
    const properties = {
        scrollX: "pageXOffset",
        scrollY: "pageYOffset"
    };
    const readonly = new Set([
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "online"
    ]);
    class WindowWrapper extends Wrapper {
        constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.handlers = this.node.handlers.map((handler)=>new EventHandlerWrapper(handler, this));
        }
        render(block, _parent_node, _parent_nodes) {
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            const events = {};
            const bindings = {};
            add_actions(block, "@_window", this.node.actions);
            add_event_handlers(block, "@_window", this.handlers);
            this.node.bindings.forEach((binding)=>{
                // TODO: what if it's a MemberExpression?
                const binding_name = binding.expression.node.name;
                // in dev mode, throw if read-only values are written to
                if (readonly.has(binding.name)) renderer.readonly.add(binding_name);
                bindings[binding.name] = binding_name;
                // bind:online is a special case, we need to listen for two separate events
                if (binding.name === "online") return;
                const associated_event = associated_events[binding.name];
                const property = properties[binding.name] || binding.name;
                if (!events[associated_event]) events[associated_event] = [];
                events[associated_event].push({
                    name: binding_name,
                    value: property
                });
            });
            const scrolling = block.get_unique_name("scrolling");
            const clear_scrolling = block.get_unique_name("clear_scrolling");
            const scrolling_timeout = block.get_unique_name("scrolling_timeout");
            Object.keys(events).forEach((event)=>{
                const id = block.get_unique_name(`onwindow${event}`);
                const props = events[event];
                renderer.add_to_context(id.name);
                const fn = renderer.reference(id.name);
                if (event === "scroll") {
                    // TODO other bidirectional bindings...
                    block.add_variable(scrolling, x`false`);
                    block.add_variable(clear_scrolling, x`() => { ${scrolling} = false }`);
                    block.add_variable(scrolling_timeout);
                    const condition = bindings.scrollX && bindings.scrollY ? x`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x`"${bindings.scrollX || bindings.scrollY}" in this._state`;
                    const scrollX = bindings.scrollX && x`this._state.${bindings.scrollX}`;
                    const scrollY = bindings.scrollY && x`this._state.${bindings.scrollY}`;
                    renderer.meta_bindings.push(b`
					if (${condition}) {
						@_scrollTo(${scrollX || "@_window.pageXOffset"}, ${scrollY || "@_window.pageYOffset"});
					}
					${scrollX && `${scrollX} = @_window.pageXOffset;`}
					${scrollY && `${scrollY} = @_window.pageYOffset;`}
				`);
                    block.event_listeners.push(x`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
                } else {
                    props.forEach((prop)=>{
                        renderer.meta_bindings.push(b`this._state.${prop.name} = @_window.${prop.value};`);
                    });
                    block.event_listeners.push(x`
					@listen(@_window, "${event}", ${fn})
				`);
                }
                component.partly_hoisted.push(b`
				function ${id}() {
					${props.map((prop)=>renderer.invalidate(prop.name, x`${prop.name} = @_window.${prop.value}`))}
				}
			`);
                block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
                component.has_reactive_assignments = true;
            });
            // special case... might need to abstract this out if we add more special cases
            if (bindings.scrollX || bindings.scrollY) {
                const condition = renderer.dirty([
                    bindings.scrollX,
                    bindings.scrollY
                ].filter(Boolean));
                const scrollX = bindings.scrollX ? renderer.reference(bindings.scrollX) : x`@_window.pageXOffset`;
                const scrollY = bindings.scrollY ? renderer.reference(bindings.scrollY) : x`@_window.pageYOffset`;
                block.chunks.update.push(b`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scrollX}, ${scrollY});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
            }
            // another special case. (I'm starting to think these are all special cases.)
            if (bindings.online) {
                const id = block.get_unique_name("onlinestatuschanged");
                const name = bindings.online;
                renderer.add_to_context(id.name);
                const reference = renderer.reference(id.name);
                component.partly_hoisted.push(b`
				function ${id}() {
					${renderer.invalidate(name, x`${name} = @_navigator.onLine`)}
				}
			`);
                block.chunks.init.push(b`
				@add_render_callback(${reference});
			`);
                block.event_listeners.push(x`@listen(@_window, "online", ${reference})`, x`@listen(@_window, "offline", ${reference})`);
                component.has_reactive_assignments = true;
            }
        }
    }
    function link(next, prev) {
        prev.next = next;
        if (next) next.prev = prev;
    }
    const wrappers = {
        AwaitBlock: AwaitBlockWrapper,
        Body: BodyWrapper,
        Comment: null,
        DebugTag: DebugTagWrapper,
        EachBlock: EachBlockWrapper,
        Element: ElementWrapper,
        Head: HeadWrapper,
        IfBlock: IfBlockWrapper,
        InlineComponent: InlineComponentWrapper,
        KeyBlock: KeyBlockWrapper,
        MustacheTag: MustacheTagWrapper,
        Options: null,
        RawMustacheTag: RawMustacheTagWrapper,
        Slot: SlotWrapper,
        SlotTemplate: SlotTemplateWrapper,
        Text: TextWrapper,
        Title: TitleWrapper,
        Window: WindowWrapper
    };
    function trimmable_at(child, next_sibling) {
        // Whitespace is trimmable if one of the following is true:
        // The child and its sibling share a common nearest each block (not at an each block boundary)
        // The next sibling's previous node is an each block
        return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
    }
    class FragmentWrapper {
        constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling){
            this.nodes = [];
            let last_child;
            let window_wrapper;
            let i = nodes.length;
            while(i--){
                const child = nodes[i];
                if (!child.type) throw new Error("missing type");
                if (!(child.type in wrappers)) throw new Error(`TODO implement ${child.type}`);
                // special case — this is an easy way to remove whitespace surrounding
                // <svelte:window/>. lil hacky but it works
                if (child.type === "Window") {
                    window_wrapper = new WindowWrapper(renderer, block, parent, child);
                    continue;
                }
                if (child.type === "Text") {
                    let { data: data } = child;
                    // We want to remove trailing whitespace inside an element/component/block,
                    // *unless* there is no whitespace between this node and its next sibling
                    if (this.nodes.length === 0) {
                        const should_trim = next_sibling ? next_sibling.node.type === "Text" && regex_starts_with_whitespace.test(next_sibling.node.data) && trimmable_at(child, next_sibling) : !child.has_ancestor("EachBlock");
                        if (should_trim && !child.keep_space()) {
                            data = trim_end(data);
                            if (!data) continue;
                        }
                    }
                    // glue text nodes (which could e.g. be separated by comments) together
                    if (last_child && last_child.node.type === "Text") {
                        last_child.data = data + last_child.data;
                        continue;
                    }
                    const wrapper = new TextWrapper(renderer, block, parent, child, data);
                    if (wrapper.skip) continue;
                    this.nodes.unshift(wrapper);
                    link(last_child, last_child = wrapper);
                } else {
                    const Wrapper = wrappers[child.type];
                    if (!Wrapper) continue;
                    const wrapper = new Wrapper(renderer, block, parent, child, strip_whitespace, last_child || next_sibling);
                    this.nodes.unshift(wrapper);
                    link(last_child, last_child = wrapper);
                }
            }
            if (strip_whitespace) {
                const first = this.nodes[0];
                if (first && first.node.type === "Text" && !first.node.keep_space()) {
                    first.data = trim_start(first.data);
                    if (!first.data) {
                        first.var = null;
                        this.nodes.shift();
                        if (this.nodes[0]) this.nodes[0].prev = null;
                    }
                }
            }
            if (window_wrapper) {
                this.nodes.unshift(window_wrapper);
                link(last_child, window_wrapper);
            }
        }
        render(block, parent_node, parent_nodes) {
            for(let i = 0; i < this.nodes.length; i += 1)this.nodes[i].render(block, parent_node, parent_nodes);
        }
    }
    class Renderer {
        constructor(component, options){
            this.context = [];
            this.initial_context = [];
            this.context_lookup = new Map();
            this.blocks = [];
            this.readonly = new Set();
            this.meta_bindings = []; // initial values for e.g. window.innerWidth, if there's a <svelte:window> meta tag
            this.binding_groups = new Map();
            this.component = component;
            this.options = options;
            this.locate = component.locate; // TODO messy
            this.file_var = options.dev && this.component.get_unique_name("file");
            component.vars.filter((v)=>!v.hoistable || v.export_name && !v.module).forEach((v)=>this.add_to_context(v.name));
            // ensure store values are included in context
            component.vars.filter((v)=>v.subscribable).forEach((v)=>this.add_to_context(`$${v.name}`));
            reserved_keywords.forEach((keyword)=>{
                if (component.var_lookup.has(keyword)) this.add_to_context(keyword);
            });
            if (component.slots.size > 0) {
                this.add_to_context("$$scope");
                this.add_to_context("#slots");
            }
            if (this.binding_groups.size > 0) this.add_to_context("$$binding_groups");
            // main block
            this.block = new Block({
                renderer: this,
                name: null,
                type: "component",
                key: null,
                bindings: new Map(),
                dependencies: new Set()
            });
            this.block.has_update_method = true;
            this.fragment = new FragmentWrapper(this, this.block, component.fragment.children, null, true, null);
            // TODO messy
            this.blocks.forEach((block)=>{
                if (block instanceof Block) block.assign_variable_names();
            });
            this.block.assign_variable_names();
            this.fragment.render(this.block, null, x`#nodes`);
            this.context_overflow = this.context.length > 31;
            this.context.forEach((member)=>{
                const { variable: variable } = member;
                if (variable) {
                    member.priority += 2;
                    if (variable.mutated || variable.reassigned) member.priority += 4;
                    // these determine whether variable is included in initial context
                    // array, so must have the highest priority
                    if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned)) member.priority += 16;
                    if (variable.export_name) member.priority += 32;
                    if (variable.referenced) member.priority += 64;
                } else if (member.is_non_contextual) // determine whether variable is included in initial context
                // array, so must have the highest priority
                member.priority += 8;
                if (!member.is_contextual) member.priority += 1;
            });
            this.context.sort((a, b)=>b.priority - a.priority || a.index.value - b.index.value);
            this.context.forEach((member, i)=>member.index.value = i);
            let i = this.context.length;
            while(i--){
                const member = this.context[i];
                if (member.variable) {
                    if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned)) break;
                } else if (member.is_non_contextual) break;
            }
            this.initial_context = this.context.slice(0, i + 1);
        }
        add_to_context(name, contextual = false) {
            if (!this.context_lookup.has(name)) {
                const member = {
                    name: name,
                    index: {
                        type: "Literal",
                        value: this.context.length
                    },
                    is_contextual: false,
                    is_non_contextual: false,
                    variable: null,
                    priority: 0
                };
                this.context_lookup.set(name, member);
                this.context.push(member);
            }
            const member = this.context_lookup.get(name);
            if (contextual) member.is_contextual = true;
            else {
                member.is_non_contextual = true;
                member.variable = this.component.var_lookup.get(name);
            }
            return member;
        }
        invalidate(name, value, main_execution_context = false) {
            return renderer_invalidate(this, name, value, main_execution_context);
        }
        dirty(names, is_reactive_declaration = false) {
            const renderer = this;
            const dirty = is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`;
            const get_bitmask = ()=>{
                const bitmask = [];
                names.forEach((name)=>{
                    const member = renderer.context_lookup.get(name);
                    if (!member) return;
                    if (member.index.value === -1) throw new Error("unset index");
                    const value = member.index.value;
                    const i = value / 31 | 0;
                    const n = 1 << value % 31;
                    if (!bitmask[i]) bitmask[i] = {
                        n: 0,
                        names: []
                    };
                    bitmask[i].n |= n;
                    bitmask[i].names.push(name);
                });
                return bitmask;
            };
            // TODO: context-overflow make it less gross
            return {
                // Using a ParenthesizedExpression allows us to create
                // the expression lazily. TODO would be better if
                // context was determined before rendering, so that
                // this indirection was unnecessary
                type: "ParenthesizedExpression",
                get expression () {
                    const bitmask = get_bitmask();
                    if (!bitmask.length) return x`${dirty} & /*${names.join(", ")}*/ 0`;
                    if (renderer.context_overflow) return bitmask.map((b, i)=>({
                            b: b,
                            i: i
                        })).filter(({ b: b })=>b).map(({ b: b, i: i })=>x`${dirty}[${i}] & /*${b.names.join(", ")}*/ ${b.n}`).reduce((lhs, rhs)=>x`${lhs} | ${rhs}`);
                    return x`${dirty} & /*${names.join(", ")}*/ ${bitmask[0].n}`;
                }
            };
        }
        // NOTE: this method may be called before this.context_overflow / this.context is fully defined
        // therefore, they can only be evaluated later in a getter function
        get_initial_dirty() {
            const _this = this;
            // TODO: context-overflow make it less gross
            const val = x`-1`;
            return {
                get type () {
                    return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
                },
                // as [-1]
                get elements () {
                    const elements = [];
                    for(let i = 0; i < _this.context.length; i += 31)elements.push(val);
                    return elements;
                },
                // as -1
                operator: val.operator,
                prefix: val.prefix,
                argument: val.argument
            };
        }
        reference(node, ctx = "#ctx") {
            if (typeof node === "string") node = {
                type: "Identifier",
                name: node
            };
            const { name: name, nodes: nodes } = flatten_reference(node);
            const member = this.context_lookup.get(name);
            // TODO is this correct?
            if (this.component.var_lookup.get(name)) this.component.add_reference(node, name);
            if (member !== undefined) {
                const replacement = x`/*${member.name}*/ ${ctx}[${member.index}]`;
                if (nodes[0].loc) replacement.object.loc = nodes[0].loc;
                nodes[0] = replacement;
                return nodes.reduce((lhs, rhs)=>x`${lhs}.${rhs}`);
            }
            return node;
        }
        remove_block(block) {
            this.blocks.splice(this.blocks.indexOf(block), 1);
        }
    }
    var charToInteger$1 = {};
    var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for(var i$2 = 0; i$2 < chars$1.length; i$2++)charToInteger$1[chars$1.charCodeAt(i$2)] = i$2;
    function decode$3(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
            0,
            0,
            0,
            0,
            0
        ];
        var j = 0;
        for(var i = 0, shift = 0, value = 0; i < mappings.length; i++){
            var c = mappings.charCodeAt(i);
            if (c === 44) {
                segmentify$1(line, segment, j);
                j = 0;
            } else if (c === 59) {
                segmentify$1(line, segment, j);
                j = 0;
                decoded.push(line);
                line = [];
                segment[0] = 0;
            } else {
                var integer = charToInteger$1[c];
                if (integer === undefined) throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
                var hasContinuationBit = integer & 32;
                integer &= 31;
                value += integer << shift;
                if (hasContinuationBit) shift += 5;
                else {
                    var shouldNegate = value & 1;
                    value >>>= 1;
                    if (shouldNegate) value = value === 0 ? -2147483648 : -value;
                    segment[j] += value;
                    j++;
                    value = shift = 0; // reset
                }
            }
        }
        segmentify$1(line, segment, j);
        decoded.push(line);
        return decoded;
    }
    function segmentify$1(line, segment, j) {
        // This looks ugly, but we're creating specialized arrays with a specific
        // length. This is much faster than creating a new array (which v8 expands to
        // a capacity of 17 after pushing the first item), or slicing out a subarray
        // (which is slow). Length 4 is assumed to be the most frequent, followed by
        // length 5 (since not everything will have an associated name), followed by
        // length 1 (it's probably rare for a source substring to not have an
        // associated segment data).
        if (j === 4) line.push([
            segment[0],
            segment[1],
            segment[2],
            segment[3]
        ]);
        else if (j === 5) line.push([
            segment[0],
            segment[1],
            segment[2],
            segment[3],
            segment[4]
        ]);
        else if (j === 1) line.push([
            segment[0]
        ]);
    }
    function encode$1(decoded) {
        var sourceFileIndex = 0; // second field
        var sourceCodeLine = 0; // third field
        var sourceCodeColumn = 0; // fourth field
        var nameIndex = 0; // fifth field
        var mappings = "";
        for(var i = 0; i < decoded.length; i++){
            var line = decoded[i];
            if (i > 0) mappings += ";";
            if (line.length === 0) continue;
            var generatedCodeColumn = 0; // first field
            var lineMappings = [];
            for(var _i = 0, line_1 = line; _i < line_1.length; _i++){
                var segment = line_1[_i];
                var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
                generatedCodeColumn = segment[0];
                if (segment.length > 1) {
                    segmentMappings += encodeInteger$1(segment[1] - sourceFileIndex) + encodeInteger$1(segment[2] - sourceCodeLine) + encodeInteger$1(segment[3] - sourceCodeColumn);
                    sourceFileIndex = segment[1];
                    sourceCodeLine = segment[2];
                    sourceCodeColumn = segment[3];
                }
                if (segment.length === 5) {
                    segmentMappings += encodeInteger$1(segment[4] - nameIndex);
                    nameIndex = segment[4];
                }
                lineMappings.push(segmentMappings);
            }
            mappings += lineMappings.join(",");
        }
        return mappings;
    }
    function encodeInteger$1(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
            var clamped = num & 31;
            num >>>= 5;
            if (num > 0) clamped |= 32;
            result += chars$1[clamped];
        }while (num > 0);
        return result;
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * Creates a brand new (prototype-less) object with the enumerable-own
	 * properties of `target`. Any enumerable-own properties from `source` which
	 * are not present on `target` will be copied as well.
	 */ function defaults(target, source) {
        return Object.assign(Object.create(null), source, target);
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * Decodes an input sourcemap into a `DecodedSourceMap` sourcemap object.
	 *
	 * Valid input maps include a `DecodedSourceMap`, a `RawSourceMap`, or JSON
	 * representations of either type.
	 */ function decodeSourceMap(map) {
        if (typeof map === "string") map = JSON.parse(map);
        let { mappings: mappings } = map;
        if (typeof mappings === "string") mappings = decode$3(mappings);
        else // Clone the Line so that we can sort it. We don't want to mutate an array
        // that we don't own directly.
        mappings = mappings.map(cloneSegmentLine);
        // Sort each Line's segments. There's no guarantee that segments are sorted for us,
        // and even Chrome's implementation sorts:
        // https://cs.chromium.org/chromium/src/third_party/devtools-frontend/src/front_end/sdk/SourceMap.js?l=507-508&rcl=109232bcf479c8f4ef8ead3cf56c49eb25f8c2f0
        mappings.forEach(sortSegments);
        return defaults({
            mappings: mappings
        }, map);
    }
    function cloneSegmentLine(segments) {
        return segments.slice();
    }
    function sortSegments(segments) {
        segments.sort(segmentComparator);
    }
    function segmentComparator(a, b) {
        return a[0] - b[0];
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * A "leaf" node in the sourcemap tree, representing an original, unmodified
	 * source file. Recursive segment tracing ends at the `OriginalSource`.
	 */ class OriginalSource {
        constructor(filename, content){
            this.filename = filename;
            this.content = content;
        }
        /**
	     * Tracing a `SourceMapSegment` ends when we get to an `OriginalSource`,
	     * meaning this line/column location originated from this source file.
	     */ traceSegment(line, column, name) {
            return {
                column: column,
                line: line,
                name: name,
                source: this
            };
        }
    }
    /* istanbul ignore next */ const Url$1 = typeof URL !== "undefined" ? URL : $4S4dR$URL;
    // Matches "..", which must be preceeded by "/" or the start of the string, and
    // must be followed by a "/". We do not eat the following "/", so that the next
    // iteration can match on it.
    const parentRegex = /(^|\/)\.\.(?=\/|$)/g;
    function isAbsoluteUrl(url) {
        try {
            return new Url$1(url), true;
        } catch (e) {
            return false;
        }
    }
    /**
	 * Creates a directory name that is guaranteed to not be in `str`.
	 */ function uniqInStr(str) {
        let uniq = String(Math.random()).slice(2);
        while(str.indexOf(uniq) > -1)/* istanbul ignore next */ uniq += uniq;
        return uniq;
    }
    /**
	 * Removes the filename from the path (everything trailing the last "/"). This
	 * is only safe to call on a path, never call with an absolute or protocol
	 * relative URL.
	 */ function stripPathFilename(path) {
        path = normalizePath(path);
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
    }
    /**
	 * Normalizes a protocol-relative URL, but keeps it protocol relative by
	 * stripping out the protocl before returning it.
	 */ function normalizeProtocolRelative(input, absoluteBase) {
        const { href: href, protocol: protocol } = new Url$1(input, absoluteBase);
        return href.slice(protocol.length);
    }
    /**
	 * Normalizes a simple path (one that has no ".."s, or is absolute so ".."s can
	 * be normalized absolutely).
	 */ function normalizeSimplePath(input) {
        const { href: href } = new Url$1(input, "https://foo.com/");
        return href.slice(16);
    }
    /**
	 * Normalizes a path, ensuring that excess ".."s are preserved for relative
	 * paths in the output.
	 *
	 * If the input is absolute, this will return an absolutey normalized path, but
	 * it will not have a leading "/".
	 *
	 * If the input has a leading "..", the output will have a leading "..".
	 *
	 * If the input has a leading ".", the output will not have a leading "."
	 * unless there are too many ".."s, in which case there will be a leading "..".
	 */ function normalizePath(input) {
        // If there are no ".."s, we can treat this as if it were an absolute path.
        // The return won't be an absolute path, so it's easy.
        if (!parentRegex.test(input)) return normalizeSimplePath(input);
        // We already found one "..". Let's see how many there are.
        let total = 1;
        while(parentRegex.test(input))total++;
        // If there are ".."s, we need to prefix the the path with the same number of
        // unique directories. This is to ensure that we "remember" how many parent
        // directories we are accessing. Eg, "../../.." must keep 3, and "foo/../.."
        // must keep 1.
        const uniqDirectory = `z${uniqInStr(input)}/`;
        // uniqDirectory is just a "z", followed by numbers, followed by a "/". So
        // generating a runtime regex from it is safe. We'll use this search regex to
        // strip out our uniq directory names and insert any needed ".."s.
        const search = new RegExp(`^(?:${uniqDirectory})*`);
        // Now we can resolve the total path. If there are excess ".."s, they will
        // eliminate one or more of the unique directories we prefix with.
        const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);
        // We can now count the number of unique directories that were eliminated. If
        // there were 3, and 1 was eliminated, we know we only need to add 1 "..". If
        // 2 were eliminated, we need to insert 2 ".."s. If all 3 were eliminated,
        // then we need 3, etc. This replace is guranteed to match (it may match 0 or
        // more times), and we can count the total match to see how many were eliminated.
        return relative.replace(search, (all)=>{
            const leftover = all.length / uniqDirectory.length;
            return "../".repeat(total - leftover);
        });
    }
    /**
	 * Attempts to resolve `input` URL relative to `base`.
	 */ function resolve(input, base) {
        if (!base) base = "";
        // Absolute URLs are very easy to resolve right.
        if (isAbsoluteUrl(input)) return new Url$1(input).href;
        if (base) {
            // Absolute URLs are easy...
            if (isAbsoluteUrl(base)) return new Url$1(input, base).href;
            // If base is protocol relative, we'll resolve with it but keep the result
            // protocol relative.
            if (base.startsWith("//")) return normalizeProtocolRelative(input, `https:${base}`);
        }
        // Normalize input, but keep it protocol relative. We know base doesn't supply
        // a protocol, because that would have been handled above.
        if (input.startsWith("//")) return normalizeProtocolRelative(input, "https://foo.com/");
        // We now know that base (if there is one) and input are paths. We've handled
        // both absolute and protocol-relative variations above.
        // Absolute paths don't need any special handling, because they cannot have
        // extra "." or ".."s. That'll all be stripped away. Input takes priority here,
        // because if input is an absolute path, base path won't affect it in any way.
        if (input.startsWith("/")) return "/" + normalizeSimplePath(input);
        // Since input and base are paths, we need to join them to do any further
        // processing. Paths are joined at the directory level, so we need to remove
        // the base's filename before joining. We also know that input does not have a
        // leading slash, and that the stripped base will have a trailing slash if
        // there are any directories (or it'll be empty).
        const joined = stripPathFilename(base) + input;
        // If base is an absolute path, then input will be relative to it.
        if (base.startsWith("/")) return "/" + normalizeSimplePath(joined);
        // We now know both base (if there is one) and input are relative paths.
        const relative = normalizePath(joined);
        // If base started with a leading ".", or there is no base and input started
        // with a ".", then we need to ensure that the relative path starts with a
        // ".". We don't know if relative starts with a "..", though, so check before
        // prepending.
        if ((base || input).startsWith(".") && !relative.startsWith(".")) return "./" + relative;
        return relative;
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ function resolve$1(input, base) {
        // The base is always treated as a directory, if it's not empty.
        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
        if (base && !base.endsWith("/")) base += "/";
        return resolve(input, base);
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * A binary search implementation that returns the index if a match is found,
	 * or the negated index of where the `needle` should be inserted.
	 *
	 * The `comparator` callback receives both the `item` under comparison and the
	 * needle we are searching for. It must return `0` if the `item` is a match,
	 * any negative number if `item` is too small (and we must search after it), or
	 * any positive number if the `item` is too large (and we must search before
	 * it).
	 *
	 * If no match is found, a negated index of where to insert the `needle` is
	 * returned. This negated index is guaranteed to be less than 0. To insert an
	 * item, negate it (again) and splice:
	 *
	 * ```js
	 * const array = [1, 3];
	 * const needle = 2;
	 * const index = binarySearch(array, needle, (item, needle) => item - needle);
	 *
	 * assert.equal(index, -2);
	 * assert.equal(~index, 1);
	 * array.splice(~index, 0, needle);
	 * assert.deepEqual(array, [1, 2, 3]);
	 * ```
	 */ function binarySearch(haystack, needle, comparator) {
        let low = 0;
        let high = haystack.length - 1;
        while(low <= high){
            const mid = low + (high - low >> 1);
            const cmp = comparator(haystack[mid], needle);
            if (cmp === 0) return mid;
            if (cmp < 0) low = mid + 1;
            else high = mid - 1;
        }
        return ~low;
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * FastStringArray acts like a `Set` (allowing only one occurrence of a string
	 * `key`), but provides the index of the `key` in the backing array.
	 *
	 * This is designed to allow synchronizing a second array with the contents of
	 * the backing array, like how `sourcesContent[i]` is the source content
	 * associated with `source[i]`, and there are never duplicates.
	 */ class FastStringArray {
        constructor(){
            this.indexes = Object.create(null);
            this.array = [];
        }
        /**
	     * Puts `key` into the backing array, if it is not already present. Returns
	     * the index of the `key` in the backing array.
	     */ put(key) {
            const { array: array, indexes: indexes } = this;
            // The key may or may not be present. If it is present, it's a number.
            let index = indexes[key];
            // If it's not yet present, we need to insert it and track the index in the
            // indexes.
            if (index === undefined) {
                index = indexes[key] = array.length;
                array.push(key);
            }
            return index;
        }
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * SourceMapTree represents a single sourcemap, with the ability to trace
	 * mappings into its child nodes (which may themselves be SourceMapTrees).
	 */ class SourceMapTree {
        constructor(map, sources){
            this.map = map;
            this.sources = sources;
        }
        /**
	     * traceMappings is only called on the root level SourceMapTree, and begins
	     * the process of resolving each mapping in terms of the original source
	     * files.
	     */ traceMappings() {
            const mappings = [];
            const names = new FastStringArray();
            const sources = new FastStringArray();
            const sourcesContent = [];
            const { mappings: rootMappings, names: rootNames } = this.map;
            for(let i = 0; i < rootMappings.length; i++){
                const segments = rootMappings[i];
                const tracedSegments = [];
                for(let j = 0; j < segments.length; j++){
                    const segment = segments[j];
                    // 1-length segments only move the current generated column, there's no
                    // source information to gather from it.
                    if (segment.length === 1) continue;
                    const source = this.sources[segment[1]];
                    const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
                    if (!traced) continue;
                    // So we traced a segment down into its original source file. Now push a
                    // new segment pointing to this location.
                    const { column: column, line: line, name: name } = traced;
                    const { content: content, filename: filename } = traced.source;
                    // Store the source location, and ensure we keep sourcesContent up to
                    // date with the sources array.
                    const sourceIndex = sources.put(filename);
                    sourcesContent[sourceIndex] = content;
                    // This looks like unnecessary duplication, but it noticeably increases
                    // performance. If we were to push the nameIndex onto length-4 array, v8
                    // would internally allocate 22 slots! That's 68 wasted bytes! Array
                    // literals have the same capacity as their length, saving memory.
                    if (name) tracedSegments.push([
                        segment[0],
                        sourceIndex,
                        line,
                        column,
                        names.put(name)
                    ]);
                    else tracedSegments.push([
                        segment[0],
                        sourceIndex,
                        line,
                        column
                    ]);
                }
                mappings.push(tracedSegments);
            }
            // TODO: Make all sources relative to the sourceRoot.
            return defaults({
                mappings: mappings,
                names: names.array,
                sources: sources.array,
                sourcesContent: sourcesContent
            }, this.map);
        }
        /**
	     * traceSegment is only called on children SourceMapTrees. It recurses down
	     * into its own child SourceMapTrees, until we find the original source map.
	     */ traceSegment(line, column, name) {
            const { mappings: mappings, names: names } = this.map;
            // It's common for parent sourcemaps to have pointers to lines that have no
            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
            if (line >= mappings.length) return null;
            const segments = mappings[line];
            if (segments.length === 0) return null;
            let index = binarySearch(segments, column, segmentComparator$1);
            if (index === -1) return null; // we come before any mapped segment
            // If we can't find a segment that lines up to this column, we use the
            // segment before.
            if (index < 0) index = ~index - 1;
            const segment = segments[index];
            // 1-length segments only move the current generated column, there's no
            // source information to gather from it.
            if (segment.length === 1) return null;
            const source = this.sources[segment[1]];
            // So now we can recurse down, until we hit the original source file.
            return source.traceSegment(segment[2], segment[3], // A child map's recorded name for this segment takes precedence over the
            // parent's mapped name. Imagine a mangler changing the name over, etc.
            segment.length === 5 ? names[segment[4]] : name);
        }
    }
    function segmentComparator$1(segment, column) {
        return segment[0] - column;
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * Removes the filename from a path.
	 */ function stripFilename(path) {
        if (!path) return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ function asArray(value) {
        if (Array.isArray(value)) return value;
        return [
            value
        ];
    }
    /**
	 * Recursively builds a tree structure out of sourcemap files, with each node
	 * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
	 * `OriginalSource`s and `SourceMapTree`s.
	 *
	 * Every sourcemap is composed of a collection of source files and mappings
	 * into locations of those source files. When we generate a `SourceMapTree` for
	 * the sourcemap, we attempt to load each source file's own sourcemap. If it
	 * does not have an associated sourcemap, it is considered an original,
	 * unmodified source file.
	 */ function buildSourceMapTree(input, loader, relativeRoot) {
        const maps = asArray(input).map(decodeSourceMap);
        const map = maps.pop();
        for(let i = 0; i < maps.length; i++){
            if (maps[i].sources.length !== 1) throw new Error(`Transformation map ${i} must have exactly one source file.\n` + "Did you specify these with the most recent transformation maps first?");
        }
        const { sourceRoot: sourceRoot, sources: sources, sourcesContent: sourcesContent } = map;
        const children = sources.map((sourceFile, i)=>{
            // Each source file is loaded relative to the sourcemap's own sourceRoot,
            // which is itself relative to the sourcemap's parent.
            const uri = resolve$1(sourceFile || "", resolve$1(sourceRoot || "", stripFilename(relativeRoot)));
            // Use the provided loader callback to retrieve the file's sourcemap.
            // TODO: We should eventually support async loading of sourcemap files.
            const sourceMap = loader(uri);
            // If there is no sourcemap, then it is an unmodified source file.
            if (!sourceMap) {
                // The source file's actual contents must be included in the sourcemap
                // (done when generating the sourcemap) for it to be included as a
                // sourceContent in the output sourcemap.
                const sourceContent = sourcesContent ? sourcesContent[i] : null;
                return new OriginalSource(uri, sourceContent);
            }
            // Else, it's a real sourcemap, and we need to recurse into it to load its
            // source files.
            return buildSourceMapTree(decodeSourceMap(sourceMap), loader, uri);
        });
        let tree = new SourceMapTree(map, children);
        for(let i = maps.length - 1; i >= 0; i--)tree = new SourceMapTree(maps[i], [
            tree
        ]);
        return tree;
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * A SourceMap v3 compatible sourcemap, which only includes fields that were
	 * provided to it.
	 */ class SourceMap {
        constructor(map, excludeContent){
            this.version = 3; // SourceMap spec says this should be first.
            if ("file" in map) this.file = map.file;
            this.mappings = encode$1(map.mappings);
            this.names = map.names;
            // TODO: We first need to make all source URIs relative to the sourceRoot
            // before we can support a sourceRoot.
            // if ('sourceRoot' in map) this.sourceRoot = map.sourceRoot;
            this.sources = map.sources;
            if (!excludeContent && "sourcesContent" in map) this.sourcesContent = map.sourcesContent;
        }
        toString() {
            return JSON.stringify(this);
        }
    }
    /**
	 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ /**
	 * Traces through all the mappings in the root sourcemap, through the sources
	 * (and their sourcemaps), all the way back to the original source location.
	 *
	 * `loader` will be called every time we encounter a source file. If it returns
	 * a sourcemap, we will recurse into that sourcemap to continue the trace. If
	 * it returns a falsey value, that source file is treated as an original,
	 * unmodified source file.
	 *
	 * Pass `excludeContent` content to exclude any self-containing source file
	 * content from the output sourcemap.
	 */ function remapping(input, loader, excludeContent) {
        const graph = buildSourceMapTree(input, loader);
        return new SourceMap(graph.traceMappings(), !!excludeContent);
    }
    function last_line_length(s) {
        return s.length - s.lastIndexOf("\n") - 1;
    }
    // mutate map in-place
    function sourcemap_add_offset(map, offset, source_index) {
        if (map.mappings.length == 0) return;
        for(let line = 0; line < map.mappings.length; line++){
            const segment_list = map.mappings[line];
            for(let segment = 0; segment < segment_list.length; segment++){
                const seg = segment_list[segment];
                // shift only segments that belong to component source file
                if (seg[1] === source_index) {
                    // shift column if it points at the first line
                    if (seg[2] === 0) seg[3] += offset.column;
                    // shift line
                    seg[2] += offset.line;
                }
            }
        }
    }
    function merge_tables(this_table, other_table) {
        const new_table = this_table.slice();
        const idx_map = [];
        other_table = other_table || [];
        let val_changed = false;
        for (const [other_idx, other_val] of other_table.entries()){
            const this_idx = this_table.indexOf(other_val);
            if (this_idx >= 0) idx_map[other_idx] = this_idx;
            else {
                const new_idx = new_table.length;
                new_table[new_idx] = other_val;
                idx_map[other_idx] = new_idx;
                val_changed = true;
            }
        }
        let idx_changed = val_changed;
        if (val_changed) {
            if (idx_map.find((val, idx)=>val != idx) === undefined) // idx_map is identity map [0, 1, 2, 3, 4, ....]
            idx_changed = false;
        }
        return [
            new_table,
            idx_map,
            val_changed,
            idx_changed
        ];
    }
    const regex_line_token = /([^\d\w\s]|\s+)/g;
    class MappedCode {
        constructor(string = "", map = null){
            this.string = string;
            if (map) this.map = map;
            else this.map = {
                version: 3,
                mappings: [],
                sources: [],
                names: []
            };
        }
        /**
	     * concat in-place (mutable), return this (chainable)
	     * will also mutate the `other` object
	     */ concat(other) {
            // noop: if one is empty, return the other
            if (other.string == "") return this;
            if (this.string == "") {
                this.string = other.string;
                this.map = other.map;
                return this;
            }
            // compute last line length before mutating
            const column_offset = last_line_length(this.string);
            this.string += other.string;
            const m1 = this.map;
            const m2 = other.map;
            if (m2.mappings.length == 0) return this;
            // combine sources and names
            const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(m1.sources, m2.sources);
            const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(m1.names, m2.names);
            if (sources_changed) m1.sources = sources;
            if (names_changed) m1.names = names;
            // unswitched loops are faster
            if (sources_idx_changed && names_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
                    if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
                }
            }
            else if (sources_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
                }
            }
            else if (names_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
                }
            }
            // combine the mappings
            // combine
            // 1. last line of first map
            // 2. first line of second map
            // columns of 2 must be shifted
            if (m2.mappings.length > 0 && column_offset > 0) {
                const first_line = m2.mappings[0];
                for(let i = 0; i < first_line.length; i++)first_line[i][0] += column_offset;
            }
            // combine last line + first line
            push_array$1(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
            // append other lines
            push_array$1(m1.mappings, m2.mappings);
            return this;
        }
        static from_processed(string, map) {
            const line_count = string.split("\n").length;
            if (map) {
                // ensure that count of source map mappings lines
                // is equal to count of generated code lines
                // (some tools may produce less)
                const missing_lines = line_count - map.mappings.length;
                for(let i = 0; i < missing_lines; i++)map.mappings.push([]);
                return new MappedCode(string, map);
            }
            if (string == "") return new MappedCode();
            map = {
                version: 3,
                names: [],
                sources: [],
                mappings: []
            };
            // add empty SourceMapSegment[] for every line
            for(let i = 0; i < line_count; i++)map.mappings.push([]);
            return new MappedCode(string, map);
        }
        static from_source({ source: source, file_basename: file_basename, get_location: get_location }) {
            let offset = get_location(0);
            if (!offset) offset = {
                line: 0,
                column: 0
            };
            const map = {
                version: 3,
                names: [],
                sources: [
                    file_basename
                ],
                mappings: []
            };
            if (source == "") return new MappedCode(source, map);
            // we create a high resolution identity map here,
            // we know that it will eventually be merged with svelte's map,
            // at which stage the resolution will decrease.
            const line_list = source.split("\n");
            for(let line = 0; line < line_list.length; line++){
                map.mappings.push([]);
                const token_list = line_list[line].split(regex_line_token);
                for(let token = 0, column = 0; token < token_list.length; token++){
                    if (token_list[token] == "") continue;
                    map.mappings[line].push([
                        column,
                        0,
                        offset.line + line,
                        column
                    ]);
                    column += token_list[token].length;
                }
            }
            // shift columns in first line
            const segment_list = map.mappings[0];
            for(let segment = 0; segment < segment_list.length; segment++)segment_list[segment][3] += offset.column;
            return new MappedCode(source, map);
        }
    }
    function combine_sourcemaps(filename, sourcemap_list) {
        if (sourcemap_list.length == 0) return null;
        let map_idx = 1;
        const map = sourcemap_list.slice(0, -1).find((m)=>m.sources.length !== 1) === undefined ? remapping(// only the oldest sourcemap can have multiple sources
        sourcemap_list, ()=>null, true // skip optional field `sourcesContent`
        ) : remapping(sourcemap_list[0], function loader(sourcefile) {
            if (sourcefile === filename && sourcemap_list[map_idx]) return sourcemap_list[map_idx++]; // idx 1, 2, ...
            else return null; // source file = leaf node
        }, true);
        if (!map.file) delete map.file; // skip optional field `file`
        // When source maps are combined and the leading map is empty, sources is not set.
        // Add the filename to the empty array in this case.
        // Further improvements to remapping may help address this as well https://github.com/ampproject/remapping/issues/116
        if (!map.sources.length) map.sources = [
            filename
        ];
        return map;
    }
    // browser vs node.js
    const b64enc = typeof btoa == "function" ? btoa : (b)=>Buffer.from(b).toString("base64");
    const b64dec = typeof atob == "function" ? atob : (a)=>Buffer.from(a, "base64").toString();
    function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
        if (!svelte_map || !preprocessor_map_input) return svelte_map;
        const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
        const result_map = combine_sourcemaps(filename, [
            svelte_map,
            preprocessor_map
        ]);
        // Svelte expects a SourceMap which includes toUrl and toString. Instead of wrapping our output in a class,
        // we just tack on the extra properties.
        Object.defineProperties(result_map, {
            toString: {
                enumerable: false,
                value: function toString() {
                    return JSON.stringify(this);
                }
            },
            toUrl: {
                enumerable: false,
                value: function toUrl() {
                    return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
                }
            }
        });
        return result_map;
    }
    const regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
    // parse attached sourcemap in processed.code
    function parse_attached_sourcemap(processed, tag_name) {
        const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
        const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
        function log_warning(message) {
            // code_start: help to find preprocessor
            const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
            console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
        }
        processed.code = processed.code.replace(regex, (_, match1, match2)=>{
            const map_url = tag_name == "script" ? match1 || match2 : match1;
            const map_data = (map_url.match(regex_data_uri) || [])[1];
            if (map_data) {
                // sourceMappingURL is data URL
                if (processed.map) {
                    log_warning("Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap.");
                    // ignore attached sourcemap
                    return "";
                }
                processed.map = b64dec(map_data); // use attached sourcemap
                return ""; // remove from processed.code
            }
            // sourceMappingURL is path or URL
            if (!processed.map) log_warning(`Found sourcemap path ${JSON.stringify(map_url)} in processed.code, but no sourcemap data. ` + "Please update your preprocessor to return sourcemap data directly.");
            // ignore sourcemap path
            return ""; // remove from processed.code
        });
    }
    function check_enable_sourcemap(enable_sourcemap, namespace) {
        return typeof enable_sourcemap === "boolean" ? enable_sourcemap : enable_sourcemap[namespace];
    }
    function dom(component, options) {
        const { name: name } = component;
        const renderer = new Renderer(component, options);
        const { block: block } = renderer;
        block.has_outro_method = true;
        // prevent fragment being created twice (#1063)
        if (options.customElement) block.chunks.create.push(b`this.c = @noop;`);
        const body = [];
        if (renderer.file_var) {
            const file = component.file ? x`"${component.file}"` : x`undefined`;
            body.push(b`const ${renderer.file_var} = ${file};`);
        }
        const css = component.stylesheet.render(options.filename, !options.customElement);
        const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
        if (css_sourcemap_enabled) css.map = apply_preprocessor_sourcemap(options.filename, css.map, options.sourcemap);
        else css.map = null;
        const styles = css_sourcemap_enabled && component.stylesheet.has_styles && options.dev ? `${css.code}\n/*# sourceMappingURL=${css.map.toUrl()} */` : css.code;
        const add_css = component.get_unique_name("add_css");
        const should_add_css = !options.customElement && !!styles && options.css === "injected";
        if (should_add_css) body.push(b`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
        // fix order
        // TODO the deconflicted names of blocks are reversed... should set them here
        const blocks = renderer.blocks.slice().reverse();
        push_array$1(body, blocks.map((block)=>{
            // TODO this is a horrible mess — renderer.blocks
            // contains a mixture of Blocks and Nodes
            if (block.render) return block.render();
            return block;
        }));
        if (options.dev && !options.hydratable) block.chunks.claim.push(b`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`);
        const uses_slots = component.var_lookup.has("$$slots");
        let compute_slots;
        if (uses_slots) compute_slots = b`
			const $$slots = @compute_slots(#slots);
		`;
        const uses_props = component.var_lookup.has("$$props");
        const uses_rest = component.var_lookup.has("$$restProps");
        const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
        const props = component.vars.filter((variable)=>!variable.module && variable.export_name);
        const writable_props = props.filter((variable)=>variable.writable);
        const omit_props_names = component.get_unique_name("omit_props_names");
        const compute_rest = x`@compute_rest_props($$props, ${omit_props_names.name})`;
        const rest = uses_rest ? b`
		const ${omit_props_names.name} = [${props.map((prop)=>`"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
        const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x`
			${$$props} => {
				${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`)}
				${uses_rest && !uses_props && x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x`$$restProps = ${compute_rest}`)}
				${writable_props.map((prop)=>b`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(prop.name, x`${prop.name} = ${$$props}.${prop.export_name}`)};`)}
				${component.slots.size > 0 && b`if ('$$scope' in ${$$props}) ${renderer.invalidate("$$scope", x`$$scope = ${$$props}.$$scope`)};`}
			}
		` : null;
        const accessors = [];
        const not_equal = component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
        let missing_props_check;
        let inject_state;
        let capture_state;
        let props_inject;
        props.forEach((prop)=>{
            const variable = component.var_lookup.get(prop.name);
            if (!variable.writable || component.component_options.accessors) accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x`function() {
					return ${prop.hoistable ? prop.name : x`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
            });
            else if (component.compile_options.dev) accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
            if (component.component_options.accessors) {
                if (variable.writable && !renderer.readonly.has(prop.name)) accessors.push({
                    type: "MethodDefinition",
                    kind: "set",
                    key: {
                        type: "Identifier",
                        name: prop.export_name
                    },
                    value: x`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
                });
                else if (component.compile_options.dev) accessors.push({
                    type: "MethodDefinition",
                    kind: "set",
                    key: {
                        type: "Identifier",
                        name: prop.export_name
                    },
                    value: x`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
                });
            } else if (component.compile_options.dev) accessors.push({
                type: "MethodDefinition",
                kind: "set",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
        });
        component.instance_exports_from.forEach((exports_from)=>{
            const import_declaration = Object.assign(Object.assign({}, exports_from), {
                type: "ImportDeclaration",
                specifiers: [],
                source: exports_from.source
            });
            component.imports.push(import_declaration);
            exports_from.specifiers.forEach((specifier)=>{
                if (component.component_options.accessors) {
                    const name = component.get_unique_name(specifier.exported.name);
                    import_declaration.specifiers.push(Object.assign(Object.assign({}, specifier), {
                        type: "ImportSpecifier",
                        imported: specifier.local,
                        local: name
                    }));
                    accessors.push({
                        type: "MethodDefinition",
                        kind: "get",
                        key: {
                            type: "Identifier",
                            name: specifier.exported.name
                        },
                        value: x`function() {
						return ${name}
					}`
                    });
                } else if (component.compile_options.dev) accessors.push({
                    type: "MethodDefinition",
                    kind: "get",
                    key: {
                        type: "Identifier",
                        name: specifier.exported.name
                    },
                    value: x`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
                });
            });
        });
        if (component.compile_options.dev) {
            // checking that expected ones were passed
            const expected = props.filter((prop)=>prop.writable && !prop.initialised);
            if (expected.length) missing_props_check = b`
				$$self.$$.on_mount.push(function () {
					${expected.map((prop)=>b`
					if (${prop.name} === undefined && !(('${prop.export_name}' in $$props) || $$self.$$.bound[$$self.$$.props['${prop.export_name}']])) {
						@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
					}`)}
				});
			`;
            const capturable_vars = component.vars.filter((v)=>!v.internal && !v.global && !v.name.startsWith("$$"));
            if (capturable_vars.length > 0) capture_state = x`() => ({ ${capturable_vars.map((prop)=>p`${prop.name}`)} })`;
            const injectable_vars = capturable_vars.filter((v)=>!v.module && v.writable && v.name[0] !== "$");
            if (uses_props || injectable_vars.length > 0) {
                inject_state = x`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map((v)=>b`if ('${v.name}' in $$props) ${renderer.invalidate(v.name, x`${v.name} = ${$$props}.${v.name}`)};`)}
				}
			`;
                props_inject = b`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
            }
        }
        // instrument assignments
        if (component.ast.instance) {
            let scope = component.instance_scope;
            const map = component.instance_scope_map;
            let execution_context = null;
            walk(component.ast.instance.content, {
                enter (node) {
                    if (map.has(node)) {
                        scope = map.get(node);
                        if (!execution_context && !scope.block) execution_context = node;
                    } else if (!execution_context && node.type === "LabeledStatement" && node.label.name === "$") execution_context = node;
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (execution_context === node) execution_context = null;
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        // normally (`a = 1`, `b.c = 2`), there'll be a single name
                        // (a or b). In destructuring cases (`[d, e] = [e, d]`) there
                        // may be more, in which case we need to tack the extra ones
                        // onto the initial function call
                        const names = new Set(extract_names(assignee));
                        this.replace(invalidate(renderer, scope, node, names, execution_context === null));
                    }
                }
            });
            component.rewrite_props(({ name: name, reassigned: reassigned, export_name: export_name })=>{
                const value = `$${name}`;
                const i = renderer.context_lookup.get(`$${name}`).index;
                const insert = reassigned || export_name ? b`${`$$subscribe_${name}`}()` : b`@component_subscribe($$self, ${name}, #value => $$invalidate(${i}, ${value} = #value))`;
                if (component.compile_options.dev) return b`@validate_store(${name}, '${name}'); ${insert}`;
                return insert;
            });
        }
        const args = [
            x`$$self`
        ];
        const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
        if (has_invalidate) args.push(x`$$props`, x`$$invalidate`);
        else if (component.compile_options.dev) // $$props arg is still needed for unknown prop check
        args.push(x`$$props`);
        // has_create_fragment is intentionally to be true in dev mode.
        const has_create_fragment = component.compile_options.dev || block.has_content();
        if (has_create_fragment) body.push(b`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
        body.push(b`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
        const filtered_props = props.filter((prop)=>{
            const variable = component.var_lookup.get(prop.name);
            if (variable.hoistable) return false;
            return prop.name[0] !== "$";
        });
        const reactive_stores = component.vars.filter((variable)=>variable.name[0] === "$" && variable.name[1] !== "$");
        const instance_javascript = component.extract_javascript(component.ast.instance);
        const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
        const definition = has_definition ? component.alias("instance") : {
            type: "Literal",
            value: null
        };
        const reactive_store_subscriptions = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return !variable || variable.hoistable;
        }).map(({ name: name })=>b`
			${component.compile_options.dev && b`@validate_store(${name.slice(1)}, '${name.slice(1)}');`}
			@component_subscribe($$self, ${name.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name).index}, ${name} = $$value));
		`);
        const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return variable && (variable.reassigned || variable.export_name);
        }).map(({ name: name })=>b`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name.slice(1)}`}());`);
        if (has_definition) {
            const reactive_declarations = [];
            const fixed_reactive_declarations = []; // not really 'reactive' but whatever
            component.reactive_declarations.forEach((d)=>{
                const dependencies = Array.from(d.dependencies);
                const uses_rest_or_props = !!dependencies.find((n)=>n === "$$props" || n === "$$restProps");
                const writable = dependencies.filter((n)=>{
                    const variable = component.var_lookup.get(n);
                    return variable && (variable.export_name || variable.mutated || variable.reassigned);
                });
                const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
                let statement = d.node; // TODO remove label (use d.node.body) if it's not referenced
                if (condition) statement = b`if (${condition}) { ${statement} }`[0];
                if (condition || uses_rest_or_props) reactive_declarations.push(statement);
                else fixed_reactive_declarations.push(statement);
            });
            const injected = Array.from(component.injected_reactive_declaration_vars).filter((name)=>{
                const variable = component.var_lookup.get(name);
                return variable.injected && variable.name[0] !== "$";
            });
            const reactive_store_declarations = reactive_stores.map((variable)=>{
                const $name = variable.name;
                const name = $name.slice(1);
                const store = component.var_lookup.get(name);
                if (store && (store.reassigned || store.export_name)) {
                    const unsubscribe = `$$unsubscribe_${name}`;
                    const subscribe = `$$subscribe_${name}`;
                    const i = renderer.context_lookup.get($name).index;
                    return b`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name}, $$value => $$invalidate(${i}, ${$name} = $$value)), ${name})`;
                }
                return b`let ${$name};`;
            });
            let unknown_props_check;
            if (component.compile_options.dev && !(uses_props || uses_rest)) unknown_props_check = b`
				const writable_props = [${writable_props.map((prop)=>x`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
            const return_value = {
                type: "ArrayExpression",
                elements: renderer.initial_context.map((member)=>({
                        type: "Identifier",
                        name: member.name
                    }))
            };
            body.push(b`
			function ${definition}(${args}) {
				${injected.map((name)=>b`let ${name};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b`@validate_slots('${component.tag}', #slots, [${[
                ...component.slots.keys()
            ].map((key)=>`'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${missing_props_check}
				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b`const $$binding_groups = [${[
                ...renderer.binding_groups.keys()
            ].map((_)=>x`[]`)}];`}

				${component.partly_hoisted}

				${set && b`$$self.$$set = ${set};`}

				${capture_state && b`$$self.$capture_state = ${capture_state};`}

				${inject_state && b`$$self.$inject_state = ${inject_state};`}

				${props_inject}

				${reactive_declarations.length > 0 && b`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
        }
        const prop_indexes = x`{
		${props.filter((v)=>v.export_name && !v.module).map((v)=>p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`;
        let dirty;
        if (renderer.context_overflow) {
            dirty = x`[]`;
            for(let i = 0; i < renderer.context.length; i += 31)dirty.elements.push(x`-1`);
        }
        if (options.customElement) {
            let init_props = x`@attribute_to_object(this.attributes)`;
            if (uses_slots) init_props = x`{ ...${init_props}, $$slots: @get_custom_elements_slots(this) }`;
            const declaration = b`
			class ${name} extends @SvelteElement {
				constructor(options) {
					super();

					${css.code && b`this.shadowRoot.innerHTML = \`<style>${css.code.replace(regex_backslashes, "\\\\")}${css_sourcemap_enabled && options.dev ? `\n/*# sourceMappingURL=${css.map.toUrl()} */` : ""}</style>\`;`}

					@init(this, { target: this.shadowRoot, props: ${init_props}, customElement: true }, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, null, ${dirty});

					if (options) {
						if (options.target) {
							@insert(options.target, this, options.anchor);
						}

						${(props.length > 0 || uses_props || uses_rest) && b`
						if (options.props) {
							this.$set(options.props);
							@flush();
						}`}
					}
				}
			}
		`[0];
            if (props.length > 0) declaration.body.body.push({
                type: "MethodDefinition",
                kind: "get",
                static: true,
                computed: false,
                key: {
                    type: "Identifier",
                    name: "observedAttributes"
                },
                value: x`function() {
					return [${props.map((prop)=>x`"${prop.export_name}"`)}];
				}`
            });
            push_array$1(declaration.body.body, accessors);
            body.push(declaration);
            if (component.tag != null) body.push(b`
				@_customElements.define("${component.tag}", ${name});
			`);
        } else {
            const superclass = {
                type: "Identifier",
                name: options.dev ? "@SvelteComponentDev" : "@SvelteComponent"
            };
            const optional_parameters = [];
            if (should_add_css) optional_parameters.push(add_css);
            else if (dirty) optional_parameters.push(x`null`);
            if (dirty) optional_parameters.push(dirty);
            const declaration = b`
			class ${name} extends ${superclass} {
				constructor(options) {
					super(${options.dev && "options"});
					@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
					${options.dev && b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`}
				}
			}
		`[0];
            push_array$1(declaration.body.body, accessors);
            body.push(declaration);
        }
        return {
            js: flatten(body),
            css: css
        };
    }
    function get_const_tags$1(const_tags) {
        if (const_tags.length === 0) return null;
        return {
            type: "VariableDeclaration",
            kind: "let",
            declarations: const_tags.map((const_tag)=>{
                const assignment = const_tag.node.expression;
                return {
                    type: "VariableDeclarator",
                    id: assignment.left,
                    init: assignment.right
                };
            })
        };
    }
    function AwaitBlock$1(node, renderer, options) {
        renderer.push();
        renderer.render(node.pending.children, options);
        const pending = renderer.pop();
        renderer.push();
        renderer.render(node.then.children, options);
        const then = renderer.pop();
        renderer.add_expression(x`
		function(__value) {
			if (@is_promise(__value)) {
				__value.then(null, @noop);
				return ${pending};
			}
			return (function(${node.then_node ? node.then_node : ""}) { ${get_const_tags$1(node.then.const_tags)}; return ${then}; }(__value));
		}(${node.expression.node})
	`);
    }
    function Comment$2(node, renderer, options) {
        if (options.preserveComments) renderer.add_string(`<!--${node.data}-->`);
    }
    function DebugTag$1(node, renderer, options) {
        if (!options.dev) return;
        const filename = options.filename || null;
        const { line: line, column: column } = options.locate(node.start + 1);
        const obj = x`{
		${node.expressions.map((e)=>p`${e.node.name}`)}
	}`;
        renderer.add_expression(x`@debug(${filename ? x`"${filename}"` : x`null`}, ${line - 1}, ${column}, ${obj})`);
    }
    function EachBlock$1(node, renderer, options) {
        const args = [
            node.context_node
        ];
        if (node.index) args.push({
            type: "Identifier",
            name: node.index
        });
        renderer.push();
        renderer.render(node.children, options);
        const result = renderer.pop();
        const consequent = x`@each(${node.expression.node}, (${args}) => { ${get_const_tags$1(node.const_tags)}; return ${result} })`;
        if (node.else) {
            renderer.push();
            renderer.render(node.else.children, options);
            let alternate = renderer.pop();
            if (node.else.const_tags.length > 0) alternate = x`(() => { ${get_const_tags$1(node.else.const_tags)}; return ${alternate} })()`;
            renderer.add_expression(x`${node.expression.node}.length ? ${consequent} : ${alternate}`);
        } else renderer.add_expression(consequent);
    }
    function get_class_attribute_value(attribute) {
        // handle special case — `class={possiblyUndefined}` with scoped CSS
        if (attribute.chunks.length === 2 && attribute.chunks[1].synthetic) {
            const value = attribute.chunks[0].node;
            return x`@escape(@null_to_empty(${value}), true) + "${attribute.chunks[1].data}"`;
        }
        return get_attribute_value(attribute);
    }
    function get_attribute_value(attribute) {
        if (attribute.chunks.length === 0) return x`""`;
        return attribute.chunks.map((chunk)=>{
            return chunk.type === "Text" ? string_literal(chunk.data.replace(regex_double_quotes, "&quot;")) : x`@escape(${chunk.node}, true)`;
        }).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
    }
    function get_attribute_expression(attribute) {
        if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression") return attribute.chunks[0].node;
        return get_attribute_value(attribute);
    }
    // similar logic from `compile/render_dom/wrappers/Fragment`
    // We want to remove trailing whitespace inside an element/component/block,
    // *unless* there is no whitespace between this node and its next sibling
    function remove_whitespace_children(children, next) {
        const nodes = [];
        let last_child;
        let i = children.length;
        while(i--){
            const child = children[i];
            if (child.type === "Text") {
                if (child.should_skip()) continue;
                let { data: data } = child;
                if (nodes.length === 0) {
                    const should_trim = next ? next.type === "Text" && regex_starts_with_whitespace.test(next.data) && trimmable_at$1(child, next) : !child.has_ancestor("EachBlock");
                    if (should_trim && !child.keep_space()) {
                        data = trim_end(data);
                        if (!data) continue;
                    }
                }
                // glue text nodes (which could e.g. be separated by comments) together
                if (last_child && last_child.type === "Text") {
                    last_child.data = data + last_child.data;
                    continue;
                }
                nodes.unshift(child);
                link(last_child, last_child = child);
            } else {
                nodes.unshift(child);
                link(last_child, last_child = child);
            }
        }
        const first = nodes[0];
        if (first && first.type === "Text" && !first.keep_space()) {
            first.data = trim_start(first.data);
            if (!first.data) {
                first.var = null;
                nodes.shift();
                if (nodes[0]) nodes[0].prev = null;
            }
        }
        return nodes;
    }
    function trimmable_at$1(child, next_sibling) {
        // Whitespace is trimmable if one of the following is true:
        // The child and its sibling share a common nearest each block (not at an each block boundary)
        // The next sibling's previous node is an each block
        return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
    }
    function Element$1(node, renderer, options) {
        const children = remove_whitespace_children(node.children, node.next);
        // awkward special case
        let node_contents;
        const contenteditable = node.name !== "textarea" && node.name !== "input" && node.attributes.some((attribute)=>attribute.name === "contenteditable");
        if (node.is_dynamic_element) renderer.push();
        renderer.add_string("<");
        add_tag_name();
        const class_expression_list = node.classes.map((class_directive)=>{
            const { expression: expression, name: name } = class_directive;
            const snippet = expression ? expression.node : x`#ctx.${name}`; // TODO is this right?
            return x`${snippet} ? "${name}" : ""`;
        });
        if (node.needs_manual_style_scoping) class_expression_list.push(x`"${node.component.stylesheet.id}"`);
        const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs)=>x`${lhs} + ' ' + ${rhs}`);
        const style_expression_list = node.styles.map((style_directive)=>{
            let { name: name, important: important, expression: { node: expression } } = style_directive;
            if (important) expression = x`${expression} + ' !important'`;
            return p`"${name}": ${expression}`;
        });
        const style_expression = style_expression_list.length > 0 && x`{ ${style_expression_list} }`;
        if (node.attributes.some((attr)=>attr.is_spread)) {
            // TODO dry this out
            const args = [];
            node.attributes.forEach((attribute)=>{
                if (attribute.is_spread) args.push(x`@escape_object(${attribute.expression.node})`);
                else {
                    const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
                    const name = attribute.name.toLowerCase();
                    if (name === "value" && node.name.toLowerCase() === "textarea") node_contents = get_attribute_value(attribute);
                    else if (attribute.is_true) args.push(x`{ ${attr_name}: true }`);
                    else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") // a boolean attribute with one non-Text chunk
                    args.push(x`{ ${attr_name}: ${attribute.chunks[0].node} || null }`);
                    else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                        const snippet = attribute.chunks[0].node;
                        args.push(x`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
                    } else args.push(x`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
                }
            });
            renderer.add_expression(x`@spread([${args}], { classes: ${class_expression}, styles: ${style_expression} })`);
        } else {
            let add_class_attribute = !!class_expression;
            let add_style_attribute = !!style_expression;
            node.attributes.forEach((attribute)=>{
                const name = attribute.name.toLowerCase();
                const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
                if (name === "value" && node.name.toLowerCase() === "textarea") node_contents = get_attribute_value(attribute);
                else if (attribute.is_true) renderer.add_string(` ${attr_name}`);
                else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                    // a boolean attribute with one non-Text chunk
                    renderer.add_string(" ");
                    renderer.add_expression(x`${attribute.chunks[0].node} ? "${attr_name}" : ""`);
                } else if (name === "class" && class_expression) {
                    add_class_attribute = false;
                    renderer.add_string(` ${attr_name}="`);
                    renderer.add_expression(x`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`);
                    renderer.add_string('"');
                } else if (name === "style" && style_expression) {
                    add_style_attribute = false;
                    renderer.add_expression(x`@add_styles(@merge_ssr_styles(${get_attribute_value(attribute)}, ${style_expression}))`);
                } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                    const snippet = attribute.chunks[0].node;
                    renderer.add_expression(x`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
                } else {
                    renderer.add_string(` ${attr_name}="`);
                    renderer.add_expression((name === "class" ? get_class_attribute_value : get_attribute_value)(attribute));
                    renderer.add_string('"');
                }
            });
            if (add_class_attribute) renderer.add_expression(x`@add_classes((${class_expression}).trim())`);
            if (add_style_attribute) renderer.add_expression(x`@add_styles(${style_expression})`);
        }
        node.bindings.forEach((binding)=>{
            const { name: name, expression: expression } = binding;
            if (binding.is_readonly) return;
            if (name === "group") {
                const value_attribute = node.attributes.find(({ name: name })=>name === "value");
                if (value_attribute) {
                    const value = get_attribute_expression(value_attribute);
                    const type = node.get_static_attribute_value("type");
                    const bound = expression.node;
                    const condition = type === "checkbox" ? x`~${bound}.indexOf(${value})` : x`${value} === ${bound}`;
                    renderer.add_expression(x`${condition} ? @add_attribute("checked", true, 1) : ""`);
                }
            } else if (contenteditable && (name === "textContent" || name === "innerHTML")) node_contents = expression.node;
            else if (binding.name === "value" && node.name === "textarea") {
                const snippet = expression.node;
                node_contents = x`${snippet} || ""`;
            } else if (binding.name === "value" && node.name === "select") ;
            else {
                const snippet = expression.node;
                renderer.add_expression(x`@add_attribute("${name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
            }
        });
        renderer.add_string(">");
        if (node_contents !== undefined) {
            if (contenteditable) {
                renderer.push();
                renderer.render(children, options);
                const result = renderer.pop();
                renderer.add_expression(x`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`);
            } else {
                if (node.name === "textarea") {
                    // Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`.
                    // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                    const value_attribute = node.attributes.find(({ name: name })=>name === "value");
                    if (value_attribute) {
                        const first = value_attribute.chunks[0];
                        if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) renderer.add_string("\n");
                    }
                }
                renderer.add_expression(node_contents);
            }
            add_close_tag();
        } else {
            if (node.name === "pre") {
                // Two or more leading newlines are required to restore the leading newline immediately after `<pre>`.
                // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                const first = children[0];
                if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) renderer.add_string("\n");
            }
            if (node.is_dynamic_element) renderer.push();
            renderer.render(children, options);
            if (node.is_dynamic_element) {
                const children = renderer.pop();
                renderer.add_expression(x`@is_void(#tag) ? '' : ${children}`);
            }
            add_close_tag();
        }
        if (node.is_dynamic_element) {
            let content = renderer.pop();
            if (options.dev && node.children.length > 0) content = x`(() => { @validate_void_dynamic_element(#tag); return ${content}; })()`;
            renderer.add_expression(x`((#tag) => {
			${options.dev && x`@validate_dynamic_element(#tag)`}
			return #tag ? ${content} : '';
		})(${node.tag_expr.node})`);
        }
        function add_close_tag() {
            if (node.tag_expr.node.type === "Literal") {
                if (!is_void(node.tag_expr.node.value)) {
                    renderer.add_string("</");
                    add_tag_name();
                    renderer.add_string(">");
                }
                return;
            }
            renderer.add_expression(x`@is_void(#tag) ? '' : \`</\${#tag}>\``);
        }
        function add_tag_name() {
            if (node.tag_expr.node.type === "Literal") renderer.add_string(node.tag_expr.node.value);
            else renderer.add_expression(node.tag_expr.node);
        }
    }
    function Head$1(node, renderer, options) {
        const head_options = Object.assign(Object.assign({}, options), {
            head_id: node.id
        });
        renderer.push();
        renderer.render(node.children, head_options);
        const result = renderer.pop();
        let expression = result;
        if (options.hydratable) {
            const start_comment = `HEAD_${node.id}_START`;
            const end_comment = `HEAD_${node.id}_END`;
            expression = x`'<!-- ${start_comment} -->' + ${expression} + '<!-- ${end_comment} -->'`;
        }
        renderer.add_expression(x`$$result.head += ${expression}, ""`);
    }
    function HtmlTag(node, renderer, options) {
        if (options.hydratable) renderer.add_string("<!-- HTML_TAG_START -->");
        renderer.add_expression(node.expression.node);
        if (options.hydratable) renderer.add_string("<!-- HTML_TAG_END -->");
    }
    function IfBlock$1(node, renderer, options) {
        const condition = node.expression.node;
        renderer.push();
        renderer.render(node.children, options);
        let consequent = renderer.pop();
        if (node.const_tags.length > 0) consequent = x`(() => { ${get_const_tags$1(node.const_tags)}; return ${consequent} })()`;
        renderer.push();
        if (node.else) renderer.render(node.else.children, options);
        let alternate = renderer.pop();
        if (node.else && node.else.const_tags.length > 0) alternate = x`(() => { ${get_const_tags$1(node.else.const_tags)}; return ${alternate} })()`;
        renderer.add_expression(x`${condition} ? ${consequent} : ${alternate}`);
    }
    function get_prop_value(attribute) {
        if (attribute.is_true) return x`true`;
        if (attribute.chunks.length === 0) return x`''`;
        return attribute.chunks.map((chunk)=>{
            if (chunk.type === "Text") return string_literal(chunk.data);
            return chunk.node;
        }).reduce((lhs, rhs)=>x`${lhs} + ${rhs}`);
    }
    function InlineComponent$1(node, renderer, options) {
        const binding_props = [];
        const binding_fns = [];
        node.bindings.forEach((binding)=>{
            renderer.has_bindings = true;
            // TODO this probably won't work for contextual bindings
            const snippet = binding.expression.node;
            binding_props.push(p`${binding.name}: ${snippet}`);
            binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
        });
        const uses_spread = node.attributes.find((attr)=>attr.is_spread);
        let props;
        if (uses_spread) props = x`@_Object.assign(${node.attributes.map((attribute)=>{
            if (attribute.is_spread) return attribute.expression.node;
            else return x`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
        }).concat(binding_props.map((p)=>x`{ ${p} }`))})`;
        else props = x`{
			${node.attributes.map((attribute)=>p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
        const bindings = x`{
		${binding_fns}
	}`;
        const expression = node.name === "svelte:self" ? renderer.name : node.name === "svelte:component" ? x`(${node.expression.node}) || @missing_component` : node.name.split(".").reduce((lhs, rhs)=>x`${lhs}.${rhs}`);
        const slot_fns = [];
        const children = node.children;
        if (children.length) {
            const slot_scopes = new Map();
            renderer.render(children, Object.assign({}, options, {
                slot_scopes: slot_scopes
            }));
            slot_scopes.forEach(({ input: input, output: output, statements: statements }, name)=>{
                slot_fns.push(p`${name}: (${input}) => { ${statements}; return ${output}; }`);
            });
        }
        const slots = x`{
		${slot_fns}
	}`;
        if (node.css_custom_properties.length > 0) {
            if (node.namespace === namespaces.svg) renderer.add_string('<g style="');
            else renderer.add_string('<div style="display: contents; ');
            node.css_custom_properties.forEach((attr, index)=>{
                renderer.add_string(`${attr.name}:`);
                renderer.add_expression(get_attribute_value(attr));
                renderer.add_string(";");
                if (index < node.css_custom_properties.length - 1) renderer.add_string(" ");
            });
            renderer.add_string('">');
        }
        renderer.add_expression(x`@validate_component(${expression}, "${node.name}").$$render($$result, ${props}, ${bindings}, ${slots})`);
        if (node.css_custom_properties.length > 0) {
            if (node.namespace === namespaces.svg) renderer.add_string("</g>");
            else renderer.add_string("</div>");
        }
    }
    function KeyBlock$1(node, renderer, options) {
        renderer.render(node.children, options);
    }
    function get_slot_scope(lets) {
        if (lets.length === 0) return null;
        return {
            type: "ObjectPattern",
            properties: lets.map((l)=>{
                return {
                    type: "Property",
                    kind: "init",
                    method: false,
                    shorthand: false,
                    computed: false,
                    key: l.name,
                    value: l.value || l.name
                };
            })
        };
    }
    function Slot$1(node, renderer, options) {
        const slot_data = get_slot_data(node.values);
        const slot = node.get_static_attribute_value("slot");
        const nearest_inline_component = node.find_nearest(/InlineComponent/);
        if (slot && nearest_inline_component) renderer.push();
        renderer.push();
        renderer.render(node.children, options);
        const result = renderer.pop();
        renderer.add_expression(x`
		#slots.${node.slot_name}
			? #slots.${node.slot_name}(${slot_data})
			: ${result}
	`);
        if (slot && nearest_inline_component) {
            const lets = node.lets;
            const seen = new Set(lets.map((l)=>l.name.name));
            nearest_inline_component.lets.forEach((l)=>{
                if (!seen.has(l.name.name)) lets.push(l);
            });
            options.slot_scopes.set(slot, {
                input: get_slot_scope(node.lets),
                output: renderer.pop()
            });
        }
    }
    function SlotTemplate$1(node, renderer, options) {
        const parent_inline_component = node.parent;
        const children = remove_whitespace_children(node instanceof SlotTemplate ? node.children : [
            node
        ], node.next);
        renderer.push();
        renderer.render(children, options);
        const lets = node.lets;
        const seen = new Set(lets.map((l)=>l.name.name));
        parent_inline_component.lets.forEach((l)=>{
            if (!seen.has(l.name.name)) lets.push(l);
        });
        const slot_fragment_content = renderer.pop();
        if (!is_empty_template_literal(slot_fragment_content)) {
            if (options.slot_scopes.has(node.slot_template_name)) {
                if (node.slot_template_name === "default") throw new Error('Found elements without slot attribute when using slot="default"');
                throw new Error(`Duplicate slot name "${node.slot_template_name}" in <${parent_inline_component.name}>`);
            }
            options.slot_scopes.set(node.slot_template_name, {
                input: get_slot_scope(node.lets),
                output: slot_fragment_content,
                statements: get_const_tags$1(node.const_tags)
            });
        }
    }
    function is_empty_template_literal(template_literal) {
        return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
    }
    function Tag$2(node, renderer, _options) {
        const snippet = node.expression.node;
        renderer.add_expression(node.parent && node.parent.type === "Element" && node.parent.name === "style" ? snippet : x`@escape(${snippet})`);
    }
    function Text$1(node, renderer, _options) {
        let text = node.data;
        if (!node.parent || node.parent.type !== "Element" || node.parent.name !== "script" && node.parent.name !== "style") // unless this Text node is inside a <script> or <style> element, escape &,<,>
        text = escape_html(text);
        renderer.add_string(text);
    }
    function Title$1(node, renderer, options) {
        renderer.push();
        renderer.add_string("<title>");
        renderer.render(node.children, options);
        renderer.add_string("</title>");
        const result = renderer.pop();
        renderer.add_expression(x`$$result.title = ${result}, ""`);
    }
    function noop() {}
    const handlers$1 = {
        AwaitBlock: AwaitBlock$1,
        Body: noop,
        Comment: Comment$2,
        DebugTag: DebugTag$1,
        EachBlock: EachBlock$1,
        Element: Element$1,
        Head: Head$1,
        IfBlock: IfBlock$1,
        InlineComponent: InlineComponent$1,
        KeyBlock: KeyBlock$1,
        MustacheTag: Tag$2,
        Options: noop,
        RawMustacheTag: HtmlTag,
        Slot: Slot$1,
        SlotTemplate: SlotTemplate$1,
        Text: Text$1,
        Title: Title$1,
        Window: noop
    };
    class Renderer$1 {
        constructor({ name: name }){
            this.has_bindings = false;
            this.stack = [];
            this.targets = [];
            this.name = name;
            this.push();
        }
        add_string(str) {
            this.current.value += escape_template(str);
        }
        add_expression(node) {
            this.literal.quasis.push({
                type: "TemplateElement",
                value: {
                    raw: this.current.value,
                    cooked: null
                },
                tail: false
            });
            this.literal.expressions.push(node);
            this.current.value = "";
        }
        push() {
            const current = this.current = {
                value: ""
            };
            const literal = this.literal = {
                type: "TemplateLiteral",
                expressions: [],
                quasis: []
            };
            this.stack.push({
                current: current,
                literal: literal
            });
        }
        pop() {
            this.literal.quasis.push({
                type: "TemplateElement",
                value: {
                    raw: this.current.value,
                    cooked: null
                },
                tail: true
            });
            const popped = this.stack.pop();
            const last = this.stack[this.stack.length - 1];
            if (last) {
                this.literal = last.literal;
                this.current = last.current;
            }
            return popped.literal;
        }
        render(nodes, options) {
            nodes.forEach((node)=>{
                const handler = handlers$1[node.type];
                if (!handler) throw new Error(`No handler for '${node.type}' nodes`);
                handler(node, this, options);
            });
        }
    }
    function ssr(component, options) {
        const renderer = new Renderer$1({
            name: component.name
        });
        const { name: name } = component;
        // create $$render function
        renderer.render(trim(component.fragment.children), Object.assign({
            locate: component.locate
        }, options));
        // TODO put this inside the Renderer class
        const literal = renderer.pop();
        // TODO concatenate CSS maps
        const css = options.customElement ? {
            code: null,
            map: null
        } : component.stylesheet.render(options.filename, true);
        const uses_rest = component.var_lookup.has("$$restProps");
        const props = component.vars.filter((variable)=>!variable.module && variable.export_name);
        const rest = uses_rest ? b`let $$restProps = @compute_rest_props($$props, [${props.map((prop)=>`"${prop.export_name}"`).join(",")}]);` : null;
        const uses_slots = component.var_lookup.has("$$slots");
        const slots = uses_slots ? b`let $$slots = @compute_slots(#slots);` : null;
        const reactive_stores = component.vars.filter((variable)=>variable.name[0] === "$" && variable.name[1] !== "$");
        const reactive_store_subscriptions = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return !variable || variable.hoistable;
        }).map(({ name: name })=>{
            const store_name = name.slice(1);
            return b`
				${component.compile_options.dev && b`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name} = #value)
			`;
        });
        const reactive_store_unsubscriptions = reactive_stores.map(({ name: name })=>b`${`$$unsubscribe_${name.slice(1)}`}()`);
        const reactive_store_declarations = reactive_stores.map(({ name: name })=>{
            const store_name = name.slice(1);
            const store = component.var_lookup.get(store_name);
            if (store && store.reassigned) {
                const unsubscribe = `$$unsubscribe_${store_name}`;
                const subscribe = `$$subscribe_${store_name}`;
                return b`let ${name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name} = $$value), ${store_name})`;
            }
            return b`let ${name}, ${`$$unsubscribe_${store_name}`};`;
        });
        // instrument get/set store value
        if (component.ast.instance) {
            let scope = component.instance_scope;
            const map = component.instance_scope_map;
            walk(component.ast.instance.content, {
                enter (node) {
                    if (map.has(node)) scope = map.get(node);
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const names = new Set(extract_names(assignee));
                        const to_invalidate = new Set();
                        for (const name of names){
                            const variable = component.var_lookup.get(name);
                            if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$")) to_invalidate.add(variable.name);
                        }
                        if (to_invalidate.size) this.replace(invalidate({
                            component: component
                        }, scope, node, to_invalidate, true));
                    }
                }
            });
        }
        component.rewrite_props(({ name: name, reassigned: reassigned })=>{
            const value = `$${name}`;
            let insert = reassigned ? b`${`$$subscribe_${name}`}()` : b`${`$$unsubscribe_${name}`} = @subscribe(${name}, #value => $${value} = #value)`;
            if (component.compile_options.dev) insert = b`@validate_store(${name}, '${name}'); ${insert}`;
            return insert;
        });
        const instance_javascript = component.extract_javascript(component.ast.instance);
        // TODO only do this for props with a default value
        const parent_bindings = instance_javascript ? component.vars.filter((variable)=>!variable.module && variable.export_name).map((prop)=>{
            return b`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
        }) : [];
        const injected = Array.from(component.injected_reactive_declaration_vars).filter((name)=>{
            const variable = component.var_lookup.get(name);
            return variable.injected;
        });
        const reactive_declarations = component.reactive_declarations.map((d)=>{
            const body = d.node.body;
            let statement = b`${body}`;
            if (!d.declaration) statement = b`$: { ${statement} }`;
            return statement;
        });
        const main = renderer.has_bindings ? b`
			let $$settled;
			let $$rendered;

			do {
				$$settled = true;

				${reactive_declarations}

				$$rendered = ${literal};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal};`;
        const blocks = [
            ...injected.map((name)=>b`let ${name};`),
            rest,
            slots,
            ...reactive_store_declarations,
            ...reactive_store_subscriptions,
            instance_javascript,
            ...parent_bindings,
            css.code && b`$$result.css.add(#css);`,
            main
        ].filter(Boolean);
        const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
        const js = b`
		${css.code ? b`
		const #css = {
			code: "${css.code}",
			map: ${css_sourcemap_enabled && css.map ? string_literal(css.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
        return {
            js: js,
            css: css
        };
    }
    function trim(nodes) {
        let start = 0;
        for(; start < nodes.length; start += 1){
            const node = nodes[start];
            if (node.type !== "Text") break;
            node.data = node.data.replace(/^\s+/, "");
            if (node.data) break;
        }
        let end = nodes.length;
        for(; end > start; end -= 1){
            const node = nodes[end - 1];
            if (node.type !== "Text") break;
            node.data = node.data.trimRight();
            if (node.data) break;
        }
        return nodes.slice(start, end);
    }
    /** ----------------------------------------------------------------------
	This file is automatically generated by `scripts/globals-extractor.mjs`.
	Generated At: 2022-09-03T15:22:37.415Z
	---------------------------------------------------------------------- */ var globals = new Set([
        "AbortController",
        "AbortSignal",
        "AbstractRange",
        "ActiveXObject",
        "AggregateError",
        "AnalyserNode",
        "Animation",
        "AnimationEffect",
        "AnimationEvent",
        "AnimationPlaybackEvent",
        "AnimationTimeline",
        "Array",
        "ArrayBuffer",
        "Atomics",
        "Attr",
        "Audio",
        "AudioBuffer",
        "AudioBufferSourceNode",
        "AudioContext",
        "AudioDestinationNode",
        "AudioListener",
        "AudioNode",
        "AudioParam",
        "AudioParamMap",
        "AudioProcessingEvent",
        "AudioScheduledSourceNode",
        "AudioWorklet",
        "AudioWorkletNode",
        "AuthenticatorAssertionResponse",
        "AuthenticatorAttestationResponse",
        "AuthenticatorResponse",
        "BarProp",
        "BaseAudioContext",
        "BeforeUnloadEvent",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "BiquadFilterNode",
        "Blob",
        "BlobEvent",
        "Boolean",
        "BroadcastChannel",
        "ByteLengthQueuingStrategy",
        "CDATASection",
        "CSS",
        "CSSAnimation",
        "CSSConditionRule",
        "CSSCounterStyleRule",
        "CSSFontFaceRule",
        "CSSGroupingRule",
        "CSSImportRule",
        "CSSKeyframeRule",
        "CSSKeyframesRule",
        "CSSMediaRule",
        "CSSNamespaceRule",
        "CSSPageRule",
        "CSSRule",
        "CSSRuleList",
        "CSSStyleDeclaration",
        "CSSStyleRule",
        "CSSStyleSheet",
        "CSSSupportsRule",
        "CSSTransition",
        "Cache",
        "CacheStorage",
        "CanvasCaptureMediaStreamTrack",
        "CanvasGradient",
        "CanvasPattern",
        "CanvasRenderingContext2D",
        "ChannelMergerNode",
        "ChannelSplitterNode",
        "CharacterData",
        "ClientRect",
        "Clipboard",
        "ClipboardEvent",
        "ClipboardItem",
        "CloseEvent",
        "Comment",
        "CompositionEvent",
        "ConstantSourceNode",
        "ConvolverNode",
        "CountQueuingStrategy",
        "Credential",
        "CredentialsContainer",
        "Crypto",
        "CryptoKey",
        "CustomElementRegistry",
        "CustomEvent",
        "DOMException",
        "DOMImplementation",
        "DOMMatrix",
        "DOMMatrixReadOnly",
        "DOMParser",
        "DOMPoint",
        "DOMPointReadOnly",
        "DOMQuad",
        "DOMRect",
        "DOMRectList",
        "DOMRectReadOnly",
        "DOMStringList",
        "DOMStringMap",
        "DOMTokenList",
        "DataTransfer",
        "DataTransferItem",
        "DataTransferItemList",
        "DataView",
        "Date",
        "DelayNode",
        "DeviceMotionEvent",
        "DeviceOrientationEvent",
        "Document",
        "DocumentFragment",
        "DocumentTimeline",
        "DocumentType",
        "DragEvent",
        "DynamicsCompressorNode",
        "Element",
        "ElementInternals",
        "Enumerator",
        "Error",
        "ErrorEvent",
        "EvalError",
        "Event",
        "EventCounts",
        "EventSource",
        "EventTarget",
        "External",
        "File",
        "FileList",
        "FileReader",
        "FileSystem",
        "FileSystemDirectoryEntry",
        "FileSystemDirectoryHandle",
        "FileSystemDirectoryReader",
        "FileSystemEntry",
        "FileSystemFileEntry",
        "FileSystemFileHandle",
        "FileSystemHandle",
        "FinalizationRegistry",
        "Float32Array",
        "Float64Array",
        "FocusEvent",
        "FontFace",
        "FontFaceSet",
        "FontFaceSetLoadEvent",
        "FormData",
        "FormDataEvent",
        "Function",
        "GainNode",
        "Gamepad",
        "GamepadButton",
        "GamepadEvent",
        "GamepadHapticActuator",
        "Geolocation",
        "GeolocationCoordinates",
        "GeolocationPosition",
        "GeolocationPositionError",
        "HTMLAllCollection",
        "HTMLAnchorElement",
        "HTMLAreaElement",
        "HTMLAudioElement",
        "HTMLBRElement",
        "HTMLBaseElement",
        "HTMLBodyElement",
        "HTMLButtonElement",
        "HTMLCanvasElement",
        "HTMLCollection",
        "HTMLDListElement",
        "HTMLDataElement",
        "HTMLDataListElement",
        "HTMLDetailsElement",
        "HTMLDialogElement",
        "HTMLDirectoryElement",
        "HTMLDivElement",
        "HTMLDocument",
        "HTMLElement",
        "HTMLEmbedElement",
        "HTMLFieldSetElement",
        "HTMLFontElement",
        "HTMLFormControlsCollection",
        "HTMLFormElement",
        "HTMLFrameElement",
        "HTMLFrameSetElement",
        "HTMLHRElement",
        "HTMLHeadElement",
        "HTMLHeadingElement",
        "HTMLHtmlElement",
        "HTMLIFrameElement",
        "HTMLImageElement",
        "HTMLInputElement",
        "HTMLLIElement",
        "HTMLLabelElement",
        "HTMLLegendElement",
        "HTMLLinkElement",
        "HTMLMapElement",
        "HTMLMarqueeElement",
        "HTMLMediaElement",
        "HTMLMenuElement",
        "HTMLMetaElement",
        "HTMLMeterElement",
        "HTMLModElement",
        "HTMLOListElement",
        "HTMLObjectElement",
        "HTMLOptGroupElement",
        "HTMLOptionElement",
        "HTMLOptionsCollection",
        "HTMLOutputElement",
        "HTMLParagraphElement",
        "HTMLParamElement",
        "HTMLPictureElement",
        "HTMLPreElement",
        "HTMLProgressElement",
        "HTMLQuoteElement",
        "HTMLScriptElement",
        "HTMLSelectElement",
        "HTMLSlotElement",
        "HTMLSourceElement",
        "HTMLSpanElement",
        "HTMLStyleElement",
        "HTMLTableCaptionElement",
        "HTMLTableCellElement",
        "HTMLTableColElement",
        "HTMLTableElement",
        "HTMLTableRowElement",
        "HTMLTableSectionElement",
        "HTMLTemplateElement",
        "HTMLTextAreaElement",
        "HTMLTimeElement",
        "HTMLTitleElement",
        "HTMLTrackElement",
        "HTMLUListElement",
        "HTMLUnknownElement",
        "HTMLVideoElement",
        "HashChangeEvent",
        "Headers",
        "History",
        "IDBCursor",
        "IDBCursorWithValue",
        "IDBDatabase",
        "IDBFactory",
        "IDBIndex",
        "IDBKeyRange",
        "IDBObjectStore",
        "IDBOpenDBRequest",
        "IDBRequest",
        "IDBTransaction",
        "IDBVersionChangeEvent",
        "IIRFilterNode",
        "IdleDeadline",
        "Image",
        "ImageBitmap",
        "ImageBitmapRenderingContext",
        "ImageData",
        "Infinity",
        "InputDeviceInfo",
        "InputEvent",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "InternalError",
        "IntersectionObserver",
        "IntersectionObserverEntry",
        "Intl",
        "JSON",
        "KeyboardEvent",
        "KeyframeEffect",
        "Location",
        "Lock",
        "LockManager",
        "Map",
        "Math",
        "MathMLElement",
        "MediaCapabilities",
        "MediaDeviceInfo",
        "MediaDevices",
        "MediaElementAudioSourceNode",
        "MediaEncryptedEvent",
        "MediaError",
        "MediaKeyMessageEvent",
        "MediaKeySession",
        "MediaKeyStatusMap",
        "MediaKeySystemAccess",
        "MediaKeys",
        "MediaList",
        "MediaMetadata",
        "MediaQueryList",
        "MediaQueryListEvent",
        "MediaRecorder",
        "MediaRecorderErrorEvent",
        "MediaSession",
        "MediaSource",
        "MediaStream",
        "MediaStreamAudioDestinationNode",
        "MediaStreamAudioSourceNode",
        "MediaStreamTrack",
        "MediaStreamTrackEvent",
        "MessageChannel",
        "MessageEvent",
        "MessagePort",
        "MimeType",
        "MimeTypeArray",
        "MouseEvent",
        "MutationEvent",
        "MutationObserver",
        "MutationRecord",
        "NaN",
        "NamedNodeMap",
        "NavigationPreloadManager",
        "Navigator",
        "NetworkInformation",
        "Node",
        "NodeFilter",
        "NodeIterator",
        "NodeList",
        "Notification",
        "Number",
        "Object",
        "OfflineAudioCompletionEvent",
        "OfflineAudioContext",
        "Option",
        "OscillatorNode",
        "OverconstrainedError",
        "PageTransitionEvent",
        "PannerNode",
        "Path2D",
        "PaymentAddress",
        "PaymentMethodChangeEvent",
        "PaymentRequest",
        "PaymentRequestUpdateEvent",
        "PaymentResponse",
        "Performance",
        "PerformanceEntry",
        "PerformanceEventTiming",
        "PerformanceMark",
        "PerformanceMeasure",
        "PerformanceNavigation",
        "PerformanceNavigationTiming",
        "PerformanceObserver",
        "PerformanceObserverEntryList",
        "PerformancePaintTiming",
        "PerformanceResourceTiming",
        "PerformanceServerTiming",
        "PerformanceTiming",
        "PeriodicWave",
        "PermissionStatus",
        "Permissions",
        "PictureInPictureWindow",
        "Plugin",
        "PluginArray",
        "PointerEvent",
        "PopStateEvent",
        "ProcessingInstruction",
        "ProgressEvent",
        "Promise",
        "PromiseRejectionEvent",
        "Proxy",
        "PublicKeyCredential",
        "PushManager",
        "PushSubscription",
        "PushSubscriptionOptions",
        "RTCCertificate",
        "RTCDTMFSender",
        "RTCDTMFToneChangeEvent",
        "RTCDataChannel",
        "RTCDataChannelEvent",
        "RTCDtlsTransport",
        "RTCEncodedAudioFrame",
        "RTCEncodedVideoFrame",
        "RTCError",
        "RTCErrorEvent",
        "RTCIceCandidate",
        "RTCIceTransport",
        "RTCPeerConnection",
        "RTCPeerConnectionIceErrorEvent",
        "RTCPeerConnectionIceEvent",
        "RTCRtpReceiver",
        "RTCRtpSender",
        "RTCRtpTransceiver",
        "RTCSctpTransport",
        "RTCSessionDescription",
        "RTCStatsReport",
        "RTCTrackEvent",
        "RadioNodeList",
        "Range",
        "RangeError",
        "ReadableByteStreamController",
        "ReadableStream",
        "ReadableStreamBYOBReader",
        "ReadableStreamBYOBRequest",
        "ReadableStreamDefaultController",
        "ReadableStreamDefaultReader",
        "ReferenceError",
        "Reflect",
        "RegExp",
        "RemotePlayback",
        "Request",
        "ResizeObserver",
        "ResizeObserverEntry",
        "ResizeObserverSize",
        "Response",
        "SVGAElement",
        "SVGAngle",
        "SVGAnimateElement",
        "SVGAnimateMotionElement",
        "SVGAnimateTransformElement",
        "SVGAnimatedAngle",
        "SVGAnimatedBoolean",
        "SVGAnimatedEnumeration",
        "SVGAnimatedInteger",
        "SVGAnimatedLength",
        "SVGAnimatedLengthList",
        "SVGAnimatedNumber",
        "SVGAnimatedNumberList",
        "SVGAnimatedPreserveAspectRatio",
        "SVGAnimatedRect",
        "SVGAnimatedString",
        "SVGAnimatedTransformList",
        "SVGAnimationElement",
        "SVGCircleElement",
        "SVGClipPathElement",
        "SVGComponentTransferFunctionElement",
        "SVGCursorElement",
        "SVGDefsElement",
        "SVGDescElement",
        "SVGElement",
        "SVGEllipseElement",
        "SVGFEBlendElement",
        "SVGFEColorMatrixElement",
        "SVGFEComponentTransferElement",
        "SVGFECompositeElement",
        "SVGFEConvolveMatrixElement",
        "SVGFEDiffuseLightingElement",
        "SVGFEDisplacementMapElement",
        "SVGFEDistantLightElement",
        "SVGFEDropShadowElement",
        "SVGFEFloodElement",
        "SVGFEFuncAElement",
        "SVGFEFuncBElement",
        "SVGFEFuncGElement",
        "SVGFEFuncRElement",
        "SVGFEGaussianBlurElement",
        "SVGFEImageElement",
        "SVGFEMergeElement",
        "SVGFEMergeNodeElement",
        "SVGFEMorphologyElement",
        "SVGFEOffsetElement",
        "SVGFEPointLightElement",
        "SVGFESpecularLightingElement",
        "SVGFESpotLightElement",
        "SVGFETileElement",
        "SVGFETurbulenceElement",
        "SVGFilterElement",
        "SVGForeignObjectElement",
        "SVGGElement",
        "SVGGeometryElement",
        "SVGGradientElement",
        "SVGGraphicsElement",
        "SVGImageElement",
        "SVGLength",
        "SVGLengthList",
        "SVGLineElement",
        "SVGLinearGradientElement",
        "SVGMPathElement",
        "SVGMarkerElement",
        "SVGMaskElement",
        "SVGMatrix",
        "SVGMetadataElement",
        "SVGNumber",
        "SVGNumberList",
        "SVGPathElement",
        "SVGPatternElement",
        "SVGPoint",
        "SVGPointList",
        "SVGPolygonElement",
        "SVGPolylineElement",
        "SVGPreserveAspectRatio",
        "SVGRadialGradientElement",
        "SVGRect",
        "SVGRectElement",
        "SVGSVGElement",
        "SVGScriptElement",
        "SVGSetElement",
        "SVGStopElement",
        "SVGStringList",
        "SVGStyleElement",
        "SVGSwitchElement",
        "SVGSymbolElement",
        "SVGTSpanElement",
        "SVGTextContentElement",
        "SVGTextElement",
        "SVGTextPathElement",
        "SVGTextPositioningElement",
        "SVGTitleElement",
        "SVGTransform",
        "SVGTransformList",
        "SVGUnitTypes",
        "SVGUseElement",
        "SVGViewElement",
        "SafeArray",
        "Screen",
        "ScreenOrientation",
        "ScriptProcessorNode",
        "SecurityPolicyViolationEvent",
        "Selection",
        "ServiceWorker",
        "ServiceWorkerContainer",
        "ServiceWorkerRegistration",
        "Set",
        "ShadowRoot",
        "SharedArrayBuffer",
        "SharedWorker",
        "SourceBuffer",
        "SourceBufferList",
        "SpeechRecognitionAlternative",
        "SpeechRecognitionErrorEvent",
        "SpeechRecognitionResult",
        "SpeechRecognitionResultList",
        "SpeechSynthesis",
        "SpeechSynthesisErrorEvent",
        "SpeechSynthesisEvent",
        "SpeechSynthesisUtterance",
        "SpeechSynthesisVoice",
        "StaticRange",
        "StereoPannerNode",
        "Storage",
        "StorageEvent",
        "StorageManager",
        "String",
        "StyleMedia",
        "StyleSheet",
        "StyleSheetList",
        "SubmitEvent",
        "SubtleCrypto",
        "Symbol",
        "SyntaxError",
        "Text",
        "TextDecoder",
        "TextDecoderStream",
        "TextEncoder",
        "TextEncoderStream",
        "TextMetrics",
        "TextTrack",
        "TextTrackCue",
        "TextTrackCueList",
        "TextTrackList",
        "TimeRanges",
        "Touch",
        "TouchEvent",
        "TouchList",
        "TrackEvent",
        "TransformStream",
        "TransformStreamDefaultController",
        "TransitionEvent",
        "TreeWalker",
        "TypeError",
        "UIEvent",
        "URIError",
        "URL",
        "URLSearchParams",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "VBArray",
        "VTTCue",
        "VTTRegion",
        "ValidityState",
        "VarDate",
        "VideoColorSpace",
        "VideoPlaybackQuality",
        "VisualViewport",
        "WSH",
        "WScript",
        "WaveShaperNode",
        "WeakMap",
        "WeakRef",
        "WeakSet",
        "WebAssembly",
        "WebGL2RenderingContext",
        "WebGLActiveInfo",
        "WebGLBuffer",
        "WebGLContextEvent",
        "WebGLFramebuffer",
        "WebGLProgram",
        "WebGLQuery",
        "WebGLRenderbuffer",
        "WebGLRenderingContext",
        "WebGLSampler",
        "WebGLShader",
        "WebGLShaderPrecisionFormat",
        "WebGLSync",
        "WebGLTexture",
        "WebGLTransformFeedback",
        "WebGLUniformLocation",
        "WebGLVertexArrayObject",
        "WebKitCSSMatrix",
        "WebSocket",
        "WheelEvent",
        "Window",
        "Worker",
        "Worklet",
        "WritableStream",
        "WritableStreamDefaultController",
        "WritableStreamDefaultWriter",
        "XMLDocument",
        "XMLHttpRequest",
        "XMLHttpRequestEventTarget",
        "XMLHttpRequestUpload",
        "XMLSerializer",
        "XPathEvaluator",
        "XPathExpression",
        "XPathResult",
        "XSLTProcessor",
        "addEventListener",
        "alert",
        "atob",
        "blur",
        "btoa",
        "caches",
        "cancelAnimationFrame",
        "cancelIdleCallback",
        "captureEvents",
        "clearInterval",
        "clearTimeout",
        "clientInformation",
        "close",
        "closed",
        "confirm",
        "console",
        "createImageBitmap",
        "crossOriginIsolated",
        "crypto",
        "customElements",
        "decodeURI",
        "decodeURIComponent",
        "devicePixelRatio",
        "dispatchEvent",
        "document",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "eval",
        "event",
        "external",
        "fetch",
        "focus",
        "frameElement",
        "frames",
        "getComputedStyle",
        "getSelection",
        "global",
        "globalThis",
        "history",
        "importScripts",
        "indexedDB",
        "innerHeight",
        "innerWidth",
        "isFinite",
        "isNaN",
        "isSecureContext",
        "length",
        "localStorage",
        "location",
        "locationbar",
        "matchMedia",
        "menubar",
        "moveBy",
        "moveTo",
        "name",
        "navigator",
        "onabort",
        "onafterprint",
        "onanimationcancel",
        "onanimationend",
        "onanimationiteration",
        "onanimationstart",
        "onauxclick",
        "onbeforeprint",
        "onbeforeunload",
        "onblur",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextmenu",
        "oncuechange",
        "ondblclick",
        "ondevicemotion",
        "ondeviceorientation",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "ongamepadconnected",
        "ongamepaddisconnected",
        "ongotpointercapture",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onlostpointercapture",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onorientationchange",
        "onpagehide",
        "onpageshow",
        "onpause",
        "onplay",
        "onplaying",
        "onpointercancel",
        "onpointerdown",
        "onpointerenter",
        "onpointerleave",
        "onpointermove",
        "onpointerout",
        "onpointerover",
        "onpointerup",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onrejectionhandled",
        "onreset",
        "onresize",
        "onscroll",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onselectionchange",
        "onselectstart",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "ontouchcancel",
        "ontouchend",
        "ontouchmove",
        "ontouchstart",
        "ontransitioncancel",
        "ontransitionend",
        "ontransitionrun",
        "ontransitionstart",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwebkitanimationend",
        "onwebkitanimationiteration",
        "onwebkitanimationstart",
        "onwebkittransitionend",
        "onwheel",
        "open",
        "opener",
        "orientation",
        "origin",
        "outerHeight",
        "outerWidth",
        "pageXOffset",
        "pageYOffset",
        "parent",
        "parseFloat",
        "parseInt",
        "performance",
        "personalbar",
        "postMessage",
        "print",
        "process",
        "prompt",
        "queueMicrotask",
        "releaseEvents",
        "removeEventListener",
        "reportError",
        "requestAnimationFrame",
        "requestIdleCallback",
        "resizeBy",
        "resizeTo",
        "screen",
        "screenLeft",
        "screenTop",
        "screenX",
        "screenY",
        "scroll",
        "scrollBy",
        "scrollTo",
        "scrollX",
        "scrollY",
        "scrollbars",
        "self",
        "sessionStorage",
        "setInterval",
        "setTimeout",
        "speechSynthesis",
        "status",
        "statusbar",
        "stop",
        "structuredClone",
        "toString",
        "toolbar",
        "top",
        "undefined",
        "unescape",
        "visualViewport",
        "webkitURL",
        "window"
    ]);
    const wrappers$1 = {
        esm: esm,
        cjs: cjs
    };
    function create_module(program, format, name, banner, sveltePath = "svelte", helpers, globals, imports, module_exports, exports_from) {
        const internal_path = `${sveltePath}/internal`;
        helpers.sort((a, b)=>a.name < b.name ? -1 : 1);
        globals.sort((a, b)=>a.name < b.name ? -1 : 1);
        const formatter = wrappers$1[format];
        if (!formatter) throw new Error(`options.format is invalid (must be ${list$1(Object.keys(wrappers$1))})`);
        return formatter(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports, exports_from);
    }
    function edit_source(source, sveltePath) {
        return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", sveltePath) : source;
    }
    function get_internal_globals(globals, helpers) {
        return globals.length > 0 && {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [
                {
                    type: "VariableDeclarator",
                    id: {
                        type: "ObjectPattern",
                        properties: globals.map((g)=>({
                                type: "Property",
                                method: false,
                                shorthand: false,
                                computed: false,
                                key: {
                                    type: "Identifier",
                                    name: g.name
                                },
                                value: g.alias,
                                kind: "init"
                            }))
                    },
                    init: helpers.find(({ name: name })=>name === "globals").alias
                }
            ]
        };
    }
    function esm(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports, exports_from) {
        const import_declaration = {
            type: "ImportDeclaration",
            specifiers: helpers.map((h)=>({
                    type: "ImportSpecifier",
                    local: h.alias,
                    imported: {
                        type: "Identifier",
                        name: h.name
                    }
                })),
            source: {
                type: "Literal",
                value: internal_path
            }
        };
        const internal_globals = get_internal_globals(globals, helpers);
        // edit user imports
        function rewrite_import(node) {
            const value = edit_source(node.source.value, sveltePath);
            if (node.source.value !== value) {
                node.source.value = value;
                node.source.raw = null;
            }
        }
        imports.forEach(rewrite_import);
        exports_from.forEach(rewrite_import);
        const exports1 = module_exports.length > 0 && {
            type: "ExportNamedDeclaration",
            specifiers: module_exports.map((x)=>({
                    type: "Specifier",
                    local: {
                        type: "Identifier",
                        name: x.name
                    },
                    exported: {
                        type: "Identifier",
                        name: x.as
                    }
                }))
        };
        program.body = b`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name};
		${exports1}
	`;
    }
    function cjs(program, name, banner, sveltePath, internal_path, helpers, globals, imports, module_exports, exports_from) {
        const internal_requires = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [
                {
                    type: "VariableDeclarator",
                    id: {
                        type: "ObjectPattern",
                        properties: helpers.map((h)=>({
                                type: "Property",
                                method: false,
                                shorthand: false,
                                computed: false,
                                key: {
                                    type: "Identifier",
                                    name: h.name
                                },
                                value: h.alias,
                                kind: "init"
                            }))
                    },
                    init: x`require("${internal_path}")`
                }
            ]
        };
        const internal_globals = get_internal_globals(globals, helpers);
        const user_requires = imports.map((node)=>{
            const init = x`require("${edit_source(node.source.value, sveltePath)}")`;
            if (node.specifiers.length === 0) return b`${init};`;
            return {
                type: "VariableDeclaration",
                kind: "const",
                declarations: [
                    {
                        type: "VariableDeclarator",
                        id: node.specifiers[0].type === "ImportNamespaceSpecifier" ? {
                            type: "Identifier",
                            name: node.specifiers[0].local.name
                        } : {
                            type: "ObjectPattern",
                            properties: node.specifiers.map((s)=>({
                                    type: "Property",
                                    method: false,
                                    shorthand: false,
                                    computed: false,
                                    key: s.type === "ImportSpecifier" ? s.imported : {
                                        type: "Identifier",
                                        name: "default"
                                    },
                                    value: s.local,
                                    kind: "init"
                                }))
                        },
                        init: init
                    }
                ]
            };
        });
        const exports1 = module_exports.map((x)=>b`exports.${{
                type: "Identifier",
                name: x.as
            }} = ${{
                type: "Identifier",
                name: x.name
            }};`);
        const user_exports_from = exports_from.map((node)=>{
            const init = x`require("${edit_source(node.source.value, sveltePath)}")`;
            return node.specifiers.map((specifier)=>{
                return b`exports.${specifier.exported} = ${init}.${specifier.local};`;
            });
        });
        program.body = b`
		/* ${banner} */

		"use strict";
		${internal_requires}
		${internal_globals}
		${user_requires}
		${user_exports_from}

		${program.body}

		exports.default = ${name};
		${exports1}
	`;
    }
    var Chunk = function Chunk(start, end, content) {
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = "";
        this.outro = "";
        this.content = content;
        this.storeName = false;
        this.edited = false;
        // we make these non-enumerable, for sanity while debugging
        Object.defineProperties(this, {
            previous: {
                writable: true,
                value: null
            },
            next: {
                writable: true,
                value: null
            }
        });
    };
    Chunk.prototype.appendLeft = function appendLeft(content) {
        this.outro += content;
    };
    Chunk.prototype.appendRight = function appendRight(content) {
        this.intro = this.intro + content;
    };
    Chunk.prototype.clone = function clone() {
        var chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
    };
    Chunk.prototype.contains = function contains(index) {
        return this.start < index && index < this.end;
    };
    Chunk.prototype.eachNext = function eachNext(fn) {
        var chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.next;
        }
    };
    Chunk.prototype.eachPrevious = function eachPrevious(fn) {
        var chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.previous;
        }
    };
    Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
            this.intro = "";
            this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
    };
    Chunk.prototype.prependLeft = function prependLeft(content) {
        this.outro = content + this.outro;
    };
    Chunk.prototype.prependRight = function prependRight(content) {
        this.intro = content + this.intro;
    };
    Chunk.prototype.split = function split(index) {
        var sliceIndex = index - this.start;
        var originalBefore = this.original.slice(0, sliceIndex);
        var originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        var newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index;
        if (this.edited) {
            // TODO is this block necessary?...
            newChunk.edit("", false);
            this.content = "";
        } else this.content = originalBefore;
        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
    };
    Chunk.prototype.toString = function toString() {
        return this.intro + this.content + this.outro;
    };
    Chunk.prototype.trimEnd = function trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) return true;
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
            if (trimmed !== this.content) this.split(this.start + trimmed.length).edit("", undefined, true);
            return true;
        } else {
            this.edit("", undefined, true);
            this.intro = this.intro.replace(rx, "");
            if (this.intro.length) return true;
        }
    };
    Chunk.prototype.trimStart = function trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) return true;
        var trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
            if (trimmed !== this.content) {
                this.split(this.end - trimmed.length);
                this.edit("", undefined, true);
            }
            return true;
        } else {
            this.edit("", undefined, true);
            this.outro = this.outro.replace(rx, "");
            if (this.outro.length) return true;
        }
    };
    var btoa$2 = function() {
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") btoa$2 = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
    };
    else if (typeof Buffer === "function") btoa$2 = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
    };
    var SourceMap$1 = function SourceMap(properties) {
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = encode(properties.mappings);
    };
    SourceMap$1.prototype.toString = function toString() {
        return JSON.stringify(this);
    };
    SourceMap$1.prototype.toUrl = function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
    };
    function guessIndent(code) {
        var lines = code.split("\n");
        var tabbed = lines.filter(function(line) {
            return /^\t+/.test(line);
        });
        var spaced = lines.filter(function(line) {
            return /^ {2,}/.test(line);
        });
        if (tabbed.length === 0 && spaced.length === 0) return null;
        // More lines tabbed than spaced? Assume tabs, and
        // default to tabs in the case of a tie (or nothing
        // to go on)
        if (tabbed.length >= spaced.length) return "	";
        // Otherwise, we need to guess the multiple
        var min = spaced.reduce(function(previous, current) {
            var numSpaces = /^ +/.exec(current)[0].length;
            return Math.min(numSpaces, previous);
        }, Infinity);
        return new Array(min + 1).join(" ");
    }
    function getRelativePath(from, to) {
        var fromParts = from.split(/[/\\]/);
        var toParts = to.split(/[/\\]/);
        fromParts.pop(); // get dirname
        while(fromParts[0] === toParts[0]){
            fromParts.shift();
            toParts.shift();
        }
        if (fromParts.length) {
            var i = fromParts.length;
            while(i--)fromParts[i] = "..";
        }
        return fromParts.concat(toParts).join("/");
    }
    var toString$2 = Object.prototype.toString;
    function isObject(thing) {
        return toString$2.call(thing) === "[object Object]";
    }
    function getLocator$1(source) {
        var originalLines = source.split("\n");
        var lineOffsets = [];
        for(var i = 0, pos = 0; i < originalLines.length; i++){
            lineOffsets.push(pos);
            pos += originalLines[i].length + 1;
        }
        return function locate(index) {
            var i = 0;
            var j = lineOffsets.length;
            while(i < j){
                var m = i + j >> 1;
                if (index < lineOffsets[m]) j = m;
                else i = m + 1;
            }
            var line = i - 1;
            var column = index - lineOffsets[line];
            return {
                line: line,
                column: column
            };
        };
    }
    var Mappings = function Mappings(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
    };
    Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
            var segment = [
                this.generatedCodeColumn,
                sourceIndex,
                loc.line,
                loc.column
            ];
            if (nameIndex >= 0) segment.push(nameIndex);
            this.rawSegments.push(segment);
        } else if (this.pending) this.rawSegments.push(this.pending);
        this.advance(content);
        this.pending = null;
    };
    Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        var originalCharIndex = chunk.start;
        var first = true;
        while(originalCharIndex < chunk.end){
            if (this.hires || first || sourcemapLocations[originalCharIndex]) this.rawSegments.push([
                this.generatedCodeColumn,
                sourceIndex,
                loc.line,
                loc.column
            ]);
            if (original[originalCharIndex] === "\n") {
                loc.line += 1;
                loc.column = 0;
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
            } else {
                loc.column += 1;
                this.generatedCodeColumn += 1;
            }
            originalCharIndex += 1;
            first = false;
        }
        this.pending = [
            this.generatedCodeColumn,
            sourceIndex,
            loc.line,
            loc.column
        ];
    };
    Mappings.prototype.advance = function advance(str) {
        if (!str) return;
        var lines = str.split("\n");
        if (lines.length > 1) {
            for(var i = 0; i < lines.length - 1; i++){
                this.generatedCodeLine++;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
            }
            this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    var n = "\n";
    var warned = {
        insertLeft: false,
        insertRight: false,
        storeName: false
    };
    var MagicString = function MagicString(string, options) {
        if (options === void 0) options = {};
        var chunk = new Chunk(0, string.length, string);
        Object.defineProperties(this, {
            original: {
                writable: true,
                value: string
            },
            outro: {
                writable: true,
                value: ""
            },
            intro: {
                writable: true,
                value: ""
            },
            firstChunk: {
                writable: true,
                value: chunk
            },
            lastChunk: {
                writable: true,
                value: chunk
            },
            lastSearchedChunk: {
                writable: true,
                value: chunk
            },
            byStart: {
                writable: true,
                value: {}
            },
            byEnd: {
                writable: true,
                value: {}
            },
            filename: {
                writable: true,
                value: options.filename
            },
            indentExclusionRanges: {
                writable: true,
                value: options.indentExclusionRanges
            },
            sourcemapLocations: {
                writable: true,
                value: {}
            },
            storedNames: {
                writable: true,
                value: {}
            },
            indentStr: {
                writable: true,
                value: guessIndent(string)
            }
        });
        this.byStart[0] = chunk;
        this.byEnd[string.length] = chunk;
    };
    MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
        this.sourcemapLocations[char] = true;
    };
    MagicString.prototype.append = function append(content) {
        if (typeof content !== "string") throw new TypeError("outro content must be a string");
        this.outro += content;
        return this;
    };
    MagicString.prototype.appendLeft = function appendLeft(index, content) {
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        var chunk = this.byEnd[index];
        if (chunk) chunk.appendLeft(content);
        else this.intro += content;
        return this;
    };
    MagicString.prototype.appendRight = function appendRight(index, content) {
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        var chunk = this.byStart[index];
        if (chunk) chunk.appendRight(content);
        else this.outro += content;
        return this;
    };
    MagicString.prototype.clone = function clone() {
        var cloned = new MagicString(this.original, {
            filename: this.filename
        });
        var originalChunk = this.firstChunk;
        var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while(originalChunk){
            cloned.byStart[clonedChunk.start] = clonedChunk;
            cloned.byEnd[clonedChunk.end] = clonedChunk;
            var nextOriginalChunk = originalChunk.next;
            var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
            if (nextClonedChunk) {
                clonedChunk.next = nextClonedChunk;
                nextClonedChunk.previous = clonedChunk;
                clonedChunk = nextClonedChunk;
            }
            originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        Object.keys(this.sourcemapLocations).forEach(function(loc) {
            cloned.sourcemapLocations[loc] = true;
        });
        return cloned;
    };
    MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
        var this$1 = this;
        options = options || {};
        var sourceIndex = 0;
        var names = Object.keys(this.storedNames);
        var mappings = new Mappings(options.hires);
        var locate = getLocator$1(this.original);
        if (this.intro) mappings.advance(this.intro);
        this.firstChunk.eachNext(function(chunk) {
            var loc = locate(chunk.start);
            if (chunk.intro.length) mappings.advance(chunk.intro);
            if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
            else mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
            if (chunk.outro.length) mappings.advance(chunk.outro);
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : null,
            sources: [
                options.source ? getRelativePath(options.file || "", options.source) : null
            ],
            sourcesContent: options.includeContent ? [
                this.original
            ] : [
                null
            ],
            names: names,
            mappings: mappings.raw
        };
    };
    MagicString.prototype.generateMap = function generateMap(options) {
        return new SourceMap$1(this.generateDecodedMap(options));
    };
    MagicString.prototype.getIndentString = function getIndentString() {
        return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString.prototype.indent = function indent(indentStr, options) {
        var pattern = /^[^\r\n]/gm;
        if (isObject(indentStr)) {
            options = indentStr;
            indentStr = undefined;
        }
        indentStr = indentStr !== undefined ? indentStr : this.indentStr || "	";
        if (indentStr === "") return this;
         // noop
        options = options || {};
        // Process exclusion ranges
        var isExcluded = {};
        if (options.exclude) {
            var exclusions = typeof options.exclude[0] === "number" ? [
                options.exclude
            ] : options.exclude;
            exclusions.forEach(function(exclusion) {
                for(var i = exclusion[0]; i < exclusion[1]; i += 1)isExcluded[i] = true;
            });
        }
        var shouldIndentNextCharacter = options.indentStart !== false;
        var replacer = function(match) {
            if (shouldIndentNextCharacter) return "" + indentStr + match;
            shouldIndentNextCharacter = true;
            return match;
        };
        this.intro = this.intro.replace(pattern, replacer);
        var charIndex = 0;
        var chunk = this.firstChunk;
        while(chunk){
            var end = chunk.end;
            if (chunk.edited) {
                if (!isExcluded[charIndex]) {
                    chunk.content = chunk.content.replace(pattern, replacer);
                    if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
                }
            } else {
                charIndex = chunk.start;
                while(charIndex < end){
                    if (!isExcluded[charIndex]) {
                        var char = this.original[charIndex];
                        if (char === "\n") shouldIndentNextCharacter = true;
                        else if (char !== "\r" && shouldIndentNextCharacter) {
                            shouldIndentNextCharacter = false;
                            if (charIndex === chunk.start) chunk.prependRight(indentStr);
                            else {
                                this._splitChunk(chunk, charIndex);
                                chunk = chunk.next;
                                chunk.prependRight(indentStr);
                            }
                        }
                    }
                    charIndex += 1;
                }
            }
            charIndex = chunk.end;
            chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern, replacer);
        return this;
    };
    MagicString.prototype.insert = function insert() {
        throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    };
    MagicString.prototype.insertLeft = function insertLeft(index, content) {
        if (!warned.insertLeft) {
            console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"); // eslint-disable-line no-console
            warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
    };
    MagicString.prototype.insertRight = function insertRight(index, content) {
        if (!warned.insertRight) {
            console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"); // eslint-disable-line no-console
            warned.insertRight = true;
        }
        return this.prependRight(index, content);
    };
    MagicString.prototype.move = function move(start, end, index) {
        if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
        this._split(start);
        this._split(end);
        this._split(index);
        var first = this.byStart[start];
        var last = this.byEnd[end];
        var oldLeft = first.previous;
        var oldRight = last.next;
        var newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk) return this;
        var newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;
        if (newLeft) newLeft.next = first;
        if (newRight) newRight.previous = last;
        if (!first.previous) this.firstChunk = last.next;
        if (!last.next) {
            this.lastChunk = first.previous;
            this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft) this.firstChunk = first;
        if (!newRight) this.lastChunk = last;
        return this;
    };
    MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
        if (typeof content !== "string") throw new TypeError("replacement content must be a string");
        while(start < 0)start += this.original.length;
        while(end < 0)end += this.original.length;
        if (end > this.original.length) throw new Error("end is out of bounds");
        if (start === end) throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
        this._split(start);
        this._split(end);
        if (options === true) {
            if (!warned.storeName) {
                console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"); // eslint-disable-line no-console
                warned.storeName = true;
            }
            options = {
                storeName: true
            };
        }
        var storeName = options !== undefined ? options.storeName : false;
        var contentOnly = options !== undefined ? options.contentOnly : false;
        if (storeName) {
            var original = this.original.slice(start, end);
            this.storedNames[original] = true;
        }
        var first = this.byStart[start];
        var last = this.byEnd[end];
        if (first) {
            if (end > first.end && first.next !== this.byStart[first.end]) throw new Error("Cannot overwrite across a split point");
            first.edit(content, storeName, contentOnly);
            if (first !== last) {
                var chunk = first.next;
                while(chunk !== last){
                    chunk.edit("", false);
                    chunk = chunk.next;
                }
                chunk.edit("", false);
            }
        } else {
            // must be inserting at the end
            var newChunk = new Chunk(start, end, "").edit(content, storeName);
            // TODO last chunk in the array may not be the last chunk, if it's moved...
            last.next = newChunk;
            newChunk.previous = last;
        }
        return this;
    };
    MagicString.prototype.prepend = function prepend(content) {
        if (typeof content !== "string") throw new TypeError("outro content must be a string");
        this.intro = content + this.intro;
        return this;
    };
    MagicString.prototype.prependLeft = function prependLeft(index, content) {
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        var chunk = this.byEnd[index];
        if (chunk) chunk.prependLeft(content);
        else this.intro = content + this.intro;
        return this;
    };
    MagicString.prototype.prependRight = function prependRight(index, content) {
        if (typeof content !== "string") throw new TypeError("inserted content must be a string");
        this._split(index);
        var chunk = this.byStart[index];
        if (chunk) chunk.prependRight(content);
        else this.outro = content + this.outro;
        return this;
    };
    MagicString.prototype.remove = function remove(start, end) {
        while(start < 0)start += this.original.length;
        while(end < 0)end += this.original.length;
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
        if (start > end) throw new Error("end must be greater than start");
        this._split(start);
        this._split(end);
        var chunk = this.byStart[start];
        while(chunk){
            chunk.intro = "";
            chunk.outro = "";
            chunk.edit("");
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    };
    MagicString.prototype.lastChar = function lastChar() {
        if (this.outro.length) return this.outro[this.outro.length - 1];
        var chunk = this.lastChunk;
        do {
            if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
            if (chunk.content.length) return chunk.content[chunk.content.length - 1];
            if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
        }while (chunk = chunk.previous);
        if (this.intro.length) return this.intro[this.intro.length - 1];
        return "";
    };
    MagicString.prototype.lastLine = function lastLine() {
        var lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
        var lineStr = this.outro;
        var chunk = this.lastChunk;
        do {
            if (chunk.outro.length > 0) {
                lineIndex = chunk.outro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.outro + lineStr;
            }
            if (chunk.content.length > 0) {
                lineIndex = chunk.content.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.content + lineStr;
            }
            if (chunk.intro.length > 0) {
                lineIndex = chunk.intro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.intro + lineStr;
            }
        }while (chunk = chunk.previous);
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
    };
    MagicString.prototype.slice = function slice(start, end) {
        if (start === void 0) start = 0;
        if (end === void 0) end = this.original.length;
        while(start < 0)start += this.original.length;
        while(end < 0)end += this.original.length;
        var result = "";
        // find start chunk
        var chunk = this.firstChunk;
        while(chunk && (chunk.start > start || chunk.end <= start)){
            // found end chunk before start
            if (chunk.start < end && chunk.end >= end) return result;
            chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
        var startChunk = chunk;
        while(chunk){
            if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
            var containsEnd = chunk.start < end && chunk.end >= end;
            if (containsEnd && chunk.edited && chunk.end !== end) throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
            var sliceStart = startChunk === chunk ? start - chunk.start : 0;
            var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
            result += chunk.content.slice(sliceStart, sliceEnd);
            if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
            if (containsEnd) break;
            chunk = chunk.next;
        }
        return result;
    };
    // TODO deprecate this? not really very useful
    MagicString.prototype.snip = function snip(start, end) {
        var clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
    };
    MagicString.prototype._split = function _split(index) {
        if (this.byStart[index] || this.byEnd[index]) return;
        var chunk = this.lastSearchedChunk;
        var searchForward = index > chunk.end;
        while(chunk){
            if (chunk.contains(index)) return this._splitChunk(chunk, index);
            chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
    };
    MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
            // zero-length edited chunks are a special case (overlapping replacements)
            var loc = getLocator$1(this.original)(index);
            throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
        }
        var newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
    };
    MagicString.prototype.toString = function toString() {
        var str = this.intro;
        var chunk = this.firstChunk;
        while(chunk){
            str += chunk.toString();
            chunk = chunk.next;
        }
        return str + this.outro;
    };
    MagicString.prototype.isEmpty = function isEmpty() {
        var chunk = this.firstChunk;
        do {
            if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
        }while (chunk = chunk.next);
        return true;
    };
    MagicString.prototype.length = function length() {
        var chunk = this.firstChunk;
        var length = 0;
        do length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        while (chunk = chunk.next);
        return length;
    };
    MagicString.prototype.trimLines = function trimLines() {
        return this.trim("[\\r\\n]");
    };
    MagicString.prototype.trim = function trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    };
    MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
        var rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) return true;
        var chunk = this.lastChunk;
        do {
            var end = chunk.end;
            var aborted = chunk.trimEnd(rx);
            // if chunk was trimmed, we have a new lastChunk
            if (chunk.end !== end) {
                if (this.lastChunk === chunk) this.lastChunk = chunk.next;
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.previous;
        }while (chunk);
        return false;
    };
    MagicString.prototype.trimEnd = function trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
    };
    MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
        var rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) return true;
        var chunk = this.firstChunk;
        do {
            var end = chunk.end;
            var aborted = chunk.trimStart(rx);
            if (chunk.end !== end) {
                // special case...
                if (chunk === this.lastChunk) this.lastChunk = chunk.next;
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.next;
        }while (chunk);
        return false;
    };
    MagicString.prototype.trimStart = function trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
    };
    const UNKNOWN = {};
    function gather_possible_values(node, set) {
        if (node.type === "Literal") set.add(node.value);
        else if (node.type === "ConditionalExpression") {
            gather_possible_values(node.consequent, set);
            gather_possible_values(node.alternate, set);
        } else set.add(UNKNOWN);
    }
    var BlockAppliesToNode;
    (function(BlockAppliesToNode) {
        BlockAppliesToNode[BlockAppliesToNode["NotPossible"] = 0] = "NotPossible";
        BlockAppliesToNode[BlockAppliesToNode["Possible"] = 1] = "Possible";
        BlockAppliesToNode[BlockAppliesToNode["UnknownSelectorType"] = 2] = "UnknownSelectorType";
    })(BlockAppliesToNode || (BlockAppliesToNode = {}));
    var NodeExist;
    (function(NodeExist) {
        NodeExist[NodeExist["Probably"] = 1] = "Probably";
        NodeExist[NodeExist["Definitely"] = 2] = "Definitely";
    })(NodeExist || (NodeExist = {}));
    const whitelist_attribute_selector = new Map([
        [
            "details",
            new Set([
                "open"
            ])
        ],
        [
            "dialog",
            new Set([
                "open"
            ])
        ]
    ]);
    const regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
    class Selector {
        constructor(node, stylesheet){
            this.node = node;
            this.stylesheet = stylesheet;
            this.blocks = group_selectors(node);
            // take trailing :global(...) selectors out of consideration
            let i = this.blocks.length;
            while(i > 0){
                if (!this.blocks[i - 1].global) break;
                i -= 1;
            }
            this.local_blocks = this.blocks.slice(0, i);
            const host_only = this.blocks.length === 1 && this.blocks[0].host;
            const root_only = this.blocks.length === 1 && this.blocks[0].root;
            this.used = this.local_blocks.length === 0 || host_only || root_only;
        }
        apply(node) {
            const to_encapsulate = [];
            apply_selector(this.local_blocks.slice(), node, to_encapsulate);
            if (to_encapsulate.length > 0) {
                to_encapsulate.forEach(({ node: node, block: block })=>{
                    this.stylesheet.nodes_with_css_class.add(node);
                    block.should_encapsulate = true;
                });
                this.used = true;
            }
        }
        minify(code) {
            let c = null;
            this.blocks.forEach((block, i)=>{
                if (i > 0) {
                    if (block.start - c > 1) code.overwrite(c, block.start, block.combinator.name || " ");
                }
                c = block.end;
            });
        }
        transform(code, attr, max_amount_class_specificity_increased) {
            const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block)=>block.should_encapsulate).length;
            function remove_global_pseudo_class(selector) {
                const first = selector.children[0];
                const last = selector.children[selector.children.length - 1];
                code.remove(selector.start, first.start).remove(last.end, selector.end);
            }
            function encapsulate_block(block, attr) {
                for (const selector of block.selectors)if (selector.type === "PseudoClassSelector" && selector.name === "global") remove_global_pseudo_class(selector);
                let i = block.selectors.length;
                while(i--){
                    const selector = block.selectors[i];
                    if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
                        if (selector.name !== "root" && selector.name !== "host") {
                            if (i === 0) code.prependRight(selector.start, attr);
                        }
                        continue;
                    }
                    if (selector.type === "TypeSelector" && selector.name === "*") code.overwrite(selector.start, selector.end, attr);
                    else code.appendLeft(selector.end, attr);
                    break;
                }
            }
            this.blocks.forEach((block, index)=>{
                if (block.global) remove_global_pseudo_class(block.selectors[0]);
                if (block.should_encapsulate) encapsulate_block(block, index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr);
            });
        }
        validate(component) {
            let start = 0;
            let end = this.blocks.length;
            for(; start < end; start += 1){
                if (!this.blocks[start].global) break;
            }
            for(; end > start; end -= 1){
                if (!this.blocks[end - 1].global) break;
            }
            for(let i = start; i < end; i += 1){
                if (this.blocks[i].global) return component.error(this.blocks[i].selectors[0], compiler_errors.css_invalid_global);
            }
            this.validate_global_with_multiple_selectors(component);
            this.validate_invalid_combinator_without_selector(component);
        }
        validate_global_with_multiple_selectors(component) {
            if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) // standalone :global() with multiple selectors is OK
            return;
            for (const block of this.blocks)for (const selector of block.selectors){
                if (selector.type === "PseudoClassSelector" && selector.name === "global") {
                    if (regex_is_single_css_selector.test(selector.children[0].value)) component.error(selector, compiler_errors.css_invalid_global_selector);
                }
            }
        }
        validate_invalid_combinator_without_selector(component) {
            for(let i = 0; i < this.blocks.length; i++){
                const block = this.blocks[i];
                if (block.combinator && block.selectors.length === 0) component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
                if (!block.combinator && block.selectors.length === 0) component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
            }
        }
        get_amount_class_specificity_increased() {
            let count = 0;
            for (const block of this.blocks)if (block.should_encapsulate) count++;
            return count;
        }
    }
    function apply_selector(blocks, node, to_encapsulate) {
        const block = blocks.pop();
        if (!block) return false;
        if (!node) return block.global && blocks.every((block)=>block.global) || block.host && blocks.length === 0;
        switch(block_might_apply_to_node(block, node)){
            case BlockAppliesToNode.NotPossible:
                return false;
            case BlockAppliesToNode.UnknownSelectorType:
                // bail. TODO figure out what these could be
                to_encapsulate.push({
                    node: node,
                    block: block
                });
                return true;
        }
        if (block.combinator) {
            if (block.combinator.type === "Combinator" && block.combinator.name === " ") {
                for (const ancestor_block of blocks){
                    if (ancestor_block.global) continue;
                    if (ancestor_block.host) {
                        to_encapsulate.push({
                            node: node,
                            block: block
                        });
                        return true;
                    }
                    let parent = node;
                    while(parent = get_element_parent(parent))if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible) to_encapsulate.push({
                        node: parent,
                        block: ancestor_block
                    });
                    if (to_encapsulate.length) {
                        to_encapsulate.push({
                            node: node,
                            block: block
                        });
                        return true;
                    }
                }
                if (blocks.every((block)=>block.global)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                return false;
            } else if (block.combinator.name === ">") {
                const has_global_parent = blocks.every((block)=>block.global);
                if (has_global_parent || apply_selector(blocks, get_element_parent(node), to_encapsulate)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                return false;
            } else if (block.combinator.name === "+" || block.combinator.name === "~") {
                const siblings = get_possible_element_siblings(node, block.combinator.name === "+");
                let has_match = false;
                // NOTE: if we have :global(), we couldn't figure out what is selected within `:global` due to the
                // css-tree limitation that does not parse the inner selector of :global
                // so unless we are sure there will be no sibling to match, we will consider it as matched
                const has_global = blocks.some((block)=>block.global);
                if (has_global) {
                    if (siblings.size === 0 && get_element_parent(node) !== null) return false;
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                for (const possible_sibling of siblings.keys())if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    has_match = true;
                }
                return has_match;
            }
            // TODO other combinators
            to_encapsulate.push({
                node: node,
                block: block
            });
            return true;
        }
        to_encapsulate.push({
            node: node,
            block: block
        });
        return true;
    }
    const regex_backslash_and_following_character = /\\(.)/g;
    function block_might_apply_to_node(block, node) {
        let i = block.selectors.length;
        while(i--){
            const selector = block.selectors[i];
            const name = typeof selector.name === "string" && selector.name.replace(regex_backslash_and_following_character, "$1");
            if (selector.type === "PseudoClassSelector" && (name === "host" || name === "root")) return BlockAppliesToNode.NotPossible;
            if (block.selectors.length === 1 && selector.type === "PseudoClassSelector" && name === "global") return BlockAppliesToNode.NotPossible;
            if (selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector") continue;
            if (selector.type === "ClassSelector") {
                if (!attribute_matches(node, "class", name, "~=", false) && !node.classes.some((c)=>c.name === name)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "IdSelector") {
                if (!attribute_matches(node, "id", name, "=", false)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "AttributeSelector") {
                if (!(whitelist_attribute_selector.has(node.name.toLowerCase()) && whitelist_attribute_selector.get(node.name.toLowerCase()).has(selector.name.name.toLowerCase())) && !attribute_matches(node, selector.name.name, selector.value && unquote(selector.value), selector.matcher, selector.flags)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "TypeSelector") {
                if (node.name.toLowerCase() !== name.toLowerCase() && name !== "*" && !node.is_dynamic_element) return BlockAppliesToNode.NotPossible;
            } else return BlockAppliesToNode.UnknownSelectorType;
        }
        return BlockAppliesToNode.Possible;
    }
    function test_attribute(operator, expected_value, case_insensitive, value) {
        if (case_insensitive) {
            expected_value = expected_value.toLowerCase();
            value = value.toLowerCase();
        }
        switch(operator){
            case "=":
                return value === expected_value;
            case "~=":
                return value.split(/\s/).includes(expected_value);
            case "|=":
                return `${value}-`.startsWith(`${expected_value}-`);
            case "^=":
                return value.startsWith(expected_value);
            case "$=":
                return value.endsWith(expected_value);
            case "*=":
                return value.includes(expected_value);
            default:
                throw new Error("this shouldn't happen");
        }
    }
    function attribute_matches(node, name, expected_value, operator, case_insensitive) {
        const spread = node.attributes.find((attr)=>attr.type === "Spread");
        if (spread) return true;
        if (node.bindings.some((binding)=>binding.name === name)) return true;
        const attr = node.attributes.find((attr)=>attr.name === name);
        if (!attr) return false;
        if (attr.is_true) return operator === null;
        if (!expected_value) return true;
        if (attr.chunks.length === 1) {
            const value = attr.chunks[0];
            if (!value) return false;
            if (value.type === "Text") return test_attribute(operator, expected_value, case_insensitive, value.data);
        }
        const possible_values = new Set();
        let prev_values = [];
        for (const chunk of attr.chunks){
            const current_possible_values = new Set();
            if (chunk.type === "Text") current_possible_values.add(chunk.data);
            else gather_possible_values(chunk.node, current_possible_values);
            // impossible to find out all combinations
            if (current_possible_values.has(UNKNOWN)) return true;
            if (prev_values.length > 0) {
                const start_with_space = [];
                const remaining = [];
                current_possible_values.forEach((current_possible_value)=>{
                    if (regex_starts_with_whitespace.test(current_possible_value)) start_with_space.push(current_possible_value);
                    else remaining.push(current_possible_value);
                });
                if (remaining.length > 0) {
                    if (start_with_space.length > 0) prev_values.forEach((prev_value)=>possible_values.add(prev_value));
                    const combined = [];
                    prev_values.forEach((prev_value)=>{
                        remaining.forEach((value)=>{
                            combined.push(prev_value + value);
                        });
                    });
                    prev_values = combined;
                    start_with_space.forEach((value)=>{
                        if (regex_ends_with_whitespace.test(value)) possible_values.add(value);
                        else prev_values.push(value);
                    });
                    continue;
                } else {
                    prev_values.forEach((prev_value)=>possible_values.add(prev_value));
                    prev_values = [];
                }
            }
            current_possible_values.forEach((current_possible_value)=>{
                if (regex_ends_with_whitespace.test(current_possible_value)) possible_values.add(current_possible_value);
                else prev_values.push(current_possible_value);
            });
            if (prev_values.length < current_possible_values.size) prev_values.push(" ");
            if (prev_values.length > 20) // might grow exponentially, bail out
            return true;
        }
        prev_values.forEach((prev_value)=>possible_values.add(prev_value));
        if (possible_values.has(UNKNOWN)) return true;
        for (const value of possible_values){
            if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
        }
        return false;
    }
    function unquote(value) {
        if (value.type === "Identifier") return value.name;
        const str = value.value;
        if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') return str.slice(1, str.length - 1);
        return str;
    }
    function get_element_parent(node) {
        let parent = node;
        while((parent = parent.parent) && parent.type !== "Element");
        return parent;
    }
    function get_possible_element_siblings(node, adjacent_only) {
        const result = new Map();
        let prev = node;
        while(prev = prev.prev){
            if (prev.type === "Element") {
                if (!prev.attributes.find((attr)=>attr.type === "Attribute" && attr.name.toLowerCase() === "slot")) result.set(prev, NodeExist.Definitely);
                if (adjacent_only) break;
            } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
                const possible_last_child = get_possible_last_child(prev, adjacent_only);
                add_to_map(possible_last_child, result);
                if (adjacent_only && has_definite_elements(possible_last_child)) return result;
            }
        }
        if (!prev || !adjacent_only) {
            let parent = node;
            let skip_each_for_last_child = node.type === "ElseBlock";
            while((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")){
                const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
                add_to_map(possible_siblings, result);
                if (parent.type === "EachBlock") {
                    // first child of each block can select the last child of each block as previous sibling
                    if (skip_each_for_last_child) skip_each_for_last_child = false;
                    else add_to_map(get_possible_last_child(parent, adjacent_only), result);
                } else if (parent.type === "ElseBlock") {
                    skip_each_for_last_child = true;
                    parent = parent.parent;
                }
                if (adjacent_only && has_definite_elements(possible_siblings)) break;
            }
        }
        return result;
    }
    function get_possible_last_child(block, adjacent_only) {
        const result = new Map();
        if (block.type === "EachBlock") {
            const each_result = loop_child(block.children, adjacent_only);
            const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(else_result);
            if (not_exhaustive) {
                mark_as_probably(each_result);
                mark_as_probably(else_result);
            }
            add_to_map(each_result, result);
            add_to_map(else_result, result);
        } else if (block.type === "IfBlock") {
            const if_result = loop_child(block.children, adjacent_only);
            const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
            if (not_exhaustive) {
                mark_as_probably(if_result);
                mark_as_probably(else_result);
            }
            add_to_map(if_result, result);
            add_to_map(else_result, result);
        } else if (block.type === "AwaitBlock") {
            const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : new Map();
            const then_result = block.then ? loop_child(block.then.children, adjacent_only) : new Map();
            const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
            if (not_exhaustive) {
                mark_as_probably(pending_result);
                mark_as_probably(then_result);
                mark_as_probably(catch_result);
            }
            add_to_map(pending_result, result);
            add_to_map(then_result, result);
            add_to_map(catch_result, result);
        }
        return result;
    }
    function has_definite_elements(result) {
        if (result.size === 0) return false;
        for (const exist of result.values()){
            if (exist === NodeExist.Definitely) return true;
        }
        return false;
    }
    function add_to_map(from, to) {
        from.forEach((exist, element)=>{
            to.set(element, higher_existence(exist, to.get(element)));
        });
    }
    function higher_existence(exist1, exist2) {
        if (exist1 === undefined || exist2 === undefined) return exist1 || exist2;
        return exist1 > exist2 ? exist1 : exist2;
    }
    function mark_as_probably(result) {
        for (const key of result.keys())result.set(key, NodeExist.Probably);
    }
    function loop_child(children, adjacent_only) {
        const result = new Map();
        for(let i = children.length - 1; i >= 0; i--){
            const child = children[i];
            if (child.type === "Element") {
                result.set(child, NodeExist.Definitely);
                if (adjacent_only) break;
            } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
                const child_result = get_possible_last_child(child, adjacent_only);
                add_to_map(child_result, result);
                if (adjacent_only && has_definite_elements(child_result)) break;
            }
        }
        return result;
    }
    class Block$1 {
        constructor(combinator){
            this.combinator = combinator;
            this.host = false;
            this.root = false;
            this.selectors = [];
            this.start = null;
            this.end = null;
            this.should_encapsulate = false;
        }
        add(selector) {
            if (this.selectors.length === 0) {
                this.start = selector.start;
                this.host = selector.type === "PseudoClassSelector" && selector.name === "host";
            }
            this.root = this.root || selector.type === "PseudoClassSelector" && selector.name === "root";
            this.selectors.push(selector);
            this.end = selector.end;
        }
        get global() {
            return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every((selector)=>selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector");
        }
    }
    function group_selectors(selector) {
        let block = new Block$1(null);
        const blocks = [
            block
        ];
        selector.children.forEach((child)=>{
            if (child.type === "WhiteSpace" || child.type === "Combinator") {
                block = new Block$1(child);
                blocks.push(block);
            } else block.add(child);
        });
        return blocks;
    }
    const regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
    function remove_css_prefix(name) {
        return name.replace(regex_css_browser_prefix, "");
    }
    const is_keyframes_node = (node)=>remove_css_prefix(node.name) === "keyframes";
    const at_rule_has_declaration = ({ block: block })=>block && block.children && block.children.find((node)=>node.type === "Declaration");
    function minify_declarations(code, start, declarations) {
        let c = start;
        declarations.forEach((declaration, i)=>{
            const separator = i > 0 ? ";" : "";
            if (declaration.node.start - c > separator.length) code.overwrite(c, declaration.node.start, separator);
            declaration.minify(code);
            c = declaration.node.end;
        });
        return c;
    }
    class Rule {
        constructor(node, stylesheet, parent){
            this.node = node;
            this.parent = parent;
            this.selectors = node.prelude.children.map((node)=>new Selector(node, stylesheet));
            this.declarations = node.block.children.map((node)=>new Declaration(node));
        }
        apply(node) {
            this.selectors.forEach((selector)=>selector.apply(node)); // TODO move the logic in here?
        }
        is_used(dev) {
            if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) return true;
            if (this.declarations.length === 0) return dev;
            return this.selectors.some((s)=>s.used);
        }
        minify(code, _dev) {
            let c = this.node.start;
            let started = false;
            this.selectors.forEach((selector)=>{
                if (selector.used) {
                    const separator = started ? "," : "";
                    if (selector.node.start - c > separator.length) code.overwrite(c, selector.node.start, separator);
                    selector.minify(code);
                    c = selector.node.end;
                    started = true;
                }
            });
            code.remove(c, this.node.block.start);
            c = this.node.block.start + 1;
            c = minify_declarations(code, c, this.declarations);
            code.remove(c, this.node.block.end - 1);
        }
        transform(code, id, keyframes, max_amount_class_specificity_increased) {
            if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) return true;
            const attr = `.${id}`;
            this.selectors.forEach((selector)=>selector.transform(code, attr, max_amount_class_specificity_increased));
            this.declarations.forEach((declaration)=>declaration.transform(code, keyframes));
        }
        validate(component) {
            this.selectors.forEach((selector)=>{
                selector.validate(component);
            });
        }
        warn_on_unused_selector(handler) {
            this.selectors.forEach((selector)=>{
                if (!selector.used) handler(selector);
            });
        }
        get_max_amount_class_specificity_increased() {
            return Math.max(...this.selectors.map((selector)=>selector.get_amount_class_specificity_increased()));
        }
    }
    class Declaration {
        constructor(node){
            this.node = node;
        }
        transform(code, keyframes) {
            const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
            if (property === "animation" || property === "animation-name") this.node.value.children.forEach((block)=>{
                if (block.type === "Identifier") {
                    const name = block.name;
                    if (keyframes.has(name)) code.overwrite(block.start, block.end, keyframes.get(name));
                }
            });
        }
        minify(code) {
            if (!this.node.property) return; // @apply, and possibly other weird cases?
            const c = this.node.start + this.node.property.length;
            const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
            // Don't minify whitespace in custom properties, since some browsers (Chromium < 99)
            // treat --foo: ; and --foo:; differently
            if (first.type === "Raw" && regex_only_whitespaces.test(first.value)) return;
            let start = first.start;
            while(regex_whitespace.test(code.original[start]))start += 1;
            if (start - c > 1) code.overwrite(c, start, ":");
        }
    }
    class Atrule {
        constructor(node){
            this.node = node;
            this.children = [];
            this.declarations = [];
        }
        apply(node) {
            if (this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") this.children.forEach((child)=>{
                child.apply(node);
            });
            else if (is_keyframes_node(this.node)) this.children.forEach((rule)=>{
                rule.selectors.forEach((selector)=>{
                    selector.used = true;
                });
            });
        }
        is_used(_dev) {
            return true; // TODO
        }
        minify(code, dev) {
            if (this.node.name === "media") {
                const expression_char = code.original[this.node.prelude.start];
                let c = this.node.start + (expression_char === "(" ? 6 : 7);
                if (this.node.prelude.start > c) code.remove(c, this.node.prelude.start);
                this.node.prelude.children.forEach((query)=>{
                    // TODO minify queries
                    c = query.end;
                });
                code.remove(c, this.node.block.start);
            } else if (this.node.name === "supports") {
                let c = this.node.start + 9;
                if (this.node.prelude.start - c > 1) code.overwrite(c, this.node.prelude.start, " ");
                this.node.prelude.children.forEach((query)=>{
                    // TODO minify queries
                    c = query.end;
                });
                code.remove(c, this.node.block.start);
            } else {
                let c = this.node.start + this.node.name.length + 1;
                if (this.node.prelude) {
                    if (this.node.prelude.start - c > 1) code.overwrite(c, this.node.prelude.start, " ");
                    c = this.node.prelude.end;
                }
                if (this.node.block && this.node.block.start - c > 0) code.remove(c, this.node.block.start);
            }
            // TODO other atrules
            if (this.node.block) {
                let c = this.node.block.start + 1;
                if (this.declarations.length) {
                    c = minify_declarations(code, c, this.declarations);
                    // if the atrule has children, leave the last declaration semicolon alone
                    if (this.children.length) c++;
                }
                this.children.forEach((child)=>{
                    if (child.is_used(dev)) {
                        code.remove(c, child.node.start);
                        child.minify(code, dev);
                        c = child.node.end;
                    }
                });
                code.remove(c, this.node.block.end - 1);
            }
        }
        transform(code, id, keyframes, max_amount_class_specificity_increased) {
            if (is_keyframes_node(this.node)) this.node.prelude.children.forEach(({ type: type, name: name, start: start, end: end })=>{
                if (type === "Identifier") {
                    if (name.startsWith("-global-")) {
                        code.remove(start, start + 8);
                        this.children.forEach((rule)=>{
                            rule.selectors.forEach((selector)=>{
                                selector.used = true;
                            });
                        });
                    } else code.overwrite(start, end, keyframes.get(name));
                }
            });
            this.children.forEach((child)=>{
                child.transform(code, id, keyframes, max_amount_class_specificity_increased);
            });
        }
        validate(component) {
            this.children.forEach((child)=>{
                child.validate(component);
            });
        }
        warn_on_unused_selector(handler) {
            if (this.node.name !== "media") return;
            this.children.forEach((child)=>{
                child.warn_on_unused_selector(handler);
            });
        }
        get_max_amount_class_specificity_increased() {
            return Math.max(...this.children.map((rule)=>rule.get_max_amount_class_specificity_increased()));
        }
    }
    const get_default_css_hash = ({ css: css, hash: hash })=>{
        return `svelte-${hash(css)}`;
    };
    class Stylesheet {
        constructor({ source: source, ast: ast, component_name: component_name, filename: filename, dev: dev, get_css_hash: get_css_hash = get_default_css_hash }){
            this.children = [];
            this.keyframes = new Map();
            this.nodes_with_css_class = new Set();
            this.source = source;
            this.ast = ast;
            this.filename = filename;
            this.dev = dev;
            if (ast.css && ast.css.children.length) {
                this.id = get_css_hash({
                    filename: filename,
                    name: component_name,
                    css: ast.css.content.styles,
                    hash: hash
                });
                this.has_styles = true;
                const stack = [];
                let depth = 0;
                let current_atrule = null;
                walk(ast.css, {
                    enter: (node)=>{
                        if (node.type === "Atrule") {
                            const atrule = new Atrule(node);
                            stack.push(atrule);
                            if (current_atrule) current_atrule.children.push(atrule);
                            else if (depth <= 1) this.children.push(atrule);
                            if (is_keyframes_node(node)) node.prelude.children.forEach((expression)=>{
                                if (expression.type === "Identifier" && !expression.name.startsWith("-global-")) this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
                            });
                            else if (at_rule_has_declaration(node)) {
                                const at_rule_declarations = node.block.children.filter((node)=>node.type === "Declaration").map((node)=>new Declaration(node));
                                push_array$1(atrule.declarations, at_rule_declarations);
                            }
                            current_atrule = atrule;
                        }
                        if (node.type === "Rule") {
                            const rule = new Rule(node, this, current_atrule);
                            if (current_atrule) current_atrule.children.push(rule);
                            else if (depth <= 1) this.children.push(rule);
                        }
                        depth += 1;
                    },
                    leave: (node)=>{
                        if (node.type === "Atrule") {
                            stack.pop();
                            current_atrule = stack[stack.length - 1];
                        }
                        depth -= 1;
                    }
                });
            } else this.has_styles = false;
        }
        apply(node) {
            if (!this.has_styles) return;
            for(let i = 0; i < this.children.length; i += 1){
                const child = this.children[i];
                child.apply(node);
            }
        }
        reify() {
            this.nodes_with_css_class.forEach((node)=>{
                node.add_css_class();
            });
        }
        render(file, should_transform_selectors) {
            if (!this.has_styles) return {
                code: null,
                map: null
            };
            const code = new MagicString(this.source);
            walk(this.ast.css, {
                enter: (node)=>{
                    code.addSourcemapLocation(node.start);
                    code.addSourcemapLocation(node.end);
                }
            });
            if (should_transform_selectors) {
                const max = Math.max(...this.children.map((rule)=>rule.get_max_amount_class_specificity_increased()));
                this.children.forEach((child)=>{
                    child.transform(code, this.id, this.keyframes, max);
                });
            }
            let c = 0;
            this.children.forEach((child)=>{
                if (child.is_used(this.dev)) {
                    code.remove(c, child.node.start);
                    child.minify(code, this.dev);
                    c = child.node.end;
                }
            });
            code.remove(c, this.source.length);
            return {
                code: code.toString(),
                map: code.generateMap({
                    includeContent: true,
                    source: this.filename,
                    file: file
                })
            };
        }
        validate(component) {
            this.children.forEach((child)=>{
                child.validate(component);
            });
        }
        warn_on_unused_selectors(component) {
            const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
            component.push_ignores(ignores);
            this.children.forEach((child)=>{
                child.warn_on_unused_selector((selector)=>{
                    component.warn(selector.node, compiler_warnings.css_unused_selector(this.source.slice(selector.node.start, selector.node.end)));
                });
            });
            component.pop_ignores();
        }
    }
    const test = typeof process !== "undefined" && process.env.TEST;
    class TemplateScope {
        constructor(parent){
            this.owners = new Map();
            this.parent = parent;
            this.names = new Set(parent ? parent.names : []);
            this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
        }
        add(name, dependencies, owner) {
            this.names.add(name);
            this.dependencies_for_name.set(name, dependencies);
            this.owners.set(name, owner);
            return this;
        }
        child() {
            const child = new TemplateScope(this);
            return child;
        }
        is_top_level(name) {
            return !this.parent || !this.names.has(name) && this.parent.is_top_level(name);
        }
        get_owner(name) {
            return this.owners.get(name) || this.parent && this.parent.get_owner(name);
        }
        is_let(name) {
            const owner = this.get_owner(name);
            return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
        }
        is_await(name) {
            const owner = this.get_owner(name);
            return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
        }
        is_const(name) {
            const owner = this.get_owner(name);
            return owner && owner.type === "ConstTag";
        }
    }
    class Fragment extends Node$1 {
        constructor(component, info){
            const scope = new TemplateScope();
            super(component, null, scope, info);
            this.scope = scope;
            this.children = map_children(component, this, scope, info.children);
        }
    }
    // This file is automatically generated
    var internal_exports = new Set([
        "HtmlTag",
        "HtmlTagHydration",
        "SvelteComponent",
        "SvelteComponentDev",
        "SvelteComponentTyped",
        "SvelteElement",
        "action_destroyer",
        "add_attribute",
        "add_classes",
        "add_flush_callback",
        "add_location",
        "add_render_callback",
        "add_resize_listener",
        "add_styles",
        "add_transform",
        "afterUpdate",
        "append",
        "append_dev",
        "append_empty_stylesheet",
        "append_hydration",
        "append_hydration_dev",
        "append_styles",
        "assign",
        "attr",
        "attr_dev",
        "attribute_to_object",
        "beforeUpdate",
        "bind",
        "binding_callbacks",
        "blank_object",
        "bubble",
        "check_outros",
        "children",
        "claim_component",
        "claim_element",
        "claim_html_tag",
        "claim_space",
        "claim_svg_element",
        "claim_text",
        "clear_loops",
        "component_subscribe",
        "compute_rest_props",
        "compute_slots",
        "construct_svelte_component",
        "construct_svelte_component_dev",
        "createEventDispatcher",
        "create_animation",
        "create_bidirectional_transition",
        "create_component",
        "create_in_transition",
        "create_out_transition",
        "create_slot",
        "create_ssr_component",
        "current_component",
        "custom_event",
        "dataset_dev",
        "debug",
        "destroy_block",
        "destroy_component",
        "destroy_each",
        "detach",
        "detach_after_dev",
        "detach_before_dev",
        "detach_between_dev",
        "detach_dev",
        "dirty_components",
        "dispatch_dev",
        "each",
        "element",
        "element_is",
        "empty",
        "end_hydrating",
        "escape",
        "escape_attribute_value",
        "escape_object",
        "exclude_internal_props",
        "fix_and_destroy_block",
        "fix_and_outro_and_destroy_block",
        "fix_position",
        "flush",
        "getAllContexts",
        "getContext",
        "get_all_dirty_from_scope",
        "get_binding_group_value",
        "get_current_component",
        "get_custom_elements_slots",
        "get_root_for_style",
        "get_slot_changes",
        "get_spread_object",
        "get_spread_update",
        "get_store_value",
        "globals",
        "group_outros",
        "handle_promise",
        "hasContext",
        "has_prop",
        "head_selector",
        "identity",
        "init",
        "insert",
        "insert_dev",
        "insert_hydration",
        "insert_hydration_dev",
        "intros",
        "invalid_attribute_name_character",
        "is_client",
        "is_crossorigin",
        "is_empty",
        "is_function",
        "is_promise",
        "is_void",
        "listen",
        "listen_dev",
        "loop",
        "loop_guard",
        "merge_ssr_styles",
        "missing_component",
        "mount_component",
        "noop",
        "not_equal",
        "now",
        "null_to_empty",
        "object_without_properties",
        "onDestroy",
        "onMount",
        "once",
        "outro_and_destroy_block",
        "prevent_default",
        "prop_dev",
        "query_selector_all",
        "raf",
        "run",
        "run_all",
        "safe_not_equal",
        "schedule_update",
        "select_multiple_value",
        "select_option",
        "select_options",
        "select_value",
        "self",
        "setContext",
        "set_attributes",
        "set_current_component",
        "set_custom_element_data",
        "set_custom_element_data_map",
        "set_data",
        "set_data_dev",
        "set_input_type",
        "set_input_value",
        "set_now",
        "set_raf",
        "set_store_value",
        "set_style",
        "set_svg_attributes",
        "space",
        "spread",
        "src_url_equal",
        "start_hydrating",
        "stop_propagation",
        "subscribe",
        "svg_element",
        "text",
        "tick",
        "time_ranges_to_array",
        "to_number",
        "toggle_class",
        "transition_in",
        "transition_out",
        "trusted",
        "update_await_block_branch",
        "update_keyed_each",
        "update_slot",
        "update_slot_base",
        "validate_component",
        "validate_dynamic_element",
        "validate_each_argument",
        "validate_each_keys",
        "validate_slots",
        "validate_store",
        "validate_void_dynamic_element",
        "xlink_attr"
    ]);
    function is_used_as_reference(node, parent) {
        if (!is_reference(node, parent)) return false;
        if (!parent) return true;
        /* eslint-disable no-fallthrough */ switch(parent.type){
            // disregard the `foo` in `const foo = bar`
            case "VariableDeclarator":
                return node !== parent.id;
            // disregard the `foo`, `bar` in `function foo(bar){}`
            case "FunctionDeclaration":
            // disregard the `foo` in `import { foo } from 'foo'`
            case "ImportSpecifier":
            // disregard the `foo` in `import foo from 'foo'`
            case "ImportDefaultSpecifier":
            // disregard the `foo` in `import * as foo from 'foo'`
            case "ImportNamespaceSpecifier":
            // disregard the `foo` in `export { foo }`
            case "ExportSpecifier":
                return false;
            default:
                return true;
        }
    }
    const regex_leading_directory_separator = /^[/\\]/;
    const regex_starts_with_term_export = /^Export/;
    const regex_contains_term_function = /Function/;
    class Component {
        constructor(ast, source, name, compile_options, stats, warnings){
            this.ignore_stack = [];
            this.vars = [];
            this.var_lookup = new Map();
            this.imports = [];
            this.exports_from = [];
            this.instance_exports_from = [];
            this.hoistable_nodes = new Set();
            this.node_for_declaration = new Map();
            this.partly_hoisted = [];
            this.fully_hoisted = [];
            this.reactive_declarations = [];
            this.reactive_declaration_nodes = new Set();
            this.has_reactive_assignments = false;
            this.injected_reactive_declaration_vars = new Set();
            this.helpers = new Map();
            this.globals = new Map();
            this.indirect_dependencies = new Map();
            this.elements = [];
            this.aliases = new Map();
            this.used_names = new Set();
            this.globally_used_names = new Set();
            this.slots = new Map();
            this.slot_outlets = new Set();
            this.name = {
                type: "Identifier",
                name: name
            };
            this.stats = stats;
            this.warnings = warnings;
            this.ast = ast;
            this.source = source;
            this.compile_options = compile_options;
            // the instance JS gets mutated, so we park
            // a copy here for later. TODO this feels gross
            this.original_ast = clone({
                html: ast.html,
                css: ast.css,
                instance: ast.instance,
                module: ast.module
            });
            this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(regex_leading_directory_separator, "") : compile_options.filename);
            this.locate = getLocator(this.source, {
                offsetLine: 1
            });
            // styles
            this.stylesheet = new Stylesheet({
                source: source,
                ast: ast,
                filename: compile_options.filename,
                component_name: name,
                dev: compile_options.dev,
                get_css_hash: compile_options.cssHash
            });
            this.stylesheet.validate(this);
            this.component_options = process_component_options(this, this.ast.html.children);
            this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
            if (compile_options.customElement) {
                if (this.component_options.tag === undefined && compile_options.tag === undefined) {
                    const svelteOptions = ast.html.children.find((child)=>child.name === "svelte:options") || {
                        start: 0,
                        end: 0
                    };
                    this.warn(svelteOptions, compiler_warnings.custom_element_no_tag);
                }
                this.tag = this.component_options.tag || compile_options.tag;
            } else this.tag = this.name.name;
            this.walk_module_js();
            this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
            this.walk_instance_js_pre_template();
            this.pop_ignores();
            this.fragment = new Fragment(this, ast.html);
            this.name = this.get_unique_name(name);
            this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
            this.walk_instance_js_post_template();
            this.pop_ignores();
            this.elements.forEach((element)=>this.stylesheet.apply(element));
            if (!compile_options.customElement) this.stylesheet.reify();
            this.stylesheet.warn_on_unused_selectors(this);
        }
        add_var(node, variable, add_to_lookup = true) {
            this.vars.push(variable);
            if (add_to_lookup) {
                if (this.var_lookup.has(variable.name)) {
                    const exists_var = this.var_lookup.get(variable.name);
                    if (exists_var.module && exists_var.imported) this.error(node, compiler_errors.illegal_variable_declaration);
                }
                this.var_lookup.set(variable.name, variable);
            }
        }
        add_reference(node, name) {
            const variable = this.var_lookup.get(name);
            if (variable) variable.referenced = true;
            else if (is_reserved_keyword(name)) this.add_var(node, {
                name: name,
                injected: true,
                referenced: true
            });
            else if (name[0] === "$") {
                this.add_var(node, {
                    name: name,
                    injected: true,
                    referenced: true,
                    mutated: true,
                    writable: true
                });
                const subscribable_name = name.slice(1);
                const variable = this.var_lookup.get(subscribable_name);
                if (variable) {
                    variable.referenced = true;
                    variable.subscribable = true;
                }
            } else {
                if (this.compile_options.varsReport === "full") this.add_var(node, {
                    name: name,
                    referenced: true
                }, false);
                this.used_names.add(name);
            }
        }
        alias(name) {
            if (!this.aliases.has(name)) this.aliases.set(name, this.get_unique_name(name));
            return this.aliases.get(name);
        }
        apply_stylesheet(element) {
            this.elements.push(element);
        }
        global(name) {
            const alias = this.alias(name);
            this.globals.set(name, alias);
            return alias;
        }
        generate(result) {
            let js = null;
            let css = null;
            if (result) {
                const { compile_options: compile_options, name: name } = this;
                const { format: format = "esm" } = compile_options;
                const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${"3.55.0"}`;
                const program = {
                    type: "Program",
                    body: result.js
                };
                walk(program, {
                    enter: (node, parent, key)=>{
                        if (node.type === "Identifier") {
                            if (node.name[0] === "@") {
                                if (node.name[1] === "_") {
                                    const alias = this.global(node.name.slice(2));
                                    node.name = alias.name;
                                } else {
                                    let name = node.name.slice(1);
                                    if (compile_options.hydratable) {
                                        if (internal_exports.has(`${name}_hydration`)) name += "_hydration";
                                        else if (internal_exports.has(`${name}Hydration`)) name += "Hydration";
                                    }
                                    if (compile_options.dev) {
                                        if (internal_exports.has(`${name}_dev`)) name += "_dev";
                                        else if (internal_exports.has(`${name}Dev`)) name += "Dev";
                                    }
                                    const alias = this.alias(name);
                                    this.helpers.set(name, alias);
                                    node.name = alias.name;
                                }
                            } else if (node.name[0] !== "#" && !is_valid(node.name)) {
                                // this hack allows x`foo.${bar}` where bar could be invalid
                                const literal = {
                                    type: "Literal",
                                    value: node.name
                                };
                                if (parent.type === "Property" && key === "key") parent.key = literal;
                                else if (parent.type === "MemberExpression" && key === "property") {
                                    parent.property = literal;
                                    parent.computed = true;
                                }
                            }
                        }
                    }
                });
                const referenced_globals = Array.from(this.globals, ([name, alias])=>name !== alias.name && {
                        name: name,
                        alias: alias
                    }).filter(Boolean);
                if (referenced_globals.length) this.helpers.set("globals", this.alias("globals"));
                const imported_helpers = Array.from(this.helpers, ([name, alias])=>({
                        name: name,
                        alias: alias
                    }));
                create_module(program, format, name, banner, compile_options.sveltePath, imported_helpers, referenced_globals, this.imports, this.vars.filter((variable)=>variable.module && variable.export_name).map((variable)=>({
                        name: variable.name,
                        as: variable.export_name
                    })), this.exports_from);
                css = compile_options.customElement ? {
                    code: null,
                    map: null
                } : result.css;
                const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, "js");
                if (!js_sourcemap_enabled) {
                    js = print(program);
                    js.map = null;
                } else {
                    const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
                    js = print(program, {
                        sourceMapSource: sourcemap_source_filename
                    });
                    js.map.sources = [
                        sourcemap_source_filename
                    ];
                    js.map.sourcesContent = [
                        this.source
                    ];
                    js.map = apply_preprocessor_sourcemap(sourcemap_source_filename, js.map, compile_options.sourcemap);
                }
            }
            return {
                js: js,
                css: css,
                ast: this.original_ast,
                warnings: this.warnings,
                vars: this.get_vars_report(),
                stats: this.stats.render()
            };
        }
        get_unique_name(name, scope) {
            if (test) name = `${name}$`;
            let alias = name;
            for(let i = 1; reserved.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope && scope.has(alias); alias = `${name}_${i++}`);
            this.used_names.add(alias);
            return {
                type: "Identifier",
                name: alias
            };
        }
        get_unique_name_maker() {
            const local_used_names = new Set();
            function add(name) {
                local_used_names.add(name);
            }
            reserved.forEach(add);
            internal_exports.forEach(add);
            this.var_lookup.forEach((_value, key)=>add(key));
            return (name)=>{
                if (test) name = `${name}$`;
                let alias = name;
                for(let i = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name}_${i++}`);
                local_used_names.add(alias);
                this.globally_used_names.add(alias);
                return {
                    type: "Identifier",
                    name: alias
                };
            };
        }
        get_vars_report() {
            const { compile_options: compile_options, vars: vars } = this;
            const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v)=>!v.global && !v.internal);
            return vars_report.map((v)=>({
                    name: v.name,
                    export_name: v.export_name || null,
                    injected: v.injected || false,
                    module: v.module || false,
                    mutated: v.mutated || false,
                    reassigned: v.reassigned || false,
                    referenced: v.referenced || false,
                    writable: v.writable || false,
                    referenced_from_script: v.referenced_from_script || false
                }));
        }
        error(pos, e) {
            if (this.compile_options.errorMode === "warn") this.warn(pos, e);
            else error(e.message, {
                name: "ValidationError",
                code: e.code,
                source: this.source,
                start: pos.start,
                end: pos.end,
                filename: this.compile_options.filename
            });
        }
        warn(pos, warning) {
            if (this.ignores && this.ignores.has(warning.code)) return;
            const start = this.locate(pos.start);
            const end = this.locate(pos.end);
            const frame = get_code_frame(this.source, start.line - 1, start.column);
            this.warnings.push({
                code: warning.code,
                message: warning.message,
                frame: frame,
                start: start,
                end: end,
                pos: pos.start,
                filename: this.compile_options.filename,
                toString: ()=>`${warning.message} (${start.line}:${start.column})\n${frame}`
            });
        }
        extract_imports(node) {
            this.imports.push(node);
        }
        extract_exports(node, module_script = false) {
            const ignores = extract_svelte_ignore_from_comments(node);
            if (ignores.length) this.push_ignores(ignores);
            const result = this._extract_exports(node, module_script);
            if (ignores.length) this.pop_ignores();
            return result;
        }
        _extract_exports(node, module_script) {
            if (node.type === "ExportDefaultDeclaration") return this.error(node, compiler_errors.default_export);
            if (node.type === "ExportNamedDeclaration") {
                if (node.source) {
                    if (module_script) this.exports_from.push(node);
                    else this.instance_exports_from.push(node);
                    return null;
                }
                if (node.declaration) {
                    if (node.declaration.type === "VariableDeclaration") node.declaration.declarations.forEach((declarator)=>{
                        extract_names(declarator.id).forEach((name)=>{
                            const variable = this.var_lookup.get(name);
                            variable.export_name = name;
                            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) this.warn(declarator, compiler_warnings.unused_export_let(this.name.name, name));
                        });
                    });
                    else {
                        const { name: name } = node.declaration.id;
                        const variable = this.var_lookup.get(name);
                        variable.export_name = name;
                    }
                    return node.declaration;
                } else {
                    node.specifiers.forEach((specifier)=>{
                        const variable = this.var_lookup.get(specifier.local.name);
                        if (variable) {
                            variable.export_name = specifier.exported.name;
                            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) this.warn(specifier, compiler_warnings.unused_export_let(this.name.name, specifier.exported.name));
                        }
                    });
                    return null;
                }
            }
        }
        extract_javascript(script) {
            if (!script) return null;
            return script.content.body.filter((node)=>{
                if (!node) return false;
                if (this.hoistable_nodes.has(node)) return false;
                if (this.reactive_declaration_nodes.has(node)) return false;
                if (node.type === "ImportDeclaration") return false;
                if (node.type === "ExportDeclaration" && node.specifiers.length > 0) return false;
                return true;
            });
        }
        walk_module_js() {
            const component = this;
            const script = this.ast.module;
            if (!script) return;
            walk(script.content, {
                enter (node) {
                    if (node.type === "LabeledStatement" && node.label.name === "$") component.warn(node, compiler_warnings.module_script_reactive_declaration);
                }
            });
            const { scope: scope, globals: globals } = create_scopes(script.content);
            this.module_scope = scope;
            scope.declarations.forEach((node, name)=>{
                if (name[0] === "$") return this.error(node, compiler_errors.illegal_declaration);
                const writable = node.type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let");
                const imported = node.type.startsWith("Import");
                this.add_var(node, {
                    name: name,
                    module: true,
                    hoistable: true,
                    writable: writable,
                    imported: imported
                });
            });
            globals.forEach((node, name)=>{
                if (name[0] === "$") return this.error(node, compiler_errors.illegal_subscription);
                else this.add_var(node, {
                    name: name,
                    global: true,
                    hoistable: true
                });
            });
            const { body: body } = script.content;
            let i = body.length;
            while(--i >= 0){
                const node = body[i];
                if (node.type === "ImportDeclaration") {
                    this.extract_imports(node);
                    body.splice(i, 1);
                }
                if (regex_starts_with_term_export.test(node.type)) {
                    const replacement = this.extract_exports(node, true);
                    if (replacement) body[i] = replacement;
                    else body.splice(i, 1);
                }
            }
        }
        walk_instance_js_pre_template() {
            const script = this.ast.instance;
            if (!script) return;
            // inject vars for reactive declarations
            script.content.body.forEach((node)=>{
                if (node.type !== "LabeledStatement") return;
                if (node.body.type !== "ExpressionStatement") return;
                const { expression: expression } = node.body;
                if (expression.type !== "AssignmentExpression") return;
                if (expression.left.type === "MemberExpression") return;
                extract_names(expression.left).forEach((name)=>{
                    if (!this.var_lookup.has(name) && name[0] !== "$") this.injected_reactive_declaration_vars.add(name);
                });
            });
            const { scope: instance_scope, map: map, globals: globals } = create_scopes(script.content);
            this.instance_scope = instance_scope;
            this.instance_scope_map = map;
            instance_scope.declarations.forEach((node, name)=>{
                if (name[0] === "$") return this.error(node, compiler_errors.illegal_declaration);
                const writable = node.type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let");
                const imported = node.type.startsWith("Import");
                this.add_var(node, {
                    name: name,
                    initialised: instance_scope.initialised_declarations.has(name),
                    writable: writable,
                    imported: imported
                });
                this.node_for_declaration.set(name, node);
            });
            // NOTE: add store variable first, then only $store value
            // as `$store` will mark `store` variable as referenced and subscribable
            const global_keys = Array.from(globals.keys());
            const sorted_globals = [
                ...global_keys.filter((key)=>key[0] !== "$"),
                ...global_keys.filter((key)=>key[0] === "$")
            ];
            sorted_globals.forEach((name)=>{
                if (this.var_lookup.has(name)) return;
                const node = globals.get(name);
                if (this.injected_reactive_declaration_vars.has(name)) this.add_var(node, {
                    name: name,
                    injected: true,
                    writable: true,
                    reassigned: true,
                    initialised: true
                });
                else if (is_reserved_keyword(name)) this.add_var(node, {
                    name: name,
                    injected: true
                });
                else if (name[0] === "$") {
                    if (name === "$" || name[1] === "$") return this.error(node, compiler_errors.illegal_global(name));
                    this.add_var(node, {
                        name: name,
                        injected: true,
                        mutated: true,
                        writable: true
                    });
                    this.add_reference(node, name.slice(1));
                    const variable = this.var_lookup.get(name.slice(1));
                    if (variable) {
                        variable.subscribable = true;
                        variable.referenced_from_script = true;
                    }
                } else this.add_var(node, {
                    name: name,
                    global: true,
                    hoistable: true
                });
            });
            this.track_references_and_mutations();
        }
        walk_instance_js_post_template() {
            const script = this.ast.instance;
            if (!script) return;
            this.post_template_walk();
            this.hoist_instance_declarations();
            this.extract_reactive_declarations();
        }
        post_template_walk() {
            const script = this.ast.instance;
            if (!script) return;
            const component = this;
            const { content: content } = script;
            const { instance_scope: instance_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            const to_remove = [];
            const remove = (parent, prop, index)=>{
                to_remove.unshift([
                    parent,
                    prop,
                    index
                ]);
            };
            let scope_updated = false;
            const current_function_stack = [];
            let current_function = null;
            walk(content, {
                enter (node, parent, prop, index) {
                    if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") current_function_stack.push(current_function = node);
                    if (map.has(node)) scope = map.get(node);
                    let deep = false;
                    let names;
                    if (node.type === "AssignmentExpression") {
                        deep = node.left.type === "MemberExpression";
                        names = deep ? [
                            get_object(node.left).name
                        ] : extract_names(node.left);
                    } else if (node.type === "UpdateExpression") {
                        deep = node.argument.type === "MemberExpression";
                        const { name: name } = get_object(node.argument);
                        names = [
                            name
                        ];
                    }
                    if (names) names.forEach((name)=>{
                        let current_scope = scope;
                        let declaration;
                        while(current_scope){
                            if (current_scope.declarations.has(name)) {
                                declaration = current_scope.declarations.get(name);
                                break;
                            }
                            current_scope = current_scope.parent;
                        }
                        if (declaration && declaration.kind === "const" && !deep) component.error(node, {
                            code: "assignment-to-const",
                            message: "You are assigning to a const"
                        });
                    });
                    if (node.type === "ImportDeclaration") {
                        component.extract_imports(node);
                        // TODO: to use actual remove
                        remove(parent, prop, index);
                        return this.skip();
                    }
                    if (regex_starts_with_term_export.test(node.type)) {
                        const replacement = component.extract_exports(node);
                        if (replacement) this.replace(replacement);
                        else // TODO: to use actual remove
                        remove(parent, prop, index);
                        return this.skip();
                    }
                    component.warn_on_undefined_store_value_references(node, parent, prop, scope);
                },
                leave (node) {
                    if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
                        current_function_stack.pop();
                        current_function = current_function_stack[current_function_stack.length - 1];
                    }
                    // do it on leave, to prevent infinite loop
                    if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && (!current_function || !current_function.generator && !current_function.async)) {
                        const to_replace_for_loop_protect = component.loop_protect(node, scope, component.compile_options.loopGuardTimeout);
                        if (to_replace_for_loop_protect) {
                            this.replace(to_replace_for_loop_protect);
                            scope_updated = true;
                        }
                    }
                    if (map.has(node)) scope = scope.parent;
                }
            });
            for (const [parent, prop, index] of to_remove)if (parent) {
                if (index !== null) parent[prop].splice(index, 1);
                else delete parent[prop];
            }
            if (scope_updated) {
                const { scope: scope, map: map } = create_scopes(script.content);
                this.instance_scope = scope;
                this.instance_scope_map = map;
            }
        }
        track_references_and_mutations() {
            const script = this.ast.instance;
            if (!script) return;
            const component = this;
            const { content: content } = script;
            const { instance_scope: instance_scope, module_scope: module_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            walk(content, {
                enter (node, parent) {
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const names = extract_names(assignee);
                        const deep = assignee.type === "MemberExpression";
                        names.forEach((name)=>{
                            const scope_owner = scope.find_owner(name);
                            if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name)) {
                                const variable = component.var_lookup.get(name);
                                variable[deep ? "mutated" : "reassigned"] = true;
                            }
                        });
                    }
                    if (is_used_as_reference(node, parent)) {
                        const object = get_object(node);
                        if (scope.find_owner(object.name) === instance_scope) {
                            const variable = component.var_lookup.get(object.name);
                            variable.referenced_from_script = true;
                        }
                    }
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                }
            });
        }
        warn_on_undefined_store_value_references(node, parent, prop, scope) {
            if (node.type === "LabeledStatement" && node.label.name === "$" && parent.type !== "Program") this.warn(node, compiler_warnings.non_top_level_reactive_declaration);
            if (is_reference(node, parent)) {
                const object = get_object(node);
                const { name: name } = object;
                if (name[0] === "$") {
                    if (!scope.has(name)) this.warn_if_undefined(name, object, null);
                    if (name[1] !== "$" && scope.has(name.slice(1)) && scope.find_owner(name.slice(1)) !== this.instance_scope) {
                        if (!(regex_contains_term_function.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id")) return this.error(node, compiler_errors.contextual_store);
                    }
                }
            }
        }
        loop_protect(node, scope, timeout) {
            if (node.type === "WhileStatement" || node.type === "ForStatement" || node.type === "DoWhileStatement") {
                const guard = this.get_unique_name("guard", scope);
                this.used_names.add(guard.name);
                const before = b`const ${guard} = @loop_guard(${timeout})`;
                const inside = b`${guard}();`;
                // wrap expression statement with BlockStatement
                if (node.body.type !== "BlockStatement") node.body = {
                    type: "BlockStatement",
                    body: [
                        node.body
                    ]
                };
                node.body.body.push(inside[0]);
                return {
                    type: "BlockStatement",
                    body: [
                        before[0],
                        node
                    ]
                };
            }
            return null;
        }
        rewrite_props(get_insert) {
            if (!this.ast.instance) return;
            const component = this;
            const { instance_scope: instance_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            walk(this.ast.instance.content, {
                enter (node) {
                    if (regex_contains_term_function.test(node.type)) return this.skip();
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "ExportNamedDeclaration" && node.declaration) return this.replace(node.declaration);
                    if (node.type === "VariableDeclaration") // NOTE: `var` does not follow block scoping
                    {
                        if (node.kind === "var" || scope === instance_scope) {
                            const inserts = [];
                            const props = [];
                            function add_new_props(exported, local, default_value) {
                                props.push({
                                    type: "Property",
                                    method: false,
                                    shorthand: false,
                                    computed: false,
                                    kind: "init",
                                    key: exported,
                                    value: default_value ? {
                                        type: "AssignmentPattern",
                                        left: local,
                                        right: default_value
                                    } : local
                                });
                            }
                            // transform
                            // ```
                            // export let { x, y = 123 } = OBJ, z = 456
                            // ```
                            // into
                            // ```
                            // let { x: x$, y: y$ = 123 } = OBJ;
                            // let { x = x$, y = y$, z = 456 } = $$props;
                            // ```
                            for(let index = 0; index < node.declarations.length; index++){
                                const declarator = node.declarations[index];
                                if (declarator.id.type !== "Identifier") {
                                    function get_new_name(local) {
                                        const variable = component.var_lookup.get(local.name);
                                        if (variable.subscribable) inserts.push(get_insert(variable));
                                        if (variable.export_name && variable.writable) {
                                            const alias_name = component.get_unique_name(local.name);
                                            add_new_props({
                                                type: "Identifier",
                                                name: variable.export_name
                                            }, local, alias_name);
                                            return alias_name;
                                        }
                                        return local;
                                    }
                                    function rename_identifiers(param) {
                                        switch(param.type){
                                            case "ObjectPattern":
                                                {
                                                    const handle_prop = (prop)=>{
                                                        if (prop.type === "RestElement") rename_identifiers(prop);
                                                        else if (prop.value.type === "Identifier") prop.value = get_new_name(prop.value);
                                                        else rename_identifiers(prop.value);
                                                    };
                                                    param.properties.forEach(handle_prop);
                                                    break;
                                                }
                                            case "ArrayPattern":
                                                {
                                                    const handle_element = (element, index, array)=>{
                                                        if (element) {
                                                            if (element.type === "Identifier") array[index] = get_new_name(element);
                                                            else rename_identifiers(element);
                                                        }
                                                    };
                                                    param.elements.forEach(handle_element);
                                                    break;
                                                }
                                            case "RestElement":
                                                param.argument = get_new_name(param.argument);
                                                break;
                                            case "AssignmentPattern":
                                                if (param.left.type === "Identifier") param.left = get_new_name(param.left);
                                                else rename_identifiers(param.left);
                                                break;
                                        }
                                    }
                                    rename_identifiers(declarator.id);
                                } else {
                                    const { name: name } = declarator.id;
                                    const variable = component.var_lookup.get(name);
                                    const is_props = variable.export_name && variable.writable;
                                    if (is_props) {
                                        add_new_props({
                                            type: "Identifier",
                                            name: variable.export_name
                                        }, declarator.id, declarator.init);
                                        node.declarations.splice(index--, 1);
                                    }
                                    if (variable.subscribable && (is_props || declarator.init)) inserts.push(get_insert(variable));
                                }
                            }
                            this.replace(b`
							${node.declarations.length ? node : null}
							${props.length > 0 && b`let { ${props} } = $$props;`}
							${inserts}
						`);
                            return this.skip();
                        }
                    }
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                }
            });
        }
        hoist_instance_declarations() {
            // we can safely hoist variable declarations that are
            // initialised to literals, and functions that don't
            // reference instance variables other than other
            // hoistable functions. TODO others?
            const { hoistable_nodes: hoistable_nodes, var_lookup: var_lookup, injected_reactive_declaration_vars: injected_reactive_declaration_vars, imports: imports } = this;
            const top_level_function_declarations = new Map();
            const { body: body } = this.ast.instance.content;
            for(let i = 0; i < body.length; i += 1){
                const node = body[i];
                if (node.type === "VariableDeclaration") {
                    const all_hoistable = node.declarations.every((d)=>{
                        if (!d.init) return false;
                        if (d.init.type !== "Literal") return false;
                        // everything except const values can be changed by e.g. svelte devtools
                        // which means we can't hoist it
                        if (node.kind !== "const" && this.compile_options.dev) return false;
                        const { name: name } = d.id;
                        const v = this.var_lookup.get(name);
                        if (v.reassigned) return false;
                        if (v.export_name) return false;
                        if (this.var_lookup.get(name).reassigned) return false;
                        if (this.vars.find((variable)=>variable.name === name && variable.module)) return false;
                        return true;
                    });
                    if (all_hoistable) {
                        node.declarations.forEach((d)=>{
                            const variable = this.var_lookup.get(d.id.name);
                            variable.hoistable = true;
                        });
                        hoistable_nodes.add(node);
                        body.splice(i--, 1);
                        this.fully_hoisted.push(node);
                    }
                }
                if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "FunctionDeclaration") top_level_function_declarations.set(node.declaration.id.name, node);
                if (node.type === "FunctionDeclaration") top_level_function_declarations.set(node.id.name, node);
            }
            const checked = new Set();
            const walking = new Set();
            const is_hoistable = (fn_declaration)=>{
                if (fn_declaration.type === "ExportNamedDeclaration") fn_declaration = fn_declaration.declaration;
                const instance_scope = this.instance_scope;
                let scope = this.instance_scope;
                const map = this.instance_scope_map;
                let hoistable = true;
                // handle cycles
                walking.add(fn_declaration);
                walk(fn_declaration, {
                    enter (node, parent) {
                        if (!hoistable) return this.skip();
                        if (map.has(node)) scope = map.get(node);
                        if (is_reference(node, parent)) {
                            const { name: name } = flatten_reference(node);
                            const owner = scope.find_owner(name);
                            if (injected_reactive_declaration_vars.has(name)) hoistable = false;
                            else if (name[0] === "$" && !owner) hoistable = false;
                            else if (owner === instance_scope) {
                                const variable = var_lookup.get(name);
                                if (variable.reassigned || variable.mutated) hoistable = false;
                                if (name === fn_declaration.id.name) return;
                                if (variable.hoistable) return;
                                if (top_level_function_declarations.has(name)) {
                                    const other_declaration = top_level_function_declarations.get(name);
                                    if (walking.has(other_declaration)) hoistable = false;
                                    else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration)) hoistable = false;
                                    else if (!is_hoistable(other_declaration)) hoistable = false;
                                } else hoistable = false;
                            }
                            this.skip();
                        }
                    },
                    leave (node) {
                        if (map.has(node)) scope = scope.parent;
                    }
                });
                checked.add(fn_declaration);
                walking.delete(fn_declaration);
                return hoistable;
            };
            for (const [name, node] of top_level_function_declarations)if (is_hoistable(node)) {
                const variable = this.var_lookup.get(name);
                variable.hoistable = true;
                hoistable_nodes.add(node);
                const i = body.indexOf(node);
                body.splice(i, 1);
                this.fully_hoisted.push(node);
            }
            for (const { specifiers: specifiers } of imports)for (const specifier of specifiers){
                const variable = var_lookup.get(specifier.local.name);
                if (!variable.mutated || variable.subscribable) variable.hoistable = true;
            }
        }
        extract_reactive_declarations() {
            const component = this;
            const unsorted_reactive_declarations = [];
            this.ast.instance.content.body.forEach((node)=>{
                const ignores = extract_svelte_ignore_from_comments(node);
                if (ignores.length) this.push_ignores(ignores);
                if (node.type === "LabeledStatement" && node.label.name === "$") {
                    this.reactive_declaration_nodes.add(node);
                    const assignees = new Set();
                    const assignee_nodes = new Set();
                    const dependencies = new Set();
                    const module_dependencies = new Set();
                    let scope = this.instance_scope;
                    const map = this.instance_scope_map;
                    walk(node.body, {
                        enter (node, parent) {
                            if (map.has(node)) scope = map.get(node);
                            if (node.type === "AssignmentExpression") {
                                const left = get_object(node.left);
                                extract_identifiers(left).forEach((node)=>{
                                    assignee_nodes.add(node);
                                    assignees.add(node.name);
                                });
                                if (node.operator !== "=") dependencies.add(left.name);
                            } else if (node.type === "UpdateExpression") {
                                const identifier = get_object(node.argument);
                                assignees.add(identifier.name);
                            } else if (is_reference(node, parent)) {
                                const identifier = get_object(node);
                                if (!assignee_nodes.has(identifier)) {
                                    const { name: name } = identifier;
                                    const owner = scope.find_owner(name);
                                    const variable = component.var_lookup.get(name);
                                    let should_add_as_dependency = true;
                                    if (variable) {
                                        variable.is_reactive_dependency = true;
                                        if (variable.module && variable.writable) {
                                            should_add_as_dependency = false;
                                            module_dependencies.add(name);
                                        }
                                    }
                                    const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                                    if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name[0] === "$" || is_writable_or_mutated)) dependencies.add(name);
                                }
                                this.skip();
                            }
                        },
                        leave (node) {
                            if (map.has(node)) scope = scope.parent;
                        }
                    });
                    if (module_dependencies.size > 0 && dependencies.size === 0) component.warn(node.body, compiler_warnings.module_script_variable_reactive_declaration(Array.from(module_dependencies)));
                    const { expression: expression } = node.body;
                    const declaration = expression && expression.left;
                    unsorted_reactive_declarations.push({
                        assignees: assignees,
                        dependencies: dependencies,
                        node: node,
                        declaration: declaration
                    });
                }
                if (ignores.length) this.pop_ignores();
            });
            const lookup = new Map();
            unsorted_reactive_declarations.forEach((declaration)=>{
                declaration.assignees.forEach((name)=>{
                    if (!lookup.has(name)) lookup.set(name, []);
                    // TODO warn or error if a name is assigned to in
                    // multiple reactive declarations?
                    lookup.get(name).push(declaration);
                });
            });
            const cycle = check_graph_for_cycles(unsorted_reactive_declarations.reduce((acc, declaration)=>{
                declaration.assignees.forEach((v)=>{
                    declaration.dependencies.forEach((w)=>{
                        if (!declaration.assignees.has(w)) acc.push([
                            v,
                            w
                        ]);
                    });
                });
                return acc;
            }, []));
            if (cycle && cycle.length) {
                const declarationList = lookup.get(cycle[0]);
                const declaration = declarationList[0];
                return this.error(declaration.node, compiler_errors.cyclical_reactive_declaration(cycle));
            }
            const add_declaration = (declaration)=>{
                if (this.reactive_declarations.includes(declaration)) return;
                declaration.dependencies.forEach((name)=>{
                    if (declaration.assignees.has(name)) return;
                    const earlier_declarations = lookup.get(name);
                    if (earlier_declarations) earlier_declarations.forEach(add_declaration);
                });
                this.reactive_declarations.push(declaration);
            };
            unsorted_reactive_declarations.forEach(add_declaration);
        }
        warn_if_undefined(name, node, template_scope) {
            if (name[0] === "$") {
                if (name === "$" || name[1] === "$" && !is_reserved_keyword(name)) return this.error(node, compiler_errors.illegal_global(name));
                this.has_reactive_assignments = true; // TODO does this belong here?
                if (is_reserved_keyword(name)) return;
                name = name.slice(1);
            }
            if (this.var_lookup.has(name) && !this.var_lookup.get(name).global) return;
            if (template_scope && template_scope.names.has(name)) return;
            if (globals.has(name) && node.type !== "InlineComponent") return;
            this.warn(node, compiler_warnings.missing_declaration(name, !!this.ast.instance));
        }
        push_ignores(ignores) {
            this.ignores = new Set(this.ignores || []);
            add_to_set(this.ignores, ignores);
            this.ignore_stack.push(this.ignores);
        }
        pop_ignores() {
            this.ignore_stack.pop();
            this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
        }
    }
    const regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
    function process_component_options(component, nodes) {
        const component_options = {
            immutable: component.compile_options.immutable || false,
            accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
            preserveWhitespace: !!component.compile_options.preserveWhitespace,
            namespace: component.compile_options.namespace
        };
        const node = nodes.find((node)=>node.name === "svelte:options");
        function get_value(attribute, { code: code, message: message }) {
            const { value: value } = attribute;
            const chunk = value[0];
            if (!chunk) return true;
            if (value.length > 1) return component.error(attribute, {
                code: code,
                message: message
            });
            if (chunk.type === "Text") return chunk.data;
            if (chunk.expression.type !== "Literal") return component.error(attribute, {
                code: code,
                message: message
            });
            return chunk.expression.value;
        }
        if (node) node.attributes.forEach((attribute)=>{
            if (attribute.type === "Attribute") {
                const { name: name } = attribute;
                switch(name){
                    case "tag":
                        {
                            const tag = get_value(attribute, compiler_errors.invalid_tag_attribute);
                            if (typeof tag !== "string" && tag !== null) return component.error(attribute, compiler_errors.invalid_tag_attribute);
                            if (tag && !regex_valid_tag_name.test(tag)) return component.error(attribute, compiler_errors.invalid_tag_property);
                            if (tag && !component.compile_options.customElement) component.warn(attribute, compiler_warnings.missing_custom_element_compile_options);
                            component_options.tag = tag;
                            break;
                        }
                    case "namespace":
                        {
                            const ns = get_value(attribute, compiler_errors.invalid_namespace_attribute);
                            if (typeof ns !== "string") return component.error(attribute, compiler_errors.invalid_namespace_attribute);
                            if (valid_namespaces.indexOf(ns) === -1) {
                                const match = fuzzymatch(ns, valid_namespaces);
                                return component.error(attribute, compiler_errors.invalid_namespace_property(ns, match));
                            }
                            component_options.namespace = ns;
                            break;
                        }
                    case "accessors":
                    case "immutable":
                    case "preserveWhitespace":
                        {
                            const value = get_value(attribute, compiler_errors.invalid_attribute_value(name));
                            if (typeof value !== "boolean") return component.error(attribute, compiler_errors.invalid_attribute_value(name));
                            component_options[name] = value;
                            break;
                        }
                    default:
                        return component.error(attribute, compiler_errors.invalid_options_attribute_unknown);
                }
            } else return component.error(attribute, compiler_errors.invalid_options_attribute);
        });
        return component_options;
    }
    function get_relative_path(from, to) {
        const from_parts = from.split(/[/\\]/);
        const to_parts = to.split(/[/\\]/);
        from_parts.pop(); // get dirname
        while(from_parts[0] === to_parts[0]){
            from_parts.shift();
            to_parts.shift();
        }
        if (from_parts.length) {
            let i = from_parts.length;
            while(i--)from_parts[i] = "..";
        }
        return from_parts.concat(to_parts).join("/");
    }
    function get_basename(filename) {
        return filename.split(/[/\\]/).pop();
    }
    function get_sourcemap_source_filename(compile_options) {
        if (!compile_options.filename) return null;
        return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
    }
    const regex_percentage_characters = /%/g;
    const regex_file_ending = /\.[^.]+$/;
    const regex_repeated_invalid_variable_identifier_characters = /[^a-zA-Z_$0-9]+/g;
    const regex_starts_with_digit = /^(\d)/;
    function get_name_from_filename(filename) {
        if (!filename) return null;
        const parts = filename.split(/[/\\]/).map(encodeURI);
        if (parts.length > 1) {
            const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
            if (index_match) {
                parts.pop();
                parts[parts.length - 1] += index_match[1];
            }
        }
        const base = parts.pop().replace(regex_percentage_characters, "u").replace(regex_file_ending, "").replace(regex_repeated_invalid_variable_identifier_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_digit, "_$1");
        if (!base) throw new Error(`Could not derive component name from file ${filename}`);
        return base[0].toUpperCase() + base.slice(1);
    }
    const valid_options = [
        "format",
        "name",
        "filename",
        "sourcemap",
        "enableSourcemap",
        "generate",
        "errorMode",
        "varsReport",
        "outputFilename",
        "cssOutputFilename",
        "sveltePath",
        "dev",
        "accessors",
        "immutable",
        "hydratable",
        "legacy",
        "customElement",
        "namespace",
        "tag",
        "css",
        "loopGuardTimeout",
        "preserveComments",
        "preserveWhitespace",
        "cssHash"
    ];
    const valid_css_values = [
        true,
        false,
        "injected",
        "external",
        "none"
    ];
    const regex_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    const regex_starts_with_lowercase_character = /^[a-z]/;
    function validate_options(options, warnings) {
        const { name: name, filename: filename, loopGuardTimeout: loopGuardTimeout, dev: dev, namespace: namespace, css: css } = options;
        Object.keys(options).forEach((key)=>{
            if (!valid_options.includes(key)) {
                const match = fuzzymatch(key, valid_options);
                let message = `Unrecognized option '${key}'`;
                if (match) message += ` (did you mean '${match}'?)`;
                throw new Error(message);
            }
        });
        if (name && !regex_valid_identifier.test(name)) throw new Error(`options.name must be a valid identifier (got '${name}')`);
        if (name && regex_starts_with_lowercase_character.test(name)) {
            const message = "options.name should be capitalised";
            warnings.push({
                code: "options-lowercase-name",
                message: message,
                filename: filename,
                toString: ()=>message
            });
        }
        if (loopGuardTimeout && !dev) {
            const message = "options.loopGuardTimeout is for options.dev = true only";
            warnings.push({
                code: "options-loop-guard-timeout",
                message: message,
                filename: filename,
                toString: ()=>message
            });
        }
        if (valid_css_values.indexOf(css) === -1) throw new Error(`options.css must be true, false, 'injected', 'external', or 'none' (got '${css}')`);
        if (css === true || css === false) options.css = css === true ? "injected" : "external";
        if (namespace && valid_namespaces.indexOf(namespace) === -1) {
            const match = fuzzymatch(namespace, valid_namespaces);
            if (match) throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
            else throw new Error(`Invalid namespace '${namespace}'`);
        }
    }
    function compile(source, options = {}) {
        options = Object.assign({
            generate: "dom",
            dev: false,
            enableSourcemap: true,
            css: "injected"
        }, options);
        const stats = new Stats();
        const warnings = [];
        validate_options(options, warnings);
        stats.start("parse");
        const ast = parse$I(source, options);
        stats.stop("parse");
        stats.start("create component");
        const component = new Component(ast, source, options.name || get_name_from_filename(options.filename) || "Component", options, stats, warnings);
        stats.stop("create component");
        const result = options.generate === false ? null : options.generate === "ssr" ? ssr(component, options) : dom(component, options);
        return component.generate(result);
    }
    /**
	 * Import decoded sourcemap from mozilla/source-map/SourceMapGenerator
	 * Forked from source-map/lib/source-map-generator.js
	 * from methods _serializeMappings and toJSON.
	 * We cannot use source-map.d.ts types, because we access hidden properties.
	 */ function decoded_sourcemap_from_generator(generator) {
        let previous_generated_line = 1;
        const converted_mappings = [
            []
        ];
        let result_line;
        let result_segment;
        let mapping;
        const source_idx = generator._sources.toArray().reduce((acc, val, idx)=>(acc[val] = idx, acc), {});
        const name_idx = generator._names.toArray().reduce((acc, val, idx)=>(acc[val] = idx, acc), {});
        const mappings = generator._mappings.toArray();
        result_line = converted_mappings[0];
        for(let i = 0, len = mappings.length; i < len; i++){
            mapping = mappings[i];
            if (mapping.generatedLine > previous_generated_line) {
                while(mapping.generatedLine > previous_generated_line){
                    converted_mappings.push([]);
                    previous_generated_line++;
                }
                result_line = converted_mappings[mapping.generatedLine - 1]; // line is one-based
            } else if (i > 0) {
                const previous_mapping = mappings[i - 1];
                if (// sorted by selectivity
                mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source) continue;
            }
            result_line.push([
                mapping.generatedColumn
            ]);
            result_segment = result_line[result_line.length - 1];
            if (mapping.source != null) {
                result_segment.push(...[
                    source_idx[mapping.source],
                    mapping.originalLine - 1,
                    mapping.originalColumn
                ]);
                if (mapping.name != null) result_segment.push(name_idx[mapping.name]);
            }
        }
        const map = {
            version: generator._version,
            sources: generator._sources.toArray(),
            names: generator._names.toArray(),
            mappings: converted_mappings
        };
        if (generator._file != null) map.file = generator._file;
        // not needed: map.sourcesContent and map.sourceRoot
        return map;
    }
    function decode_map(processed) {
        let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
        if (typeof decoded_map.mappings === "string") decoded_map.mappings = decode(decoded_map.mappings);
        if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") // import decoded sourcemap from mozilla/source-map/SourceMapGenerator
        decoded_map = decoded_sourcemap_from_generator(decoded_map);
        return decoded_map;
    }
    function slice_source(code_slice, offset, { file_basename: file_basename, filename: filename, get_location: get_location }) {
        return {
            source: code_slice,
            get_location: (index)=>get_location(index + offset),
            file_basename: file_basename,
            filename: filename
        };
    }
    function calculate_replacements(re, get_replacement, source) {
        const replacements = [];
        source.replace(re, (...match)=>{
            replacements.push(get_replacement(...match).then((replacement)=>{
                const matched_string = match[0];
                const offset = match[match.length - 2];
                return {
                    offset: offset,
                    length: matched_string.length,
                    replacement: replacement
                };
            }));
            return "";
        });
        return Promise.all(replacements);
    }
    function perform_replacements(replacements, source) {
        const out = new MappedCode();
        let last_end = 0;
        for (const { offset: offset, length: length, replacement: replacement } of replacements){
            const unchanged_prefix = MappedCode.from_source(slice_source(source.source.slice(last_end, offset), last_end, source));
            out.concat(unchanged_prefix).concat(replacement);
            last_end = offset + length;
        }
        const unchanged_suffix = MappedCode.from_source(slice_source(source.source.slice(last_end), last_end, source));
        return out.concat(unchanged_suffix);
    }
    async function replace_in_code(regex, get_replacement, location) {
        const replacements = await calculate_replacements(regex, get_replacement, location.source);
        return perform_replacements(replacements, location);
    }
    const regex_filepath_separator = /[/\\]/;
    function get_file_basename(filename) {
        return filename.split(regex_filepath_separator).pop();
    }
    /**
	 * Represents intermediate states of the preprocessing.
	 */ class PreprocessResult {
        constructor(source, filename){
            this.source = source;
            this.filename = filename;
            // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
            // so we use sourcemap_list.unshift() to add new maps
            // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
            this.sourcemap_list = [];
            this.dependencies = [];
            this.update_source({
                string: source
            });
            // preprocess source must be relative to itself or equal null
            this.file_basename = filename == null ? null : get_file_basename(filename);
        }
        update_source({ string: source, map: map, dependencies: dependencies }) {
            if (source != null) {
                this.source = source;
                this.get_location = getLocator(source);
            }
            if (map) this.sourcemap_list.unshift(map);
            if (dependencies) this.dependencies.push(...dependencies);
        }
        to_processed() {
            // Combine all the source maps for each preprocessor function into one
            const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
            return {
                // TODO return separated output, in future version where svelte.compile supports it:
                // style: { code: styleCode, map: styleMap },
                // script { code: scriptCode, map: scriptMap },
                // markup { code: markupCode, map: markupMap },
                code: this.source,
                dependencies: [
                    ...new Set(this.dependencies)
                ],
                map: map,
                toString: ()=>this.source
            };
        }
    }
    /**
	 * Convert preprocessor output for the tag content into MappedCode
	 */ function processed_content_to_code(processed, location, file_basename) {
        // Convert the preprocessed code and its sourcemap to a MappedCode
        let decoded_map;
        if (processed.map) {
            decoded_map = decode_map(processed);
            // decoded map may not have sources for empty maps like `{ mappings: '' }`
            if (decoded_map.sources) {
                // offset only segments pointing at original component source
                const source_index = decoded_map.sources.indexOf(file_basename);
                if (source_index !== -1) sourcemap_add_offset(decoded_map, location, source_index);
            }
        }
        return MappedCode.from_processed(processed.code, decoded_map);
    }
    /**
	 * Given the whole tag including content, return a `MappedCode`
	 * representing the tag content replaced with `processed`.
	 */ function processed_tag_to_code(processed, tag_name, attributes, source) {
        const { file_basename: file_basename, get_location: get_location } = source;
        const build_mapped_code = (code, offset)=>MappedCode.from_source(slice_source(code, offset, source));
        const tag_open = `<${tag_name}${attributes || ""}>`;
        const tag_close = `</${tag_name}>`;
        const tag_open_code = build_mapped_code(tag_open, 0);
        const tag_close_code = build_mapped_code(tag_close, tag_open.length + source.source.length);
        parse_attached_sourcemap(processed, tag_name);
        const content_code = processed_content_to_code(processed, get_location(tag_open.length), file_basename);
        return tag_open_code.concat(content_code).concat(tag_close_code);
    }
    const regex_quoted_value = /^['"](.*)['"]$/;
    function parse_tag_attributes(str) {
        // note: won't work with attribute values containing spaces.
        return str.split(regex_whitespaces).filter(Boolean).reduce((attrs, attr)=>{
            var _a;
            const i = attr.indexOf("=");
            const [key, value] = i > 0 ? [
                attr.slice(0, i),
                attr.slice(i + 1)
            ] : [
                attr
            ];
            const [, unquoted] = value && value.match(regex_quoted_value) || [];
            return Object.assign(Object.assign({}, attrs), {
                [key]: (_a = unquoted !== null && unquoted !== void 0 ? unquoted : value) !== null && _a !== void 0 ? _a : true
            });
        }, {});
    }
    const regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
    const regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
    /**
	 * Calculate the updates required to process all instances of the specified tag.
	 */ async function process_tag(tag_name, preprocessor, source) {
        const { filename: filename, source: markup } = source;
        const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
        const dependencies = [];
        async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
            const no_change = ()=>MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
            if (!attributes && !content) return no_change();
            const processed = await preprocessor({
                content: content || "",
                attributes: parse_tag_attributes(attributes || ""),
                markup: markup,
                filename: filename
            });
            if (!processed) return no_change();
            if (processed.dependencies) dependencies.push(...processed.dependencies);
            if (!processed.map && processed.code === content) return no_change();
            return processed_tag_to_code(processed, tag_name, attributes, slice_source(content, tag_offset, source));
        }
        const { string: string, map: map } = await replace_in_code(tag_regex, process_single_tag, source);
        return {
            string: string,
            map: map,
            dependencies: dependencies
        };
    }
    async function process_markup(process1, source) {
        const processed = await process1({
            content: source.source,
            filename: source.filename
        });
        if (processed) return {
            string: processed.code,
            map: processed.map ? typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map : undefined,
            dependencies: processed.dependencies
        };
        else return {};
    }
    async function preprocess(source, preprocessor, options) {
        const filename = options && options.filename || preprocessor.filename; // legacy
        const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [
            preprocessor
        ] : [];
        const markup = preprocessors.map((p)=>p.markup).filter(Boolean);
        const script = preprocessors.map((p)=>p.script).filter(Boolean);
        const style = preprocessors.map((p)=>p.style).filter(Boolean);
        const result = new PreprocessResult(source, filename);
        // TODO keep track: what preprocessor generated what sourcemap?
        // to make debugging easier = detect low-resolution sourcemaps in fn combine_mappings
        for (const process1 of markup)result.update_source(await process_markup(process1, result));
        for (const process1 of script)result.update_source(await process_tag("script", process1, result));
        for (const preprocess of style)result.update_source(await process_tag("style", preprocess, result));
        return result.to_processed();
    }
    const VERSION = "3.55.0";
    // additional exports added through generate-type-definitions.js
    exports1.VERSION = VERSION;
    exports1.compile = compile;
    exports1.parse = parse$I;
    exports1.preprocess = preprocess;
    exports1.walk = walk;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});



const $560639d49e3c9a19$export$707b977e56f140b4 = (config)=>config;
var $560639d49e3c9a19$var$bail_1 = $560639d49e3c9a19$var$bail;
function $560639d49e3c9a19$var$bail(err) {
    if (err) throw err;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var $560639d49e3c9a19$var$isBuffer = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var $560639d49e3c9a19$var$hasOwn = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$toStr = Object.prototype.toString;
var $560639d49e3c9a19$var$defineProperty = Object.defineProperty;
var $560639d49e3c9a19$var$gOPD = Object.getOwnPropertyDescriptor;
var $560639d49e3c9a19$var$isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") return Array.isArray(arr);
    return $560639d49e3c9a19$var$toStr.call(arr) === "[object Array]";
};
var $560639d49e3c9a19$var$isPlainObject = function isPlainObject(obj) {
    if (!obj || $560639d49e3c9a19$var$toStr.call(obj) !== "[object Object]") return false;
    var hasOwnConstructor = $560639d49e3c9a19$var$hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $560639d49e3c9a19$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for(key in obj);
    return typeof key === "undefined" || $560639d49e3c9a19$var$hasOwn.call(obj, key);
};
// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var $560639d49e3c9a19$var$setProperty = function setProperty(target, options) {
    if ($560639d49e3c9a19$var$defineProperty && options.name === "__proto__") $560639d49e3c9a19$var$defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
    });
    else target[options.name] = options.newValue;
};
// Return undefined instead of __proto__ if '__proto__' is not an own property
var $560639d49e3c9a19$var$getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
        if (!$560639d49e3c9a19$var$hasOwn.call(obj, name)) return void 0;
        else if ($560639d49e3c9a19$var$gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return $560639d49e3c9a19$var$gOPD(obj, name).value;
    }
    return obj[name];
};
var $560639d49e3c9a19$var$extend$2 = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
    for(; i < length; ++i){
        options = arguments[i];
        // Only deal with non-null/undefined values
        if (options != null) // Extend the base object
        for(name in options){
            src = $560639d49e3c9a19$var$getProperty(target, name);
            copy = $560639d49e3c9a19$var$getProperty(options, name);
            // Prevent never-ending loop
            if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && ($560639d49e3c9a19$var$isPlainObject(copy) || (copyIsArray = $560639d49e3c9a19$var$isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && $560639d49e3c9a19$var$isArray(src) ? src : [];
                    } else clone = src && $560639d49e3c9a19$var$isPlainObject(src) ? src : {};
                    // Never move original objects, clone them
                    $560639d49e3c9a19$var$setProperty(target, {
                        name: name,
                        newValue: extend(deep, clone, copy)
                    });
                // Don't bring in undefined values
                } else if (typeof copy !== "undefined") $560639d49e3c9a19$var$setProperty(target, {
                    name: name,
                    newValue: copy
                });
            }
        }
    }
    // Return the modified object
    return target;
};
var $560639d49e3c9a19$var$isPlainObj = (value)=>{
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};
var $560639d49e3c9a19$var$slice$3 = [].slice;
var $560639d49e3c9a19$var$wrap_1$1 = $560639d49e3c9a19$var$wrap$2;
// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function $560639d49e3c9a19$var$wrap$2(fn, callback) {
    var invoked;
    return wrapped;
    function wrapped() {
        var params = $560639d49e3c9a19$var$slice$3.call(arguments, 0);
        var callback = fn.length > params.length;
        var result;
        if (callback) params.push(done);
        try {
            result = fn.apply(null, params);
        } catch (error) {
            // Well, this is quite the pickle.
            // `fn` received a callback and invoked it (thus continuing the pipeline),
            // but later also threw an error.
            // We’re not about to restart the pipeline again, so the only thing left
            // to do is to throw the thing instead.
            if (callback && invoked) throw error;
            return done(error);
        }
        if (!callback) {
            if (result && typeof result.then === "function") result.then(then, done);
            else if (result instanceof Error) done(result);
            else then(result);
        }
    }
    // Invoke `next`, only once.
    function done() {
        if (!invoked) {
            invoked = true;
            callback.apply(null, arguments);
        }
    }
    // Invoke `done` with one value.
    // Tracks if an error is passed, too.
    function then(value) {
        done(null, value);
    }
}
var $560639d49e3c9a19$var$trough_1 = $560639d49e3c9a19$var$trough;
$560639d49e3c9a19$var$trough.wrap = $560639d49e3c9a19$var$wrap_1$1;
var $560639d49e3c9a19$var$slice$2 = [].slice;
// Create new middleware.
function $560639d49e3c9a19$var$trough() {
    var fns = [];
    var middleware = {};
    middleware.run = run;
    middleware.use = use;
    return middleware;
    // Run `fns`.  Last argument must be a completion handler.
    function run() {
        var index = -1;
        var input = $560639d49e3c9a19$var$slice$2.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") throw new Error("Expected function as last argument, not " + done);
        next.apply(null, [
            null
        ].concat(input));
        // Run the next `fn`, if any.
        function next(err) {
            var fn = fns[++index];
            var params = $560639d49e3c9a19$var$slice$2.call(arguments, 0);
            var values = params.slice(1);
            var length = input.length;
            var pos = -1;
            if (err) {
                done(err);
                return;
            }
            // Copy non-nully input into values.
            while(++pos < length)if (values[pos] === null || values[pos] === undefined) values[pos] = input[pos];
            input = values;
            // Next or done.
            if (fn) $560639d49e3c9a19$var$wrap_1$1(fn, next).apply(null, input);
            else done.apply(null, [
                null
            ].concat(input));
        }
    }
    // Add `fn` to the list.
    function use(fn) {
        if (typeof fn !== "function") throw new Error("Expected `fn` to be a function, not " + fn);
        fns.push(fn);
        return middleware;
    }
}
var $560639d49e3c9a19$var$own$f = {}.hasOwnProperty;
var $560639d49e3c9a19$var$unistUtilStringifyPosition = $560639d49e3c9a19$var$stringify$4;
function $560639d49e3c9a19$var$stringify$4(value) {
    // Nothing.
    if (!value || typeof value !== "object") return "";
    // Node.
    if ($560639d49e3c9a19$var$own$f.call(value, "position") || $560639d49e3c9a19$var$own$f.call(value, "type")) return $560639d49e3c9a19$var$position$1(value.position);
    // Position.
    if ($560639d49e3c9a19$var$own$f.call(value, "start") || $560639d49e3c9a19$var$own$f.call(value, "end")) return $560639d49e3c9a19$var$position$1(value);
    // Point.
    if ($560639d49e3c9a19$var$own$f.call(value, "line") || $560639d49e3c9a19$var$own$f.call(value, "column")) return $560639d49e3c9a19$var$point(value);
    // ?
    return "";
}
function $560639d49e3c9a19$var$point(point) {
    if (!point || typeof point !== "object") point = {};
    return $560639d49e3c9a19$var$index$6(point.line) + ":" + $560639d49e3c9a19$var$index$6(point.column);
}
function $560639d49e3c9a19$var$position$1(pos) {
    if (!pos || typeof pos !== "object") pos = {};
    return $560639d49e3c9a19$var$point(pos.start) + "-" + $560639d49e3c9a19$var$point(pos.end);
}
function $560639d49e3c9a19$var$index$6(value) {
    return value && typeof value === "number" ? value : 1;
}
var $560639d49e3c9a19$var$vfileMessage = $560639d49e3c9a19$var$VMessage;
// Inherit from `Error#`.
function $560639d49e3c9a19$var$VMessagePrototype() {}
$560639d49e3c9a19$var$VMessagePrototype.prototype = Error.prototype;
$560639d49e3c9a19$var$VMessage.prototype = new $560639d49e3c9a19$var$VMessagePrototype();
// Message properties.
var $560639d49e3c9a19$var$proto$6 = $560639d49e3c9a19$var$VMessage.prototype;
$560639d49e3c9a19$var$proto$6.file = "";
$560639d49e3c9a19$var$proto$6.name = "";
$560639d49e3c9a19$var$proto$6.reason = "";
$560639d49e3c9a19$var$proto$6.message = "";
$560639d49e3c9a19$var$proto$6.stack = "";
$560639d49e3c9a19$var$proto$6.fatal = null;
$560639d49e3c9a19$var$proto$6.column = null;
$560639d49e3c9a19$var$proto$6.line = null;
// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function $560639d49e3c9a19$var$VMessage(reason, position, origin) {
    var parts;
    var range;
    var location;
    if (typeof position === "string") {
        origin = position;
        position = null;
    }
    parts = $560639d49e3c9a19$var$parseOrigin(origin);
    range = $560639d49e3c9a19$var$unistUtilStringifyPosition(position) || "1:1";
    location = {
        start: {
            line: null,
            column: null
        },
        end: {
            line: null,
            column: null
        }
    };
    // Node.
    if (position && position.position) position = position.position;
    if (position) {
        // Position.
        if (position.start) {
            location = position;
            position = position.start;
        } else // Point.
        location.start = position;
    }
    if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location;
    this.source = parts[0];
    this.ruleId = parts[1];
}
function $560639d49e3c9a19$var$parseOrigin(origin) {
    var result = [
        null,
        null
    ];
    var index;
    if (typeof origin === "string") {
        index = origin.indexOf(":");
        if (index === -1) result[1] = origin;
        else {
            result[0] = origin.slice(0, index);
            result[1] = origin.slice(index + 1);
        }
    }
    return result;
}
function $560639d49e3c9a19$var$replaceExt(npath, ext) {
    if (typeof npath !== "string") return npath;
    if (npath.length === 0) return npath;
    var nFileName = (0, $4S4dR$path1).basename(npath, (0, $4S4dR$path1).extname(npath)) + ext;
    return (0, $4S4dR$path1).join((0, $4S4dR$path1).dirname(npath), nFileName);
}
var $560639d49e3c9a19$var$replaceExt_1 = $560639d49e3c9a19$var$replaceExt;
var $560639d49e3c9a19$var$core$1 = $560639d49e3c9a19$var$VFile;
var $560639d49e3c9a19$var$own$e = {}.hasOwnProperty;
var $560639d49e3c9a19$var$proto$5 = $560639d49e3c9a19$var$VFile.prototype;
// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var $560639d49e3c9a19$var$order$1 = [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
];
$560639d49e3c9a19$var$proto$5.toString = $560639d49e3c9a19$var$toString;
// Access full path (`~/index.min.js`).
Object.defineProperty($560639d49e3c9a19$var$proto$5, "path", {
    get: $560639d49e3c9a19$var$getPath,
    set: $560639d49e3c9a19$var$setPath
});
// Access parent path (`~`).
Object.defineProperty($560639d49e3c9a19$var$proto$5, "dirname", {
    get: $560639d49e3c9a19$var$getDirname,
    set: $560639d49e3c9a19$var$setDirname
});
// Access basename (`index.min.js`).
Object.defineProperty($560639d49e3c9a19$var$proto$5, "basename", {
    get: $560639d49e3c9a19$var$getBasename,
    set: $560639d49e3c9a19$var$setBasename
});
// Access extname (`.js`).
Object.defineProperty($560639d49e3c9a19$var$proto$5, "extname", {
    get: $560639d49e3c9a19$var$getExtname,
    set: $560639d49e3c9a19$var$setExtname
});
// Access stem (`index.min`).
Object.defineProperty($560639d49e3c9a19$var$proto$5, "stem", {
    get: $560639d49e3c9a19$var$getStem,
    set: $560639d49e3c9a19$var$setStem
});
// Construct a new file.
function $560639d49e3c9a19$var$VFile(options) {
    var prop;
    var index;
    var length;
    if (!options) options = {};
    else if (typeof options === "string" || $560639d49e3c9a19$var$isBuffer(options)) options = {
        contents: options
    };
    else if ("message" in options && "messages" in options) return options;
    if (!(this instanceof $560639d49e3c9a19$var$VFile)) return new $560639d49e3c9a19$var$VFile(options);
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = process.cwd();
    // Set path related properties in the correct order.
    index = -1;
    length = $560639d49e3c9a19$var$order$1.length;
    while(++index < length){
        prop = $560639d49e3c9a19$var$order$1[index];
        if ($560639d49e3c9a19$var$own$e.call(options, prop)) this[prop] = options[prop];
    }
    // Set non-path related properties.
    for(prop in options)if ($560639d49e3c9a19$var$order$1.indexOf(prop) === -1) this[prop] = options[prop];
}
function $560639d49e3c9a19$var$getPath() {
    return this.history[this.history.length - 1];
}
function $560639d49e3c9a19$var$setPath(path) {
    $560639d49e3c9a19$var$assertNonEmpty(path, "path");
    if (path !== this.path) this.history.push(path);
}
function $560639d49e3c9a19$var$getDirname() {
    return typeof this.path === "string" ? (0, $4S4dR$path1).dirname(this.path) : undefined;
}
function $560639d49e3c9a19$var$setDirname(dirname) {
    $560639d49e3c9a19$var$assertPath(this.path, "dirname");
    this.path = (0, $4S4dR$path1).join(dirname || "", this.basename);
}
function $560639d49e3c9a19$var$getBasename() {
    return typeof this.path === "string" ? (0, $4S4dR$path1).basename(this.path) : undefined;
}
function $560639d49e3c9a19$var$setBasename(basename) {
    $560639d49e3c9a19$var$assertNonEmpty(basename, "basename");
    $560639d49e3c9a19$var$assertPart(basename, "basename");
    this.path = (0, $4S4dR$path1).join(this.dirname || "", basename);
}
function $560639d49e3c9a19$var$getExtname() {
    return typeof this.path === "string" ? (0, $4S4dR$path1).extname(this.path) : undefined;
}
function $560639d49e3c9a19$var$setExtname(extname) {
    var ext = extname || "";
    $560639d49e3c9a19$var$assertPart(ext, "extname");
    $560639d49e3c9a19$var$assertPath(this.path, "extname");
    if (ext) {
        if (ext.charAt(0) !== ".") throw new Error("`extname` must start with `.`");
        if (ext.indexOf(".", 1) !== -1) throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $560639d49e3c9a19$var$replaceExt_1(this.path, ext);
}
function $560639d49e3c9a19$var$getStem() {
    return typeof this.path === "string" ? (0, $4S4dR$path1).basename(this.path, this.extname) : undefined;
}
function $560639d49e3c9a19$var$setStem(stem) {
    $560639d49e3c9a19$var$assertNonEmpty(stem, "stem");
    $560639d49e3c9a19$var$assertPart(stem, "stem");
    this.path = (0, $4S4dR$path1).join(this.dirname || "", stem + (this.extname || ""));
}
// Get the value of the file.
function $560639d49e3c9a19$var$toString(encoding) {
    var value = this.contents || "";
    return $560639d49e3c9a19$var$isBuffer(value) ? value.toString(encoding) : String(value);
}
// Assert that `part` is not a path (i.e., does not contain `path.sep`).
function $560639d49e3c9a19$var$assertPart(part, name) {
    if (part.indexOf((0, $4S4dR$path1).sep) !== -1) throw new Error("`" + name + "` cannot be a path: did not expect `" + (0, $4S4dR$path1).sep + "`");
}
// Assert that `part` is not empty.
function $560639d49e3c9a19$var$assertNonEmpty(part, name) {
    if (!part) throw new Error("`" + name + "` cannot be empty");
}
// Assert `path` exists.
function $560639d49e3c9a19$var$assertPath(path, name) {
    if (!path) throw new Error("Setting `" + name + "` requires `path` to be set too");
}
var $560639d49e3c9a19$var$vfile = $560639d49e3c9a19$var$core$1;
var $560639d49e3c9a19$var$proto$4 = $560639d49e3c9a19$var$core$1.prototype;
$560639d49e3c9a19$var$proto$4.message = $560639d49e3c9a19$var$message;
$560639d49e3c9a19$var$proto$4.info = $560639d49e3c9a19$var$info$1;
$560639d49e3c9a19$var$proto$4.fail = $560639d49e3c9a19$var$fail;
// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function $560639d49e3c9a19$var$message(reason, position, origin) {
    var filePath = this.path;
    var message = new $560639d49e3c9a19$var$vfileMessage(reason, position, origin);
    if (filePath) {
        message.name = filePath + ":" + message.name;
        message.file = filePath;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
}
// Fail: creates a vmessage, associates it with the file, and throws it.
function $560639d49e3c9a19$var$fail() {
    var message = this.message.apply(this, arguments);
    message.fatal = true;
    throw message;
}
// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function $560639d49e3c9a19$var$info$1() {
    var message = this.message.apply(this, arguments);
    message.fatal = null;
    return message;
}
// Expose a frozen processor.
var $560639d49e3c9a19$var$unified_1$1 = $560639d49e3c9a19$var$unified$1().freeze();
var $560639d49e3c9a19$var$slice$1 = [].slice;
var $560639d49e3c9a19$var$own$d = {}.hasOwnProperty;
// Process pipeline.
var $560639d49e3c9a19$var$pipeline$1 = $560639d49e3c9a19$var$trough_1().use($560639d49e3c9a19$var$pipelineParse$1).use($560639d49e3c9a19$var$pipelineRun$1).use($560639d49e3c9a19$var$pipelineStringify$1);
function $560639d49e3c9a19$var$pipelineParse$1(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $560639d49e3c9a19$var$pipelineRun$1(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $560639d49e3c9a19$var$pipelineStringify$1(p, ctx) {
    var result = p.stringify(ctx.tree, ctx.file);
    var file = ctx.file;
    if (result === undefined || result === null) ;
    else if (typeof result === "string" || $560639d49e3c9a19$var$isBuffer(result)) file.contents = result;
    else file.result = result;
}
// Function to create the first processor.
function $560639d49e3c9a19$var$unified$1() {
    var attachers = [];
    var transformers = $560639d49e3c9a19$var$trough_1();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process1;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $560639d49e3c9a19$var$unified$1();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($560639d49e3c9a19$var$extend$2(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $560639d49e3c9a19$var$assertUnfrozen$1("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $560639d49e3c9a19$var$own$d.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $560639d49e3c9a19$var$assertUnfrozen$1("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $560639d49e3c9a19$var$assertUnfrozen$1("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $560639d49e3c9a19$var$extend$2(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $560639d49e3c9a19$var$extend$2(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($560639d49e3c9a19$var$isPlainObj(entry[1]) && $560639d49e3c9a19$var$isPlainObj(value)) value = $560639d49e3c9a19$var$extend$2(entry[1], value);
                entry[1] = value;
            } else attachers.push($560639d49e3c9a19$var$slice$1.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $560639d49e3c9a19$var$vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $560639d49e3c9a19$var$assertParser$1("parse", Parser);
        if ($560639d49e3c9a19$var$newable$1(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $560639d49e3c9a19$var$assertNode$1(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $560639d49e3c9a19$var$vfile(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $560639d49e3c9a19$var$assertDone$1("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $560639d49e3c9a19$var$bail_1(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $560639d49e3c9a19$var$vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $560639d49e3c9a19$var$assertCompiler$1("stringify", Compiler);
        $560639d49e3c9a19$var$assertNode$1(node);
        if ($560639d49e3c9a19$var$newable$1(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process1(doc, cb) {
        freeze();
        $560639d49e3c9a19$var$assertParser$1("process", processor.Parser);
        $560639d49e3c9a19$var$assertCompiler$1("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $560639d49e3c9a19$var$vfile(doc);
            $560639d49e3c9a19$var$pipeline$1.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $560639d49e3c9a19$var$assertParser$1("processSync", processor.Parser);
        $560639d49e3c9a19$var$assertCompiler$1("processSync", processor.Compiler);
        file = $560639d49e3c9a19$var$vfile(doc);
        process1(file, done);
        $560639d49e3c9a19$var$assertDone$1("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $560639d49e3c9a19$var$bail_1(err);
        }
    }
}
// Check if `value` is a constructor.
function $560639d49e3c9a19$var$newable$1(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($560639d49e3c9a19$var$keys$2(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $560639d49e3c9a19$var$keys$2(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $560639d49e3c9a19$var$assertParser$1(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $560639d49e3c9a19$var$assertCompiler$1(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $560639d49e3c9a19$var$assertUnfrozen$1(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $560639d49e3c9a19$var$assertNode$1(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $560639d49e3c9a19$var$assertDone$1(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $560639d49e3c9a19$var$immutable = $560639d49e3c9a19$var$extend$1;
var $560639d49e3c9a19$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $560639d49e3c9a19$var$extend$1() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($560639d49e3c9a19$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}
function $560639d49e3c9a19$var$commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
function $560639d49e3c9a19$var$createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}
function $560639d49e3c9a19$var$getCjsExportFromNamespace(n) {
    return n && n["default"] || n;
}
var $560639d49e3c9a19$var$inherits_browser = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
    if (typeof Object.create === "function") // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
    else // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
});
var $560639d49e3c9a19$var$inherits = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
    try {
        var util$1 = (0, $4S4dR$util);
        /* istanbul ignore next */ if (typeof util$1.inherits !== "function") throw "";
        module.exports = util$1.inherits;
    } catch (e) {
        /* istanbul ignore next */ module.exports = $560639d49e3c9a19$var$inherits_browser;
    }
});
var $560639d49e3c9a19$var$unherit_1 = $560639d49e3c9a19$var$unherit;
// Create a custom constructor which can be modified without affecting the
// original class.
function $560639d49e3c9a19$var$unherit(Super) {
    var result;
    var key;
    var value;
    $560639d49e3c9a19$var$inherits(Of, Super);
    $560639d49e3c9a19$var$inherits(From, Of);
    // Clone values.
    result = Of.prototype;
    for(key in result){
        value = result[key];
        if (value && typeof value === "object") result[key] = "concat" in value ? value.concat() : $560639d49e3c9a19$var$immutable(value);
    }
    return Of;
    // Constructor accepting a single argument, which itself is an `arguments`
    // object.
    function From(parameters) {
        return Super.apply(this, parameters);
    }
    // Constructor accepting variadic arguments.
    function Of() {
        if (!(this instanceof Of)) return new From(arguments);
        return Super.apply(this, arguments);
    }
}
var $560639d49e3c9a19$var$stateToggle = $560639d49e3c9a19$var$factory$6;
// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function $560639d49e3c9a19$var$factory$6(key, state, ctx) {
    return enter;
    function enter() {
        var context = ctx || this;
        var current = context[key];
        context[key] = !state;
        return exit;
        function exit() {
            context[key] = current;
        }
    }
}
var $560639d49e3c9a19$var$vfileLocation = $560639d49e3c9a19$var$factory$5;
function $560639d49e3c9a19$var$factory$5(file) {
    var contents = $560639d49e3c9a19$var$indices(String(file));
    return {
        toPosition: $560639d49e3c9a19$var$offsetToPositionFactory(contents),
        toOffset: $560639d49e3c9a19$var$positionToOffsetFactory(contents)
    };
}
// Factory to get the line and column-based `position` for `offset` in the bound
// indices.
function $560639d49e3c9a19$var$offsetToPositionFactory(indices) {
    return offsetToPosition;
    // Get the line and column-based `position` for `offset` in the bound indices.
    function offsetToPosition(offset) {
        var index = -1;
        var length = indices.length;
        if (offset < 0) return {};
        while(++index < length){
            if (indices[index] > offset) return {
                line: index + 1,
                column: offset - (indices[index - 1] || 0) + 1,
                offset: offset
            };
        }
        return {};
    }
}
// Factory to get the `offset` for a line and column-based `position` in the
// bound indices.
function $560639d49e3c9a19$var$positionToOffsetFactory(indices) {
    return positionToOffset;
    // Get the `offset` for a line and column-based `position` in the bound
    // indices.
    function positionToOffset(position) {
        var line = position && position.line;
        var column = position && position.column;
        if (!isNaN(line) && !isNaN(column) && line - 1 in indices) return (indices[line - 2] || 0) + column - 1 || 0;
        return -1;
    }
}
// Get indices of line-breaks in `value`.
function $560639d49e3c9a19$var$indices(value) {
    var result = [];
    var index = value.indexOf("\n");
    while(index !== -1){
        result.push(index + 1);
        index = value.indexOf("\n", index + 1);
    }
    result.push(value.length + 1);
    return result;
}
var $560639d49e3c9a19$var$_unescape = $560639d49e3c9a19$var$factory$4;
var $560639d49e3c9a19$var$backslash$7 = "\\";
// Factory to de-escape a value, based on a list at `key` in `ctx`.
function $560639d49e3c9a19$var$factory$4(ctx, key) {
    return unescape;
    // De-escape a string using the expression at `key` in `ctx`.
    function unescape(value) {
        var previous = 0;
        var index = value.indexOf($560639d49e3c9a19$var$backslash$7);
        var escape = ctx[key];
        var queue = [];
        var character;
        while(index !== -1){
            queue.push(value.slice(previous, index));
            previous = index + 1;
            character = value.charAt(previous);
            // If the following character is not a valid escape, add the slash.
            if (!character || escape.indexOf(character) === -1) queue.push($560639d49e3c9a19$var$backslash$7);
            index = value.indexOf($560639d49e3c9a19$var$backslash$7, previous + 1);
        }
        queue.push(value.slice(previous));
        return queue.join("");
    }
}
var $560639d49e3c9a19$var$AElig$2 = "\xc6";
var $560639d49e3c9a19$var$AMP$2 = "&";
var $560639d49e3c9a19$var$Aacute$2 = "\xc1";
var $560639d49e3c9a19$var$Acirc$2 = "\xc2";
var $560639d49e3c9a19$var$Agrave$2 = "\xc0";
var $560639d49e3c9a19$var$Aring$2 = "\xc5";
var $560639d49e3c9a19$var$Atilde$2 = "\xc3";
var $560639d49e3c9a19$var$Auml$2 = "\xc4";
var $560639d49e3c9a19$var$COPY$1 = "\xa9";
var $560639d49e3c9a19$var$Ccedil$2 = "\xc7";
var $560639d49e3c9a19$var$ETH$2 = "\xd0";
var $560639d49e3c9a19$var$Eacute$2 = "\xc9";
var $560639d49e3c9a19$var$Ecirc$2 = "\xca";
var $560639d49e3c9a19$var$Egrave$2 = "\xc8";
var $560639d49e3c9a19$var$Euml$2 = "\xcb";
var $560639d49e3c9a19$var$GT$2 = ">";
var $560639d49e3c9a19$var$Iacute$2 = "\xcd";
var $560639d49e3c9a19$var$Icirc$2 = "\xce";
var $560639d49e3c9a19$var$Igrave$2 = "\xcc";
var $560639d49e3c9a19$var$Iuml$2 = "\xcf";
var $560639d49e3c9a19$var$LT$2 = "<";
var $560639d49e3c9a19$var$Ntilde$2 = "\xd1";
var $560639d49e3c9a19$var$Oacute$2 = "\xd3";
var $560639d49e3c9a19$var$Ocirc$2 = "\xd4";
var $560639d49e3c9a19$var$Ograve$2 = "\xd2";
var $560639d49e3c9a19$var$Oslash$2 = "\xd8";
var $560639d49e3c9a19$var$Otilde$2 = "\xd5";
var $560639d49e3c9a19$var$Ouml$2 = "\xd6";
var $560639d49e3c9a19$var$QUOT$1 = '"';
var $560639d49e3c9a19$var$REG$1 = "\xae";
var $560639d49e3c9a19$var$THORN$2 = "\xde";
var $560639d49e3c9a19$var$Uacute$2 = "\xda";
var $560639d49e3c9a19$var$Ucirc$2 = "\xdb";
var $560639d49e3c9a19$var$Ugrave$2 = "\xd9";
var $560639d49e3c9a19$var$Uuml$2 = "\xdc";
var $560639d49e3c9a19$var$Yacute$2 = "\xdd";
var $560639d49e3c9a19$var$aacute$2 = "\xe1";
var $560639d49e3c9a19$var$acirc$2 = "\xe2";
var $560639d49e3c9a19$var$acute$2 = "\xb4";
var $560639d49e3c9a19$var$aelig$2 = "\xe6";
var $560639d49e3c9a19$var$agrave$2 = "\xe0";
var $560639d49e3c9a19$var$amp$2 = "&";
var $560639d49e3c9a19$var$aring$2 = "\xe5";
var $560639d49e3c9a19$var$atilde$2 = "\xe3";
var $560639d49e3c9a19$var$auml$2 = "\xe4";
var $560639d49e3c9a19$var$brvbar$2 = "\xa6";
var $560639d49e3c9a19$var$ccedil$2 = "\xe7";
var $560639d49e3c9a19$var$cedil$2 = "\xb8";
var $560639d49e3c9a19$var$cent$2 = "\xa2";
var $560639d49e3c9a19$var$copy$2 = "\xa9";
var $560639d49e3c9a19$var$curren$2 = "\xa4";
var $560639d49e3c9a19$var$deg$2 = "\xb0";
var $560639d49e3c9a19$var$divide$2 = "\xf7";
var $560639d49e3c9a19$var$eacute$2 = "\xe9";
var $560639d49e3c9a19$var$ecirc$2 = "\xea";
var $560639d49e3c9a19$var$egrave$2 = "\xe8";
var $560639d49e3c9a19$var$eth$2 = "\xf0";
var $560639d49e3c9a19$var$euml$2 = "\xeb";
var $560639d49e3c9a19$var$frac12$2 = "\xbd";
var $560639d49e3c9a19$var$frac14$2 = "\xbc";
var $560639d49e3c9a19$var$frac34$2 = "\xbe";
var $560639d49e3c9a19$var$gt$2 = ">";
var $560639d49e3c9a19$var$iacute$2 = "\xed";
var $560639d49e3c9a19$var$icirc$2 = "\xee";
var $560639d49e3c9a19$var$iexcl$2 = "\xa1";
var $560639d49e3c9a19$var$igrave$2 = "\xec";
var $560639d49e3c9a19$var$iquest$2 = "\xbf";
var $560639d49e3c9a19$var$iuml$2 = "\xef";
var $560639d49e3c9a19$var$laquo$2 = "\xab";
var $560639d49e3c9a19$var$lt$2 = "<";
var $560639d49e3c9a19$var$macr$2 = "\xaf";
var $560639d49e3c9a19$var$micro$2 = "\xb5";
var $560639d49e3c9a19$var$middot$2 = "\xb7";
var $560639d49e3c9a19$var$nbsp$2 = "\xa0";
var $560639d49e3c9a19$var$not$2 = "\xac";
var $560639d49e3c9a19$var$ntilde$2 = "\xf1";
var $560639d49e3c9a19$var$oacute$2 = "\xf3";
var $560639d49e3c9a19$var$ocirc$2 = "\xf4";
var $560639d49e3c9a19$var$ograve$2 = "\xf2";
var $560639d49e3c9a19$var$ordf$2 = "\xaa";
var $560639d49e3c9a19$var$ordm$2 = "\xba";
var $560639d49e3c9a19$var$oslash$2 = "\xf8";
var $560639d49e3c9a19$var$otilde$2 = "\xf5";
var $560639d49e3c9a19$var$ouml$2 = "\xf6";
var $560639d49e3c9a19$var$para$2 = "\xb6";
var $560639d49e3c9a19$var$plusmn$2 = "\xb1";
var $560639d49e3c9a19$var$pound$2 = "\xa3";
var $560639d49e3c9a19$var$quot$2 = '"';
var $560639d49e3c9a19$var$raquo$2 = "\xbb";
var $560639d49e3c9a19$var$reg$2 = "\xae";
var $560639d49e3c9a19$var$sect$2 = "\xa7";
var $560639d49e3c9a19$var$shy$2 = "\xad";
var $560639d49e3c9a19$var$sup1$2 = "\xb9";
var $560639d49e3c9a19$var$sup2$2 = "\xb2";
var $560639d49e3c9a19$var$sup3$2 = "\xb3";
var $560639d49e3c9a19$var$szlig$2 = "\xdf";
var $560639d49e3c9a19$var$thorn$2 = "\xfe";
var $560639d49e3c9a19$var$times$2 = "\xd7";
var $560639d49e3c9a19$var$uacute$2 = "\xfa";
var $560639d49e3c9a19$var$ucirc$2 = "\xfb";
var $560639d49e3c9a19$var$ugrave$2 = "\xf9";
var $560639d49e3c9a19$var$uml$2 = "\xa8";
var $560639d49e3c9a19$var$uuml$2 = "\xfc";
var $560639d49e3c9a19$var$yacute$2 = "\xfd";
var $560639d49e3c9a19$var$yen$2 = "\xa5";
var $560639d49e3c9a19$var$yuml$2 = "\xff";
var $560639d49e3c9a19$var$index$5 = {
    AElig: $560639d49e3c9a19$var$AElig$2,
    AMP: $560639d49e3c9a19$var$AMP$2,
    Aacute: $560639d49e3c9a19$var$Aacute$2,
    Acirc: $560639d49e3c9a19$var$Acirc$2,
    Agrave: $560639d49e3c9a19$var$Agrave$2,
    Aring: $560639d49e3c9a19$var$Aring$2,
    Atilde: $560639d49e3c9a19$var$Atilde$2,
    Auml: $560639d49e3c9a19$var$Auml$2,
    COPY: $560639d49e3c9a19$var$COPY$1,
    Ccedil: $560639d49e3c9a19$var$Ccedil$2,
    ETH: $560639d49e3c9a19$var$ETH$2,
    Eacute: $560639d49e3c9a19$var$Eacute$2,
    Ecirc: $560639d49e3c9a19$var$Ecirc$2,
    Egrave: $560639d49e3c9a19$var$Egrave$2,
    Euml: $560639d49e3c9a19$var$Euml$2,
    GT: $560639d49e3c9a19$var$GT$2,
    Iacute: $560639d49e3c9a19$var$Iacute$2,
    Icirc: $560639d49e3c9a19$var$Icirc$2,
    Igrave: $560639d49e3c9a19$var$Igrave$2,
    Iuml: $560639d49e3c9a19$var$Iuml$2,
    LT: $560639d49e3c9a19$var$LT$2,
    Ntilde: $560639d49e3c9a19$var$Ntilde$2,
    Oacute: $560639d49e3c9a19$var$Oacute$2,
    Ocirc: $560639d49e3c9a19$var$Ocirc$2,
    Ograve: $560639d49e3c9a19$var$Ograve$2,
    Oslash: $560639d49e3c9a19$var$Oslash$2,
    Otilde: $560639d49e3c9a19$var$Otilde$2,
    Ouml: $560639d49e3c9a19$var$Ouml$2,
    QUOT: $560639d49e3c9a19$var$QUOT$1,
    REG: $560639d49e3c9a19$var$REG$1,
    THORN: $560639d49e3c9a19$var$THORN$2,
    Uacute: $560639d49e3c9a19$var$Uacute$2,
    Ucirc: $560639d49e3c9a19$var$Ucirc$2,
    Ugrave: $560639d49e3c9a19$var$Ugrave$2,
    Uuml: $560639d49e3c9a19$var$Uuml$2,
    Yacute: $560639d49e3c9a19$var$Yacute$2,
    aacute: $560639d49e3c9a19$var$aacute$2,
    acirc: $560639d49e3c9a19$var$acirc$2,
    acute: $560639d49e3c9a19$var$acute$2,
    aelig: $560639d49e3c9a19$var$aelig$2,
    agrave: $560639d49e3c9a19$var$agrave$2,
    amp: $560639d49e3c9a19$var$amp$2,
    aring: $560639d49e3c9a19$var$aring$2,
    atilde: $560639d49e3c9a19$var$atilde$2,
    auml: $560639d49e3c9a19$var$auml$2,
    brvbar: $560639d49e3c9a19$var$brvbar$2,
    ccedil: $560639d49e3c9a19$var$ccedil$2,
    cedil: $560639d49e3c9a19$var$cedil$2,
    cent: $560639d49e3c9a19$var$cent$2,
    copy: $560639d49e3c9a19$var$copy$2,
    curren: $560639d49e3c9a19$var$curren$2,
    deg: $560639d49e3c9a19$var$deg$2,
    divide: $560639d49e3c9a19$var$divide$2,
    eacute: $560639d49e3c9a19$var$eacute$2,
    ecirc: $560639d49e3c9a19$var$ecirc$2,
    egrave: $560639d49e3c9a19$var$egrave$2,
    eth: $560639d49e3c9a19$var$eth$2,
    euml: $560639d49e3c9a19$var$euml$2,
    frac12: $560639d49e3c9a19$var$frac12$2,
    frac14: $560639d49e3c9a19$var$frac14$2,
    frac34: $560639d49e3c9a19$var$frac34$2,
    gt: $560639d49e3c9a19$var$gt$2,
    iacute: $560639d49e3c9a19$var$iacute$2,
    icirc: $560639d49e3c9a19$var$icirc$2,
    iexcl: $560639d49e3c9a19$var$iexcl$2,
    igrave: $560639d49e3c9a19$var$igrave$2,
    iquest: $560639d49e3c9a19$var$iquest$2,
    iuml: $560639d49e3c9a19$var$iuml$2,
    laquo: $560639d49e3c9a19$var$laquo$2,
    lt: $560639d49e3c9a19$var$lt$2,
    macr: $560639d49e3c9a19$var$macr$2,
    micro: $560639d49e3c9a19$var$micro$2,
    middot: $560639d49e3c9a19$var$middot$2,
    nbsp: $560639d49e3c9a19$var$nbsp$2,
    not: $560639d49e3c9a19$var$not$2,
    ntilde: $560639d49e3c9a19$var$ntilde$2,
    oacute: $560639d49e3c9a19$var$oacute$2,
    ocirc: $560639d49e3c9a19$var$ocirc$2,
    ograve: $560639d49e3c9a19$var$ograve$2,
    ordf: $560639d49e3c9a19$var$ordf$2,
    ordm: $560639d49e3c9a19$var$ordm$2,
    oslash: $560639d49e3c9a19$var$oslash$2,
    otilde: $560639d49e3c9a19$var$otilde$2,
    ouml: $560639d49e3c9a19$var$ouml$2,
    para: $560639d49e3c9a19$var$para$2,
    plusmn: $560639d49e3c9a19$var$plusmn$2,
    pound: $560639d49e3c9a19$var$pound$2,
    quot: $560639d49e3c9a19$var$quot$2,
    raquo: $560639d49e3c9a19$var$raquo$2,
    reg: $560639d49e3c9a19$var$reg$2,
    sect: $560639d49e3c9a19$var$sect$2,
    shy: $560639d49e3c9a19$var$shy$2,
    sup1: $560639d49e3c9a19$var$sup1$2,
    sup2: $560639d49e3c9a19$var$sup2$2,
    sup3: $560639d49e3c9a19$var$sup3$2,
    szlig: $560639d49e3c9a19$var$szlig$2,
    thorn: $560639d49e3c9a19$var$thorn$2,
    times: $560639d49e3c9a19$var$times$2,
    uacute: $560639d49e3c9a19$var$uacute$2,
    ucirc: $560639d49e3c9a19$var$ucirc$2,
    ugrave: $560639d49e3c9a19$var$ugrave$2,
    uml: $560639d49e3c9a19$var$uml$2,
    uuml: $560639d49e3c9a19$var$uuml$2,
    yacute: $560639d49e3c9a19$var$yacute$2,
    yen: $560639d49e3c9a19$var$yen$2,
    yuml: $560639d49e3c9a19$var$yuml$2
};
var $560639d49e3c9a19$var$characterEntitiesLegacy = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AElig: $560639d49e3c9a19$var$AElig$2,
    AMP: $560639d49e3c9a19$var$AMP$2,
    Aacute: $560639d49e3c9a19$var$Aacute$2,
    Acirc: $560639d49e3c9a19$var$Acirc$2,
    Agrave: $560639d49e3c9a19$var$Agrave$2,
    Aring: $560639d49e3c9a19$var$Aring$2,
    Atilde: $560639d49e3c9a19$var$Atilde$2,
    Auml: $560639d49e3c9a19$var$Auml$2,
    COPY: $560639d49e3c9a19$var$COPY$1,
    Ccedil: $560639d49e3c9a19$var$Ccedil$2,
    ETH: $560639d49e3c9a19$var$ETH$2,
    Eacute: $560639d49e3c9a19$var$Eacute$2,
    Ecirc: $560639d49e3c9a19$var$Ecirc$2,
    Egrave: $560639d49e3c9a19$var$Egrave$2,
    Euml: $560639d49e3c9a19$var$Euml$2,
    GT: $560639d49e3c9a19$var$GT$2,
    Iacute: $560639d49e3c9a19$var$Iacute$2,
    Icirc: $560639d49e3c9a19$var$Icirc$2,
    Igrave: $560639d49e3c9a19$var$Igrave$2,
    Iuml: $560639d49e3c9a19$var$Iuml$2,
    LT: $560639d49e3c9a19$var$LT$2,
    Ntilde: $560639d49e3c9a19$var$Ntilde$2,
    Oacute: $560639d49e3c9a19$var$Oacute$2,
    Ocirc: $560639d49e3c9a19$var$Ocirc$2,
    Ograve: $560639d49e3c9a19$var$Ograve$2,
    Oslash: $560639d49e3c9a19$var$Oslash$2,
    Otilde: $560639d49e3c9a19$var$Otilde$2,
    Ouml: $560639d49e3c9a19$var$Ouml$2,
    QUOT: $560639d49e3c9a19$var$QUOT$1,
    REG: $560639d49e3c9a19$var$REG$1,
    THORN: $560639d49e3c9a19$var$THORN$2,
    Uacute: $560639d49e3c9a19$var$Uacute$2,
    Ucirc: $560639d49e3c9a19$var$Ucirc$2,
    Ugrave: $560639d49e3c9a19$var$Ugrave$2,
    Uuml: $560639d49e3c9a19$var$Uuml$2,
    Yacute: $560639d49e3c9a19$var$Yacute$2,
    aacute: $560639d49e3c9a19$var$aacute$2,
    acirc: $560639d49e3c9a19$var$acirc$2,
    acute: $560639d49e3c9a19$var$acute$2,
    aelig: $560639d49e3c9a19$var$aelig$2,
    agrave: $560639d49e3c9a19$var$agrave$2,
    amp: $560639d49e3c9a19$var$amp$2,
    aring: $560639d49e3c9a19$var$aring$2,
    atilde: $560639d49e3c9a19$var$atilde$2,
    auml: $560639d49e3c9a19$var$auml$2,
    brvbar: $560639d49e3c9a19$var$brvbar$2,
    ccedil: $560639d49e3c9a19$var$ccedil$2,
    cedil: $560639d49e3c9a19$var$cedil$2,
    cent: $560639d49e3c9a19$var$cent$2,
    copy: $560639d49e3c9a19$var$copy$2,
    curren: $560639d49e3c9a19$var$curren$2,
    deg: $560639d49e3c9a19$var$deg$2,
    divide: $560639d49e3c9a19$var$divide$2,
    eacute: $560639d49e3c9a19$var$eacute$2,
    ecirc: $560639d49e3c9a19$var$ecirc$2,
    egrave: $560639d49e3c9a19$var$egrave$2,
    eth: $560639d49e3c9a19$var$eth$2,
    euml: $560639d49e3c9a19$var$euml$2,
    frac12: $560639d49e3c9a19$var$frac12$2,
    frac14: $560639d49e3c9a19$var$frac14$2,
    frac34: $560639d49e3c9a19$var$frac34$2,
    gt: $560639d49e3c9a19$var$gt$2,
    iacute: $560639d49e3c9a19$var$iacute$2,
    icirc: $560639d49e3c9a19$var$icirc$2,
    iexcl: $560639d49e3c9a19$var$iexcl$2,
    igrave: $560639d49e3c9a19$var$igrave$2,
    iquest: $560639d49e3c9a19$var$iquest$2,
    iuml: $560639d49e3c9a19$var$iuml$2,
    laquo: $560639d49e3c9a19$var$laquo$2,
    lt: $560639d49e3c9a19$var$lt$2,
    macr: $560639d49e3c9a19$var$macr$2,
    micro: $560639d49e3c9a19$var$micro$2,
    middot: $560639d49e3c9a19$var$middot$2,
    nbsp: $560639d49e3c9a19$var$nbsp$2,
    not: $560639d49e3c9a19$var$not$2,
    ntilde: $560639d49e3c9a19$var$ntilde$2,
    oacute: $560639d49e3c9a19$var$oacute$2,
    ocirc: $560639d49e3c9a19$var$ocirc$2,
    ograve: $560639d49e3c9a19$var$ograve$2,
    ordf: $560639d49e3c9a19$var$ordf$2,
    ordm: $560639d49e3c9a19$var$ordm$2,
    oslash: $560639d49e3c9a19$var$oslash$2,
    otilde: $560639d49e3c9a19$var$otilde$2,
    ouml: $560639d49e3c9a19$var$ouml$2,
    para: $560639d49e3c9a19$var$para$2,
    plusmn: $560639d49e3c9a19$var$plusmn$2,
    pound: $560639d49e3c9a19$var$pound$2,
    quot: $560639d49e3c9a19$var$quot$2,
    raquo: $560639d49e3c9a19$var$raquo$2,
    reg: $560639d49e3c9a19$var$reg$2,
    sect: $560639d49e3c9a19$var$sect$2,
    shy: $560639d49e3c9a19$var$shy$2,
    sup1: $560639d49e3c9a19$var$sup1$2,
    sup2: $560639d49e3c9a19$var$sup2$2,
    sup3: $560639d49e3c9a19$var$sup3$2,
    szlig: $560639d49e3c9a19$var$szlig$2,
    thorn: $560639d49e3c9a19$var$thorn$2,
    times: $560639d49e3c9a19$var$times$2,
    uacute: $560639d49e3c9a19$var$uacute$2,
    ucirc: $560639d49e3c9a19$var$ucirc$2,
    ugrave: $560639d49e3c9a19$var$ugrave$2,
    uml: $560639d49e3c9a19$var$uml$2,
    uuml: $560639d49e3c9a19$var$uuml$2,
    yacute: $560639d49e3c9a19$var$yacute$2,
    yen: $560639d49e3c9a19$var$yen$2,
    yuml: $560639d49e3c9a19$var$yuml$2,
    "default": $560639d49e3c9a19$var$index$5
});
var $560639d49e3c9a19$var$index$4 = {
    "0": "\uFFFD",
    "128": "\u20AC",
    "130": "\u201A",
    "131": "\u0192",
    "132": "\u201E",
    "133": "\u2026",
    "134": "\u2020",
    "135": "\u2021",
    "136": "\u02C6",
    "137": "\u2030",
    "138": "\u0160",
    "139": "\u2039",
    "140": "\u0152",
    "142": "\u017D",
    "145": "\u2018",
    "146": "\u2019",
    "147": "\u201C",
    "148": "\u201D",
    "149": "\u2022",
    "150": "\u2013",
    "151": "\u2014",
    "152": "\u02DC",
    "153": "\u2122",
    "154": "\u0161",
    "155": "\u203A",
    "156": "\u0153",
    "158": "\u017E",
    "159": "\u0178"
};
var $560639d49e3c9a19$var$characterReferenceInvalid = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $560639d49e3c9a19$var$index$4
});
var $560639d49e3c9a19$var$isDecimal = $560639d49e3c9a19$var$decimal$1;
// Check if the given character code, or the character code at the first
// character, is decimal.
function $560639d49e3c9a19$var$decimal$1(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57 /* 0-9 */ ;
}
var $560639d49e3c9a19$var$isHexadecimal = $560639d49e3c9a19$var$hexadecimal;
// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function $560639d49e3c9a19$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 /* a */  && code <= 102 || code >= 65 /* A */  && code <= 70 || code >= 48 /* A */  && code <= 57;
}
var $560639d49e3c9a19$var$isAlphabetical = $560639d49e3c9a19$var$alphabetical;
// Check if the given character code, or the character code at the first
// character, is alphabetical.
function $560639d49e3c9a19$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
var $560639d49e3c9a19$var$isAlphanumerical = $560639d49e3c9a19$var$alphanumerical;
// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function $560639d49e3c9a19$var$alphanumerical(character) {
    return $560639d49e3c9a19$var$isAlphabetical(character) || $560639d49e3c9a19$var$isDecimal(character);
}
var $560639d49e3c9a19$var$AEli = "\xc6";
var $560639d49e3c9a19$var$AElig$1 = "\xc6";
var $560639d49e3c9a19$var$AM = "&";
var $560639d49e3c9a19$var$AMP$1 = "&";
var $560639d49e3c9a19$var$Aacut = "\xc1";
var $560639d49e3c9a19$var$Aacute$1 = "\xc1";
var $560639d49e3c9a19$var$Abreve = "\u0102";
var $560639d49e3c9a19$var$Acir = "\xc2";
var $560639d49e3c9a19$var$Acirc$1 = "\xc2";
var $560639d49e3c9a19$var$Acy = "\u0410";
var $560639d49e3c9a19$var$Afr = "\uD835\uDD04";
var $560639d49e3c9a19$var$Agrav = "\xc0";
var $560639d49e3c9a19$var$Agrave$1 = "\xc0";
var $560639d49e3c9a19$var$Alpha$1 = "\u0391";
var $560639d49e3c9a19$var$Amacr = "\u0100";
var $560639d49e3c9a19$var$And = "\u2A53";
var $560639d49e3c9a19$var$Aogon = "\u0104";
var $560639d49e3c9a19$var$Aopf = "\uD835\uDD38";
var $560639d49e3c9a19$var$ApplyFunction = "\u2061";
var $560639d49e3c9a19$var$Arin = "\xc5";
var $560639d49e3c9a19$var$Aring$1 = "\xc5";
var $560639d49e3c9a19$var$Ascr = "\uD835\uDC9C";
var $560639d49e3c9a19$var$Assign = "\u2254";
var $560639d49e3c9a19$var$Atild = "\xc3";
var $560639d49e3c9a19$var$Atilde$1 = "\xc3";
var $560639d49e3c9a19$var$Aum = "\xc4";
var $560639d49e3c9a19$var$Auml$1 = "\xc4";
var $560639d49e3c9a19$var$Backslash = "\u2216";
var $560639d49e3c9a19$var$Barv = "\u2AE7";
var $560639d49e3c9a19$var$Barwed = "\u2306";
var $560639d49e3c9a19$var$Bcy = "\u0411";
var $560639d49e3c9a19$var$Because = "\u2235";
var $560639d49e3c9a19$var$Bernoullis = "\u212C";
var $560639d49e3c9a19$var$Beta$1 = "\u0392";
var $560639d49e3c9a19$var$Bfr = "\uD835\uDD05";
var $560639d49e3c9a19$var$Bopf = "\uD835\uDD39";
var $560639d49e3c9a19$var$Breve = "\u02D8";
var $560639d49e3c9a19$var$Bscr = "\u212C";
var $560639d49e3c9a19$var$Bumpeq = "\u224E";
var $560639d49e3c9a19$var$CHcy = "\u0427";
var $560639d49e3c9a19$var$COP = "\xa9";
var $560639d49e3c9a19$var$COPY = "\xa9";
var $560639d49e3c9a19$var$Cacute = "\u0106";
var $560639d49e3c9a19$var$Cap = "\u22D2";
var $560639d49e3c9a19$var$CapitalDifferentialD = "\u2145";
var $560639d49e3c9a19$var$Cayleys = "\u212D";
var $560639d49e3c9a19$var$Ccaron = "\u010C";
var $560639d49e3c9a19$var$Ccedi = "\xc7";
var $560639d49e3c9a19$var$Ccedil$1 = "\xc7";
var $560639d49e3c9a19$var$Ccirc = "\u0108";
var $560639d49e3c9a19$var$Cconint = "\u2230";
var $560639d49e3c9a19$var$Cdot = "\u010A";
var $560639d49e3c9a19$var$Cedilla = "\xb8";
var $560639d49e3c9a19$var$CenterDot = "\xb7";
var $560639d49e3c9a19$var$Cfr = "\u212D";
var $560639d49e3c9a19$var$Chi$1 = "\u03A7";
var $560639d49e3c9a19$var$CircleDot = "\u2299";
var $560639d49e3c9a19$var$CircleMinus = "\u2296";
var $560639d49e3c9a19$var$CirclePlus = "\u2295";
var $560639d49e3c9a19$var$CircleTimes = "\u2297";
var $560639d49e3c9a19$var$ClockwiseContourIntegral = "\u2232";
var $560639d49e3c9a19$var$CloseCurlyDoubleQuote = "\u201D";
var $560639d49e3c9a19$var$CloseCurlyQuote = "\u2019";
var $560639d49e3c9a19$var$Colon = "\u2237";
var $560639d49e3c9a19$var$Colone = "\u2A74";
var $560639d49e3c9a19$var$Congruent = "\u2261";
var $560639d49e3c9a19$var$Conint = "\u222F";
var $560639d49e3c9a19$var$ContourIntegral = "\u222E";
var $560639d49e3c9a19$var$Copf = "\u2102";
var $560639d49e3c9a19$var$Coproduct = "\u2210";
var $560639d49e3c9a19$var$CounterClockwiseContourIntegral = "\u2233";
var $560639d49e3c9a19$var$Cross = "\u2A2F";
var $560639d49e3c9a19$var$Cscr = "\uD835\uDC9E";
var $560639d49e3c9a19$var$Cup = "\u22D3";
var $560639d49e3c9a19$var$CupCap = "\u224D";
var $560639d49e3c9a19$var$DD = "\u2145";
var $560639d49e3c9a19$var$DDotrahd = "\u2911";
var $560639d49e3c9a19$var$DJcy = "\u0402";
var $560639d49e3c9a19$var$DScy = "\u0405";
var $560639d49e3c9a19$var$DZcy = "\u040F";
var $560639d49e3c9a19$var$Dagger$1 = "\u2021";
var $560639d49e3c9a19$var$Darr = "\u21A1";
var $560639d49e3c9a19$var$Dashv = "\u2AE4";
var $560639d49e3c9a19$var$Dcaron = "\u010E";
var $560639d49e3c9a19$var$Dcy = "\u0414";
var $560639d49e3c9a19$var$Del = "\u2207";
var $560639d49e3c9a19$var$Delta$1 = "\u0394";
var $560639d49e3c9a19$var$Dfr = "\uD835\uDD07";
var $560639d49e3c9a19$var$DiacriticalAcute = "\xb4";
var $560639d49e3c9a19$var$DiacriticalDot = "\u02D9";
var $560639d49e3c9a19$var$DiacriticalDoubleAcute = "\u02DD";
var $560639d49e3c9a19$var$DiacriticalGrave = "`";
var $560639d49e3c9a19$var$DiacriticalTilde = "\u02DC";
var $560639d49e3c9a19$var$Diamond = "\u22C4";
var $560639d49e3c9a19$var$DifferentialD = "\u2146";
var $560639d49e3c9a19$var$Dopf = "\uD835\uDD3B";
var $560639d49e3c9a19$var$Dot = "\xa8";
var $560639d49e3c9a19$var$DotDot = "\u20DC";
var $560639d49e3c9a19$var$DotEqual = "\u2250";
var $560639d49e3c9a19$var$DoubleContourIntegral = "\u222F";
var $560639d49e3c9a19$var$DoubleDot = "\xa8";
var $560639d49e3c9a19$var$DoubleDownArrow = "\u21D3";
var $560639d49e3c9a19$var$DoubleLeftArrow = "\u21D0";
var $560639d49e3c9a19$var$DoubleLeftRightArrow = "\u21D4";
var $560639d49e3c9a19$var$DoubleLeftTee = "\u2AE4";
var $560639d49e3c9a19$var$DoubleLongLeftArrow = "\u27F8";
var $560639d49e3c9a19$var$DoubleLongLeftRightArrow = "\u27FA";
var $560639d49e3c9a19$var$DoubleLongRightArrow = "\u27F9";
var $560639d49e3c9a19$var$DoubleRightArrow = "\u21D2";
var $560639d49e3c9a19$var$DoubleRightTee = "\u22A8";
var $560639d49e3c9a19$var$DoubleUpArrow = "\u21D1";
var $560639d49e3c9a19$var$DoubleUpDownArrow = "\u21D5";
var $560639d49e3c9a19$var$DoubleVerticalBar = "\u2225";
var $560639d49e3c9a19$var$DownArrow = "\u2193";
var $560639d49e3c9a19$var$DownArrowBar = "\u2913";
var $560639d49e3c9a19$var$DownArrowUpArrow = "\u21F5";
var $560639d49e3c9a19$var$DownBreve = "\u0311";
var $560639d49e3c9a19$var$DownLeftRightVector = "\u2950";
var $560639d49e3c9a19$var$DownLeftTeeVector = "\u295E";
var $560639d49e3c9a19$var$DownLeftVector = "\u21BD";
var $560639d49e3c9a19$var$DownLeftVectorBar = "\u2956";
var $560639d49e3c9a19$var$DownRightTeeVector = "\u295F";
var $560639d49e3c9a19$var$DownRightVector = "\u21C1";
var $560639d49e3c9a19$var$DownRightVectorBar = "\u2957";
var $560639d49e3c9a19$var$DownTee = "\u22A4";
var $560639d49e3c9a19$var$DownTeeArrow = "\u21A7";
var $560639d49e3c9a19$var$Downarrow = "\u21D3";
var $560639d49e3c9a19$var$Dscr = "\uD835\uDC9F";
var $560639d49e3c9a19$var$Dstrok = "\u0110";
var $560639d49e3c9a19$var$ENG = "\u014A";
var $560639d49e3c9a19$var$ET = "\xd0";
var $560639d49e3c9a19$var$ETH$1 = "\xd0";
var $560639d49e3c9a19$var$Eacut = "\xc9";
var $560639d49e3c9a19$var$Eacute$1 = "\xc9";
var $560639d49e3c9a19$var$Ecaron = "\u011A";
var $560639d49e3c9a19$var$Ecir = "\xca";
var $560639d49e3c9a19$var$Ecirc$1 = "\xca";
var $560639d49e3c9a19$var$Ecy = "\u042D";
var $560639d49e3c9a19$var$Edot = "\u0116";
var $560639d49e3c9a19$var$Efr = "\uD835\uDD08";
var $560639d49e3c9a19$var$Egrav = "\xc8";
var $560639d49e3c9a19$var$Egrave$1 = "\xc8";
var $560639d49e3c9a19$var$Element = "\u2208";
var $560639d49e3c9a19$var$Emacr = "\u0112";
var $560639d49e3c9a19$var$EmptySmallSquare = "\u25FB";
var $560639d49e3c9a19$var$EmptyVerySmallSquare = "\u25AB";
var $560639d49e3c9a19$var$Eogon = "\u0118";
var $560639d49e3c9a19$var$Eopf = "\uD835\uDD3C";
var $560639d49e3c9a19$var$Epsilon$1 = "\u0395";
var $560639d49e3c9a19$var$Equal = "\u2A75";
var $560639d49e3c9a19$var$EqualTilde = "\u2242";
var $560639d49e3c9a19$var$Equilibrium = "\u21CC";
var $560639d49e3c9a19$var$Escr = "\u2130";
var $560639d49e3c9a19$var$Esim = "\u2A73";
var $560639d49e3c9a19$var$Eta$1 = "\u0397";
var $560639d49e3c9a19$var$Eum = "\xcb";
var $560639d49e3c9a19$var$Euml$1 = "\xcb";
var $560639d49e3c9a19$var$Exists = "\u2203";
var $560639d49e3c9a19$var$ExponentialE = "\u2147";
var $560639d49e3c9a19$var$Fcy = "\u0424";
var $560639d49e3c9a19$var$Ffr = "\uD835\uDD09";
var $560639d49e3c9a19$var$FilledSmallSquare = "\u25FC";
var $560639d49e3c9a19$var$FilledVerySmallSquare = "\u25AA";
var $560639d49e3c9a19$var$Fopf = "\uD835\uDD3D";
var $560639d49e3c9a19$var$ForAll = "\u2200";
var $560639d49e3c9a19$var$Fouriertrf = "\u2131";
var $560639d49e3c9a19$var$Fscr = "\u2131";
var $560639d49e3c9a19$var$GJcy = "\u0403";
var $560639d49e3c9a19$var$G = ">";
var $560639d49e3c9a19$var$GT$1 = ">";
var $560639d49e3c9a19$var$Gamma$1 = "\u0393";
var $560639d49e3c9a19$var$Gammad = "\u03DC";
var $560639d49e3c9a19$var$Gbreve = "\u011E";
var $560639d49e3c9a19$var$Gcedil = "\u0122";
var $560639d49e3c9a19$var$Gcirc = "\u011C";
var $560639d49e3c9a19$var$Gcy = "\u0413";
var $560639d49e3c9a19$var$Gdot = "\u0120";
var $560639d49e3c9a19$var$Gfr = "\uD835\uDD0A";
var $560639d49e3c9a19$var$Gg = "\u22D9";
var $560639d49e3c9a19$var$Gopf = "\uD835\uDD3E";
var $560639d49e3c9a19$var$GreaterEqual = "\u2265";
var $560639d49e3c9a19$var$GreaterEqualLess = "\u22DB";
var $560639d49e3c9a19$var$GreaterFullEqual = "\u2267";
var $560639d49e3c9a19$var$GreaterGreater = "\u2AA2";
var $560639d49e3c9a19$var$GreaterLess = "\u2277";
var $560639d49e3c9a19$var$GreaterSlantEqual = "\u2A7E";
var $560639d49e3c9a19$var$GreaterTilde = "\u2273";
var $560639d49e3c9a19$var$Gscr = "\uD835\uDCA2";
var $560639d49e3c9a19$var$Gt = "\u226B";
var $560639d49e3c9a19$var$HARDcy = "\u042A";
var $560639d49e3c9a19$var$Hacek = "\u02C7";
var $560639d49e3c9a19$var$Hat = "^";
var $560639d49e3c9a19$var$Hcirc = "\u0124";
var $560639d49e3c9a19$var$Hfr = "\u210C";
var $560639d49e3c9a19$var$HilbertSpace = "\u210B";
var $560639d49e3c9a19$var$Hopf = "\u210D";
var $560639d49e3c9a19$var$HorizontalLine = "\u2500";
var $560639d49e3c9a19$var$Hscr = "\u210B";
var $560639d49e3c9a19$var$Hstrok = "\u0126";
var $560639d49e3c9a19$var$HumpDownHump = "\u224E";
var $560639d49e3c9a19$var$HumpEqual = "\u224F";
var $560639d49e3c9a19$var$IEcy = "\u0415";
var $560639d49e3c9a19$var$IJlig = "\u0132";
var $560639d49e3c9a19$var$IOcy = "\u0401";
var $560639d49e3c9a19$var$Iacut = "\xcd";
var $560639d49e3c9a19$var$Iacute$1 = "\xcd";
var $560639d49e3c9a19$var$Icir = "\xce";
var $560639d49e3c9a19$var$Icirc$1 = "\xce";
var $560639d49e3c9a19$var$Icy = "\u0418";
var $560639d49e3c9a19$var$Idot = "\u0130";
var $560639d49e3c9a19$var$Ifr = "\u2111";
var $560639d49e3c9a19$var$Igrav = "\xcc";
var $560639d49e3c9a19$var$Igrave$1 = "\xcc";
var $560639d49e3c9a19$var$Im = "\u2111";
var $560639d49e3c9a19$var$Imacr = "\u012A";
var $560639d49e3c9a19$var$ImaginaryI = "\u2148";
var $560639d49e3c9a19$var$Implies = "\u21D2";
var $560639d49e3c9a19$var$Int = "\u222C";
var $560639d49e3c9a19$var$Integral = "\u222B";
var $560639d49e3c9a19$var$Intersection = "\u22C2";
var $560639d49e3c9a19$var$InvisibleComma = "\u2063";
var $560639d49e3c9a19$var$InvisibleTimes = "\u2062";
var $560639d49e3c9a19$var$Iogon = "\u012E";
var $560639d49e3c9a19$var$Iopf = "\uD835\uDD40";
var $560639d49e3c9a19$var$Iota$1 = "\u0399";
var $560639d49e3c9a19$var$Iscr = "\u2110";
var $560639d49e3c9a19$var$Itilde = "\u0128";
var $560639d49e3c9a19$var$Iukcy = "\u0406";
var $560639d49e3c9a19$var$Ium = "\xcf";
var $560639d49e3c9a19$var$Iuml$1 = "\xcf";
var $560639d49e3c9a19$var$Jcirc = "\u0134";
var $560639d49e3c9a19$var$Jcy = "\u0419";
var $560639d49e3c9a19$var$Jfr = "\uD835\uDD0D";
var $560639d49e3c9a19$var$Jopf = "\uD835\uDD41";
var $560639d49e3c9a19$var$Jscr = "\uD835\uDCA5";
var $560639d49e3c9a19$var$Jsercy = "\u0408";
var $560639d49e3c9a19$var$Jukcy = "\u0404";
var $560639d49e3c9a19$var$KHcy = "\u0425";
var $560639d49e3c9a19$var$KJcy = "\u040C";
var $560639d49e3c9a19$var$Kappa$1 = "\u039A";
var $560639d49e3c9a19$var$Kcedil = "\u0136";
var $560639d49e3c9a19$var$Kcy = "\u041A";
var $560639d49e3c9a19$var$Kfr = "\uD835\uDD0E";
var $560639d49e3c9a19$var$Kopf = "\uD835\uDD42";
var $560639d49e3c9a19$var$Kscr = "\uD835\uDCA6";
var $560639d49e3c9a19$var$LJcy = "\u0409";
var $560639d49e3c9a19$var$L = "<";
var $560639d49e3c9a19$var$LT$1 = "<";
var $560639d49e3c9a19$var$Lacute = "\u0139";
var $560639d49e3c9a19$var$Lambda$1 = "\u039B";
var $560639d49e3c9a19$var$Lang = "\u27EA";
var $560639d49e3c9a19$var$Laplacetrf = "\u2112";
var $560639d49e3c9a19$var$Larr = "\u219E";
var $560639d49e3c9a19$var$Lcaron = "\u013D";
var $560639d49e3c9a19$var$Lcedil = "\u013B";
var $560639d49e3c9a19$var$Lcy = "\u041B";
var $560639d49e3c9a19$var$LeftAngleBracket = "\u27E8";
var $560639d49e3c9a19$var$LeftArrow = "\u2190";
var $560639d49e3c9a19$var$LeftArrowBar = "\u21E4";
var $560639d49e3c9a19$var$LeftArrowRightArrow = "\u21C6";
var $560639d49e3c9a19$var$LeftCeiling = "\u2308";
var $560639d49e3c9a19$var$LeftDoubleBracket = "\u27E6";
var $560639d49e3c9a19$var$LeftDownTeeVector = "\u2961";
var $560639d49e3c9a19$var$LeftDownVector = "\u21C3";
var $560639d49e3c9a19$var$LeftDownVectorBar = "\u2959";
var $560639d49e3c9a19$var$LeftFloor = "\u230A";
var $560639d49e3c9a19$var$LeftRightArrow = "\u2194";
var $560639d49e3c9a19$var$LeftRightVector = "\u294E";
var $560639d49e3c9a19$var$LeftTee = "\u22A3";
var $560639d49e3c9a19$var$LeftTeeArrow = "\u21A4";
var $560639d49e3c9a19$var$LeftTeeVector = "\u295A";
var $560639d49e3c9a19$var$LeftTriangle = "\u22B2";
var $560639d49e3c9a19$var$LeftTriangleBar = "\u29CF";
var $560639d49e3c9a19$var$LeftTriangleEqual = "\u22B4";
var $560639d49e3c9a19$var$LeftUpDownVector = "\u2951";
var $560639d49e3c9a19$var$LeftUpTeeVector = "\u2960";
var $560639d49e3c9a19$var$LeftUpVector = "\u21BF";
var $560639d49e3c9a19$var$LeftUpVectorBar = "\u2958";
var $560639d49e3c9a19$var$LeftVector = "\u21BC";
var $560639d49e3c9a19$var$LeftVectorBar = "\u2952";
var $560639d49e3c9a19$var$Leftarrow = "\u21D0";
var $560639d49e3c9a19$var$Leftrightarrow = "\u21D4";
var $560639d49e3c9a19$var$LessEqualGreater = "\u22DA";
var $560639d49e3c9a19$var$LessFullEqual = "\u2266";
var $560639d49e3c9a19$var$LessGreater = "\u2276";
var $560639d49e3c9a19$var$LessLess = "\u2AA1";
var $560639d49e3c9a19$var$LessSlantEqual = "\u2A7D";
var $560639d49e3c9a19$var$LessTilde = "\u2272";
var $560639d49e3c9a19$var$Lfr = "\uD835\uDD0F";
var $560639d49e3c9a19$var$Ll = "\u22D8";
var $560639d49e3c9a19$var$Lleftarrow = "\u21DA";
var $560639d49e3c9a19$var$Lmidot = "\u013F";
var $560639d49e3c9a19$var$LongLeftArrow = "\u27F5";
var $560639d49e3c9a19$var$LongLeftRightArrow = "\u27F7";
var $560639d49e3c9a19$var$LongRightArrow = "\u27F6";
var $560639d49e3c9a19$var$Longleftarrow = "\u27F8";
var $560639d49e3c9a19$var$Longleftrightarrow = "\u27FA";
var $560639d49e3c9a19$var$Longrightarrow = "\u27F9";
var $560639d49e3c9a19$var$Lopf = "\uD835\uDD43";
var $560639d49e3c9a19$var$LowerLeftArrow = "\u2199";
var $560639d49e3c9a19$var$LowerRightArrow = "\u2198";
var $560639d49e3c9a19$var$Lscr = "\u2112";
var $560639d49e3c9a19$var$Lsh = "\u21B0";
var $560639d49e3c9a19$var$Lstrok = "\u0141";
var $560639d49e3c9a19$var$Lt = "\u226A";
var $560639d49e3c9a19$var$Mcy = "\u041C";
var $560639d49e3c9a19$var$MediumSpace = "\u205F";
var $560639d49e3c9a19$var$Mellintrf = "\u2133";
var $560639d49e3c9a19$var$Mfr = "\uD835\uDD10";
var $560639d49e3c9a19$var$MinusPlus = "\u2213";
var $560639d49e3c9a19$var$Mopf = "\uD835\uDD44";
var $560639d49e3c9a19$var$Mscr = "\u2133";
var $560639d49e3c9a19$var$Mu$1 = "\u039C";
var $560639d49e3c9a19$var$NJcy = "\u040A";
var $560639d49e3c9a19$var$Nacute = "\u0143";
var $560639d49e3c9a19$var$Ncaron = "\u0147";
var $560639d49e3c9a19$var$Ncedil = "\u0145";
var $560639d49e3c9a19$var$Ncy = "\u041D";
var $560639d49e3c9a19$var$NegativeMediumSpace = "\u200B";
var $560639d49e3c9a19$var$NegativeThickSpace = "\u200B";
var $560639d49e3c9a19$var$NegativeThinSpace = "\u200B";
var $560639d49e3c9a19$var$NegativeVeryThinSpace = "\u200B";
var $560639d49e3c9a19$var$NestedGreaterGreater = "\u226B";
var $560639d49e3c9a19$var$NestedLessLess = "\u226A";
var $560639d49e3c9a19$var$NewLine = "\n";
var $560639d49e3c9a19$var$Nfr = "\uD835\uDD11";
var $560639d49e3c9a19$var$NoBreak = "\u2060";
var $560639d49e3c9a19$var$NonBreakingSpace = "\xa0";
var $560639d49e3c9a19$var$Nopf = "\u2115";
var $560639d49e3c9a19$var$Not = "\u2AEC";
var $560639d49e3c9a19$var$NotCongruent = "\u2262";
var $560639d49e3c9a19$var$NotCupCap = "\u226D";
var $560639d49e3c9a19$var$NotDoubleVerticalBar = "\u2226";
var $560639d49e3c9a19$var$NotElement = "\u2209";
var $560639d49e3c9a19$var$NotEqual = "\u2260";
var $560639d49e3c9a19$var$NotEqualTilde = "\u2242\u0338";
var $560639d49e3c9a19$var$NotExists = "\u2204";
var $560639d49e3c9a19$var$NotGreater = "\u226F";
var $560639d49e3c9a19$var$NotGreaterEqual = "\u2271";
var $560639d49e3c9a19$var$NotGreaterFullEqual = "\u2267\u0338";
var $560639d49e3c9a19$var$NotGreaterGreater = "\u226B\u0338";
var $560639d49e3c9a19$var$NotGreaterLess = "\u2279";
var $560639d49e3c9a19$var$NotGreaterSlantEqual = "\u2A7E\u0338";
var $560639d49e3c9a19$var$NotGreaterTilde = "\u2275";
var $560639d49e3c9a19$var$NotHumpDownHump = "\u224E\u0338";
var $560639d49e3c9a19$var$NotHumpEqual = "\u224F\u0338";
var $560639d49e3c9a19$var$NotLeftTriangle = "\u22EA";
var $560639d49e3c9a19$var$NotLeftTriangleBar = "\u29CF\u0338";
var $560639d49e3c9a19$var$NotLeftTriangleEqual = "\u22EC";
var $560639d49e3c9a19$var$NotLess = "\u226E";
var $560639d49e3c9a19$var$NotLessEqual = "\u2270";
var $560639d49e3c9a19$var$NotLessGreater = "\u2278";
var $560639d49e3c9a19$var$NotLessLess = "\u226A\u0338";
var $560639d49e3c9a19$var$NotLessSlantEqual = "\u2A7D\u0338";
var $560639d49e3c9a19$var$NotLessTilde = "\u2274";
var $560639d49e3c9a19$var$NotNestedGreaterGreater = "\u2AA2\u0338";
var $560639d49e3c9a19$var$NotNestedLessLess = "\u2AA1\u0338";
var $560639d49e3c9a19$var$NotPrecedes = "\u2280";
var $560639d49e3c9a19$var$NotPrecedesEqual = "\u2AAF\u0338";
var $560639d49e3c9a19$var$NotPrecedesSlantEqual = "\u22E0";
var $560639d49e3c9a19$var$NotReverseElement = "\u220C";
var $560639d49e3c9a19$var$NotRightTriangle = "\u22EB";
var $560639d49e3c9a19$var$NotRightTriangleBar = "\u29D0\u0338";
var $560639d49e3c9a19$var$NotRightTriangleEqual = "\u22ED";
var $560639d49e3c9a19$var$NotSquareSubset = "\u228F\u0338";
var $560639d49e3c9a19$var$NotSquareSubsetEqual = "\u22E2";
var $560639d49e3c9a19$var$NotSquareSuperset = "\u2290\u0338";
var $560639d49e3c9a19$var$NotSquareSupersetEqual = "\u22E3";
var $560639d49e3c9a19$var$NotSubset = "\u2282\u20D2";
var $560639d49e3c9a19$var$NotSubsetEqual = "\u2288";
var $560639d49e3c9a19$var$NotSucceeds = "\u2281";
var $560639d49e3c9a19$var$NotSucceedsEqual = "\u2AB0\u0338";
var $560639d49e3c9a19$var$NotSucceedsSlantEqual = "\u22E1";
var $560639d49e3c9a19$var$NotSucceedsTilde = "\u227F\u0338";
var $560639d49e3c9a19$var$NotSuperset = "\u2283\u20D2";
var $560639d49e3c9a19$var$NotSupersetEqual = "\u2289";
var $560639d49e3c9a19$var$NotTilde = "\u2241";
var $560639d49e3c9a19$var$NotTildeEqual = "\u2244";
var $560639d49e3c9a19$var$NotTildeFullEqual = "\u2247";
var $560639d49e3c9a19$var$NotTildeTilde = "\u2249";
var $560639d49e3c9a19$var$NotVerticalBar = "\u2224";
var $560639d49e3c9a19$var$Nscr = "\uD835\uDCA9";
var $560639d49e3c9a19$var$Ntild = "\xd1";
var $560639d49e3c9a19$var$Ntilde$1 = "\xd1";
var $560639d49e3c9a19$var$Nu$1 = "\u039D";
var $560639d49e3c9a19$var$OElig$1 = "\u0152";
var $560639d49e3c9a19$var$Oacut = "\xd3";
var $560639d49e3c9a19$var$Oacute$1 = "\xd3";
var $560639d49e3c9a19$var$Ocir = "\xd4";
var $560639d49e3c9a19$var$Ocirc$1 = "\xd4";
var $560639d49e3c9a19$var$Ocy = "\u041E";
var $560639d49e3c9a19$var$Odblac = "\u0150";
var $560639d49e3c9a19$var$Ofr = "\uD835\uDD12";
var $560639d49e3c9a19$var$Ograv = "\xd2";
var $560639d49e3c9a19$var$Ograve$1 = "\xd2";
var $560639d49e3c9a19$var$Omacr = "\u014C";
var $560639d49e3c9a19$var$Omega$1 = "\u03A9";
var $560639d49e3c9a19$var$Omicron$1 = "\u039F";
var $560639d49e3c9a19$var$Oopf = "\uD835\uDD46";
var $560639d49e3c9a19$var$OpenCurlyDoubleQuote = "\u201C";
var $560639d49e3c9a19$var$OpenCurlyQuote = "\u2018";
var $560639d49e3c9a19$var$Or = "\u2A54";
var $560639d49e3c9a19$var$Oscr = "\uD835\uDCAA";
var $560639d49e3c9a19$var$Oslas = "\xd8";
var $560639d49e3c9a19$var$Oslash$1 = "\xd8";
var $560639d49e3c9a19$var$Otild = "\xd5";
var $560639d49e3c9a19$var$Otilde$1 = "\xd5";
var $560639d49e3c9a19$var$Otimes = "\u2A37";
var $560639d49e3c9a19$var$Oum = "\xd6";
var $560639d49e3c9a19$var$Ouml$1 = "\xd6";
var $560639d49e3c9a19$var$OverBar = "\u203E";
var $560639d49e3c9a19$var$OverBrace = "\u23DE";
var $560639d49e3c9a19$var$OverBracket = "\u23B4";
var $560639d49e3c9a19$var$OverParenthesis = "\u23DC";
var $560639d49e3c9a19$var$PartialD = "\u2202";
var $560639d49e3c9a19$var$Pcy = "\u041F";
var $560639d49e3c9a19$var$Pfr = "\uD835\uDD13";
var $560639d49e3c9a19$var$Phi$1 = "\u03A6";
var $560639d49e3c9a19$var$Pi$1 = "\u03A0";
var $560639d49e3c9a19$var$PlusMinus = "\xb1";
var $560639d49e3c9a19$var$Poincareplane = "\u210C";
var $560639d49e3c9a19$var$Popf = "\u2119";
var $560639d49e3c9a19$var$Pr = "\u2ABB";
var $560639d49e3c9a19$var$Precedes = "\u227A";
var $560639d49e3c9a19$var$PrecedesEqual = "\u2AAF";
var $560639d49e3c9a19$var$PrecedesSlantEqual = "\u227C";
var $560639d49e3c9a19$var$PrecedesTilde = "\u227E";
var $560639d49e3c9a19$var$Prime$1 = "\u2033";
var $560639d49e3c9a19$var$Product = "\u220F";
var $560639d49e3c9a19$var$Proportion = "\u2237";
var $560639d49e3c9a19$var$Proportional = "\u221D";
var $560639d49e3c9a19$var$Pscr = "\uD835\uDCAB";
var $560639d49e3c9a19$var$Psi$1 = "\u03A8";
var $560639d49e3c9a19$var$QUO = '"';
var $560639d49e3c9a19$var$QUOT = '"';
var $560639d49e3c9a19$var$Qfr = "\uD835\uDD14";
var $560639d49e3c9a19$var$Qopf = "\u211A";
var $560639d49e3c9a19$var$Qscr = "\uD835\uDCAC";
var $560639d49e3c9a19$var$RBarr = "\u2910";
var $560639d49e3c9a19$var$RE = "\xae";
var $560639d49e3c9a19$var$REG = "\xae";
var $560639d49e3c9a19$var$Racute = "\u0154";
var $560639d49e3c9a19$var$Rang = "\u27EB";
var $560639d49e3c9a19$var$Rarr = "\u21A0";
var $560639d49e3c9a19$var$Rarrtl = "\u2916";
var $560639d49e3c9a19$var$Rcaron = "\u0158";
var $560639d49e3c9a19$var$Rcedil = "\u0156";
var $560639d49e3c9a19$var$Rcy = "\u0420";
var $560639d49e3c9a19$var$Re = "\u211C";
var $560639d49e3c9a19$var$ReverseElement = "\u220B";
var $560639d49e3c9a19$var$ReverseEquilibrium = "\u21CB";
var $560639d49e3c9a19$var$ReverseUpEquilibrium = "\u296F";
var $560639d49e3c9a19$var$Rfr = "\u211C";
var $560639d49e3c9a19$var$Rho$1 = "\u03A1";
var $560639d49e3c9a19$var$RightAngleBracket = "\u27E9";
var $560639d49e3c9a19$var$RightArrow = "\u2192";
var $560639d49e3c9a19$var$RightArrowBar = "\u21E5";
var $560639d49e3c9a19$var$RightArrowLeftArrow = "\u21C4";
var $560639d49e3c9a19$var$RightCeiling = "\u2309";
var $560639d49e3c9a19$var$RightDoubleBracket = "\u27E7";
var $560639d49e3c9a19$var$RightDownTeeVector = "\u295D";
var $560639d49e3c9a19$var$RightDownVector = "\u21C2";
var $560639d49e3c9a19$var$RightDownVectorBar = "\u2955";
var $560639d49e3c9a19$var$RightFloor = "\u230B";
var $560639d49e3c9a19$var$RightTee = "\u22A2";
var $560639d49e3c9a19$var$RightTeeArrow = "\u21A6";
var $560639d49e3c9a19$var$RightTeeVector = "\u295B";
var $560639d49e3c9a19$var$RightTriangle = "\u22B3";
var $560639d49e3c9a19$var$RightTriangleBar = "\u29D0";
var $560639d49e3c9a19$var$RightTriangleEqual = "\u22B5";
var $560639d49e3c9a19$var$RightUpDownVector = "\u294F";
var $560639d49e3c9a19$var$RightUpTeeVector = "\u295C";
var $560639d49e3c9a19$var$RightUpVector = "\u21BE";
var $560639d49e3c9a19$var$RightUpVectorBar = "\u2954";
var $560639d49e3c9a19$var$RightVector = "\u21C0";
var $560639d49e3c9a19$var$RightVectorBar = "\u2953";
var $560639d49e3c9a19$var$Rightarrow = "\u21D2";
var $560639d49e3c9a19$var$Ropf = "\u211D";
var $560639d49e3c9a19$var$RoundImplies = "\u2970";
var $560639d49e3c9a19$var$Rrightarrow = "\u21DB";
var $560639d49e3c9a19$var$Rscr = "\u211B";
var $560639d49e3c9a19$var$Rsh = "\u21B1";
var $560639d49e3c9a19$var$RuleDelayed = "\u29F4";
var $560639d49e3c9a19$var$SHCHcy = "\u0429";
var $560639d49e3c9a19$var$SHcy = "\u0428";
var $560639d49e3c9a19$var$SOFTcy = "\u042C";
var $560639d49e3c9a19$var$Sacute = "\u015A";
var $560639d49e3c9a19$var$Sc = "\u2ABC";
var $560639d49e3c9a19$var$Scaron$1 = "\u0160";
var $560639d49e3c9a19$var$Scedil = "\u015E";
var $560639d49e3c9a19$var$Scirc = "\u015C";
var $560639d49e3c9a19$var$Scy = "\u0421";
var $560639d49e3c9a19$var$Sfr = "\uD835\uDD16";
var $560639d49e3c9a19$var$ShortDownArrow = "\u2193";
var $560639d49e3c9a19$var$ShortLeftArrow = "\u2190";
var $560639d49e3c9a19$var$ShortRightArrow = "\u2192";
var $560639d49e3c9a19$var$ShortUpArrow = "\u2191";
var $560639d49e3c9a19$var$Sigma$1 = "\u03A3";
var $560639d49e3c9a19$var$SmallCircle = "\u2218";
var $560639d49e3c9a19$var$Sopf = "\uD835\uDD4A";
var $560639d49e3c9a19$var$Sqrt = "\u221A";
var $560639d49e3c9a19$var$Square = "\u25A1";
var $560639d49e3c9a19$var$SquareIntersection = "\u2293";
var $560639d49e3c9a19$var$SquareSubset = "\u228F";
var $560639d49e3c9a19$var$SquareSubsetEqual = "\u2291";
var $560639d49e3c9a19$var$SquareSuperset = "\u2290";
var $560639d49e3c9a19$var$SquareSupersetEqual = "\u2292";
var $560639d49e3c9a19$var$SquareUnion = "\u2294";
var $560639d49e3c9a19$var$Sscr = "\uD835\uDCAE";
var $560639d49e3c9a19$var$Star = "\u22C6";
var $560639d49e3c9a19$var$Sub = "\u22D0";
var $560639d49e3c9a19$var$Subset = "\u22D0";
var $560639d49e3c9a19$var$SubsetEqual = "\u2286";
var $560639d49e3c9a19$var$Succeeds = "\u227B";
var $560639d49e3c9a19$var$SucceedsEqual = "\u2AB0";
var $560639d49e3c9a19$var$SucceedsSlantEqual = "\u227D";
var $560639d49e3c9a19$var$SucceedsTilde = "\u227F";
var $560639d49e3c9a19$var$SuchThat = "\u220B";
var $560639d49e3c9a19$var$Sum = "\u2211";
var $560639d49e3c9a19$var$Sup = "\u22D1";
var $560639d49e3c9a19$var$Superset = "\u2283";
var $560639d49e3c9a19$var$SupersetEqual = "\u2287";
var $560639d49e3c9a19$var$Supset = "\u22D1";
var $560639d49e3c9a19$var$THOR = "\xde";
var $560639d49e3c9a19$var$THORN$1 = "\xde";
var $560639d49e3c9a19$var$TRADE = "\u2122";
var $560639d49e3c9a19$var$TSHcy = "\u040B";
var $560639d49e3c9a19$var$TScy = "\u0426";
var $560639d49e3c9a19$var$Tab = "	";
var $560639d49e3c9a19$var$Tau$1 = "\u03A4";
var $560639d49e3c9a19$var$Tcaron = "\u0164";
var $560639d49e3c9a19$var$Tcedil = "\u0162";
var $560639d49e3c9a19$var$Tcy = "\u0422";
var $560639d49e3c9a19$var$Tfr = "\uD835\uDD17";
var $560639d49e3c9a19$var$Therefore = "\u2234";
var $560639d49e3c9a19$var$Theta$1 = "\u0398";
var $560639d49e3c9a19$var$ThickSpace = "\u205F\u200A";
var $560639d49e3c9a19$var$ThinSpace = "\u2009";
var $560639d49e3c9a19$var$Tilde = "\u223C";
var $560639d49e3c9a19$var$TildeEqual = "\u2243";
var $560639d49e3c9a19$var$TildeFullEqual = "\u2245";
var $560639d49e3c9a19$var$TildeTilde = "\u2248";
var $560639d49e3c9a19$var$Topf = "\uD835\uDD4B";
var $560639d49e3c9a19$var$TripleDot = "\u20DB";
var $560639d49e3c9a19$var$Tscr = "\uD835\uDCAF";
var $560639d49e3c9a19$var$Tstrok = "\u0166";
var $560639d49e3c9a19$var$Uacut = "\xda";
var $560639d49e3c9a19$var$Uacute$1 = "\xda";
var $560639d49e3c9a19$var$Uarr = "\u219F";
var $560639d49e3c9a19$var$Uarrocir = "\u2949";
var $560639d49e3c9a19$var$Ubrcy = "\u040E";
var $560639d49e3c9a19$var$Ubreve = "\u016C";
var $560639d49e3c9a19$var$Ucir = "\xdb";
var $560639d49e3c9a19$var$Ucirc$1 = "\xdb";
var $560639d49e3c9a19$var$Ucy = "\u0423";
var $560639d49e3c9a19$var$Udblac = "\u0170";
var $560639d49e3c9a19$var$Ufr = "\uD835\uDD18";
var $560639d49e3c9a19$var$Ugrav = "\xd9";
var $560639d49e3c9a19$var$Ugrave$1 = "\xd9";
var $560639d49e3c9a19$var$Umacr = "\u016A";
var $560639d49e3c9a19$var$UnderBar = "_";
var $560639d49e3c9a19$var$UnderBrace = "\u23DF";
var $560639d49e3c9a19$var$UnderBracket = "\u23B5";
var $560639d49e3c9a19$var$UnderParenthesis = "\u23DD";
var $560639d49e3c9a19$var$Union = "\u22C3";
var $560639d49e3c9a19$var$UnionPlus = "\u228E";
var $560639d49e3c9a19$var$Uogon = "\u0172";
var $560639d49e3c9a19$var$Uopf = "\uD835\uDD4C";
var $560639d49e3c9a19$var$UpArrow = "\u2191";
var $560639d49e3c9a19$var$UpArrowBar = "\u2912";
var $560639d49e3c9a19$var$UpArrowDownArrow = "\u21C5";
var $560639d49e3c9a19$var$UpDownArrow = "\u2195";
var $560639d49e3c9a19$var$UpEquilibrium = "\u296E";
var $560639d49e3c9a19$var$UpTee = "\u22A5";
var $560639d49e3c9a19$var$UpTeeArrow = "\u21A5";
var $560639d49e3c9a19$var$Uparrow = "\u21D1";
var $560639d49e3c9a19$var$Updownarrow = "\u21D5";
var $560639d49e3c9a19$var$UpperLeftArrow = "\u2196";
var $560639d49e3c9a19$var$UpperRightArrow = "\u2197";
var $560639d49e3c9a19$var$Upsi = "\u03D2";
var $560639d49e3c9a19$var$Upsilon$1 = "\u03A5";
var $560639d49e3c9a19$var$Uring = "\u016E";
var $560639d49e3c9a19$var$Uscr = "\uD835\uDCB0";
var $560639d49e3c9a19$var$Utilde = "\u0168";
var $560639d49e3c9a19$var$Uum = "\xdc";
var $560639d49e3c9a19$var$Uuml$1 = "\xdc";
var $560639d49e3c9a19$var$VDash = "\u22AB";
var $560639d49e3c9a19$var$Vbar = "\u2AEB";
var $560639d49e3c9a19$var$Vcy = "\u0412";
var $560639d49e3c9a19$var$Vdash = "\u22A9";
var $560639d49e3c9a19$var$Vdashl = "\u2AE6";
var $560639d49e3c9a19$var$Vee = "\u22C1";
var $560639d49e3c9a19$var$Verbar = "\u2016";
var $560639d49e3c9a19$var$Vert = "\u2016";
var $560639d49e3c9a19$var$VerticalBar = "\u2223";
var $560639d49e3c9a19$var$VerticalLine = "|";
var $560639d49e3c9a19$var$VerticalSeparator = "\u2758";
var $560639d49e3c9a19$var$VerticalTilde = "\u2240";
var $560639d49e3c9a19$var$VeryThinSpace = "\u200A";
var $560639d49e3c9a19$var$Vfr = "\uD835\uDD19";
var $560639d49e3c9a19$var$Vopf = "\uD835\uDD4D";
var $560639d49e3c9a19$var$Vscr = "\uD835\uDCB1";
var $560639d49e3c9a19$var$Vvdash = "\u22AA";
var $560639d49e3c9a19$var$Wcirc = "\u0174";
var $560639d49e3c9a19$var$Wedge = "\u22C0";
var $560639d49e3c9a19$var$Wfr = "\uD835\uDD1A";
var $560639d49e3c9a19$var$Wopf = "\uD835\uDD4E";
var $560639d49e3c9a19$var$Wscr = "\uD835\uDCB2";
var $560639d49e3c9a19$var$Xfr = "\uD835\uDD1B";
var $560639d49e3c9a19$var$Xi$1 = "\u039E";
var $560639d49e3c9a19$var$Xopf = "\uD835\uDD4F";
var $560639d49e3c9a19$var$Xscr = "\uD835\uDCB3";
var $560639d49e3c9a19$var$YAcy = "\u042F";
var $560639d49e3c9a19$var$YIcy = "\u0407";
var $560639d49e3c9a19$var$YUcy = "\u042E";
var $560639d49e3c9a19$var$Yacut = "\xdd";
var $560639d49e3c9a19$var$Yacute$1 = "\xdd";
var $560639d49e3c9a19$var$Ycirc = "\u0176";
var $560639d49e3c9a19$var$Ycy = "\u042B";
var $560639d49e3c9a19$var$Yfr = "\uD835\uDD1C";
var $560639d49e3c9a19$var$Yopf = "\uD835\uDD50";
var $560639d49e3c9a19$var$Yscr = "\uD835\uDCB4";
var $560639d49e3c9a19$var$Yuml$1 = "\u0178";
var $560639d49e3c9a19$var$ZHcy = "\u0416";
var $560639d49e3c9a19$var$Zacute = "\u0179";
var $560639d49e3c9a19$var$Zcaron = "\u017D";
var $560639d49e3c9a19$var$Zcy = "\u0417";
var $560639d49e3c9a19$var$Zdot = "\u017B";
var $560639d49e3c9a19$var$ZeroWidthSpace = "\u200B";
var $560639d49e3c9a19$var$Zeta$1 = "\u0396";
var $560639d49e3c9a19$var$Zfr = "\u2128";
var $560639d49e3c9a19$var$Zopf = "\u2124";
var $560639d49e3c9a19$var$Zscr = "\uD835\uDCB5";
var $560639d49e3c9a19$var$aacut = "\xe1";
var $560639d49e3c9a19$var$aacute$1 = "\xe1";
var $560639d49e3c9a19$var$abreve = "\u0103";
var $560639d49e3c9a19$var$ac = "\u223E";
var $560639d49e3c9a19$var$acE = "\u223E\u0333";
var $560639d49e3c9a19$var$acd = "\u223F";
var $560639d49e3c9a19$var$acir = "\xe2";
var $560639d49e3c9a19$var$acirc$1 = "\xe2";
var $560639d49e3c9a19$var$acut = "\xb4";
var $560639d49e3c9a19$var$acute$1 = "\xb4";
var $560639d49e3c9a19$var$acy = "\u0430";
var $560639d49e3c9a19$var$aeli = "\xe6";
var $560639d49e3c9a19$var$aelig$1 = "\xe6";
var $560639d49e3c9a19$var$af = "\u2061";
var $560639d49e3c9a19$var$afr = "\uD835\uDD1E";
var $560639d49e3c9a19$var$agrav = "\xe0";
var $560639d49e3c9a19$var$agrave$1 = "\xe0";
var $560639d49e3c9a19$var$alefsym$1 = "\u2135";
var $560639d49e3c9a19$var$aleph = "\u2135";
var $560639d49e3c9a19$var$alpha$1 = "\u03B1";
var $560639d49e3c9a19$var$amacr = "\u0101";
var $560639d49e3c9a19$var$amalg = "\u2A3F";
var $560639d49e3c9a19$var$am = "&";
var $560639d49e3c9a19$var$amp$1 = "&";
var $560639d49e3c9a19$var$and$1 = "\u2227";
var $560639d49e3c9a19$var$andand = "\u2A55";
var $560639d49e3c9a19$var$andd = "\u2A5C";
var $560639d49e3c9a19$var$andslope = "\u2A58";
var $560639d49e3c9a19$var$andv = "\u2A5A";
var $560639d49e3c9a19$var$ang$1 = "\u2220";
var $560639d49e3c9a19$var$ange = "\u29A4";
var $560639d49e3c9a19$var$angle = "\u2220";
var $560639d49e3c9a19$var$angmsd = "\u2221";
var $560639d49e3c9a19$var$angmsdaa = "\u29A8";
var $560639d49e3c9a19$var$angmsdab = "\u29A9";
var $560639d49e3c9a19$var$angmsdac = "\u29AA";
var $560639d49e3c9a19$var$angmsdad = "\u29AB";
var $560639d49e3c9a19$var$angmsdae = "\u29AC";
var $560639d49e3c9a19$var$angmsdaf = "\u29AD";
var $560639d49e3c9a19$var$angmsdag = "\u29AE";
var $560639d49e3c9a19$var$angmsdah = "\u29AF";
var $560639d49e3c9a19$var$angrt = "\u221F";
var $560639d49e3c9a19$var$angrtvb = "\u22BE";
var $560639d49e3c9a19$var$angrtvbd = "\u299D";
var $560639d49e3c9a19$var$angsph = "\u2222";
var $560639d49e3c9a19$var$angst = "\xc5";
var $560639d49e3c9a19$var$angzarr = "\u237C";
var $560639d49e3c9a19$var$aogon = "\u0105";
var $560639d49e3c9a19$var$aopf = "\uD835\uDD52";
var $560639d49e3c9a19$var$ap = "\u2248";
var $560639d49e3c9a19$var$apE = "\u2A70";
var $560639d49e3c9a19$var$apacir = "\u2A6F";
var $560639d49e3c9a19$var$ape = "\u224A";
var $560639d49e3c9a19$var$apid = "\u224B";
var $560639d49e3c9a19$var$apos = "'";
var $560639d49e3c9a19$var$approx = "\u2248";
var $560639d49e3c9a19$var$approxeq = "\u224A";
var $560639d49e3c9a19$var$arin = "\xe5";
var $560639d49e3c9a19$var$aring$1 = "\xe5";
var $560639d49e3c9a19$var$ascr = "\uD835\uDCB6";
var $560639d49e3c9a19$var$ast = "*";
var $560639d49e3c9a19$var$asymp$1 = "\u2248";
var $560639d49e3c9a19$var$asympeq = "\u224D";
var $560639d49e3c9a19$var$atild = "\xe3";
var $560639d49e3c9a19$var$atilde$1 = "\xe3";
var $560639d49e3c9a19$var$aum = "\xe4";
var $560639d49e3c9a19$var$auml$1 = "\xe4";
var $560639d49e3c9a19$var$awconint = "\u2233";
var $560639d49e3c9a19$var$awint = "\u2A11";
var $560639d49e3c9a19$var$bNot = "\u2AED";
var $560639d49e3c9a19$var$backcong = "\u224C";
var $560639d49e3c9a19$var$backepsilon = "\u03F6";
var $560639d49e3c9a19$var$backprime = "\u2035";
var $560639d49e3c9a19$var$backsim = "\u223D";
var $560639d49e3c9a19$var$backsimeq = "\u22CD";
var $560639d49e3c9a19$var$barvee = "\u22BD";
var $560639d49e3c9a19$var$barwed = "\u2305";
var $560639d49e3c9a19$var$barwedge = "\u2305";
var $560639d49e3c9a19$var$bbrk = "\u23B5";
var $560639d49e3c9a19$var$bbrktbrk = "\u23B6";
var $560639d49e3c9a19$var$bcong = "\u224C";
var $560639d49e3c9a19$var$bcy = "\u0431";
var $560639d49e3c9a19$var$bdquo$1 = "\u201E";
var $560639d49e3c9a19$var$becaus = "\u2235";
var $560639d49e3c9a19$var$because = "\u2235";
var $560639d49e3c9a19$var$bemptyv = "\u29B0";
var $560639d49e3c9a19$var$bepsi = "\u03F6";
var $560639d49e3c9a19$var$bernou = "\u212C";
var $560639d49e3c9a19$var$beta$1 = "\u03B2";
var $560639d49e3c9a19$var$beth = "\u2136";
var $560639d49e3c9a19$var$between = "\u226C";
var $560639d49e3c9a19$var$bfr = "\uD835\uDD1F";
var $560639d49e3c9a19$var$bigcap = "\u22C2";
var $560639d49e3c9a19$var$bigcirc = "\u25EF";
var $560639d49e3c9a19$var$bigcup = "\u22C3";
var $560639d49e3c9a19$var$bigodot = "\u2A00";
var $560639d49e3c9a19$var$bigoplus = "\u2A01";
var $560639d49e3c9a19$var$bigotimes = "\u2A02";
var $560639d49e3c9a19$var$bigsqcup = "\u2A06";
var $560639d49e3c9a19$var$bigstar = "\u2605";
var $560639d49e3c9a19$var$bigtriangledown = "\u25BD";
var $560639d49e3c9a19$var$bigtriangleup = "\u25B3";
var $560639d49e3c9a19$var$biguplus = "\u2A04";
var $560639d49e3c9a19$var$bigvee = "\u22C1";
var $560639d49e3c9a19$var$bigwedge = "\u22C0";
var $560639d49e3c9a19$var$bkarow = "\u290D";
var $560639d49e3c9a19$var$blacklozenge = "\u29EB";
var $560639d49e3c9a19$var$blacksquare = "\u25AA";
var $560639d49e3c9a19$var$blacktriangle = "\u25B4";
var $560639d49e3c9a19$var$blacktriangledown = "\u25BE";
var $560639d49e3c9a19$var$blacktriangleleft = "\u25C2";
var $560639d49e3c9a19$var$blacktriangleright = "\u25B8";
var $560639d49e3c9a19$var$blank = "\u2423";
var $560639d49e3c9a19$var$blk12 = "\u2592";
var $560639d49e3c9a19$var$blk14 = "\u2591";
var $560639d49e3c9a19$var$blk34 = "\u2593";
var $560639d49e3c9a19$var$block = "\u2588";
var $560639d49e3c9a19$var$bne = "=\u20E5";
var $560639d49e3c9a19$var$bnequiv = "\u2261\u20E5";
var $560639d49e3c9a19$var$bnot = "\u2310";
var $560639d49e3c9a19$var$bopf = "\uD835\uDD53";
var $560639d49e3c9a19$var$bot = "\u22A5";
var $560639d49e3c9a19$var$bottom = "\u22A5";
var $560639d49e3c9a19$var$bowtie = "\u22C8";
var $560639d49e3c9a19$var$boxDL = "\u2557";
var $560639d49e3c9a19$var$boxDR = "\u2554";
var $560639d49e3c9a19$var$boxDl = "\u2556";
var $560639d49e3c9a19$var$boxDr = "\u2553";
var $560639d49e3c9a19$var$boxH = "\u2550";
var $560639d49e3c9a19$var$boxHD = "\u2566";
var $560639d49e3c9a19$var$boxHU = "\u2569";
var $560639d49e3c9a19$var$boxHd = "\u2564";
var $560639d49e3c9a19$var$boxHu = "\u2567";
var $560639d49e3c9a19$var$boxUL = "\u255D";
var $560639d49e3c9a19$var$boxUR = "\u255A";
var $560639d49e3c9a19$var$boxUl = "\u255C";
var $560639d49e3c9a19$var$boxUr = "\u2559";
var $560639d49e3c9a19$var$boxV = "\u2551";
var $560639d49e3c9a19$var$boxVH = "\u256C";
var $560639d49e3c9a19$var$boxVL = "\u2563";
var $560639d49e3c9a19$var$boxVR = "\u2560";
var $560639d49e3c9a19$var$boxVh = "\u256B";
var $560639d49e3c9a19$var$boxVl = "\u2562";
var $560639d49e3c9a19$var$boxVr = "\u255F";
var $560639d49e3c9a19$var$boxbox = "\u29C9";
var $560639d49e3c9a19$var$boxdL = "\u2555";
var $560639d49e3c9a19$var$boxdR = "\u2552";
var $560639d49e3c9a19$var$boxdl = "\u2510";
var $560639d49e3c9a19$var$boxdr = "\u250C";
var $560639d49e3c9a19$var$boxh = "\u2500";
var $560639d49e3c9a19$var$boxhD = "\u2565";
var $560639d49e3c9a19$var$boxhU = "\u2568";
var $560639d49e3c9a19$var$boxhd = "\u252C";
var $560639d49e3c9a19$var$boxhu = "\u2534";
var $560639d49e3c9a19$var$boxminus = "\u229F";
var $560639d49e3c9a19$var$boxplus = "\u229E";
var $560639d49e3c9a19$var$boxtimes = "\u22A0";
var $560639d49e3c9a19$var$boxuL = "\u255B";
var $560639d49e3c9a19$var$boxuR = "\u2558";
var $560639d49e3c9a19$var$boxul = "\u2518";
var $560639d49e3c9a19$var$boxur = "\u2514";
var $560639d49e3c9a19$var$boxv = "\u2502";
var $560639d49e3c9a19$var$boxvH = "\u256A";
var $560639d49e3c9a19$var$boxvL = "\u2561";
var $560639d49e3c9a19$var$boxvR = "\u255E";
var $560639d49e3c9a19$var$boxvh = "\u253C";
var $560639d49e3c9a19$var$boxvl = "\u2524";
var $560639d49e3c9a19$var$boxvr = "\u251C";
var $560639d49e3c9a19$var$bprime = "\u2035";
var $560639d49e3c9a19$var$breve = "\u02D8";
var $560639d49e3c9a19$var$brvba = "\xa6";
var $560639d49e3c9a19$var$brvbar$1 = "\xa6";
var $560639d49e3c9a19$var$bscr = "\uD835\uDCB7";
var $560639d49e3c9a19$var$bsemi = "\u204F";
var $560639d49e3c9a19$var$bsim = "\u223D";
var $560639d49e3c9a19$var$bsime = "\u22CD";
var $560639d49e3c9a19$var$bsol = "\\";
var $560639d49e3c9a19$var$bsolb = "\u29C5";
var $560639d49e3c9a19$var$bsolhsub = "\u27C8";
var $560639d49e3c9a19$var$bull$1 = "\u2022";
var $560639d49e3c9a19$var$bullet = "\u2022";
var $560639d49e3c9a19$var$bump = "\u224E";
var $560639d49e3c9a19$var$bumpE = "\u2AAE";
var $560639d49e3c9a19$var$bumpe = "\u224F";
var $560639d49e3c9a19$var$bumpeq = "\u224F";
var $560639d49e3c9a19$var$cacute = "\u0107";
var $560639d49e3c9a19$var$cap$2 = "\u2229";
var $560639d49e3c9a19$var$capand = "\u2A44";
var $560639d49e3c9a19$var$capbrcup = "\u2A49";
var $560639d49e3c9a19$var$capcap = "\u2A4B";
var $560639d49e3c9a19$var$capcup = "\u2A47";
var $560639d49e3c9a19$var$capdot = "\u2A40";
var $560639d49e3c9a19$var$caps = "\u2229\uFE00";
var $560639d49e3c9a19$var$caret = "\u2041";
var $560639d49e3c9a19$var$caron = "\u02C7";
var $560639d49e3c9a19$var$ccaps = "\u2A4D";
var $560639d49e3c9a19$var$ccaron = "\u010D";
var $560639d49e3c9a19$var$ccedi = "\xe7";
var $560639d49e3c9a19$var$ccedil$1 = "\xe7";
var $560639d49e3c9a19$var$ccirc = "\u0109";
var $560639d49e3c9a19$var$ccups = "\u2A4C";
var $560639d49e3c9a19$var$ccupssm = "\u2A50";
var $560639d49e3c9a19$var$cdot = "\u010B";
var $560639d49e3c9a19$var$cedi = "\xb8";
var $560639d49e3c9a19$var$cedil$1 = "\xb8";
var $560639d49e3c9a19$var$cemptyv = "\u29B2";
var $560639d49e3c9a19$var$cen = "\xa2";
var $560639d49e3c9a19$var$cent$1 = "\xa2";
var $560639d49e3c9a19$var$centerdot = "\xb7";
var $560639d49e3c9a19$var$cfr = "\uD835\uDD20";
var $560639d49e3c9a19$var$chcy = "\u0447";
var $560639d49e3c9a19$var$check = "\u2713";
var $560639d49e3c9a19$var$checkmark = "\u2713";
var $560639d49e3c9a19$var$chi$1 = "\u03C7";
var $560639d49e3c9a19$var$cir = "\u25CB";
var $560639d49e3c9a19$var$cirE = "\u29C3";
var $560639d49e3c9a19$var$circ$1 = "\u02C6";
var $560639d49e3c9a19$var$circeq = "\u2257";
var $560639d49e3c9a19$var$circlearrowleft = "\u21BA";
var $560639d49e3c9a19$var$circlearrowright = "\u21BB";
var $560639d49e3c9a19$var$circledR = "\xae";
var $560639d49e3c9a19$var$circledS = "\u24C8";
var $560639d49e3c9a19$var$circledast = "\u229B";
var $560639d49e3c9a19$var$circledcirc = "\u229A";
var $560639d49e3c9a19$var$circleddash = "\u229D";
var $560639d49e3c9a19$var$cire = "\u2257";
var $560639d49e3c9a19$var$cirfnint = "\u2A10";
var $560639d49e3c9a19$var$cirmid = "\u2AEF";
var $560639d49e3c9a19$var$cirscir = "\u29C2";
var $560639d49e3c9a19$var$clubs$1 = "\u2663";
var $560639d49e3c9a19$var$clubsuit = "\u2663";
var $560639d49e3c9a19$var$colon$3 = ":";
var $560639d49e3c9a19$var$colone = "\u2254";
var $560639d49e3c9a19$var$coloneq = "\u2254";
var $560639d49e3c9a19$var$comma$2 = ",";
var $560639d49e3c9a19$var$commat = "@";
var $560639d49e3c9a19$var$comp = "\u2201";
var $560639d49e3c9a19$var$compfn = "\u2218";
var $560639d49e3c9a19$var$complement = "\u2201";
var $560639d49e3c9a19$var$complexes = "\u2102";
var $560639d49e3c9a19$var$cong$1 = "\u2245";
var $560639d49e3c9a19$var$congdot = "\u2A6D";
var $560639d49e3c9a19$var$conint = "\u222E";
var $560639d49e3c9a19$var$copf = "\uD835\uDD54";
var $560639d49e3c9a19$var$coprod = "\u2210";
var $560639d49e3c9a19$var$cop = "\xa9";
var $560639d49e3c9a19$var$copy$1 = "\xa9";
var $560639d49e3c9a19$var$copysr = "\u2117";
var $560639d49e3c9a19$var$crarr$1 = "\u21B5";
var $560639d49e3c9a19$var$cross = "\u2717";
var $560639d49e3c9a19$var$cscr = "\uD835\uDCB8";
var $560639d49e3c9a19$var$csub = "\u2ACF";
var $560639d49e3c9a19$var$csube = "\u2AD1";
var $560639d49e3c9a19$var$csup = "\u2AD0";
var $560639d49e3c9a19$var$csupe = "\u2AD2";
var $560639d49e3c9a19$var$ctdot = "\u22EF";
var $560639d49e3c9a19$var$cudarrl = "\u2938";
var $560639d49e3c9a19$var$cudarrr = "\u2935";
var $560639d49e3c9a19$var$cuepr = "\u22DE";
var $560639d49e3c9a19$var$cuesc = "\u22DF";
var $560639d49e3c9a19$var$cularr = "\u21B6";
var $560639d49e3c9a19$var$cularrp = "\u293D";
var $560639d49e3c9a19$var$cup$1 = "\u222A";
var $560639d49e3c9a19$var$cupbrcap = "\u2A48";
var $560639d49e3c9a19$var$cupcap = "\u2A46";
var $560639d49e3c9a19$var$cupcup = "\u2A4A";
var $560639d49e3c9a19$var$cupdot = "\u228D";
var $560639d49e3c9a19$var$cupor = "\u2A45";
var $560639d49e3c9a19$var$cups = "\u222A\uFE00";
var $560639d49e3c9a19$var$curarr = "\u21B7";
var $560639d49e3c9a19$var$curarrm = "\u293C";
var $560639d49e3c9a19$var$curlyeqprec = "\u22DE";
var $560639d49e3c9a19$var$curlyeqsucc = "\u22DF";
var $560639d49e3c9a19$var$curlyvee = "\u22CE";
var $560639d49e3c9a19$var$curlywedge = "\u22CF";
var $560639d49e3c9a19$var$curre = "\xa4";
var $560639d49e3c9a19$var$curren$1 = "\xa4";
var $560639d49e3c9a19$var$curvearrowleft = "\u21B6";
var $560639d49e3c9a19$var$curvearrowright = "\u21B7";
var $560639d49e3c9a19$var$cuvee = "\u22CE";
var $560639d49e3c9a19$var$cuwed = "\u22CF";
var $560639d49e3c9a19$var$cwconint = "\u2232";
var $560639d49e3c9a19$var$cwint = "\u2231";
var $560639d49e3c9a19$var$cylcty = "\u232D";
var $560639d49e3c9a19$var$dArr$1 = "\u21D3";
var $560639d49e3c9a19$var$dHar = "\u2965";
var $560639d49e3c9a19$var$dagger$1 = "\u2020";
var $560639d49e3c9a19$var$daleth = "\u2138";
var $560639d49e3c9a19$var$darr$1 = "\u2193";
var $560639d49e3c9a19$var$dash$8 = "\u2010";
var $560639d49e3c9a19$var$dashv = "\u22A3";
var $560639d49e3c9a19$var$dbkarow = "\u290F";
var $560639d49e3c9a19$var$dblac = "\u02DD";
var $560639d49e3c9a19$var$dcaron = "\u010F";
var $560639d49e3c9a19$var$dcy = "\u0434";
var $560639d49e3c9a19$var$dd$1 = "\u2146";
var $560639d49e3c9a19$var$ddagger = "\u2021";
var $560639d49e3c9a19$var$ddarr = "\u21CA";
var $560639d49e3c9a19$var$ddotseq = "\u2A77";
var $560639d49e3c9a19$var$de = "\xb0";
var $560639d49e3c9a19$var$deg$1 = "\xb0";
var $560639d49e3c9a19$var$delta$1 = "\u03B4";
var $560639d49e3c9a19$var$demptyv = "\u29B1";
var $560639d49e3c9a19$var$dfisht = "\u297F";
var $560639d49e3c9a19$var$dfr = "\uD835\uDD21";
var $560639d49e3c9a19$var$dharl = "\u21C3";
var $560639d49e3c9a19$var$dharr = "\u21C2";
var $560639d49e3c9a19$var$diam = "\u22C4";
var $560639d49e3c9a19$var$diamond = "\u22C4";
var $560639d49e3c9a19$var$diamondsuit = "\u2666";
var $560639d49e3c9a19$var$diams$1 = "\u2666";
var $560639d49e3c9a19$var$die = "\xa8";
var $560639d49e3c9a19$var$digamma = "\u03DD";
var $560639d49e3c9a19$var$disin = "\u22F2";
var $560639d49e3c9a19$var$div = "\xf7";
var $560639d49e3c9a19$var$divid = "\xf7";
var $560639d49e3c9a19$var$divide$1 = "\xf7";
var $560639d49e3c9a19$var$divideontimes = "\u22C7";
var $560639d49e3c9a19$var$divonx = "\u22C7";
var $560639d49e3c9a19$var$djcy = "\u0452";
var $560639d49e3c9a19$var$dlcorn = "\u231E";
var $560639d49e3c9a19$var$dlcrop = "\u230D";
var $560639d49e3c9a19$var$dollar = "$";
var $560639d49e3c9a19$var$dopf = "\uD835\uDD55";
var $560639d49e3c9a19$var$dot$4 = "\u02D9";
var $560639d49e3c9a19$var$doteq = "\u2250";
var $560639d49e3c9a19$var$doteqdot = "\u2251";
var $560639d49e3c9a19$var$dotminus = "\u2238";
var $560639d49e3c9a19$var$dotplus = "\u2214";
var $560639d49e3c9a19$var$dotsquare = "\u22A1";
var $560639d49e3c9a19$var$doublebarwedge = "\u2306";
var $560639d49e3c9a19$var$downarrow = "\u2193";
var $560639d49e3c9a19$var$downdownarrows = "\u21CA";
var $560639d49e3c9a19$var$downharpoonleft = "\u21C3";
var $560639d49e3c9a19$var$downharpoonright = "\u21C2";
var $560639d49e3c9a19$var$drbkarow = "\u2910";
var $560639d49e3c9a19$var$drcorn = "\u231F";
var $560639d49e3c9a19$var$drcrop = "\u230C";
var $560639d49e3c9a19$var$dscr = "\uD835\uDCB9";
var $560639d49e3c9a19$var$dscy = "\u0455";
var $560639d49e3c9a19$var$dsol = "\u29F6";
var $560639d49e3c9a19$var$dstrok = "\u0111";
var $560639d49e3c9a19$var$dtdot = "\u22F1";
var $560639d49e3c9a19$var$dtri = "\u25BF";
var $560639d49e3c9a19$var$dtrif = "\u25BE";
var $560639d49e3c9a19$var$duarr = "\u21F5";
var $560639d49e3c9a19$var$duhar = "\u296F";
var $560639d49e3c9a19$var$dwangle = "\u29A6";
var $560639d49e3c9a19$var$dzcy = "\u045F";
var $560639d49e3c9a19$var$dzigrarr = "\u27FF";
var $560639d49e3c9a19$var$eDDot = "\u2A77";
var $560639d49e3c9a19$var$eDot = "\u2251";
var $560639d49e3c9a19$var$eacut = "\xe9";
var $560639d49e3c9a19$var$eacute$1 = "\xe9";
var $560639d49e3c9a19$var$easter = "\u2A6E";
var $560639d49e3c9a19$var$ecaron = "\u011B";
var $560639d49e3c9a19$var$ecir = "\xea";
var $560639d49e3c9a19$var$ecirc$1 = "\xea";
var $560639d49e3c9a19$var$ecolon = "\u2255";
var $560639d49e3c9a19$var$ecy = "\u044D";
var $560639d49e3c9a19$var$edot = "\u0117";
var $560639d49e3c9a19$var$ee = "\u2147";
var $560639d49e3c9a19$var$efDot = "\u2252";
var $560639d49e3c9a19$var$efr = "\uD835\uDD22";
var $560639d49e3c9a19$var$eg = "\u2A9A";
var $560639d49e3c9a19$var$egrav = "\xe8";
var $560639d49e3c9a19$var$egrave$1 = "\xe8";
var $560639d49e3c9a19$var$egs = "\u2A96";
var $560639d49e3c9a19$var$egsdot = "\u2A98";
var $560639d49e3c9a19$var$el = "\u2A99";
var $560639d49e3c9a19$var$elinters = "\u23E7";
var $560639d49e3c9a19$var$ell = "\u2113";
var $560639d49e3c9a19$var$els = "\u2A95";
var $560639d49e3c9a19$var$elsdot = "\u2A97";
var $560639d49e3c9a19$var$emacr = "\u0113";
var $560639d49e3c9a19$var$empty$3 = "\u2205";
var $560639d49e3c9a19$var$emptyset = "\u2205";
var $560639d49e3c9a19$var$emptyv = "\u2205";
var $560639d49e3c9a19$var$emsp13 = "\u2004";
var $560639d49e3c9a19$var$emsp14 = "\u2005";
var $560639d49e3c9a19$var$emsp$1 = "\u2003";
var $560639d49e3c9a19$var$eng = "\u014B";
var $560639d49e3c9a19$var$ensp$1 = "\u2002";
var $560639d49e3c9a19$var$eogon = "\u0119";
var $560639d49e3c9a19$var$eopf = "\uD835\uDD56";
var $560639d49e3c9a19$var$epar = "\u22D5";
var $560639d49e3c9a19$var$eparsl = "\u29E3";
var $560639d49e3c9a19$var$eplus = "\u2A71";
var $560639d49e3c9a19$var$epsi = "\u03B5";
var $560639d49e3c9a19$var$epsilon$1 = "\u03B5";
var $560639d49e3c9a19$var$epsiv = "\u03F5";
var $560639d49e3c9a19$var$eqcirc = "\u2256";
var $560639d49e3c9a19$var$eqcolon = "\u2255";
var $560639d49e3c9a19$var$eqsim = "\u2242";
var $560639d49e3c9a19$var$eqslantgtr = "\u2A96";
var $560639d49e3c9a19$var$eqslantless = "\u2A95";
var $560639d49e3c9a19$var$equals = "=";
var $560639d49e3c9a19$var$equest = "\u225F";
var $560639d49e3c9a19$var$equiv$1 = "\u2261";
var $560639d49e3c9a19$var$equivDD = "\u2A78";
var $560639d49e3c9a19$var$eqvparsl = "\u29E5";
var $560639d49e3c9a19$var$erDot = "\u2253";
var $560639d49e3c9a19$var$erarr = "\u2971";
var $560639d49e3c9a19$var$escr = "\u212F";
var $560639d49e3c9a19$var$esdot = "\u2250";
var $560639d49e3c9a19$var$esim = "\u2242";
var $560639d49e3c9a19$var$eta$1 = "\u03B7";
var $560639d49e3c9a19$var$et = "\xf0";
var $560639d49e3c9a19$var$eth$1 = "\xf0";
var $560639d49e3c9a19$var$eum = "\xeb";
var $560639d49e3c9a19$var$euml$1 = "\xeb";
var $560639d49e3c9a19$var$euro$1 = "\u20AC";
var $560639d49e3c9a19$var$excl = "!";
var $560639d49e3c9a19$var$exist$1 = "\u2203";
var $560639d49e3c9a19$var$expectation = "\u2130";
var $560639d49e3c9a19$var$exponentiale = "\u2147";
var $560639d49e3c9a19$var$fallingdotseq = "\u2252";
var $560639d49e3c9a19$var$fcy = "\u0444";
var $560639d49e3c9a19$var$female = "\u2640";
var $560639d49e3c9a19$var$ffilig = "\uFB03";
var $560639d49e3c9a19$var$fflig = "\uFB00";
var $560639d49e3c9a19$var$ffllig = "\uFB04";
var $560639d49e3c9a19$var$ffr = "\uD835\uDD23";
var $560639d49e3c9a19$var$filig = "\uFB01";
var $560639d49e3c9a19$var$fjlig = "fj";
var $560639d49e3c9a19$var$flat = "\u266D";
var $560639d49e3c9a19$var$fllig = "\uFB02";
var $560639d49e3c9a19$var$fltns = "\u25B1";
var $560639d49e3c9a19$var$fnof$1 = "\u0192";
var $560639d49e3c9a19$var$fopf = "\uD835\uDD57";
var $560639d49e3c9a19$var$forall$1 = "\u2200";
var $560639d49e3c9a19$var$fork = "\u22D4";
var $560639d49e3c9a19$var$forkv = "\u2AD9";
var $560639d49e3c9a19$var$fpartint = "\u2A0D";
var $560639d49e3c9a19$var$frac1 = "\xbc";
var $560639d49e3c9a19$var$frac12$1 = "\xbd";
var $560639d49e3c9a19$var$frac13 = "\u2153";
var $560639d49e3c9a19$var$frac14$1 = "\xbc";
var $560639d49e3c9a19$var$frac15 = "\u2155";
var $560639d49e3c9a19$var$frac16 = "\u2159";
var $560639d49e3c9a19$var$frac18 = "\u215B";
var $560639d49e3c9a19$var$frac23 = "\u2154";
var $560639d49e3c9a19$var$frac25 = "\u2156";
var $560639d49e3c9a19$var$frac3 = "\xbe";
var $560639d49e3c9a19$var$frac34$1 = "\xbe";
var $560639d49e3c9a19$var$frac35 = "\u2157";
var $560639d49e3c9a19$var$frac38 = "\u215C";
var $560639d49e3c9a19$var$frac45 = "\u2158";
var $560639d49e3c9a19$var$frac56 = "\u215A";
var $560639d49e3c9a19$var$frac58 = "\u215D";
var $560639d49e3c9a19$var$frac78 = "\u215E";
var $560639d49e3c9a19$var$frasl$1 = "\u2044";
var $560639d49e3c9a19$var$frown = "\u2322";
var $560639d49e3c9a19$var$fscr = "\uD835\uDCBB";
var $560639d49e3c9a19$var$gE = "\u2267";
var $560639d49e3c9a19$var$gEl = "\u2A8C";
var $560639d49e3c9a19$var$gacute = "\u01F5";
var $560639d49e3c9a19$var$gamma$1 = "\u03B3";
var $560639d49e3c9a19$var$gammad = "\u03DD";
var $560639d49e3c9a19$var$gap = "\u2A86";
var $560639d49e3c9a19$var$gbreve = "\u011F";
var $560639d49e3c9a19$var$gcirc = "\u011D";
var $560639d49e3c9a19$var$gcy = "\u0433";
var $560639d49e3c9a19$var$gdot = "\u0121";
var $560639d49e3c9a19$var$ge$1 = "\u2265";
var $560639d49e3c9a19$var$gel = "\u22DB";
var $560639d49e3c9a19$var$geq = "\u2265";
var $560639d49e3c9a19$var$geqq = "\u2267";
var $560639d49e3c9a19$var$geqslant = "\u2A7E";
var $560639d49e3c9a19$var$ges = "\u2A7E";
var $560639d49e3c9a19$var$gescc = "\u2AA9";
var $560639d49e3c9a19$var$gesdot = "\u2A80";
var $560639d49e3c9a19$var$gesdoto = "\u2A82";
var $560639d49e3c9a19$var$gesdotol = "\u2A84";
var $560639d49e3c9a19$var$gesl = "\u22DB\uFE00";
var $560639d49e3c9a19$var$gesles = "\u2A94";
var $560639d49e3c9a19$var$gfr = "\uD835\uDD24";
var $560639d49e3c9a19$var$gg = "\u226B";
var $560639d49e3c9a19$var$ggg = "\u22D9";
var $560639d49e3c9a19$var$gimel = "\u2137";
var $560639d49e3c9a19$var$gjcy = "\u0453";
var $560639d49e3c9a19$var$gl = "\u2277";
var $560639d49e3c9a19$var$glE = "\u2A92";
var $560639d49e3c9a19$var$gla = "\u2AA5";
var $560639d49e3c9a19$var$glj = "\u2AA4";
var $560639d49e3c9a19$var$gnE = "\u2269";
var $560639d49e3c9a19$var$gnap = "\u2A8A";
var $560639d49e3c9a19$var$gnapprox = "\u2A8A";
var $560639d49e3c9a19$var$gne = "\u2A88";
var $560639d49e3c9a19$var$gneq = "\u2A88";
var $560639d49e3c9a19$var$gneqq = "\u2269";
var $560639d49e3c9a19$var$gnsim = "\u22E7";
var $560639d49e3c9a19$var$gopf = "\uD835\uDD58";
var $560639d49e3c9a19$var$grave = "`";
var $560639d49e3c9a19$var$gscr = "\u210A";
var $560639d49e3c9a19$var$gsim = "\u2273";
var $560639d49e3c9a19$var$gsime = "\u2A8E";
var $560639d49e3c9a19$var$gsiml = "\u2A90";
var $560639d49e3c9a19$var$g = ">";
var $560639d49e3c9a19$var$gt$1 = ">";
var $560639d49e3c9a19$var$gtcc = "\u2AA7";
var $560639d49e3c9a19$var$gtcir = "\u2A7A";
var $560639d49e3c9a19$var$gtdot = "\u22D7";
var $560639d49e3c9a19$var$gtlPar = "\u2995";
var $560639d49e3c9a19$var$gtquest = "\u2A7C";
var $560639d49e3c9a19$var$gtrapprox = "\u2A86";
var $560639d49e3c9a19$var$gtrarr = "\u2978";
var $560639d49e3c9a19$var$gtrdot = "\u22D7";
var $560639d49e3c9a19$var$gtreqless = "\u22DB";
var $560639d49e3c9a19$var$gtreqqless = "\u2A8C";
var $560639d49e3c9a19$var$gtrless = "\u2277";
var $560639d49e3c9a19$var$gtrsim = "\u2273";
var $560639d49e3c9a19$var$gvertneqq = "\u2269\uFE00";
var $560639d49e3c9a19$var$gvnE = "\u2269\uFE00";
var $560639d49e3c9a19$var$hArr$1 = "\u21D4";
var $560639d49e3c9a19$var$hairsp = "\u200A";
var $560639d49e3c9a19$var$half = "\xbd";
var $560639d49e3c9a19$var$hamilt = "\u210B";
var $560639d49e3c9a19$var$hardcy = "\u044A";
var $560639d49e3c9a19$var$harr$1 = "\u2194";
var $560639d49e3c9a19$var$harrcir = "\u2948";
var $560639d49e3c9a19$var$harrw = "\u21AD";
var $560639d49e3c9a19$var$hbar = "\u210F";
var $560639d49e3c9a19$var$hcirc = "\u0125";
var $560639d49e3c9a19$var$hearts$1 = "\u2665";
var $560639d49e3c9a19$var$heartsuit = "\u2665";
var $560639d49e3c9a19$var$hellip$1 = "\u2026";
var $560639d49e3c9a19$var$hercon = "\u22B9";
var $560639d49e3c9a19$var$hfr = "\uD835\uDD25";
var $560639d49e3c9a19$var$hksearow = "\u2925";
var $560639d49e3c9a19$var$hkswarow = "\u2926";
var $560639d49e3c9a19$var$hoarr = "\u21FF";
var $560639d49e3c9a19$var$homtht = "\u223B";
var $560639d49e3c9a19$var$hookleftarrow = "\u21A9";
var $560639d49e3c9a19$var$hookrightarrow = "\u21AA";
var $560639d49e3c9a19$var$hopf = "\uD835\uDD59";
var $560639d49e3c9a19$var$horbar = "\u2015";
var $560639d49e3c9a19$var$hscr = "\uD835\uDCBD";
var $560639d49e3c9a19$var$hslash = "\u210F";
var $560639d49e3c9a19$var$hstrok = "\u0127";
var $560639d49e3c9a19$var$hybull = "\u2043";
var $560639d49e3c9a19$var$hyphen = "\u2010";
var $560639d49e3c9a19$var$iacut = "\xed";
var $560639d49e3c9a19$var$iacute$1 = "\xed";
var $560639d49e3c9a19$var$ic = "\u2063";
var $560639d49e3c9a19$var$icir = "\xee";
var $560639d49e3c9a19$var$icirc$1 = "\xee";
var $560639d49e3c9a19$var$icy = "\u0438";
var $560639d49e3c9a19$var$iecy = "\u0435";
var $560639d49e3c9a19$var$iexc = "\xa1";
var $560639d49e3c9a19$var$iexcl$1 = "\xa1";
var $560639d49e3c9a19$var$iff = "\u21D4";
var $560639d49e3c9a19$var$ifr = "\uD835\uDD26";
var $560639d49e3c9a19$var$igrav = "\xec";
var $560639d49e3c9a19$var$igrave$1 = "\xec";
var $560639d49e3c9a19$var$ii = "\u2148";
var $560639d49e3c9a19$var$iiiint = "\u2A0C";
var $560639d49e3c9a19$var$iiint = "\u222D";
var $560639d49e3c9a19$var$iinfin = "\u29DC";
var $560639d49e3c9a19$var$iiota = "\u2129";
var $560639d49e3c9a19$var$ijlig = "\u0133";
var $560639d49e3c9a19$var$imacr = "\u012B";
var $560639d49e3c9a19$var$image$3 = "\u2111";
var $560639d49e3c9a19$var$imagline = "\u2110";
var $560639d49e3c9a19$var$imagpart = "\u2111";
var $560639d49e3c9a19$var$imath = "\u0131";
var $560639d49e3c9a19$var$imof = "\u22B7";
var $560639d49e3c9a19$var$imped = "\u01B5";
var $560639d49e3c9a19$var$incare = "\u2105";
var $560639d49e3c9a19$var$infin$1 = "\u221E";
var $560639d49e3c9a19$var$infintie = "\u29DD";
var $560639d49e3c9a19$var$inodot = "\u0131";
var $560639d49e3c9a19$var$int$1 = "\u222B";
var $560639d49e3c9a19$var$intcal = "\u22BA";
var $560639d49e3c9a19$var$integers = "\u2124";
var $560639d49e3c9a19$var$intercal = "\u22BA";
var $560639d49e3c9a19$var$intlarhk = "\u2A17";
var $560639d49e3c9a19$var$intprod = "\u2A3C";
var $560639d49e3c9a19$var$iocy = "\u0451";
var $560639d49e3c9a19$var$iogon = "\u012F";
var $560639d49e3c9a19$var$iopf = "\uD835\uDD5A";
var $560639d49e3c9a19$var$iota$1 = "\u03B9";
var $560639d49e3c9a19$var$iprod = "\u2A3C";
var $560639d49e3c9a19$var$iques = "\xbf";
var $560639d49e3c9a19$var$iquest$1 = "\xbf";
var $560639d49e3c9a19$var$iscr = "\uD835\uDCBE";
var $560639d49e3c9a19$var$isin$1 = "\u2208";
var $560639d49e3c9a19$var$isinE = "\u22F9";
var $560639d49e3c9a19$var$isindot = "\u22F5";
var $560639d49e3c9a19$var$isins = "\u22F4";
var $560639d49e3c9a19$var$isinsv = "\u22F3";
var $560639d49e3c9a19$var$isinv = "\u2208";
var $560639d49e3c9a19$var$it = "\u2062";
var $560639d49e3c9a19$var$itilde = "\u0129";
var $560639d49e3c9a19$var$iukcy = "\u0456";
var $560639d49e3c9a19$var$ium = "\xef";
var $560639d49e3c9a19$var$iuml$1 = "\xef";
var $560639d49e3c9a19$var$jcirc = "\u0135";
var $560639d49e3c9a19$var$jcy = "\u0439";
var $560639d49e3c9a19$var$jfr = "\uD835\uDD27";
var $560639d49e3c9a19$var$jmath = "\u0237";
var $560639d49e3c9a19$var$jopf = "\uD835\uDD5B";
var $560639d49e3c9a19$var$jscr = "\uD835\uDCBF";
var $560639d49e3c9a19$var$jsercy = "\u0458";
var $560639d49e3c9a19$var$jukcy = "\u0454";
var $560639d49e3c9a19$var$kappa$1 = "\u03BA";
var $560639d49e3c9a19$var$kappav = "\u03F0";
var $560639d49e3c9a19$var$kcedil = "\u0137";
var $560639d49e3c9a19$var$kcy = "\u043A";
var $560639d49e3c9a19$var$kfr = "\uD835\uDD28";
var $560639d49e3c9a19$var$kgreen = "\u0138";
var $560639d49e3c9a19$var$khcy = "\u0445";
var $560639d49e3c9a19$var$kjcy = "\u045C";
var $560639d49e3c9a19$var$kopf = "\uD835\uDD5C";
var $560639d49e3c9a19$var$kscr = "\uD835\uDCC0";
var $560639d49e3c9a19$var$lAarr = "\u21DA";
var $560639d49e3c9a19$var$lArr$1 = "\u21D0";
var $560639d49e3c9a19$var$lAtail = "\u291B";
var $560639d49e3c9a19$var$lBarr = "\u290E";
var $560639d49e3c9a19$var$lE = "\u2266";
var $560639d49e3c9a19$var$lEg = "\u2A8B";
var $560639d49e3c9a19$var$lHar = "\u2962";
var $560639d49e3c9a19$var$lacute = "\u013A";
var $560639d49e3c9a19$var$laemptyv = "\u29B4";
var $560639d49e3c9a19$var$lagran = "\u2112";
var $560639d49e3c9a19$var$lambda$1 = "\u03BB";
var $560639d49e3c9a19$var$lang$1 = "\u27E8";
var $560639d49e3c9a19$var$langd = "\u2991";
var $560639d49e3c9a19$var$langle = "\u27E8";
var $560639d49e3c9a19$var$lap = "\u2A85";
var $560639d49e3c9a19$var$laqu = "\xab";
var $560639d49e3c9a19$var$laquo$1 = "\xab";
var $560639d49e3c9a19$var$larr$1 = "\u2190";
var $560639d49e3c9a19$var$larrb = "\u21E4";
var $560639d49e3c9a19$var$larrbfs = "\u291F";
var $560639d49e3c9a19$var$larrfs = "\u291D";
var $560639d49e3c9a19$var$larrhk = "\u21A9";
var $560639d49e3c9a19$var$larrlp = "\u21AB";
var $560639d49e3c9a19$var$larrpl = "\u2939";
var $560639d49e3c9a19$var$larrsim = "\u2973";
var $560639d49e3c9a19$var$larrtl = "\u21A2";
var $560639d49e3c9a19$var$lat = "\u2AAB";
var $560639d49e3c9a19$var$latail = "\u2919";
var $560639d49e3c9a19$var$late = "\u2AAD";
var $560639d49e3c9a19$var$lates = "\u2AAD\uFE00";
var $560639d49e3c9a19$var$lbarr = "\u290C";
var $560639d49e3c9a19$var$lbbrk = "\u2772";
var $560639d49e3c9a19$var$lbrace = "{";
var $560639d49e3c9a19$var$lbrack = "[";
var $560639d49e3c9a19$var$lbrke = "\u298B";
var $560639d49e3c9a19$var$lbrksld = "\u298F";
var $560639d49e3c9a19$var$lbrkslu = "\u298D";
var $560639d49e3c9a19$var$lcaron = "\u013E";
var $560639d49e3c9a19$var$lcedil = "\u013C";
var $560639d49e3c9a19$var$lceil$1 = "\u2308";
var $560639d49e3c9a19$var$lcub = "{";
var $560639d49e3c9a19$var$lcy = "\u043B";
var $560639d49e3c9a19$var$ldca = "\u2936";
var $560639d49e3c9a19$var$ldquo$1 = "\u201C";
var $560639d49e3c9a19$var$ldquor = "\u201E";
var $560639d49e3c9a19$var$ldrdhar = "\u2967";
var $560639d49e3c9a19$var$ldrushar = "\u294B";
var $560639d49e3c9a19$var$ldsh = "\u21B2";
var $560639d49e3c9a19$var$le$1 = "\u2264";
var $560639d49e3c9a19$var$leftarrow = "\u2190";
var $560639d49e3c9a19$var$leftarrowtail = "\u21A2";
var $560639d49e3c9a19$var$leftharpoondown = "\u21BD";
var $560639d49e3c9a19$var$leftharpoonup = "\u21BC";
var $560639d49e3c9a19$var$leftleftarrows = "\u21C7";
var $560639d49e3c9a19$var$leftrightarrow = "\u2194";
var $560639d49e3c9a19$var$leftrightarrows = "\u21C6";
var $560639d49e3c9a19$var$leftrightharpoons = "\u21CB";
var $560639d49e3c9a19$var$leftrightsquigarrow = "\u21AD";
var $560639d49e3c9a19$var$leftthreetimes = "\u22CB";
var $560639d49e3c9a19$var$leg = "\u22DA";
var $560639d49e3c9a19$var$leq = "\u2264";
var $560639d49e3c9a19$var$leqq = "\u2266";
var $560639d49e3c9a19$var$leqslant = "\u2A7D";
var $560639d49e3c9a19$var$les = "\u2A7D";
var $560639d49e3c9a19$var$lescc = "\u2AA8";
var $560639d49e3c9a19$var$lesdot = "\u2A7F";
var $560639d49e3c9a19$var$lesdoto = "\u2A81";
var $560639d49e3c9a19$var$lesdotor = "\u2A83";
var $560639d49e3c9a19$var$lesg = "\u22DA\uFE00";
var $560639d49e3c9a19$var$lesges = "\u2A93";
var $560639d49e3c9a19$var$lessapprox = "\u2A85";
var $560639d49e3c9a19$var$lessdot = "\u22D6";
var $560639d49e3c9a19$var$lesseqgtr = "\u22DA";
var $560639d49e3c9a19$var$lesseqqgtr = "\u2A8B";
var $560639d49e3c9a19$var$lessgtr = "\u2276";
var $560639d49e3c9a19$var$lesssim = "\u2272";
var $560639d49e3c9a19$var$lfisht = "\u297C";
var $560639d49e3c9a19$var$lfloor$1 = "\u230A";
var $560639d49e3c9a19$var$lfr = "\uD835\uDD29";
var $560639d49e3c9a19$var$lg = "\u2276";
var $560639d49e3c9a19$var$lgE = "\u2A91";
var $560639d49e3c9a19$var$lhard = "\u21BD";
var $560639d49e3c9a19$var$lharu = "\u21BC";
var $560639d49e3c9a19$var$lharul = "\u296A";
var $560639d49e3c9a19$var$lhblk = "\u2584";
var $560639d49e3c9a19$var$ljcy = "\u0459";
var $560639d49e3c9a19$var$ll = "\u226A";
var $560639d49e3c9a19$var$llarr = "\u21C7";
var $560639d49e3c9a19$var$llcorner = "\u231E";
var $560639d49e3c9a19$var$llhard = "\u296B";
var $560639d49e3c9a19$var$lltri = "\u25FA";
var $560639d49e3c9a19$var$lmidot = "\u0140";
var $560639d49e3c9a19$var$lmoust = "\u23B0";
var $560639d49e3c9a19$var$lmoustache = "\u23B0";
var $560639d49e3c9a19$var$lnE = "\u2268";
var $560639d49e3c9a19$var$lnap = "\u2A89";
var $560639d49e3c9a19$var$lnapprox = "\u2A89";
var $560639d49e3c9a19$var$lne = "\u2A87";
var $560639d49e3c9a19$var$lneq = "\u2A87";
var $560639d49e3c9a19$var$lneqq = "\u2268";
var $560639d49e3c9a19$var$lnsim = "\u22E6";
var $560639d49e3c9a19$var$loang = "\u27EC";
var $560639d49e3c9a19$var$loarr = "\u21FD";
var $560639d49e3c9a19$var$lobrk = "\u27E6";
var $560639d49e3c9a19$var$longleftarrow = "\u27F5";
var $560639d49e3c9a19$var$longleftrightarrow = "\u27F7";
var $560639d49e3c9a19$var$longmapsto = "\u27FC";
var $560639d49e3c9a19$var$longrightarrow = "\u27F6";
var $560639d49e3c9a19$var$looparrowleft = "\u21AB";
var $560639d49e3c9a19$var$looparrowright = "\u21AC";
var $560639d49e3c9a19$var$lopar = "\u2985";
var $560639d49e3c9a19$var$lopf = "\uD835\uDD5D";
var $560639d49e3c9a19$var$loplus = "\u2A2D";
var $560639d49e3c9a19$var$lotimes = "\u2A34";
var $560639d49e3c9a19$var$lowast$1 = "\u2217";
var $560639d49e3c9a19$var$lowbar = "_";
var $560639d49e3c9a19$var$loz$1 = "\u25CA";
var $560639d49e3c9a19$var$lozenge = "\u25CA";
var $560639d49e3c9a19$var$lozf = "\u29EB";
var $560639d49e3c9a19$var$lpar = "(";
var $560639d49e3c9a19$var$lparlt = "\u2993";
var $560639d49e3c9a19$var$lrarr = "\u21C6";
var $560639d49e3c9a19$var$lrcorner = "\u231F";
var $560639d49e3c9a19$var$lrhar = "\u21CB";
var $560639d49e3c9a19$var$lrhard = "\u296D";
var $560639d49e3c9a19$var$lrm$1 = "\u200E";
var $560639d49e3c9a19$var$lrtri = "\u22BF";
var $560639d49e3c9a19$var$lsaquo$1 = "\u2039";
var $560639d49e3c9a19$var$lscr = "\uD835\uDCC1";
var $560639d49e3c9a19$var$lsh = "\u21B0";
var $560639d49e3c9a19$var$lsim = "\u2272";
var $560639d49e3c9a19$var$lsime = "\u2A8D";
var $560639d49e3c9a19$var$lsimg = "\u2A8F";
var $560639d49e3c9a19$var$lsqb = "[";
var $560639d49e3c9a19$var$lsquo$1 = "\u2018";
var $560639d49e3c9a19$var$lsquor = "\u201A";
var $560639d49e3c9a19$var$lstrok = "\u0142";
var $560639d49e3c9a19$var$l = "<";
var $560639d49e3c9a19$var$lt$1 = "<";
var $560639d49e3c9a19$var$ltcc = "\u2AA6";
var $560639d49e3c9a19$var$ltcir = "\u2A79";
var $560639d49e3c9a19$var$ltdot = "\u22D6";
var $560639d49e3c9a19$var$lthree = "\u22CB";
var $560639d49e3c9a19$var$ltimes = "\u22C9";
var $560639d49e3c9a19$var$ltlarr = "\u2976";
var $560639d49e3c9a19$var$ltquest = "\u2A7B";
var $560639d49e3c9a19$var$ltrPar = "\u2996";
var $560639d49e3c9a19$var$ltri = "\u25C3";
var $560639d49e3c9a19$var$ltrie = "\u22B4";
var $560639d49e3c9a19$var$ltrif = "\u25C2";
var $560639d49e3c9a19$var$lurdshar = "\u294A";
var $560639d49e3c9a19$var$luruhar = "\u2966";
var $560639d49e3c9a19$var$lvertneqq = "\u2268\uFE00";
var $560639d49e3c9a19$var$lvnE = "\u2268\uFE00";
var $560639d49e3c9a19$var$mDDot = "\u223A";
var $560639d49e3c9a19$var$mac = "\xaf";
var $560639d49e3c9a19$var$macr$1 = "\xaf";
var $560639d49e3c9a19$var$male = "\u2642";
var $560639d49e3c9a19$var$malt = "\u2720";
var $560639d49e3c9a19$var$maltese = "\u2720";
var $560639d49e3c9a19$var$map$1 = "\u21A6";
var $560639d49e3c9a19$var$mapsto = "\u21A6";
var $560639d49e3c9a19$var$mapstodown = "\u21A7";
var $560639d49e3c9a19$var$mapstoleft = "\u21A4";
var $560639d49e3c9a19$var$mapstoup = "\u21A5";
var $560639d49e3c9a19$var$marker = "\u25AE";
var $560639d49e3c9a19$var$mcomma = "\u2A29";
var $560639d49e3c9a19$var$mcy = "\u043C";
var $560639d49e3c9a19$var$mdash$1 = "\u2014";
var $560639d49e3c9a19$var$measuredangle = "\u2221";
var $560639d49e3c9a19$var$mfr = "\uD835\uDD2A";
var $560639d49e3c9a19$var$mho = "\u2127";
var $560639d49e3c9a19$var$micr = "\xb5";
var $560639d49e3c9a19$var$micro$1 = "\xb5";
var $560639d49e3c9a19$var$mid = "\u2223";
var $560639d49e3c9a19$var$midast = "*";
var $560639d49e3c9a19$var$midcir = "\u2AF0";
var $560639d49e3c9a19$var$middo = "\xb7";
var $560639d49e3c9a19$var$middot$1 = "\xb7";
var $560639d49e3c9a19$var$minus$1 = "\u2212";
var $560639d49e3c9a19$var$minusb = "\u229F";
var $560639d49e3c9a19$var$minusd = "\u2238";
var $560639d49e3c9a19$var$minusdu = "\u2A2A";
var $560639d49e3c9a19$var$mlcp = "\u2ADB";
var $560639d49e3c9a19$var$mldr = "\u2026";
var $560639d49e3c9a19$var$mnplus = "\u2213";
var $560639d49e3c9a19$var$models = "\u22A7";
var $560639d49e3c9a19$var$mopf = "\uD835\uDD5E";
var $560639d49e3c9a19$var$mp = "\u2213";
var $560639d49e3c9a19$var$mscr = "\uD835\uDCC2";
var $560639d49e3c9a19$var$mstpos = "\u223E";
var $560639d49e3c9a19$var$mu$1 = "\u03BC";
var $560639d49e3c9a19$var$multimap = "\u22B8";
var $560639d49e3c9a19$var$mumap = "\u22B8";
var $560639d49e3c9a19$var$nGg = "\u22D9\u0338";
var $560639d49e3c9a19$var$nGt = "\u226B\u20D2";
var $560639d49e3c9a19$var$nGtv = "\u226B\u0338";
var $560639d49e3c9a19$var$nLeftarrow = "\u21CD";
var $560639d49e3c9a19$var$nLeftrightarrow = "\u21CE";
var $560639d49e3c9a19$var$nLl = "\u22D8\u0338";
var $560639d49e3c9a19$var$nLt = "\u226A\u20D2";
var $560639d49e3c9a19$var$nLtv = "\u226A\u0338";
var $560639d49e3c9a19$var$nRightarrow = "\u21CF";
var $560639d49e3c9a19$var$nVDash = "\u22AF";
var $560639d49e3c9a19$var$nVdash = "\u22AE";
var $560639d49e3c9a19$var$nabla$1 = "\u2207";
var $560639d49e3c9a19$var$nacute = "\u0144";
var $560639d49e3c9a19$var$nang = "\u2220\u20D2";
var $560639d49e3c9a19$var$nap = "\u2249";
var $560639d49e3c9a19$var$napE = "\u2A70\u0338";
var $560639d49e3c9a19$var$napid = "\u224B\u0338";
var $560639d49e3c9a19$var$napos = "\u0149";
var $560639d49e3c9a19$var$napprox = "\u2249";
var $560639d49e3c9a19$var$natur = "\u266E";
var $560639d49e3c9a19$var$natural = "\u266E";
var $560639d49e3c9a19$var$naturals = "\u2115";
var $560639d49e3c9a19$var$nbs = "\xa0";
var $560639d49e3c9a19$var$nbsp$1 = "\xa0";
var $560639d49e3c9a19$var$nbump = "\u224E\u0338";
var $560639d49e3c9a19$var$nbumpe = "\u224F\u0338";
var $560639d49e3c9a19$var$ncap = "\u2A43";
var $560639d49e3c9a19$var$ncaron = "\u0148";
var $560639d49e3c9a19$var$ncedil = "\u0146";
var $560639d49e3c9a19$var$ncong = "\u2247";
var $560639d49e3c9a19$var$ncongdot = "\u2A6D\u0338";
var $560639d49e3c9a19$var$ncup = "\u2A42";
var $560639d49e3c9a19$var$ncy = "\u043D";
var $560639d49e3c9a19$var$ndash$1 = "\u2013";
var $560639d49e3c9a19$var$ne$1 = "\u2260";
var $560639d49e3c9a19$var$neArr = "\u21D7";
var $560639d49e3c9a19$var$nearhk = "\u2924";
var $560639d49e3c9a19$var$nearr = "\u2197";
var $560639d49e3c9a19$var$nearrow = "\u2197";
var $560639d49e3c9a19$var$nedot = "\u2250\u0338";
var $560639d49e3c9a19$var$nequiv = "\u2262";
var $560639d49e3c9a19$var$nesear = "\u2928";
var $560639d49e3c9a19$var$nesim = "\u2242\u0338";
var $560639d49e3c9a19$var$nexist = "\u2204";
var $560639d49e3c9a19$var$nexists = "\u2204";
var $560639d49e3c9a19$var$nfr = "\uD835\uDD2B";
var $560639d49e3c9a19$var$ngE = "\u2267\u0338";
var $560639d49e3c9a19$var$nge = "\u2271";
var $560639d49e3c9a19$var$ngeq = "\u2271";
var $560639d49e3c9a19$var$ngeqq = "\u2267\u0338";
var $560639d49e3c9a19$var$ngeqslant = "\u2A7E\u0338";
var $560639d49e3c9a19$var$nges = "\u2A7E\u0338";
var $560639d49e3c9a19$var$ngsim = "\u2275";
var $560639d49e3c9a19$var$ngt = "\u226F";
var $560639d49e3c9a19$var$ngtr = "\u226F";
var $560639d49e3c9a19$var$nhArr = "\u21CE";
var $560639d49e3c9a19$var$nharr = "\u21AE";
var $560639d49e3c9a19$var$nhpar = "\u2AF2";
var $560639d49e3c9a19$var$ni$1 = "\u220B";
var $560639d49e3c9a19$var$nis = "\u22FC";
var $560639d49e3c9a19$var$nisd = "\u22FA";
var $560639d49e3c9a19$var$niv = "\u220B";
var $560639d49e3c9a19$var$njcy = "\u045A";
var $560639d49e3c9a19$var$nlArr = "\u21CD";
var $560639d49e3c9a19$var$nlE = "\u2266\u0338";
var $560639d49e3c9a19$var$nlarr = "\u219A";
var $560639d49e3c9a19$var$nldr = "\u2025";
var $560639d49e3c9a19$var$nle = "\u2270";
var $560639d49e3c9a19$var$nleftarrow = "\u219A";
var $560639d49e3c9a19$var$nleftrightarrow = "\u21AE";
var $560639d49e3c9a19$var$nleq = "\u2270";
var $560639d49e3c9a19$var$nleqq = "\u2266\u0338";
var $560639d49e3c9a19$var$nleqslant = "\u2A7D\u0338";
var $560639d49e3c9a19$var$nles = "\u2A7D\u0338";
var $560639d49e3c9a19$var$nless = "\u226E";
var $560639d49e3c9a19$var$nlsim = "\u2274";
var $560639d49e3c9a19$var$nlt = "\u226E";
var $560639d49e3c9a19$var$nltri = "\u22EA";
var $560639d49e3c9a19$var$nltrie = "\u22EC";
var $560639d49e3c9a19$var$nmid = "\u2224";
var $560639d49e3c9a19$var$nopf = "\uD835\uDD5F";
var $560639d49e3c9a19$var$no = "\xac";
var $560639d49e3c9a19$var$not$1 = "\xac";
var $560639d49e3c9a19$var$notin$1 = "\u2209";
var $560639d49e3c9a19$var$notinE = "\u22F9\u0338";
var $560639d49e3c9a19$var$notindot = "\u22F5\u0338";
var $560639d49e3c9a19$var$notinva = "\u2209";
var $560639d49e3c9a19$var$notinvb = "\u22F7";
var $560639d49e3c9a19$var$notinvc = "\u22F6";
var $560639d49e3c9a19$var$notni = "\u220C";
var $560639d49e3c9a19$var$notniva = "\u220C";
var $560639d49e3c9a19$var$notnivb = "\u22FE";
var $560639d49e3c9a19$var$notnivc = "\u22FD";
var $560639d49e3c9a19$var$npar = "\u2226";
var $560639d49e3c9a19$var$nparallel = "\u2226";
var $560639d49e3c9a19$var$nparsl = "\u2AFD\u20E5";
var $560639d49e3c9a19$var$npart = "\u2202\u0338";
var $560639d49e3c9a19$var$npolint = "\u2A14";
var $560639d49e3c9a19$var$npr = "\u2280";
var $560639d49e3c9a19$var$nprcue = "\u22E0";
var $560639d49e3c9a19$var$npre = "\u2AAF\u0338";
var $560639d49e3c9a19$var$nprec = "\u2280";
var $560639d49e3c9a19$var$npreceq = "\u2AAF\u0338";
var $560639d49e3c9a19$var$nrArr = "\u21CF";
var $560639d49e3c9a19$var$nrarr = "\u219B";
var $560639d49e3c9a19$var$nrarrc = "\u2933\u0338";
var $560639d49e3c9a19$var$nrarrw = "\u219D\u0338";
var $560639d49e3c9a19$var$nrightarrow = "\u219B";
var $560639d49e3c9a19$var$nrtri = "\u22EB";
var $560639d49e3c9a19$var$nrtrie = "\u22ED";
var $560639d49e3c9a19$var$nsc = "\u2281";
var $560639d49e3c9a19$var$nsccue = "\u22E1";
var $560639d49e3c9a19$var$nsce = "\u2AB0\u0338";
var $560639d49e3c9a19$var$nscr = "\uD835\uDCC3";
var $560639d49e3c9a19$var$nshortmid = "\u2224";
var $560639d49e3c9a19$var$nshortparallel = "\u2226";
var $560639d49e3c9a19$var$nsim = "\u2241";
var $560639d49e3c9a19$var$nsime = "\u2244";
var $560639d49e3c9a19$var$nsimeq = "\u2244";
var $560639d49e3c9a19$var$nsmid = "\u2224";
var $560639d49e3c9a19$var$nspar = "\u2226";
var $560639d49e3c9a19$var$nsqsube = "\u22E2";
var $560639d49e3c9a19$var$nsqsupe = "\u22E3";
var $560639d49e3c9a19$var$nsub$1 = "\u2284";
var $560639d49e3c9a19$var$nsubE = "\u2AC5\u0338";
var $560639d49e3c9a19$var$nsube = "\u2288";
var $560639d49e3c9a19$var$nsubset = "\u2282\u20D2";
var $560639d49e3c9a19$var$nsubseteq = "\u2288";
var $560639d49e3c9a19$var$nsubseteqq = "\u2AC5\u0338";
var $560639d49e3c9a19$var$nsucc = "\u2281";
var $560639d49e3c9a19$var$nsucceq = "\u2AB0\u0338";
var $560639d49e3c9a19$var$nsup = "\u2285";
var $560639d49e3c9a19$var$nsupE = "\u2AC6\u0338";
var $560639d49e3c9a19$var$nsupe = "\u2289";
var $560639d49e3c9a19$var$nsupset = "\u2283\u20D2";
var $560639d49e3c9a19$var$nsupseteq = "\u2289";
var $560639d49e3c9a19$var$nsupseteqq = "\u2AC6\u0338";
var $560639d49e3c9a19$var$ntgl = "\u2279";
var $560639d49e3c9a19$var$ntild = "\xf1";
var $560639d49e3c9a19$var$ntilde$1 = "\xf1";
var $560639d49e3c9a19$var$ntlg = "\u2278";
var $560639d49e3c9a19$var$ntriangleleft = "\u22EA";
var $560639d49e3c9a19$var$ntrianglelefteq = "\u22EC";
var $560639d49e3c9a19$var$ntriangleright = "\u22EB";
var $560639d49e3c9a19$var$ntrianglerighteq = "\u22ED";
var $560639d49e3c9a19$var$nu$1 = "\u03BD";
var $560639d49e3c9a19$var$num = "#";
var $560639d49e3c9a19$var$numero = "\u2116";
var $560639d49e3c9a19$var$numsp = "\u2007";
var $560639d49e3c9a19$var$nvDash = "\u22AD";
var $560639d49e3c9a19$var$nvHarr = "\u2904";
var $560639d49e3c9a19$var$nvap = "\u224D\u20D2";
var $560639d49e3c9a19$var$nvdash = "\u22AC";
var $560639d49e3c9a19$var$nvge = "\u2265\u20D2";
var $560639d49e3c9a19$var$nvgt = ">\u20D2";
var $560639d49e3c9a19$var$nvinfin = "\u29DE";
var $560639d49e3c9a19$var$nvlArr = "\u2902";
var $560639d49e3c9a19$var$nvle = "\u2264\u20D2";
var $560639d49e3c9a19$var$nvlt = "<\u20D2";
var $560639d49e3c9a19$var$nvltrie = "\u22B4\u20D2";
var $560639d49e3c9a19$var$nvrArr = "\u2903";
var $560639d49e3c9a19$var$nvrtrie = "\u22B5\u20D2";
var $560639d49e3c9a19$var$nvsim = "\u223C\u20D2";
var $560639d49e3c9a19$var$nwArr = "\u21D6";
var $560639d49e3c9a19$var$nwarhk = "\u2923";
var $560639d49e3c9a19$var$nwarr = "\u2196";
var $560639d49e3c9a19$var$nwarrow = "\u2196";
var $560639d49e3c9a19$var$nwnear = "\u2927";
var $560639d49e3c9a19$var$oS = "\u24C8";
var $560639d49e3c9a19$var$oacut = "\xf3";
var $560639d49e3c9a19$var$oacute$1 = "\xf3";
var $560639d49e3c9a19$var$oast = "\u229B";
var $560639d49e3c9a19$var$ocir = "\xf4";
var $560639d49e3c9a19$var$ocirc$1 = "\xf4";
var $560639d49e3c9a19$var$ocy = "\u043E";
var $560639d49e3c9a19$var$odash = "\u229D";
var $560639d49e3c9a19$var$odblac = "\u0151";
var $560639d49e3c9a19$var$odiv = "\u2A38";
var $560639d49e3c9a19$var$odot = "\u2299";
var $560639d49e3c9a19$var$odsold = "\u29BC";
var $560639d49e3c9a19$var$oelig$1 = "\u0153";
var $560639d49e3c9a19$var$ofcir = "\u29BF";
var $560639d49e3c9a19$var$ofr = "\uD835\uDD2C";
var $560639d49e3c9a19$var$ogon = "\u02DB";
var $560639d49e3c9a19$var$ograv = "\xf2";
var $560639d49e3c9a19$var$ograve$1 = "\xf2";
var $560639d49e3c9a19$var$ogt = "\u29C1";
var $560639d49e3c9a19$var$ohbar = "\u29B5";
var $560639d49e3c9a19$var$ohm = "\u03A9";
var $560639d49e3c9a19$var$oint = "\u222E";
var $560639d49e3c9a19$var$olarr = "\u21BA";
var $560639d49e3c9a19$var$olcir = "\u29BE";
var $560639d49e3c9a19$var$olcross = "\u29BB";
var $560639d49e3c9a19$var$oline$1 = "\u203E";
var $560639d49e3c9a19$var$olt = "\u29C0";
var $560639d49e3c9a19$var$omacr = "\u014D";
var $560639d49e3c9a19$var$omega$1 = "\u03C9";
var $560639d49e3c9a19$var$omicron$1 = "\u03BF";
var $560639d49e3c9a19$var$omid = "\u29B6";
var $560639d49e3c9a19$var$ominus = "\u2296";
var $560639d49e3c9a19$var$oopf = "\uD835\uDD60";
var $560639d49e3c9a19$var$opar = "\u29B7";
var $560639d49e3c9a19$var$operp = "\u29B9";
var $560639d49e3c9a19$var$oplus$1 = "\u2295";
var $560639d49e3c9a19$var$or$1 = "\u2228";
var $560639d49e3c9a19$var$orarr = "\u21BB";
var $560639d49e3c9a19$var$ord = "\xba";
var $560639d49e3c9a19$var$order = "\u2134";
var $560639d49e3c9a19$var$orderof = "\u2134";
var $560639d49e3c9a19$var$ordf$1 = "\xaa";
var $560639d49e3c9a19$var$ordm$1 = "\xba";
var $560639d49e3c9a19$var$origof = "\u22B6";
var $560639d49e3c9a19$var$oror = "\u2A56";
var $560639d49e3c9a19$var$orslope = "\u2A57";
var $560639d49e3c9a19$var$orv = "\u2A5B";
var $560639d49e3c9a19$var$oscr = "\u2134";
var $560639d49e3c9a19$var$oslas = "\xf8";
var $560639d49e3c9a19$var$oslash$1 = "\xf8";
var $560639d49e3c9a19$var$osol = "\u2298";
var $560639d49e3c9a19$var$otild = "\xf5";
var $560639d49e3c9a19$var$otilde$1 = "\xf5";
var $560639d49e3c9a19$var$otimes$1 = "\u2297";
var $560639d49e3c9a19$var$otimesas = "\u2A36";
var $560639d49e3c9a19$var$oum = "\xf6";
var $560639d49e3c9a19$var$ouml$1 = "\xf6";
var $560639d49e3c9a19$var$ovbar = "\u233D";
var $560639d49e3c9a19$var$par = "\xb6";
var $560639d49e3c9a19$var$para$1 = "\xb6";
var $560639d49e3c9a19$var$parallel = "\u2225";
var $560639d49e3c9a19$var$parsim = "\u2AF3";
var $560639d49e3c9a19$var$parsl = "\u2AFD";
var $560639d49e3c9a19$var$part$1 = "\u2202";
var $560639d49e3c9a19$var$pcy = "\u043F";
var $560639d49e3c9a19$var$percnt = "%";
var $560639d49e3c9a19$var$period = ".";
var $560639d49e3c9a19$var$permil$1 = "\u2030";
var $560639d49e3c9a19$var$perp$1 = "\u22A5";
var $560639d49e3c9a19$var$pertenk = "\u2031";
var $560639d49e3c9a19$var$pfr = "\uD835\uDD2D";
var $560639d49e3c9a19$var$phi$1 = "\u03C6";
var $560639d49e3c9a19$var$phiv = "\u03D5";
var $560639d49e3c9a19$var$phmmat = "\u2133";
var $560639d49e3c9a19$var$phone = "\u260E";
var $560639d49e3c9a19$var$pi$1 = "\u03C0";
var $560639d49e3c9a19$var$pitchfork = "\u22D4";
var $560639d49e3c9a19$var$piv$1 = "\u03D6";
var $560639d49e3c9a19$var$planck = "\u210F";
var $560639d49e3c9a19$var$planckh = "\u210E";
var $560639d49e3c9a19$var$plankv = "\u210F";
var $560639d49e3c9a19$var$plus = "+";
var $560639d49e3c9a19$var$plusacir = "\u2A23";
var $560639d49e3c9a19$var$plusb = "\u229E";
var $560639d49e3c9a19$var$pluscir = "\u2A22";
var $560639d49e3c9a19$var$plusdo = "\u2214";
var $560639d49e3c9a19$var$plusdu = "\u2A25";
var $560639d49e3c9a19$var$pluse = "\u2A72";
var $560639d49e3c9a19$var$plusm = "\xb1";
var $560639d49e3c9a19$var$plusmn$1 = "\xb1";
var $560639d49e3c9a19$var$plussim = "\u2A26";
var $560639d49e3c9a19$var$plustwo = "\u2A27";
var $560639d49e3c9a19$var$pm = "\xb1";
var $560639d49e3c9a19$var$pointint = "\u2A15";
var $560639d49e3c9a19$var$popf = "\uD835\uDD61";
var $560639d49e3c9a19$var$poun = "\xa3";
var $560639d49e3c9a19$var$pound$1 = "\xa3";
var $560639d49e3c9a19$var$pr = "\u227A";
var $560639d49e3c9a19$var$prE = "\u2AB3";
var $560639d49e3c9a19$var$prap = "\u2AB7";
var $560639d49e3c9a19$var$prcue = "\u227C";
var $560639d49e3c9a19$var$pre = "\u2AAF";
var $560639d49e3c9a19$var$prec = "\u227A";
var $560639d49e3c9a19$var$precapprox = "\u2AB7";
var $560639d49e3c9a19$var$preccurlyeq = "\u227C";
var $560639d49e3c9a19$var$preceq = "\u2AAF";
var $560639d49e3c9a19$var$precnapprox = "\u2AB9";
var $560639d49e3c9a19$var$precneqq = "\u2AB5";
var $560639d49e3c9a19$var$precnsim = "\u22E8";
var $560639d49e3c9a19$var$precsim = "\u227E";
var $560639d49e3c9a19$var$prime$1 = "\u2032";
var $560639d49e3c9a19$var$primes = "\u2119";
var $560639d49e3c9a19$var$prnE = "\u2AB5";
var $560639d49e3c9a19$var$prnap = "\u2AB9";
var $560639d49e3c9a19$var$prnsim = "\u22E8";
var $560639d49e3c9a19$var$prod$1 = "\u220F";
var $560639d49e3c9a19$var$profalar = "\u232E";
var $560639d49e3c9a19$var$profline = "\u2312";
var $560639d49e3c9a19$var$profsurf = "\u2313";
var $560639d49e3c9a19$var$prop$1 = "\u221D";
var $560639d49e3c9a19$var$propto = "\u221D";
var $560639d49e3c9a19$var$prsim = "\u227E";
var $560639d49e3c9a19$var$prurel = "\u22B0";
var $560639d49e3c9a19$var$pscr = "\uD835\uDCC5";
var $560639d49e3c9a19$var$psi$1 = "\u03C8";
var $560639d49e3c9a19$var$puncsp = "\u2008";
var $560639d49e3c9a19$var$qfr = "\uD835\uDD2E";
var $560639d49e3c9a19$var$qint = "\u2A0C";
var $560639d49e3c9a19$var$qopf = "\uD835\uDD62";
var $560639d49e3c9a19$var$qprime = "\u2057";
var $560639d49e3c9a19$var$qscr = "\uD835\uDCC6";
var $560639d49e3c9a19$var$quaternions = "\u210D";
var $560639d49e3c9a19$var$quatint = "\u2A16";
var $560639d49e3c9a19$var$quest = "?";
var $560639d49e3c9a19$var$questeq = "\u225F";
var $560639d49e3c9a19$var$quo = '"';
var $560639d49e3c9a19$var$quot$1 = '"';
var $560639d49e3c9a19$var$rAarr = "\u21DB";
var $560639d49e3c9a19$var$rArr$1 = "\u21D2";
var $560639d49e3c9a19$var$rAtail = "\u291C";
var $560639d49e3c9a19$var$rBarr = "\u290F";
var $560639d49e3c9a19$var$rHar = "\u2964";
var $560639d49e3c9a19$var$race = "\u223D\u0331";
var $560639d49e3c9a19$var$racute = "\u0155";
var $560639d49e3c9a19$var$radic$1 = "\u221A";
var $560639d49e3c9a19$var$raemptyv = "\u29B3";
var $560639d49e3c9a19$var$rang$1 = "\u27E9";
var $560639d49e3c9a19$var$rangd = "\u2992";
var $560639d49e3c9a19$var$range = "\u29A5";
var $560639d49e3c9a19$var$rangle = "\u27E9";
var $560639d49e3c9a19$var$raqu = "\xbb";
var $560639d49e3c9a19$var$raquo$1 = "\xbb";
var $560639d49e3c9a19$var$rarr$1 = "\u2192";
var $560639d49e3c9a19$var$rarrap = "\u2975";
var $560639d49e3c9a19$var$rarrb = "\u21E5";
var $560639d49e3c9a19$var$rarrbfs = "\u2920";
var $560639d49e3c9a19$var$rarrc = "\u2933";
var $560639d49e3c9a19$var$rarrfs = "\u291E";
var $560639d49e3c9a19$var$rarrhk = "\u21AA";
var $560639d49e3c9a19$var$rarrlp = "\u21AC";
var $560639d49e3c9a19$var$rarrpl = "\u2945";
var $560639d49e3c9a19$var$rarrsim = "\u2974";
var $560639d49e3c9a19$var$rarrtl = "\u21A3";
var $560639d49e3c9a19$var$rarrw = "\u219D";
var $560639d49e3c9a19$var$ratail = "\u291A";
var $560639d49e3c9a19$var$ratio = "\u2236";
var $560639d49e3c9a19$var$rationals = "\u211A";
var $560639d49e3c9a19$var$rbarr = "\u290D";
var $560639d49e3c9a19$var$rbbrk = "\u2773";
var $560639d49e3c9a19$var$rbrace = "}";
var $560639d49e3c9a19$var$rbrack = "]";
var $560639d49e3c9a19$var$rbrke = "\u298C";
var $560639d49e3c9a19$var$rbrksld = "\u298E";
var $560639d49e3c9a19$var$rbrkslu = "\u2990";
var $560639d49e3c9a19$var$rcaron = "\u0159";
var $560639d49e3c9a19$var$rcedil = "\u0157";
var $560639d49e3c9a19$var$rceil$1 = "\u2309";
var $560639d49e3c9a19$var$rcub = "}";
var $560639d49e3c9a19$var$rcy = "\u0440";
var $560639d49e3c9a19$var$rdca = "\u2937";
var $560639d49e3c9a19$var$rdldhar = "\u2969";
var $560639d49e3c9a19$var$rdquo$1 = "\u201D";
var $560639d49e3c9a19$var$rdquor = "\u201D";
var $560639d49e3c9a19$var$rdsh = "\u21B3";
var $560639d49e3c9a19$var$real$1 = "\u211C";
var $560639d49e3c9a19$var$realine = "\u211B";
var $560639d49e3c9a19$var$realpart = "\u211C";
var $560639d49e3c9a19$var$reals = "\u211D";
var $560639d49e3c9a19$var$rect = "\u25AD";
var $560639d49e3c9a19$var$re$3 = "\xae";
var $560639d49e3c9a19$var$reg$1 = "\xae";
var $560639d49e3c9a19$var$rfisht = "\u297D";
var $560639d49e3c9a19$var$rfloor$1 = "\u230B";
var $560639d49e3c9a19$var$rfr = "\uD835\uDD2F";
var $560639d49e3c9a19$var$rhard = "\u21C1";
var $560639d49e3c9a19$var$rharu = "\u21C0";
var $560639d49e3c9a19$var$rharul = "\u296C";
var $560639d49e3c9a19$var$rho$1 = "\u03C1";
var $560639d49e3c9a19$var$rhov = "\u03F1";
var $560639d49e3c9a19$var$rightarrow = "\u2192";
var $560639d49e3c9a19$var$rightarrowtail = "\u21A3";
var $560639d49e3c9a19$var$rightharpoondown = "\u21C1";
var $560639d49e3c9a19$var$rightharpoonup = "\u21C0";
var $560639d49e3c9a19$var$rightleftarrows = "\u21C4";
var $560639d49e3c9a19$var$rightleftharpoons = "\u21CC";
var $560639d49e3c9a19$var$rightrightarrows = "\u21C9";
var $560639d49e3c9a19$var$rightsquigarrow = "\u219D";
var $560639d49e3c9a19$var$rightthreetimes = "\u22CC";
var $560639d49e3c9a19$var$ring = "\u02DA";
var $560639d49e3c9a19$var$risingdotseq = "\u2253";
var $560639d49e3c9a19$var$rlarr = "\u21C4";
var $560639d49e3c9a19$var$rlhar = "\u21CC";
var $560639d49e3c9a19$var$rlm$1 = "\u200F";
var $560639d49e3c9a19$var$rmoust = "\u23B1";
var $560639d49e3c9a19$var$rmoustache = "\u23B1";
var $560639d49e3c9a19$var$rnmid = "\u2AEE";
var $560639d49e3c9a19$var$roang = "\u27ED";
var $560639d49e3c9a19$var$roarr = "\u21FE";
var $560639d49e3c9a19$var$robrk = "\u27E7";
var $560639d49e3c9a19$var$ropar = "\u2986";
var $560639d49e3c9a19$var$ropf = "\uD835\uDD63";
var $560639d49e3c9a19$var$roplus = "\u2A2E";
var $560639d49e3c9a19$var$rotimes = "\u2A35";
var $560639d49e3c9a19$var$rpar = ")";
var $560639d49e3c9a19$var$rpargt = "\u2994";
var $560639d49e3c9a19$var$rppolint = "\u2A12";
var $560639d49e3c9a19$var$rrarr = "\u21C9";
var $560639d49e3c9a19$var$rsaquo$1 = "\u203A";
var $560639d49e3c9a19$var$rscr = "\uD835\uDCC7";
var $560639d49e3c9a19$var$rsh = "\u21B1";
var $560639d49e3c9a19$var$rsqb = "]";
var $560639d49e3c9a19$var$rsquo$1 = "\u2019";
var $560639d49e3c9a19$var$rsquor = "\u2019";
var $560639d49e3c9a19$var$rthree = "\u22CC";
var $560639d49e3c9a19$var$rtimes = "\u22CA";
var $560639d49e3c9a19$var$rtri = "\u25B9";
var $560639d49e3c9a19$var$rtrie = "\u22B5";
var $560639d49e3c9a19$var$rtrif = "\u25B8";
var $560639d49e3c9a19$var$rtriltri = "\u29CE";
var $560639d49e3c9a19$var$ruluhar = "\u2968";
var $560639d49e3c9a19$var$rx = "\u211E";
var $560639d49e3c9a19$var$sacute = "\u015B";
var $560639d49e3c9a19$var$sbquo$1 = "\u201A";
var $560639d49e3c9a19$var$sc = "\u227B";
var $560639d49e3c9a19$var$scE = "\u2AB4";
var $560639d49e3c9a19$var$scap = "\u2AB8";
var $560639d49e3c9a19$var$scaron$1 = "\u0161";
var $560639d49e3c9a19$var$sccue = "\u227D";
var $560639d49e3c9a19$var$sce = "\u2AB0";
var $560639d49e3c9a19$var$scedil = "\u015F";
var $560639d49e3c9a19$var$scirc = "\u015D";
var $560639d49e3c9a19$var$scnE = "\u2AB6";
var $560639d49e3c9a19$var$scnap = "\u2ABA";
var $560639d49e3c9a19$var$scnsim = "\u22E9";
var $560639d49e3c9a19$var$scpolint = "\u2A13";
var $560639d49e3c9a19$var$scsim = "\u227F";
var $560639d49e3c9a19$var$scy = "\u0441";
var $560639d49e3c9a19$var$sdot$1 = "\u22C5";
var $560639d49e3c9a19$var$sdotb = "\u22A1";
var $560639d49e3c9a19$var$sdote = "\u2A66";
var $560639d49e3c9a19$var$seArr = "\u21D8";
var $560639d49e3c9a19$var$searhk = "\u2925";
var $560639d49e3c9a19$var$searr = "\u2198";
var $560639d49e3c9a19$var$searrow = "\u2198";
var $560639d49e3c9a19$var$sec = "\xa7";
var $560639d49e3c9a19$var$sect$1 = "\xa7";
var $560639d49e3c9a19$var$semi = ";";
var $560639d49e3c9a19$var$seswar = "\u2929";
var $560639d49e3c9a19$var$setminus = "\u2216";
var $560639d49e3c9a19$var$setmn = "\u2216";
var $560639d49e3c9a19$var$sext = "\u2736";
var $560639d49e3c9a19$var$sfr = "\uD835\uDD30";
var $560639d49e3c9a19$var$sfrown = "\u2322";
var $560639d49e3c9a19$var$sharp = "\u266F";
var $560639d49e3c9a19$var$shchcy = "\u0449";
var $560639d49e3c9a19$var$shcy = "\u0448";
var $560639d49e3c9a19$var$shortmid = "\u2223";
var $560639d49e3c9a19$var$shortparallel = "\u2225";
var $560639d49e3c9a19$var$sh = "\xad";
var $560639d49e3c9a19$var$shy$1 = "\xad";
var $560639d49e3c9a19$var$sigma$1 = "\u03C3";
var $560639d49e3c9a19$var$sigmaf$1 = "\u03C2";
var $560639d49e3c9a19$var$sigmav = "\u03C2";
var $560639d49e3c9a19$var$sim$1 = "\u223C";
var $560639d49e3c9a19$var$simdot = "\u2A6A";
var $560639d49e3c9a19$var$sime = "\u2243";
var $560639d49e3c9a19$var$simeq = "\u2243";
var $560639d49e3c9a19$var$simg = "\u2A9E";
var $560639d49e3c9a19$var$simgE = "\u2AA0";
var $560639d49e3c9a19$var$siml = "\u2A9D";
var $560639d49e3c9a19$var$simlE = "\u2A9F";
var $560639d49e3c9a19$var$simne = "\u2246";
var $560639d49e3c9a19$var$simplus = "\u2A24";
var $560639d49e3c9a19$var$simrarr = "\u2972";
var $560639d49e3c9a19$var$slarr = "\u2190";
var $560639d49e3c9a19$var$smallsetminus = "\u2216";
var $560639d49e3c9a19$var$smashp = "\u2A33";
var $560639d49e3c9a19$var$smeparsl = "\u29E4";
var $560639d49e3c9a19$var$smid = "\u2223";
var $560639d49e3c9a19$var$smile = "\u2323";
var $560639d49e3c9a19$var$smt = "\u2AAA";
var $560639d49e3c9a19$var$smte = "\u2AAC";
var $560639d49e3c9a19$var$smtes = "\u2AAC\uFE00";
var $560639d49e3c9a19$var$softcy = "\u044C";
var $560639d49e3c9a19$var$sol = "/";
var $560639d49e3c9a19$var$solb = "\u29C4";
var $560639d49e3c9a19$var$solbar = "\u233F";
var $560639d49e3c9a19$var$sopf = "\uD835\uDD64";
var $560639d49e3c9a19$var$spades$1 = "\u2660";
var $560639d49e3c9a19$var$spadesuit = "\u2660";
var $560639d49e3c9a19$var$spar = "\u2225";
var $560639d49e3c9a19$var$sqcap = "\u2293";
var $560639d49e3c9a19$var$sqcaps = "\u2293\uFE00";
var $560639d49e3c9a19$var$sqcup = "\u2294";
var $560639d49e3c9a19$var$sqcups = "\u2294\uFE00";
var $560639d49e3c9a19$var$sqsub = "\u228F";
var $560639d49e3c9a19$var$sqsube = "\u2291";
var $560639d49e3c9a19$var$sqsubset = "\u228F";
var $560639d49e3c9a19$var$sqsubseteq = "\u2291";
var $560639d49e3c9a19$var$sqsup = "\u2290";
var $560639d49e3c9a19$var$sqsupe = "\u2292";
var $560639d49e3c9a19$var$sqsupset = "\u2290";
var $560639d49e3c9a19$var$sqsupseteq = "\u2292";
var $560639d49e3c9a19$var$squ = "\u25A1";
var $560639d49e3c9a19$var$square = "\u25A1";
var $560639d49e3c9a19$var$squarf = "\u25AA";
var $560639d49e3c9a19$var$squf = "\u25AA";
var $560639d49e3c9a19$var$srarr = "\u2192";
var $560639d49e3c9a19$var$sscr = "\uD835\uDCC8";
var $560639d49e3c9a19$var$ssetmn = "\u2216";
var $560639d49e3c9a19$var$ssmile = "\u2323";
var $560639d49e3c9a19$var$sstarf = "\u22C6";
var $560639d49e3c9a19$var$star = "\u2606";
var $560639d49e3c9a19$var$starf = "\u2605";
var $560639d49e3c9a19$var$straightepsilon = "\u03F5";
var $560639d49e3c9a19$var$straightphi = "\u03D5";
var $560639d49e3c9a19$var$strns = "\xaf";
var $560639d49e3c9a19$var$sub$1 = "\u2282";
var $560639d49e3c9a19$var$subE = "\u2AC5";
var $560639d49e3c9a19$var$subdot = "\u2ABD";
var $560639d49e3c9a19$var$sube$1 = "\u2286";
var $560639d49e3c9a19$var$subedot = "\u2AC3";
var $560639d49e3c9a19$var$submult = "\u2AC1";
var $560639d49e3c9a19$var$subnE = "\u2ACB";
var $560639d49e3c9a19$var$subne = "\u228A";
var $560639d49e3c9a19$var$subplus = "\u2ABF";
var $560639d49e3c9a19$var$subrarr = "\u2979";
var $560639d49e3c9a19$var$subset = "\u2282";
var $560639d49e3c9a19$var$subseteq = "\u2286";
var $560639d49e3c9a19$var$subseteqq = "\u2AC5";
var $560639d49e3c9a19$var$subsetneq = "\u228A";
var $560639d49e3c9a19$var$subsetneqq = "\u2ACB";
var $560639d49e3c9a19$var$subsim = "\u2AC7";
var $560639d49e3c9a19$var$subsub = "\u2AD5";
var $560639d49e3c9a19$var$subsup = "\u2AD3";
var $560639d49e3c9a19$var$succ = "\u227B";
var $560639d49e3c9a19$var$succapprox = "\u2AB8";
var $560639d49e3c9a19$var$succcurlyeq = "\u227D";
var $560639d49e3c9a19$var$succeq = "\u2AB0";
var $560639d49e3c9a19$var$succnapprox = "\u2ABA";
var $560639d49e3c9a19$var$succneqq = "\u2AB6";
var $560639d49e3c9a19$var$succnsim = "\u22E9";
var $560639d49e3c9a19$var$succsim = "\u227F";
var $560639d49e3c9a19$var$sum$1 = "\u2211";
var $560639d49e3c9a19$var$sung = "\u266A";
var $560639d49e3c9a19$var$sup$1 = "\u2283";
var $560639d49e3c9a19$var$sup1$1 = "\xb9";
var $560639d49e3c9a19$var$sup2$1 = "\xb2";
var $560639d49e3c9a19$var$sup3$1 = "\xb3";
var $560639d49e3c9a19$var$supE = "\u2AC6";
var $560639d49e3c9a19$var$supdot = "\u2ABE";
var $560639d49e3c9a19$var$supdsub = "\u2AD8";
var $560639d49e3c9a19$var$supe$1 = "\u2287";
var $560639d49e3c9a19$var$supedot = "\u2AC4";
var $560639d49e3c9a19$var$suphsol = "\u27C9";
var $560639d49e3c9a19$var$suphsub = "\u2AD7";
var $560639d49e3c9a19$var$suplarr = "\u297B";
var $560639d49e3c9a19$var$supmult = "\u2AC2";
var $560639d49e3c9a19$var$supnE = "\u2ACC";
var $560639d49e3c9a19$var$supne = "\u228B";
var $560639d49e3c9a19$var$supplus = "\u2AC0";
var $560639d49e3c9a19$var$supset = "\u2283";
var $560639d49e3c9a19$var$supseteq = "\u2287";
var $560639d49e3c9a19$var$supseteqq = "\u2AC6";
var $560639d49e3c9a19$var$supsetneq = "\u228B";
var $560639d49e3c9a19$var$supsetneqq = "\u2ACC";
var $560639d49e3c9a19$var$supsim = "\u2AC8";
var $560639d49e3c9a19$var$supsub = "\u2AD4";
var $560639d49e3c9a19$var$supsup = "\u2AD6";
var $560639d49e3c9a19$var$swArr = "\u21D9";
var $560639d49e3c9a19$var$swarhk = "\u2926";
var $560639d49e3c9a19$var$swarr = "\u2199";
var $560639d49e3c9a19$var$swarrow = "\u2199";
var $560639d49e3c9a19$var$swnwar = "\u292A";
var $560639d49e3c9a19$var$szli = "\xdf";
var $560639d49e3c9a19$var$szlig$1 = "\xdf";
var $560639d49e3c9a19$var$target = "\u2316";
var $560639d49e3c9a19$var$tau$1 = "\u03C4";
var $560639d49e3c9a19$var$tbrk = "\u23B4";
var $560639d49e3c9a19$var$tcaron = "\u0165";
var $560639d49e3c9a19$var$tcedil = "\u0163";
var $560639d49e3c9a19$var$tcy = "\u0442";
var $560639d49e3c9a19$var$tdot = "\u20DB";
var $560639d49e3c9a19$var$telrec = "\u2315";
var $560639d49e3c9a19$var$tfr = "\uD835\uDD31";
var $560639d49e3c9a19$var$there4$1 = "\u2234";
var $560639d49e3c9a19$var$therefore = "\u2234";
var $560639d49e3c9a19$var$theta$1 = "\u03B8";
var $560639d49e3c9a19$var$thetasym$1 = "\u03D1";
var $560639d49e3c9a19$var$thetav = "\u03D1";
var $560639d49e3c9a19$var$thickapprox = "\u2248";
var $560639d49e3c9a19$var$thicksim = "\u223C";
var $560639d49e3c9a19$var$thinsp$1 = "\u2009";
var $560639d49e3c9a19$var$thkap = "\u2248";
var $560639d49e3c9a19$var$thksim = "\u223C";
var $560639d49e3c9a19$var$thor = "\xfe";
var $560639d49e3c9a19$var$thorn$1 = "\xfe";
var $560639d49e3c9a19$var$tilde$4 = "\u02DC";
var $560639d49e3c9a19$var$time = "\xd7";
var $560639d49e3c9a19$var$times$1 = "\xd7";
var $560639d49e3c9a19$var$timesb = "\u22A0";
var $560639d49e3c9a19$var$timesbar = "\u2A31";
var $560639d49e3c9a19$var$timesd = "\u2A30";
var $560639d49e3c9a19$var$tint = "\u222D";
var $560639d49e3c9a19$var$toea = "\u2928";
var $560639d49e3c9a19$var$top = "\u22A4";
var $560639d49e3c9a19$var$topbot = "\u2336";
var $560639d49e3c9a19$var$topcir = "\u2AF1";
var $560639d49e3c9a19$var$topf = "\uD835\uDD65";
var $560639d49e3c9a19$var$topfork = "\u2ADA";
var $560639d49e3c9a19$var$tosa = "\u2929";
var $560639d49e3c9a19$var$tprime = "\u2034";
var $560639d49e3c9a19$var$trade$1 = "\u2122";
var $560639d49e3c9a19$var$triangle = "\u25B5";
var $560639d49e3c9a19$var$triangledown = "\u25BF";
var $560639d49e3c9a19$var$triangleleft = "\u25C3";
var $560639d49e3c9a19$var$trianglelefteq = "\u22B4";
var $560639d49e3c9a19$var$triangleq = "\u225C";
var $560639d49e3c9a19$var$triangleright = "\u25B9";
var $560639d49e3c9a19$var$trianglerighteq = "\u22B5";
var $560639d49e3c9a19$var$tridot = "\u25EC";
var $560639d49e3c9a19$var$trie = "\u225C";
var $560639d49e3c9a19$var$triminus = "\u2A3A";
var $560639d49e3c9a19$var$triplus = "\u2A39";
var $560639d49e3c9a19$var$trisb = "\u29CD";
var $560639d49e3c9a19$var$tritime = "\u2A3B";
var $560639d49e3c9a19$var$trpezium = "\u23E2";
var $560639d49e3c9a19$var$tscr = "\uD835\uDCC9";
var $560639d49e3c9a19$var$tscy = "\u0446";
var $560639d49e3c9a19$var$tshcy = "\u045B";
var $560639d49e3c9a19$var$tstrok = "\u0167";
var $560639d49e3c9a19$var$twixt = "\u226C";
var $560639d49e3c9a19$var$twoheadleftarrow = "\u219E";
var $560639d49e3c9a19$var$twoheadrightarrow = "\u21A0";
var $560639d49e3c9a19$var$uArr$1 = "\u21D1";
var $560639d49e3c9a19$var$uHar = "\u2963";
var $560639d49e3c9a19$var$uacut = "\xfa";
var $560639d49e3c9a19$var$uacute$1 = "\xfa";
var $560639d49e3c9a19$var$uarr$1 = "\u2191";
var $560639d49e3c9a19$var$ubrcy = "\u045E";
var $560639d49e3c9a19$var$ubreve = "\u016D";
var $560639d49e3c9a19$var$ucir = "\xfb";
var $560639d49e3c9a19$var$ucirc$1 = "\xfb";
var $560639d49e3c9a19$var$ucy = "\u0443";
var $560639d49e3c9a19$var$udarr = "\u21C5";
var $560639d49e3c9a19$var$udblac = "\u0171";
var $560639d49e3c9a19$var$udhar = "\u296E";
var $560639d49e3c9a19$var$ufisht = "\u297E";
var $560639d49e3c9a19$var$ufr = "\uD835\uDD32";
var $560639d49e3c9a19$var$ugrav = "\xf9";
var $560639d49e3c9a19$var$ugrave$1 = "\xf9";
var $560639d49e3c9a19$var$uharl = "\u21BF";
var $560639d49e3c9a19$var$uharr = "\u21BE";
var $560639d49e3c9a19$var$uhblk = "\u2580";
var $560639d49e3c9a19$var$ulcorn = "\u231C";
var $560639d49e3c9a19$var$ulcorner = "\u231C";
var $560639d49e3c9a19$var$ulcrop = "\u230F";
var $560639d49e3c9a19$var$ultri = "\u25F8";
var $560639d49e3c9a19$var$umacr = "\u016B";
var $560639d49e3c9a19$var$um = "\xa8";
var $560639d49e3c9a19$var$uml$1 = "\xa8";
var $560639d49e3c9a19$var$uogon = "\u0173";
var $560639d49e3c9a19$var$uopf = "\uD835\uDD66";
var $560639d49e3c9a19$var$uparrow = "\u2191";
var $560639d49e3c9a19$var$updownarrow = "\u2195";
var $560639d49e3c9a19$var$upharpoonleft = "\u21BF";
var $560639d49e3c9a19$var$upharpoonright = "\u21BE";
var $560639d49e3c9a19$var$uplus = "\u228E";
var $560639d49e3c9a19$var$upsi = "\u03C5";
var $560639d49e3c9a19$var$upsih$1 = "\u03D2";
var $560639d49e3c9a19$var$upsilon$1 = "\u03C5";
var $560639d49e3c9a19$var$upuparrows = "\u21C8";
var $560639d49e3c9a19$var$urcorn = "\u231D";
var $560639d49e3c9a19$var$urcorner = "\u231D";
var $560639d49e3c9a19$var$urcrop = "\u230E";
var $560639d49e3c9a19$var$uring = "\u016F";
var $560639d49e3c9a19$var$urtri = "\u25F9";
var $560639d49e3c9a19$var$uscr = "\uD835\uDCCA";
var $560639d49e3c9a19$var$utdot = "\u22F0";
var $560639d49e3c9a19$var$utilde = "\u0169";
var $560639d49e3c9a19$var$utri = "\u25B5";
var $560639d49e3c9a19$var$utrif = "\u25B4";
var $560639d49e3c9a19$var$uuarr = "\u21C8";
var $560639d49e3c9a19$var$uum = "\xfc";
var $560639d49e3c9a19$var$uuml$1 = "\xfc";
var $560639d49e3c9a19$var$uwangle = "\u29A7";
var $560639d49e3c9a19$var$vArr = "\u21D5";
var $560639d49e3c9a19$var$vBar = "\u2AE8";
var $560639d49e3c9a19$var$vBarv = "\u2AE9";
var $560639d49e3c9a19$var$vDash = "\u22A8";
var $560639d49e3c9a19$var$vangrt = "\u299C";
var $560639d49e3c9a19$var$varepsilon = "\u03F5";
var $560639d49e3c9a19$var$varkappa = "\u03F0";
var $560639d49e3c9a19$var$varnothing = "\u2205";
var $560639d49e3c9a19$var$varphi = "\u03D5";
var $560639d49e3c9a19$var$varpi = "\u03D6";
var $560639d49e3c9a19$var$varpropto = "\u221D";
var $560639d49e3c9a19$var$varr = "\u2195";
var $560639d49e3c9a19$var$varrho = "\u03F1";
var $560639d49e3c9a19$var$varsigma = "\u03C2";
var $560639d49e3c9a19$var$varsubsetneq = "\u228A\uFE00";
var $560639d49e3c9a19$var$varsubsetneqq = "\u2ACB\uFE00";
var $560639d49e3c9a19$var$varsupsetneq = "\u228B\uFE00";
var $560639d49e3c9a19$var$varsupsetneqq = "\u2ACC\uFE00";
var $560639d49e3c9a19$var$vartheta = "\u03D1";
var $560639d49e3c9a19$var$vartriangleleft = "\u22B2";
var $560639d49e3c9a19$var$vartriangleright = "\u22B3";
var $560639d49e3c9a19$var$vcy = "\u0432";
var $560639d49e3c9a19$var$vdash = "\u22A2";
var $560639d49e3c9a19$var$vee = "\u2228";
var $560639d49e3c9a19$var$veebar = "\u22BB";
var $560639d49e3c9a19$var$veeeq = "\u225A";
var $560639d49e3c9a19$var$vellip = "\u22EE";
var $560639d49e3c9a19$var$verbar = "|";
var $560639d49e3c9a19$var$vert = "|";
var $560639d49e3c9a19$var$vfr = "\uD835\uDD33";
var $560639d49e3c9a19$var$vltri = "\u22B2";
var $560639d49e3c9a19$var$vnsub = "\u2282\u20D2";
var $560639d49e3c9a19$var$vnsup = "\u2283\u20D2";
var $560639d49e3c9a19$var$vopf = "\uD835\uDD67";
var $560639d49e3c9a19$var$vprop = "\u221D";
var $560639d49e3c9a19$var$vrtri = "\u22B3";
var $560639d49e3c9a19$var$vscr = "\uD835\uDCCB";
var $560639d49e3c9a19$var$vsubnE = "\u2ACB\uFE00";
var $560639d49e3c9a19$var$vsubne = "\u228A\uFE00";
var $560639d49e3c9a19$var$vsupnE = "\u2ACC\uFE00";
var $560639d49e3c9a19$var$vsupne = "\u228B\uFE00";
var $560639d49e3c9a19$var$vzigzag = "\u299A";
var $560639d49e3c9a19$var$wcirc = "\u0175";
var $560639d49e3c9a19$var$wedbar = "\u2A5F";
var $560639d49e3c9a19$var$wedge = "\u2227";
var $560639d49e3c9a19$var$wedgeq = "\u2259";
var $560639d49e3c9a19$var$weierp$1 = "\u2118";
var $560639d49e3c9a19$var$wfr = "\uD835\uDD34";
var $560639d49e3c9a19$var$wopf = "\uD835\uDD68";
var $560639d49e3c9a19$var$wp = "\u2118";
var $560639d49e3c9a19$var$wr = "\u2240";
var $560639d49e3c9a19$var$wreath = "\u2240";
var $560639d49e3c9a19$var$wscr = "\uD835\uDCCC";
var $560639d49e3c9a19$var$xcap = "\u22C2";
var $560639d49e3c9a19$var$xcirc = "\u25EF";
var $560639d49e3c9a19$var$xcup = "\u22C3";
var $560639d49e3c9a19$var$xdtri = "\u25BD";
var $560639d49e3c9a19$var$xfr = "\uD835\uDD35";
var $560639d49e3c9a19$var$xhArr = "\u27FA";
var $560639d49e3c9a19$var$xharr = "\u27F7";
var $560639d49e3c9a19$var$xi$1 = "\u03BE";
var $560639d49e3c9a19$var$xlArr = "\u27F8";
var $560639d49e3c9a19$var$xlarr = "\u27F5";
var $560639d49e3c9a19$var$xmap = "\u27FC";
var $560639d49e3c9a19$var$xnis = "\u22FB";
var $560639d49e3c9a19$var$xodot = "\u2A00";
var $560639d49e3c9a19$var$xopf = "\uD835\uDD69";
var $560639d49e3c9a19$var$xoplus = "\u2A01";
var $560639d49e3c9a19$var$xotime = "\u2A02";
var $560639d49e3c9a19$var$xrArr = "\u27F9";
var $560639d49e3c9a19$var$xrarr = "\u27F6";
var $560639d49e3c9a19$var$xscr = "\uD835\uDCCD";
var $560639d49e3c9a19$var$xsqcup = "\u2A06";
var $560639d49e3c9a19$var$xuplus = "\u2A04";
var $560639d49e3c9a19$var$xutri = "\u25B3";
var $560639d49e3c9a19$var$xvee = "\u22C1";
var $560639d49e3c9a19$var$xwedge = "\u22C0";
var $560639d49e3c9a19$var$yacut = "\xfd";
var $560639d49e3c9a19$var$yacute$1 = "\xfd";
var $560639d49e3c9a19$var$yacy = "\u044F";
var $560639d49e3c9a19$var$ycirc = "\u0177";
var $560639d49e3c9a19$var$ycy = "\u044B";
var $560639d49e3c9a19$var$ye = "\xa5";
var $560639d49e3c9a19$var$yen$1 = "\xa5";
var $560639d49e3c9a19$var$yfr = "\uD835\uDD36";
var $560639d49e3c9a19$var$yicy = "\u0457";
var $560639d49e3c9a19$var$yopf = "\uD835\uDD6A";
var $560639d49e3c9a19$var$yscr = "\uD835\uDCCE";
var $560639d49e3c9a19$var$yucy = "\u044E";
var $560639d49e3c9a19$var$yum = "\xff";
var $560639d49e3c9a19$var$yuml$1 = "\xff";
var $560639d49e3c9a19$var$zacute = "\u017A";
var $560639d49e3c9a19$var$zcaron = "\u017E";
var $560639d49e3c9a19$var$zcy = "\u0437";
var $560639d49e3c9a19$var$zdot = "\u017C";
var $560639d49e3c9a19$var$zeetrf = "\u2128";
var $560639d49e3c9a19$var$zeta$1 = "\u03B6";
var $560639d49e3c9a19$var$zfr = "\uD835\uDD37";
var $560639d49e3c9a19$var$zhcy = "\u0436";
var $560639d49e3c9a19$var$zigrarr = "\u21DD";
var $560639d49e3c9a19$var$zopf = "\uD835\uDD6B";
var $560639d49e3c9a19$var$zscr = "\uD835\uDCCF";
var $560639d49e3c9a19$var$zwj$1 = "\u200D";
var $560639d49e3c9a19$var$zwnj$1 = "\u200C";
var $560639d49e3c9a19$var$index$3 = {
    AEli: $560639d49e3c9a19$var$AEli,
    AElig: $560639d49e3c9a19$var$AElig$1,
    AM: $560639d49e3c9a19$var$AM,
    AMP: $560639d49e3c9a19$var$AMP$1,
    Aacut: $560639d49e3c9a19$var$Aacut,
    Aacute: $560639d49e3c9a19$var$Aacute$1,
    Abreve: $560639d49e3c9a19$var$Abreve,
    Acir: $560639d49e3c9a19$var$Acir,
    Acirc: $560639d49e3c9a19$var$Acirc$1,
    Acy: $560639d49e3c9a19$var$Acy,
    Afr: $560639d49e3c9a19$var$Afr,
    Agrav: $560639d49e3c9a19$var$Agrav,
    Agrave: $560639d49e3c9a19$var$Agrave$1,
    Alpha: $560639d49e3c9a19$var$Alpha$1,
    Amacr: $560639d49e3c9a19$var$Amacr,
    And: $560639d49e3c9a19$var$And,
    Aogon: $560639d49e3c9a19$var$Aogon,
    Aopf: $560639d49e3c9a19$var$Aopf,
    ApplyFunction: $560639d49e3c9a19$var$ApplyFunction,
    Arin: $560639d49e3c9a19$var$Arin,
    Aring: $560639d49e3c9a19$var$Aring$1,
    Ascr: $560639d49e3c9a19$var$Ascr,
    Assign: $560639d49e3c9a19$var$Assign,
    Atild: $560639d49e3c9a19$var$Atild,
    Atilde: $560639d49e3c9a19$var$Atilde$1,
    Aum: $560639d49e3c9a19$var$Aum,
    Auml: $560639d49e3c9a19$var$Auml$1,
    Backslash: $560639d49e3c9a19$var$Backslash,
    Barv: $560639d49e3c9a19$var$Barv,
    Barwed: $560639d49e3c9a19$var$Barwed,
    Bcy: $560639d49e3c9a19$var$Bcy,
    Because: $560639d49e3c9a19$var$Because,
    Bernoullis: $560639d49e3c9a19$var$Bernoullis,
    Beta: $560639d49e3c9a19$var$Beta$1,
    Bfr: $560639d49e3c9a19$var$Bfr,
    Bopf: $560639d49e3c9a19$var$Bopf,
    Breve: $560639d49e3c9a19$var$Breve,
    Bscr: $560639d49e3c9a19$var$Bscr,
    Bumpeq: $560639d49e3c9a19$var$Bumpeq,
    CHcy: $560639d49e3c9a19$var$CHcy,
    COP: $560639d49e3c9a19$var$COP,
    COPY: $560639d49e3c9a19$var$COPY,
    Cacute: $560639d49e3c9a19$var$Cacute,
    Cap: $560639d49e3c9a19$var$Cap,
    CapitalDifferentialD: $560639d49e3c9a19$var$CapitalDifferentialD,
    Cayleys: $560639d49e3c9a19$var$Cayleys,
    Ccaron: $560639d49e3c9a19$var$Ccaron,
    Ccedi: $560639d49e3c9a19$var$Ccedi,
    Ccedil: $560639d49e3c9a19$var$Ccedil$1,
    Ccirc: $560639d49e3c9a19$var$Ccirc,
    Cconint: $560639d49e3c9a19$var$Cconint,
    Cdot: $560639d49e3c9a19$var$Cdot,
    Cedilla: $560639d49e3c9a19$var$Cedilla,
    CenterDot: $560639d49e3c9a19$var$CenterDot,
    Cfr: $560639d49e3c9a19$var$Cfr,
    Chi: $560639d49e3c9a19$var$Chi$1,
    CircleDot: $560639d49e3c9a19$var$CircleDot,
    CircleMinus: $560639d49e3c9a19$var$CircleMinus,
    CirclePlus: $560639d49e3c9a19$var$CirclePlus,
    CircleTimes: $560639d49e3c9a19$var$CircleTimes,
    ClockwiseContourIntegral: $560639d49e3c9a19$var$ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: $560639d49e3c9a19$var$CloseCurlyDoubleQuote,
    CloseCurlyQuote: $560639d49e3c9a19$var$CloseCurlyQuote,
    Colon: $560639d49e3c9a19$var$Colon,
    Colone: $560639d49e3c9a19$var$Colone,
    Congruent: $560639d49e3c9a19$var$Congruent,
    Conint: $560639d49e3c9a19$var$Conint,
    ContourIntegral: $560639d49e3c9a19$var$ContourIntegral,
    Copf: $560639d49e3c9a19$var$Copf,
    Coproduct: $560639d49e3c9a19$var$Coproduct,
    CounterClockwiseContourIntegral: $560639d49e3c9a19$var$CounterClockwiseContourIntegral,
    Cross: $560639d49e3c9a19$var$Cross,
    Cscr: $560639d49e3c9a19$var$Cscr,
    Cup: $560639d49e3c9a19$var$Cup,
    CupCap: $560639d49e3c9a19$var$CupCap,
    DD: $560639d49e3c9a19$var$DD,
    DDotrahd: $560639d49e3c9a19$var$DDotrahd,
    DJcy: $560639d49e3c9a19$var$DJcy,
    DScy: $560639d49e3c9a19$var$DScy,
    DZcy: $560639d49e3c9a19$var$DZcy,
    Dagger: $560639d49e3c9a19$var$Dagger$1,
    Darr: $560639d49e3c9a19$var$Darr,
    Dashv: $560639d49e3c9a19$var$Dashv,
    Dcaron: $560639d49e3c9a19$var$Dcaron,
    Dcy: $560639d49e3c9a19$var$Dcy,
    Del: $560639d49e3c9a19$var$Del,
    Delta: $560639d49e3c9a19$var$Delta$1,
    Dfr: $560639d49e3c9a19$var$Dfr,
    DiacriticalAcute: $560639d49e3c9a19$var$DiacriticalAcute,
    DiacriticalDot: $560639d49e3c9a19$var$DiacriticalDot,
    DiacriticalDoubleAcute: $560639d49e3c9a19$var$DiacriticalDoubleAcute,
    DiacriticalGrave: $560639d49e3c9a19$var$DiacriticalGrave,
    DiacriticalTilde: $560639d49e3c9a19$var$DiacriticalTilde,
    Diamond: $560639d49e3c9a19$var$Diamond,
    DifferentialD: $560639d49e3c9a19$var$DifferentialD,
    Dopf: $560639d49e3c9a19$var$Dopf,
    Dot: $560639d49e3c9a19$var$Dot,
    DotDot: $560639d49e3c9a19$var$DotDot,
    DotEqual: $560639d49e3c9a19$var$DotEqual,
    DoubleContourIntegral: $560639d49e3c9a19$var$DoubleContourIntegral,
    DoubleDot: $560639d49e3c9a19$var$DoubleDot,
    DoubleDownArrow: $560639d49e3c9a19$var$DoubleDownArrow,
    DoubleLeftArrow: $560639d49e3c9a19$var$DoubleLeftArrow,
    DoubleLeftRightArrow: $560639d49e3c9a19$var$DoubleLeftRightArrow,
    DoubleLeftTee: $560639d49e3c9a19$var$DoubleLeftTee,
    DoubleLongLeftArrow: $560639d49e3c9a19$var$DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: $560639d49e3c9a19$var$DoubleLongLeftRightArrow,
    DoubleLongRightArrow: $560639d49e3c9a19$var$DoubleLongRightArrow,
    DoubleRightArrow: $560639d49e3c9a19$var$DoubleRightArrow,
    DoubleRightTee: $560639d49e3c9a19$var$DoubleRightTee,
    DoubleUpArrow: $560639d49e3c9a19$var$DoubleUpArrow,
    DoubleUpDownArrow: $560639d49e3c9a19$var$DoubleUpDownArrow,
    DoubleVerticalBar: $560639d49e3c9a19$var$DoubleVerticalBar,
    DownArrow: $560639d49e3c9a19$var$DownArrow,
    DownArrowBar: $560639d49e3c9a19$var$DownArrowBar,
    DownArrowUpArrow: $560639d49e3c9a19$var$DownArrowUpArrow,
    DownBreve: $560639d49e3c9a19$var$DownBreve,
    DownLeftRightVector: $560639d49e3c9a19$var$DownLeftRightVector,
    DownLeftTeeVector: $560639d49e3c9a19$var$DownLeftTeeVector,
    DownLeftVector: $560639d49e3c9a19$var$DownLeftVector,
    DownLeftVectorBar: $560639d49e3c9a19$var$DownLeftVectorBar,
    DownRightTeeVector: $560639d49e3c9a19$var$DownRightTeeVector,
    DownRightVector: $560639d49e3c9a19$var$DownRightVector,
    DownRightVectorBar: $560639d49e3c9a19$var$DownRightVectorBar,
    DownTee: $560639d49e3c9a19$var$DownTee,
    DownTeeArrow: $560639d49e3c9a19$var$DownTeeArrow,
    Downarrow: $560639d49e3c9a19$var$Downarrow,
    Dscr: $560639d49e3c9a19$var$Dscr,
    Dstrok: $560639d49e3c9a19$var$Dstrok,
    ENG: $560639d49e3c9a19$var$ENG,
    ET: $560639d49e3c9a19$var$ET,
    ETH: $560639d49e3c9a19$var$ETH$1,
    Eacut: $560639d49e3c9a19$var$Eacut,
    Eacute: $560639d49e3c9a19$var$Eacute$1,
    Ecaron: $560639d49e3c9a19$var$Ecaron,
    Ecir: $560639d49e3c9a19$var$Ecir,
    Ecirc: $560639d49e3c9a19$var$Ecirc$1,
    Ecy: $560639d49e3c9a19$var$Ecy,
    Edot: $560639d49e3c9a19$var$Edot,
    Efr: $560639d49e3c9a19$var$Efr,
    Egrav: $560639d49e3c9a19$var$Egrav,
    Egrave: $560639d49e3c9a19$var$Egrave$1,
    Element: $560639d49e3c9a19$var$Element,
    Emacr: $560639d49e3c9a19$var$Emacr,
    EmptySmallSquare: $560639d49e3c9a19$var$EmptySmallSquare,
    EmptyVerySmallSquare: $560639d49e3c9a19$var$EmptyVerySmallSquare,
    Eogon: $560639d49e3c9a19$var$Eogon,
    Eopf: $560639d49e3c9a19$var$Eopf,
    Epsilon: $560639d49e3c9a19$var$Epsilon$1,
    Equal: $560639d49e3c9a19$var$Equal,
    EqualTilde: $560639d49e3c9a19$var$EqualTilde,
    Equilibrium: $560639d49e3c9a19$var$Equilibrium,
    Escr: $560639d49e3c9a19$var$Escr,
    Esim: $560639d49e3c9a19$var$Esim,
    Eta: $560639d49e3c9a19$var$Eta$1,
    Eum: $560639d49e3c9a19$var$Eum,
    Euml: $560639d49e3c9a19$var$Euml$1,
    Exists: $560639d49e3c9a19$var$Exists,
    ExponentialE: $560639d49e3c9a19$var$ExponentialE,
    Fcy: $560639d49e3c9a19$var$Fcy,
    Ffr: $560639d49e3c9a19$var$Ffr,
    FilledSmallSquare: $560639d49e3c9a19$var$FilledSmallSquare,
    FilledVerySmallSquare: $560639d49e3c9a19$var$FilledVerySmallSquare,
    Fopf: $560639d49e3c9a19$var$Fopf,
    ForAll: $560639d49e3c9a19$var$ForAll,
    Fouriertrf: $560639d49e3c9a19$var$Fouriertrf,
    Fscr: $560639d49e3c9a19$var$Fscr,
    GJcy: $560639d49e3c9a19$var$GJcy,
    G: $560639d49e3c9a19$var$G,
    GT: $560639d49e3c9a19$var$GT$1,
    Gamma: $560639d49e3c9a19$var$Gamma$1,
    Gammad: $560639d49e3c9a19$var$Gammad,
    Gbreve: $560639d49e3c9a19$var$Gbreve,
    Gcedil: $560639d49e3c9a19$var$Gcedil,
    Gcirc: $560639d49e3c9a19$var$Gcirc,
    Gcy: $560639d49e3c9a19$var$Gcy,
    Gdot: $560639d49e3c9a19$var$Gdot,
    Gfr: $560639d49e3c9a19$var$Gfr,
    Gg: $560639d49e3c9a19$var$Gg,
    Gopf: $560639d49e3c9a19$var$Gopf,
    GreaterEqual: $560639d49e3c9a19$var$GreaterEqual,
    GreaterEqualLess: $560639d49e3c9a19$var$GreaterEqualLess,
    GreaterFullEqual: $560639d49e3c9a19$var$GreaterFullEqual,
    GreaterGreater: $560639d49e3c9a19$var$GreaterGreater,
    GreaterLess: $560639d49e3c9a19$var$GreaterLess,
    GreaterSlantEqual: $560639d49e3c9a19$var$GreaterSlantEqual,
    GreaterTilde: $560639d49e3c9a19$var$GreaterTilde,
    Gscr: $560639d49e3c9a19$var$Gscr,
    Gt: $560639d49e3c9a19$var$Gt,
    HARDcy: $560639d49e3c9a19$var$HARDcy,
    Hacek: $560639d49e3c9a19$var$Hacek,
    Hat: $560639d49e3c9a19$var$Hat,
    Hcirc: $560639d49e3c9a19$var$Hcirc,
    Hfr: $560639d49e3c9a19$var$Hfr,
    HilbertSpace: $560639d49e3c9a19$var$HilbertSpace,
    Hopf: $560639d49e3c9a19$var$Hopf,
    HorizontalLine: $560639d49e3c9a19$var$HorizontalLine,
    Hscr: $560639d49e3c9a19$var$Hscr,
    Hstrok: $560639d49e3c9a19$var$Hstrok,
    HumpDownHump: $560639d49e3c9a19$var$HumpDownHump,
    HumpEqual: $560639d49e3c9a19$var$HumpEqual,
    IEcy: $560639d49e3c9a19$var$IEcy,
    IJlig: $560639d49e3c9a19$var$IJlig,
    IOcy: $560639d49e3c9a19$var$IOcy,
    Iacut: $560639d49e3c9a19$var$Iacut,
    Iacute: $560639d49e3c9a19$var$Iacute$1,
    Icir: $560639d49e3c9a19$var$Icir,
    Icirc: $560639d49e3c9a19$var$Icirc$1,
    Icy: $560639d49e3c9a19$var$Icy,
    Idot: $560639d49e3c9a19$var$Idot,
    Ifr: $560639d49e3c9a19$var$Ifr,
    Igrav: $560639d49e3c9a19$var$Igrav,
    Igrave: $560639d49e3c9a19$var$Igrave$1,
    Im: $560639d49e3c9a19$var$Im,
    Imacr: $560639d49e3c9a19$var$Imacr,
    ImaginaryI: $560639d49e3c9a19$var$ImaginaryI,
    Implies: $560639d49e3c9a19$var$Implies,
    Int: $560639d49e3c9a19$var$Int,
    Integral: $560639d49e3c9a19$var$Integral,
    Intersection: $560639d49e3c9a19$var$Intersection,
    InvisibleComma: $560639d49e3c9a19$var$InvisibleComma,
    InvisibleTimes: $560639d49e3c9a19$var$InvisibleTimes,
    Iogon: $560639d49e3c9a19$var$Iogon,
    Iopf: $560639d49e3c9a19$var$Iopf,
    Iota: $560639d49e3c9a19$var$Iota$1,
    Iscr: $560639d49e3c9a19$var$Iscr,
    Itilde: $560639d49e3c9a19$var$Itilde,
    Iukcy: $560639d49e3c9a19$var$Iukcy,
    Ium: $560639d49e3c9a19$var$Ium,
    Iuml: $560639d49e3c9a19$var$Iuml$1,
    Jcirc: $560639d49e3c9a19$var$Jcirc,
    Jcy: $560639d49e3c9a19$var$Jcy,
    Jfr: $560639d49e3c9a19$var$Jfr,
    Jopf: $560639d49e3c9a19$var$Jopf,
    Jscr: $560639d49e3c9a19$var$Jscr,
    Jsercy: $560639d49e3c9a19$var$Jsercy,
    Jukcy: $560639d49e3c9a19$var$Jukcy,
    KHcy: $560639d49e3c9a19$var$KHcy,
    KJcy: $560639d49e3c9a19$var$KJcy,
    Kappa: $560639d49e3c9a19$var$Kappa$1,
    Kcedil: $560639d49e3c9a19$var$Kcedil,
    Kcy: $560639d49e3c9a19$var$Kcy,
    Kfr: $560639d49e3c9a19$var$Kfr,
    Kopf: $560639d49e3c9a19$var$Kopf,
    Kscr: $560639d49e3c9a19$var$Kscr,
    LJcy: $560639d49e3c9a19$var$LJcy,
    L: $560639d49e3c9a19$var$L,
    LT: $560639d49e3c9a19$var$LT$1,
    Lacute: $560639d49e3c9a19$var$Lacute,
    Lambda: $560639d49e3c9a19$var$Lambda$1,
    Lang: $560639d49e3c9a19$var$Lang,
    Laplacetrf: $560639d49e3c9a19$var$Laplacetrf,
    Larr: $560639d49e3c9a19$var$Larr,
    Lcaron: $560639d49e3c9a19$var$Lcaron,
    Lcedil: $560639d49e3c9a19$var$Lcedil,
    Lcy: $560639d49e3c9a19$var$Lcy,
    LeftAngleBracket: $560639d49e3c9a19$var$LeftAngleBracket,
    LeftArrow: $560639d49e3c9a19$var$LeftArrow,
    LeftArrowBar: $560639d49e3c9a19$var$LeftArrowBar,
    LeftArrowRightArrow: $560639d49e3c9a19$var$LeftArrowRightArrow,
    LeftCeiling: $560639d49e3c9a19$var$LeftCeiling,
    LeftDoubleBracket: $560639d49e3c9a19$var$LeftDoubleBracket,
    LeftDownTeeVector: $560639d49e3c9a19$var$LeftDownTeeVector,
    LeftDownVector: $560639d49e3c9a19$var$LeftDownVector,
    LeftDownVectorBar: $560639d49e3c9a19$var$LeftDownVectorBar,
    LeftFloor: $560639d49e3c9a19$var$LeftFloor,
    LeftRightArrow: $560639d49e3c9a19$var$LeftRightArrow,
    LeftRightVector: $560639d49e3c9a19$var$LeftRightVector,
    LeftTee: $560639d49e3c9a19$var$LeftTee,
    LeftTeeArrow: $560639d49e3c9a19$var$LeftTeeArrow,
    LeftTeeVector: $560639d49e3c9a19$var$LeftTeeVector,
    LeftTriangle: $560639d49e3c9a19$var$LeftTriangle,
    LeftTriangleBar: $560639d49e3c9a19$var$LeftTriangleBar,
    LeftTriangleEqual: $560639d49e3c9a19$var$LeftTriangleEqual,
    LeftUpDownVector: $560639d49e3c9a19$var$LeftUpDownVector,
    LeftUpTeeVector: $560639d49e3c9a19$var$LeftUpTeeVector,
    LeftUpVector: $560639d49e3c9a19$var$LeftUpVector,
    LeftUpVectorBar: $560639d49e3c9a19$var$LeftUpVectorBar,
    LeftVector: $560639d49e3c9a19$var$LeftVector,
    LeftVectorBar: $560639d49e3c9a19$var$LeftVectorBar,
    Leftarrow: $560639d49e3c9a19$var$Leftarrow,
    Leftrightarrow: $560639d49e3c9a19$var$Leftrightarrow,
    LessEqualGreater: $560639d49e3c9a19$var$LessEqualGreater,
    LessFullEqual: $560639d49e3c9a19$var$LessFullEqual,
    LessGreater: $560639d49e3c9a19$var$LessGreater,
    LessLess: $560639d49e3c9a19$var$LessLess,
    LessSlantEqual: $560639d49e3c9a19$var$LessSlantEqual,
    LessTilde: $560639d49e3c9a19$var$LessTilde,
    Lfr: $560639d49e3c9a19$var$Lfr,
    Ll: $560639d49e3c9a19$var$Ll,
    Lleftarrow: $560639d49e3c9a19$var$Lleftarrow,
    Lmidot: $560639d49e3c9a19$var$Lmidot,
    LongLeftArrow: $560639d49e3c9a19$var$LongLeftArrow,
    LongLeftRightArrow: $560639d49e3c9a19$var$LongLeftRightArrow,
    LongRightArrow: $560639d49e3c9a19$var$LongRightArrow,
    Longleftarrow: $560639d49e3c9a19$var$Longleftarrow,
    Longleftrightarrow: $560639d49e3c9a19$var$Longleftrightarrow,
    Longrightarrow: $560639d49e3c9a19$var$Longrightarrow,
    Lopf: $560639d49e3c9a19$var$Lopf,
    LowerLeftArrow: $560639d49e3c9a19$var$LowerLeftArrow,
    LowerRightArrow: $560639d49e3c9a19$var$LowerRightArrow,
    Lscr: $560639d49e3c9a19$var$Lscr,
    Lsh: $560639d49e3c9a19$var$Lsh,
    Lstrok: $560639d49e3c9a19$var$Lstrok,
    Lt: $560639d49e3c9a19$var$Lt,
    "Map": "\u2905",
    Mcy: $560639d49e3c9a19$var$Mcy,
    MediumSpace: $560639d49e3c9a19$var$MediumSpace,
    Mellintrf: $560639d49e3c9a19$var$Mellintrf,
    Mfr: $560639d49e3c9a19$var$Mfr,
    MinusPlus: $560639d49e3c9a19$var$MinusPlus,
    Mopf: $560639d49e3c9a19$var$Mopf,
    Mscr: $560639d49e3c9a19$var$Mscr,
    Mu: $560639d49e3c9a19$var$Mu$1,
    NJcy: $560639d49e3c9a19$var$NJcy,
    Nacute: $560639d49e3c9a19$var$Nacute,
    Ncaron: $560639d49e3c9a19$var$Ncaron,
    Ncedil: $560639d49e3c9a19$var$Ncedil,
    Ncy: $560639d49e3c9a19$var$Ncy,
    NegativeMediumSpace: $560639d49e3c9a19$var$NegativeMediumSpace,
    NegativeThickSpace: $560639d49e3c9a19$var$NegativeThickSpace,
    NegativeThinSpace: $560639d49e3c9a19$var$NegativeThinSpace,
    NegativeVeryThinSpace: $560639d49e3c9a19$var$NegativeVeryThinSpace,
    NestedGreaterGreater: $560639d49e3c9a19$var$NestedGreaterGreater,
    NestedLessLess: $560639d49e3c9a19$var$NestedLessLess,
    NewLine: $560639d49e3c9a19$var$NewLine,
    Nfr: $560639d49e3c9a19$var$Nfr,
    NoBreak: $560639d49e3c9a19$var$NoBreak,
    NonBreakingSpace: $560639d49e3c9a19$var$NonBreakingSpace,
    Nopf: $560639d49e3c9a19$var$Nopf,
    Not: $560639d49e3c9a19$var$Not,
    NotCongruent: $560639d49e3c9a19$var$NotCongruent,
    NotCupCap: $560639d49e3c9a19$var$NotCupCap,
    NotDoubleVerticalBar: $560639d49e3c9a19$var$NotDoubleVerticalBar,
    NotElement: $560639d49e3c9a19$var$NotElement,
    NotEqual: $560639d49e3c9a19$var$NotEqual,
    NotEqualTilde: $560639d49e3c9a19$var$NotEqualTilde,
    NotExists: $560639d49e3c9a19$var$NotExists,
    NotGreater: $560639d49e3c9a19$var$NotGreater,
    NotGreaterEqual: $560639d49e3c9a19$var$NotGreaterEqual,
    NotGreaterFullEqual: $560639d49e3c9a19$var$NotGreaterFullEqual,
    NotGreaterGreater: $560639d49e3c9a19$var$NotGreaterGreater,
    NotGreaterLess: $560639d49e3c9a19$var$NotGreaterLess,
    NotGreaterSlantEqual: $560639d49e3c9a19$var$NotGreaterSlantEqual,
    NotGreaterTilde: $560639d49e3c9a19$var$NotGreaterTilde,
    NotHumpDownHump: $560639d49e3c9a19$var$NotHumpDownHump,
    NotHumpEqual: $560639d49e3c9a19$var$NotHumpEqual,
    NotLeftTriangle: $560639d49e3c9a19$var$NotLeftTriangle,
    NotLeftTriangleBar: $560639d49e3c9a19$var$NotLeftTriangleBar,
    NotLeftTriangleEqual: $560639d49e3c9a19$var$NotLeftTriangleEqual,
    NotLess: $560639d49e3c9a19$var$NotLess,
    NotLessEqual: $560639d49e3c9a19$var$NotLessEqual,
    NotLessGreater: $560639d49e3c9a19$var$NotLessGreater,
    NotLessLess: $560639d49e3c9a19$var$NotLessLess,
    NotLessSlantEqual: $560639d49e3c9a19$var$NotLessSlantEqual,
    NotLessTilde: $560639d49e3c9a19$var$NotLessTilde,
    NotNestedGreaterGreater: $560639d49e3c9a19$var$NotNestedGreaterGreater,
    NotNestedLessLess: $560639d49e3c9a19$var$NotNestedLessLess,
    NotPrecedes: $560639d49e3c9a19$var$NotPrecedes,
    NotPrecedesEqual: $560639d49e3c9a19$var$NotPrecedesEqual,
    NotPrecedesSlantEqual: $560639d49e3c9a19$var$NotPrecedesSlantEqual,
    NotReverseElement: $560639d49e3c9a19$var$NotReverseElement,
    NotRightTriangle: $560639d49e3c9a19$var$NotRightTriangle,
    NotRightTriangleBar: $560639d49e3c9a19$var$NotRightTriangleBar,
    NotRightTriangleEqual: $560639d49e3c9a19$var$NotRightTriangleEqual,
    NotSquareSubset: $560639d49e3c9a19$var$NotSquareSubset,
    NotSquareSubsetEqual: $560639d49e3c9a19$var$NotSquareSubsetEqual,
    NotSquareSuperset: $560639d49e3c9a19$var$NotSquareSuperset,
    NotSquareSupersetEqual: $560639d49e3c9a19$var$NotSquareSupersetEqual,
    NotSubset: $560639d49e3c9a19$var$NotSubset,
    NotSubsetEqual: $560639d49e3c9a19$var$NotSubsetEqual,
    NotSucceeds: $560639d49e3c9a19$var$NotSucceeds,
    NotSucceedsEqual: $560639d49e3c9a19$var$NotSucceedsEqual,
    NotSucceedsSlantEqual: $560639d49e3c9a19$var$NotSucceedsSlantEqual,
    NotSucceedsTilde: $560639d49e3c9a19$var$NotSucceedsTilde,
    NotSuperset: $560639d49e3c9a19$var$NotSuperset,
    NotSupersetEqual: $560639d49e3c9a19$var$NotSupersetEqual,
    NotTilde: $560639d49e3c9a19$var$NotTilde,
    NotTildeEqual: $560639d49e3c9a19$var$NotTildeEqual,
    NotTildeFullEqual: $560639d49e3c9a19$var$NotTildeFullEqual,
    NotTildeTilde: $560639d49e3c9a19$var$NotTildeTilde,
    NotVerticalBar: $560639d49e3c9a19$var$NotVerticalBar,
    Nscr: $560639d49e3c9a19$var$Nscr,
    Ntild: $560639d49e3c9a19$var$Ntild,
    Ntilde: $560639d49e3c9a19$var$Ntilde$1,
    Nu: $560639d49e3c9a19$var$Nu$1,
    OElig: $560639d49e3c9a19$var$OElig$1,
    Oacut: $560639d49e3c9a19$var$Oacut,
    Oacute: $560639d49e3c9a19$var$Oacute$1,
    Ocir: $560639d49e3c9a19$var$Ocir,
    Ocirc: $560639d49e3c9a19$var$Ocirc$1,
    Ocy: $560639d49e3c9a19$var$Ocy,
    Odblac: $560639d49e3c9a19$var$Odblac,
    Ofr: $560639d49e3c9a19$var$Ofr,
    Ograv: $560639d49e3c9a19$var$Ograv,
    Ograve: $560639d49e3c9a19$var$Ograve$1,
    Omacr: $560639d49e3c9a19$var$Omacr,
    Omega: $560639d49e3c9a19$var$Omega$1,
    Omicron: $560639d49e3c9a19$var$Omicron$1,
    Oopf: $560639d49e3c9a19$var$Oopf,
    OpenCurlyDoubleQuote: $560639d49e3c9a19$var$OpenCurlyDoubleQuote,
    OpenCurlyQuote: $560639d49e3c9a19$var$OpenCurlyQuote,
    Or: $560639d49e3c9a19$var$Or,
    Oscr: $560639d49e3c9a19$var$Oscr,
    Oslas: $560639d49e3c9a19$var$Oslas,
    Oslash: $560639d49e3c9a19$var$Oslash$1,
    Otild: $560639d49e3c9a19$var$Otild,
    Otilde: $560639d49e3c9a19$var$Otilde$1,
    Otimes: $560639d49e3c9a19$var$Otimes,
    Oum: $560639d49e3c9a19$var$Oum,
    Ouml: $560639d49e3c9a19$var$Ouml$1,
    OverBar: $560639d49e3c9a19$var$OverBar,
    OverBrace: $560639d49e3c9a19$var$OverBrace,
    OverBracket: $560639d49e3c9a19$var$OverBracket,
    OverParenthesis: $560639d49e3c9a19$var$OverParenthesis,
    PartialD: $560639d49e3c9a19$var$PartialD,
    Pcy: $560639d49e3c9a19$var$Pcy,
    Pfr: $560639d49e3c9a19$var$Pfr,
    Phi: $560639d49e3c9a19$var$Phi$1,
    Pi: $560639d49e3c9a19$var$Pi$1,
    PlusMinus: $560639d49e3c9a19$var$PlusMinus,
    Poincareplane: $560639d49e3c9a19$var$Poincareplane,
    Popf: $560639d49e3c9a19$var$Popf,
    Pr: $560639d49e3c9a19$var$Pr,
    Precedes: $560639d49e3c9a19$var$Precedes,
    PrecedesEqual: $560639d49e3c9a19$var$PrecedesEqual,
    PrecedesSlantEqual: $560639d49e3c9a19$var$PrecedesSlantEqual,
    PrecedesTilde: $560639d49e3c9a19$var$PrecedesTilde,
    Prime: $560639d49e3c9a19$var$Prime$1,
    Product: $560639d49e3c9a19$var$Product,
    Proportion: $560639d49e3c9a19$var$Proportion,
    Proportional: $560639d49e3c9a19$var$Proportional,
    Pscr: $560639d49e3c9a19$var$Pscr,
    Psi: $560639d49e3c9a19$var$Psi$1,
    QUO: $560639d49e3c9a19$var$QUO,
    QUOT: $560639d49e3c9a19$var$QUOT,
    Qfr: $560639d49e3c9a19$var$Qfr,
    Qopf: $560639d49e3c9a19$var$Qopf,
    Qscr: $560639d49e3c9a19$var$Qscr,
    RBarr: $560639d49e3c9a19$var$RBarr,
    RE: $560639d49e3c9a19$var$RE,
    REG: $560639d49e3c9a19$var$REG,
    Racute: $560639d49e3c9a19$var$Racute,
    Rang: $560639d49e3c9a19$var$Rang,
    Rarr: $560639d49e3c9a19$var$Rarr,
    Rarrtl: $560639d49e3c9a19$var$Rarrtl,
    Rcaron: $560639d49e3c9a19$var$Rcaron,
    Rcedil: $560639d49e3c9a19$var$Rcedil,
    Rcy: $560639d49e3c9a19$var$Rcy,
    Re: $560639d49e3c9a19$var$Re,
    ReverseElement: $560639d49e3c9a19$var$ReverseElement,
    ReverseEquilibrium: $560639d49e3c9a19$var$ReverseEquilibrium,
    ReverseUpEquilibrium: $560639d49e3c9a19$var$ReverseUpEquilibrium,
    Rfr: $560639d49e3c9a19$var$Rfr,
    Rho: $560639d49e3c9a19$var$Rho$1,
    RightAngleBracket: $560639d49e3c9a19$var$RightAngleBracket,
    RightArrow: $560639d49e3c9a19$var$RightArrow,
    RightArrowBar: $560639d49e3c9a19$var$RightArrowBar,
    RightArrowLeftArrow: $560639d49e3c9a19$var$RightArrowLeftArrow,
    RightCeiling: $560639d49e3c9a19$var$RightCeiling,
    RightDoubleBracket: $560639d49e3c9a19$var$RightDoubleBracket,
    RightDownTeeVector: $560639d49e3c9a19$var$RightDownTeeVector,
    RightDownVector: $560639d49e3c9a19$var$RightDownVector,
    RightDownVectorBar: $560639d49e3c9a19$var$RightDownVectorBar,
    RightFloor: $560639d49e3c9a19$var$RightFloor,
    RightTee: $560639d49e3c9a19$var$RightTee,
    RightTeeArrow: $560639d49e3c9a19$var$RightTeeArrow,
    RightTeeVector: $560639d49e3c9a19$var$RightTeeVector,
    RightTriangle: $560639d49e3c9a19$var$RightTriangle,
    RightTriangleBar: $560639d49e3c9a19$var$RightTriangleBar,
    RightTriangleEqual: $560639d49e3c9a19$var$RightTriangleEqual,
    RightUpDownVector: $560639d49e3c9a19$var$RightUpDownVector,
    RightUpTeeVector: $560639d49e3c9a19$var$RightUpTeeVector,
    RightUpVector: $560639d49e3c9a19$var$RightUpVector,
    RightUpVectorBar: $560639d49e3c9a19$var$RightUpVectorBar,
    RightVector: $560639d49e3c9a19$var$RightVector,
    RightVectorBar: $560639d49e3c9a19$var$RightVectorBar,
    Rightarrow: $560639d49e3c9a19$var$Rightarrow,
    Ropf: $560639d49e3c9a19$var$Ropf,
    RoundImplies: $560639d49e3c9a19$var$RoundImplies,
    Rrightarrow: $560639d49e3c9a19$var$Rrightarrow,
    Rscr: $560639d49e3c9a19$var$Rscr,
    Rsh: $560639d49e3c9a19$var$Rsh,
    RuleDelayed: $560639d49e3c9a19$var$RuleDelayed,
    SHCHcy: $560639d49e3c9a19$var$SHCHcy,
    SHcy: $560639d49e3c9a19$var$SHcy,
    SOFTcy: $560639d49e3c9a19$var$SOFTcy,
    Sacute: $560639d49e3c9a19$var$Sacute,
    Sc: $560639d49e3c9a19$var$Sc,
    Scaron: $560639d49e3c9a19$var$Scaron$1,
    Scedil: $560639d49e3c9a19$var$Scedil,
    Scirc: $560639d49e3c9a19$var$Scirc,
    Scy: $560639d49e3c9a19$var$Scy,
    Sfr: $560639d49e3c9a19$var$Sfr,
    ShortDownArrow: $560639d49e3c9a19$var$ShortDownArrow,
    ShortLeftArrow: $560639d49e3c9a19$var$ShortLeftArrow,
    ShortRightArrow: $560639d49e3c9a19$var$ShortRightArrow,
    ShortUpArrow: $560639d49e3c9a19$var$ShortUpArrow,
    Sigma: $560639d49e3c9a19$var$Sigma$1,
    SmallCircle: $560639d49e3c9a19$var$SmallCircle,
    Sopf: $560639d49e3c9a19$var$Sopf,
    Sqrt: $560639d49e3c9a19$var$Sqrt,
    Square: $560639d49e3c9a19$var$Square,
    SquareIntersection: $560639d49e3c9a19$var$SquareIntersection,
    SquareSubset: $560639d49e3c9a19$var$SquareSubset,
    SquareSubsetEqual: $560639d49e3c9a19$var$SquareSubsetEqual,
    SquareSuperset: $560639d49e3c9a19$var$SquareSuperset,
    SquareSupersetEqual: $560639d49e3c9a19$var$SquareSupersetEqual,
    SquareUnion: $560639d49e3c9a19$var$SquareUnion,
    Sscr: $560639d49e3c9a19$var$Sscr,
    Star: $560639d49e3c9a19$var$Star,
    Sub: $560639d49e3c9a19$var$Sub,
    Subset: $560639d49e3c9a19$var$Subset,
    SubsetEqual: $560639d49e3c9a19$var$SubsetEqual,
    Succeeds: $560639d49e3c9a19$var$Succeeds,
    SucceedsEqual: $560639d49e3c9a19$var$SucceedsEqual,
    SucceedsSlantEqual: $560639d49e3c9a19$var$SucceedsSlantEqual,
    SucceedsTilde: $560639d49e3c9a19$var$SucceedsTilde,
    SuchThat: $560639d49e3c9a19$var$SuchThat,
    Sum: $560639d49e3c9a19$var$Sum,
    Sup: $560639d49e3c9a19$var$Sup,
    Superset: $560639d49e3c9a19$var$Superset,
    SupersetEqual: $560639d49e3c9a19$var$SupersetEqual,
    Supset: $560639d49e3c9a19$var$Supset,
    THOR: $560639d49e3c9a19$var$THOR,
    THORN: $560639d49e3c9a19$var$THORN$1,
    TRADE: $560639d49e3c9a19$var$TRADE,
    TSHcy: $560639d49e3c9a19$var$TSHcy,
    TScy: $560639d49e3c9a19$var$TScy,
    Tab: $560639d49e3c9a19$var$Tab,
    Tau: $560639d49e3c9a19$var$Tau$1,
    Tcaron: $560639d49e3c9a19$var$Tcaron,
    Tcedil: $560639d49e3c9a19$var$Tcedil,
    Tcy: $560639d49e3c9a19$var$Tcy,
    Tfr: $560639d49e3c9a19$var$Tfr,
    Therefore: $560639d49e3c9a19$var$Therefore,
    Theta: $560639d49e3c9a19$var$Theta$1,
    ThickSpace: $560639d49e3c9a19$var$ThickSpace,
    ThinSpace: $560639d49e3c9a19$var$ThinSpace,
    Tilde: $560639d49e3c9a19$var$Tilde,
    TildeEqual: $560639d49e3c9a19$var$TildeEqual,
    TildeFullEqual: $560639d49e3c9a19$var$TildeFullEqual,
    TildeTilde: $560639d49e3c9a19$var$TildeTilde,
    Topf: $560639d49e3c9a19$var$Topf,
    TripleDot: $560639d49e3c9a19$var$TripleDot,
    Tscr: $560639d49e3c9a19$var$Tscr,
    Tstrok: $560639d49e3c9a19$var$Tstrok,
    Uacut: $560639d49e3c9a19$var$Uacut,
    Uacute: $560639d49e3c9a19$var$Uacute$1,
    Uarr: $560639d49e3c9a19$var$Uarr,
    Uarrocir: $560639d49e3c9a19$var$Uarrocir,
    Ubrcy: $560639d49e3c9a19$var$Ubrcy,
    Ubreve: $560639d49e3c9a19$var$Ubreve,
    Ucir: $560639d49e3c9a19$var$Ucir,
    Ucirc: $560639d49e3c9a19$var$Ucirc$1,
    Ucy: $560639d49e3c9a19$var$Ucy,
    Udblac: $560639d49e3c9a19$var$Udblac,
    Ufr: $560639d49e3c9a19$var$Ufr,
    Ugrav: $560639d49e3c9a19$var$Ugrav,
    Ugrave: $560639d49e3c9a19$var$Ugrave$1,
    Umacr: $560639d49e3c9a19$var$Umacr,
    UnderBar: $560639d49e3c9a19$var$UnderBar,
    UnderBrace: $560639d49e3c9a19$var$UnderBrace,
    UnderBracket: $560639d49e3c9a19$var$UnderBracket,
    UnderParenthesis: $560639d49e3c9a19$var$UnderParenthesis,
    Union: $560639d49e3c9a19$var$Union,
    UnionPlus: $560639d49e3c9a19$var$UnionPlus,
    Uogon: $560639d49e3c9a19$var$Uogon,
    Uopf: $560639d49e3c9a19$var$Uopf,
    UpArrow: $560639d49e3c9a19$var$UpArrow,
    UpArrowBar: $560639d49e3c9a19$var$UpArrowBar,
    UpArrowDownArrow: $560639d49e3c9a19$var$UpArrowDownArrow,
    UpDownArrow: $560639d49e3c9a19$var$UpDownArrow,
    UpEquilibrium: $560639d49e3c9a19$var$UpEquilibrium,
    UpTee: $560639d49e3c9a19$var$UpTee,
    UpTeeArrow: $560639d49e3c9a19$var$UpTeeArrow,
    Uparrow: $560639d49e3c9a19$var$Uparrow,
    Updownarrow: $560639d49e3c9a19$var$Updownarrow,
    UpperLeftArrow: $560639d49e3c9a19$var$UpperLeftArrow,
    UpperRightArrow: $560639d49e3c9a19$var$UpperRightArrow,
    Upsi: $560639d49e3c9a19$var$Upsi,
    Upsilon: $560639d49e3c9a19$var$Upsilon$1,
    Uring: $560639d49e3c9a19$var$Uring,
    Uscr: $560639d49e3c9a19$var$Uscr,
    Utilde: $560639d49e3c9a19$var$Utilde,
    Uum: $560639d49e3c9a19$var$Uum,
    Uuml: $560639d49e3c9a19$var$Uuml$1,
    VDash: $560639d49e3c9a19$var$VDash,
    Vbar: $560639d49e3c9a19$var$Vbar,
    Vcy: $560639d49e3c9a19$var$Vcy,
    Vdash: $560639d49e3c9a19$var$Vdash,
    Vdashl: $560639d49e3c9a19$var$Vdashl,
    Vee: $560639d49e3c9a19$var$Vee,
    Verbar: $560639d49e3c9a19$var$Verbar,
    Vert: $560639d49e3c9a19$var$Vert,
    VerticalBar: $560639d49e3c9a19$var$VerticalBar,
    VerticalLine: $560639d49e3c9a19$var$VerticalLine,
    VerticalSeparator: $560639d49e3c9a19$var$VerticalSeparator,
    VerticalTilde: $560639d49e3c9a19$var$VerticalTilde,
    VeryThinSpace: $560639d49e3c9a19$var$VeryThinSpace,
    Vfr: $560639d49e3c9a19$var$Vfr,
    Vopf: $560639d49e3c9a19$var$Vopf,
    Vscr: $560639d49e3c9a19$var$Vscr,
    Vvdash: $560639d49e3c9a19$var$Vvdash,
    Wcirc: $560639d49e3c9a19$var$Wcirc,
    Wedge: $560639d49e3c9a19$var$Wedge,
    Wfr: $560639d49e3c9a19$var$Wfr,
    Wopf: $560639d49e3c9a19$var$Wopf,
    Wscr: $560639d49e3c9a19$var$Wscr,
    Xfr: $560639d49e3c9a19$var$Xfr,
    Xi: $560639d49e3c9a19$var$Xi$1,
    Xopf: $560639d49e3c9a19$var$Xopf,
    Xscr: $560639d49e3c9a19$var$Xscr,
    YAcy: $560639d49e3c9a19$var$YAcy,
    YIcy: $560639d49e3c9a19$var$YIcy,
    YUcy: $560639d49e3c9a19$var$YUcy,
    Yacut: $560639d49e3c9a19$var$Yacut,
    Yacute: $560639d49e3c9a19$var$Yacute$1,
    Ycirc: $560639d49e3c9a19$var$Ycirc,
    Ycy: $560639d49e3c9a19$var$Ycy,
    Yfr: $560639d49e3c9a19$var$Yfr,
    Yopf: $560639d49e3c9a19$var$Yopf,
    Yscr: $560639d49e3c9a19$var$Yscr,
    Yuml: $560639d49e3c9a19$var$Yuml$1,
    ZHcy: $560639d49e3c9a19$var$ZHcy,
    Zacute: $560639d49e3c9a19$var$Zacute,
    Zcaron: $560639d49e3c9a19$var$Zcaron,
    Zcy: $560639d49e3c9a19$var$Zcy,
    Zdot: $560639d49e3c9a19$var$Zdot,
    ZeroWidthSpace: $560639d49e3c9a19$var$ZeroWidthSpace,
    Zeta: $560639d49e3c9a19$var$Zeta$1,
    Zfr: $560639d49e3c9a19$var$Zfr,
    Zopf: $560639d49e3c9a19$var$Zopf,
    Zscr: $560639d49e3c9a19$var$Zscr,
    aacut: $560639d49e3c9a19$var$aacut,
    aacute: $560639d49e3c9a19$var$aacute$1,
    abreve: $560639d49e3c9a19$var$abreve,
    ac: $560639d49e3c9a19$var$ac,
    acE: $560639d49e3c9a19$var$acE,
    acd: $560639d49e3c9a19$var$acd,
    acir: $560639d49e3c9a19$var$acir,
    acirc: $560639d49e3c9a19$var$acirc$1,
    acut: $560639d49e3c9a19$var$acut,
    acute: $560639d49e3c9a19$var$acute$1,
    acy: $560639d49e3c9a19$var$acy,
    aeli: $560639d49e3c9a19$var$aeli,
    aelig: $560639d49e3c9a19$var$aelig$1,
    af: $560639d49e3c9a19$var$af,
    afr: $560639d49e3c9a19$var$afr,
    agrav: $560639d49e3c9a19$var$agrav,
    agrave: $560639d49e3c9a19$var$agrave$1,
    alefsym: $560639d49e3c9a19$var$alefsym$1,
    aleph: $560639d49e3c9a19$var$aleph,
    alpha: $560639d49e3c9a19$var$alpha$1,
    amacr: $560639d49e3c9a19$var$amacr,
    amalg: $560639d49e3c9a19$var$amalg,
    am: $560639d49e3c9a19$var$am,
    amp: $560639d49e3c9a19$var$amp$1,
    and: $560639d49e3c9a19$var$and$1,
    andand: $560639d49e3c9a19$var$andand,
    andd: $560639d49e3c9a19$var$andd,
    andslope: $560639d49e3c9a19$var$andslope,
    andv: $560639d49e3c9a19$var$andv,
    ang: $560639d49e3c9a19$var$ang$1,
    ange: $560639d49e3c9a19$var$ange,
    angle: $560639d49e3c9a19$var$angle,
    angmsd: $560639d49e3c9a19$var$angmsd,
    angmsdaa: $560639d49e3c9a19$var$angmsdaa,
    angmsdab: $560639d49e3c9a19$var$angmsdab,
    angmsdac: $560639d49e3c9a19$var$angmsdac,
    angmsdad: $560639d49e3c9a19$var$angmsdad,
    angmsdae: $560639d49e3c9a19$var$angmsdae,
    angmsdaf: $560639d49e3c9a19$var$angmsdaf,
    angmsdag: $560639d49e3c9a19$var$angmsdag,
    angmsdah: $560639d49e3c9a19$var$angmsdah,
    angrt: $560639d49e3c9a19$var$angrt,
    angrtvb: $560639d49e3c9a19$var$angrtvb,
    angrtvbd: $560639d49e3c9a19$var$angrtvbd,
    angsph: $560639d49e3c9a19$var$angsph,
    angst: $560639d49e3c9a19$var$angst,
    angzarr: $560639d49e3c9a19$var$angzarr,
    aogon: $560639d49e3c9a19$var$aogon,
    aopf: $560639d49e3c9a19$var$aopf,
    ap: $560639d49e3c9a19$var$ap,
    apE: $560639d49e3c9a19$var$apE,
    apacir: $560639d49e3c9a19$var$apacir,
    ape: $560639d49e3c9a19$var$ape,
    apid: $560639d49e3c9a19$var$apid,
    apos: $560639d49e3c9a19$var$apos,
    approx: $560639d49e3c9a19$var$approx,
    approxeq: $560639d49e3c9a19$var$approxeq,
    arin: $560639d49e3c9a19$var$arin,
    aring: $560639d49e3c9a19$var$aring$1,
    ascr: $560639d49e3c9a19$var$ascr,
    ast: $560639d49e3c9a19$var$ast,
    asymp: $560639d49e3c9a19$var$asymp$1,
    asympeq: $560639d49e3c9a19$var$asympeq,
    atild: $560639d49e3c9a19$var$atild,
    atilde: $560639d49e3c9a19$var$atilde$1,
    aum: $560639d49e3c9a19$var$aum,
    auml: $560639d49e3c9a19$var$auml$1,
    awconint: $560639d49e3c9a19$var$awconint,
    awint: $560639d49e3c9a19$var$awint,
    bNot: $560639d49e3c9a19$var$bNot,
    backcong: $560639d49e3c9a19$var$backcong,
    backepsilon: $560639d49e3c9a19$var$backepsilon,
    backprime: $560639d49e3c9a19$var$backprime,
    backsim: $560639d49e3c9a19$var$backsim,
    backsimeq: $560639d49e3c9a19$var$backsimeq,
    barvee: $560639d49e3c9a19$var$barvee,
    barwed: $560639d49e3c9a19$var$barwed,
    barwedge: $560639d49e3c9a19$var$barwedge,
    bbrk: $560639d49e3c9a19$var$bbrk,
    bbrktbrk: $560639d49e3c9a19$var$bbrktbrk,
    bcong: $560639d49e3c9a19$var$bcong,
    bcy: $560639d49e3c9a19$var$bcy,
    bdquo: $560639d49e3c9a19$var$bdquo$1,
    becaus: $560639d49e3c9a19$var$becaus,
    because: $560639d49e3c9a19$var$because,
    bemptyv: $560639d49e3c9a19$var$bemptyv,
    bepsi: $560639d49e3c9a19$var$bepsi,
    bernou: $560639d49e3c9a19$var$bernou,
    beta: $560639d49e3c9a19$var$beta$1,
    beth: $560639d49e3c9a19$var$beth,
    between: $560639d49e3c9a19$var$between,
    bfr: $560639d49e3c9a19$var$bfr,
    bigcap: $560639d49e3c9a19$var$bigcap,
    bigcirc: $560639d49e3c9a19$var$bigcirc,
    bigcup: $560639d49e3c9a19$var$bigcup,
    bigodot: $560639d49e3c9a19$var$bigodot,
    bigoplus: $560639d49e3c9a19$var$bigoplus,
    bigotimes: $560639d49e3c9a19$var$bigotimes,
    bigsqcup: $560639d49e3c9a19$var$bigsqcup,
    bigstar: $560639d49e3c9a19$var$bigstar,
    bigtriangledown: $560639d49e3c9a19$var$bigtriangledown,
    bigtriangleup: $560639d49e3c9a19$var$bigtriangleup,
    biguplus: $560639d49e3c9a19$var$biguplus,
    bigvee: $560639d49e3c9a19$var$bigvee,
    bigwedge: $560639d49e3c9a19$var$bigwedge,
    bkarow: $560639d49e3c9a19$var$bkarow,
    blacklozenge: $560639d49e3c9a19$var$blacklozenge,
    blacksquare: $560639d49e3c9a19$var$blacksquare,
    blacktriangle: $560639d49e3c9a19$var$blacktriangle,
    blacktriangledown: $560639d49e3c9a19$var$blacktriangledown,
    blacktriangleleft: $560639d49e3c9a19$var$blacktriangleleft,
    blacktriangleright: $560639d49e3c9a19$var$blacktriangleright,
    blank: $560639d49e3c9a19$var$blank,
    blk12: $560639d49e3c9a19$var$blk12,
    blk14: $560639d49e3c9a19$var$blk14,
    blk34: $560639d49e3c9a19$var$blk34,
    block: $560639d49e3c9a19$var$block,
    bne: $560639d49e3c9a19$var$bne,
    bnequiv: $560639d49e3c9a19$var$bnequiv,
    bnot: $560639d49e3c9a19$var$bnot,
    bopf: $560639d49e3c9a19$var$bopf,
    bot: $560639d49e3c9a19$var$bot,
    bottom: $560639d49e3c9a19$var$bottom,
    bowtie: $560639d49e3c9a19$var$bowtie,
    boxDL: $560639d49e3c9a19$var$boxDL,
    boxDR: $560639d49e3c9a19$var$boxDR,
    boxDl: $560639d49e3c9a19$var$boxDl,
    boxDr: $560639d49e3c9a19$var$boxDr,
    boxH: $560639d49e3c9a19$var$boxH,
    boxHD: $560639d49e3c9a19$var$boxHD,
    boxHU: $560639d49e3c9a19$var$boxHU,
    boxHd: $560639d49e3c9a19$var$boxHd,
    boxHu: $560639d49e3c9a19$var$boxHu,
    boxUL: $560639d49e3c9a19$var$boxUL,
    boxUR: $560639d49e3c9a19$var$boxUR,
    boxUl: $560639d49e3c9a19$var$boxUl,
    boxUr: $560639d49e3c9a19$var$boxUr,
    boxV: $560639d49e3c9a19$var$boxV,
    boxVH: $560639d49e3c9a19$var$boxVH,
    boxVL: $560639d49e3c9a19$var$boxVL,
    boxVR: $560639d49e3c9a19$var$boxVR,
    boxVh: $560639d49e3c9a19$var$boxVh,
    boxVl: $560639d49e3c9a19$var$boxVl,
    boxVr: $560639d49e3c9a19$var$boxVr,
    boxbox: $560639d49e3c9a19$var$boxbox,
    boxdL: $560639d49e3c9a19$var$boxdL,
    boxdR: $560639d49e3c9a19$var$boxdR,
    boxdl: $560639d49e3c9a19$var$boxdl,
    boxdr: $560639d49e3c9a19$var$boxdr,
    boxh: $560639d49e3c9a19$var$boxh,
    boxhD: $560639d49e3c9a19$var$boxhD,
    boxhU: $560639d49e3c9a19$var$boxhU,
    boxhd: $560639d49e3c9a19$var$boxhd,
    boxhu: $560639d49e3c9a19$var$boxhu,
    boxminus: $560639d49e3c9a19$var$boxminus,
    boxplus: $560639d49e3c9a19$var$boxplus,
    boxtimes: $560639d49e3c9a19$var$boxtimes,
    boxuL: $560639d49e3c9a19$var$boxuL,
    boxuR: $560639d49e3c9a19$var$boxuR,
    boxul: $560639d49e3c9a19$var$boxul,
    boxur: $560639d49e3c9a19$var$boxur,
    boxv: $560639d49e3c9a19$var$boxv,
    boxvH: $560639d49e3c9a19$var$boxvH,
    boxvL: $560639d49e3c9a19$var$boxvL,
    boxvR: $560639d49e3c9a19$var$boxvR,
    boxvh: $560639d49e3c9a19$var$boxvh,
    boxvl: $560639d49e3c9a19$var$boxvl,
    boxvr: $560639d49e3c9a19$var$boxvr,
    bprime: $560639d49e3c9a19$var$bprime,
    breve: $560639d49e3c9a19$var$breve,
    brvba: $560639d49e3c9a19$var$brvba,
    brvbar: $560639d49e3c9a19$var$brvbar$1,
    bscr: $560639d49e3c9a19$var$bscr,
    bsemi: $560639d49e3c9a19$var$bsemi,
    bsim: $560639d49e3c9a19$var$bsim,
    bsime: $560639d49e3c9a19$var$bsime,
    bsol: $560639d49e3c9a19$var$bsol,
    bsolb: $560639d49e3c9a19$var$bsolb,
    bsolhsub: $560639d49e3c9a19$var$bsolhsub,
    bull: $560639d49e3c9a19$var$bull$1,
    bullet: $560639d49e3c9a19$var$bullet,
    bump: $560639d49e3c9a19$var$bump,
    bumpE: $560639d49e3c9a19$var$bumpE,
    bumpe: $560639d49e3c9a19$var$bumpe,
    bumpeq: $560639d49e3c9a19$var$bumpeq,
    cacute: $560639d49e3c9a19$var$cacute,
    cap: $560639d49e3c9a19$var$cap$2,
    capand: $560639d49e3c9a19$var$capand,
    capbrcup: $560639d49e3c9a19$var$capbrcup,
    capcap: $560639d49e3c9a19$var$capcap,
    capcup: $560639d49e3c9a19$var$capcup,
    capdot: $560639d49e3c9a19$var$capdot,
    caps: $560639d49e3c9a19$var$caps,
    caret: $560639d49e3c9a19$var$caret,
    caron: $560639d49e3c9a19$var$caron,
    ccaps: $560639d49e3c9a19$var$ccaps,
    ccaron: $560639d49e3c9a19$var$ccaron,
    ccedi: $560639d49e3c9a19$var$ccedi,
    ccedil: $560639d49e3c9a19$var$ccedil$1,
    ccirc: $560639d49e3c9a19$var$ccirc,
    ccups: $560639d49e3c9a19$var$ccups,
    ccupssm: $560639d49e3c9a19$var$ccupssm,
    cdot: $560639d49e3c9a19$var$cdot,
    cedi: $560639d49e3c9a19$var$cedi,
    cedil: $560639d49e3c9a19$var$cedil$1,
    cemptyv: $560639d49e3c9a19$var$cemptyv,
    cen: $560639d49e3c9a19$var$cen,
    cent: $560639d49e3c9a19$var$cent$1,
    centerdot: $560639d49e3c9a19$var$centerdot,
    cfr: $560639d49e3c9a19$var$cfr,
    chcy: $560639d49e3c9a19$var$chcy,
    check: $560639d49e3c9a19$var$check,
    checkmark: $560639d49e3c9a19$var$checkmark,
    chi: $560639d49e3c9a19$var$chi$1,
    cir: $560639d49e3c9a19$var$cir,
    cirE: $560639d49e3c9a19$var$cirE,
    circ: $560639d49e3c9a19$var$circ$1,
    circeq: $560639d49e3c9a19$var$circeq,
    circlearrowleft: $560639d49e3c9a19$var$circlearrowleft,
    circlearrowright: $560639d49e3c9a19$var$circlearrowright,
    circledR: $560639d49e3c9a19$var$circledR,
    circledS: $560639d49e3c9a19$var$circledS,
    circledast: $560639d49e3c9a19$var$circledast,
    circledcirc: $560639d49e3c9a19$var$circledcirc,
    circleddash: $560639d49e3c9a19$var$circleddash,
    cire: $560639d49e3c9a19$var$cire,
    cirfnint: $560639d49e3c9a19$var$cirfnint,
    cirmid: $560639d49e3c9a19$var$cirmid,
    cirscir: $560639d49e3c9a19$var$cirscir,
    clubs: $560639d49e3c9a19$var$clubs$1,
    clubsuit: $560639d49e3c9a19$var$clubsuit,
    colon: $560639d49e3c9a19$var$colon$3,
    colone: $560639d49e3c9a19$var$colone,
    coloneq: $560639d49e3c9a19$var$coloneq,
    comma: $560639d49e3c9a19$var$comma$2,
    commat: $560639d49e3c9a19$var$commat,
    comp: $560639d49e3c9a19$var$comp,
    compfn: $560639d49e3c9a19$var$compfn,
    complement: $560639d49e3c9a19$var$complement,
    complexes: $560639d49e3c9a19$var$complexes,
    cong: $560639d49e3c9a19$var$cong$1,
    congdot: $560639d49e3c9a19$var$congdot,
    conint: $560639d49e3c9a19$var$conint,
    copf: $560639d49e3c9a19$var$copf,
    coprod: $560639d49e3c9a19$var$coprod,
    cop: $560639d49e3c9a19$var$cop,
    copy: $560639d49e3c9a19$var$copy$1,
    copysr: $560639d49e3c9a19$var$copysr,
    crarr: $560639d49e3c9a19$var$crarr$1,
    cross: $560639d49e3c9a19$var$cross,
    cscr: $560639d49e3c9a19$var$cscr,
    csub: $560639d49e3c9a19$var$csub,
    csube: $560639d49e3c9a19$var$csube,
    csup: $560639d49e3c9a19$var$csup,
    csupe: $560639d49e3c9a19$var$csupe,
    ctdot: $560639d49e3c9a19$var$ctdot,
    cudarrl: $560639d49e3c9a19$var$cudarrl,
    cudarrr: $560639d49e3c9a19$var$cudarrr,
    cuepr: $560639d49e3c9a19$var$cuepr,
    cuesc: $560639d49e3c9a19$var$cuesc,
    cularr: $560639d49e3c9a19$var$cularr,
    cularrp: $560639d49e3c9a19$var$cularrp,
    cup: $560639d49e3c9a19$var$cup$1,
    cupbrcap: $560639d49e3c9a19$var$cupbrcap,
    cupcap: $560639d49e3c9a19$var$cupcap,
    cupcup: $560639d49e3c9a19$var$cupcup,
    cupdot: $560639d49e3c9a19$var$cupdot,
    cupor: $560639d49e3c9a19$var$cupor,
    cups: $560639d49e3c9a19$var$cups,
    curarr: $560639d49e3c9a19$var$curarr,
    curarrm: $560639d49e3c9a19$var$curarrm,
    curlyeqprec: $560639d49e3c9a19$var$curlyeqprec,
    curlyeqsucc: $560639d49e3c9a19$var$curlyeqsucc,
    curlyvee: $560639d49e3c9a19$var$curlyvee,
    curlywedge: $560639d49e3c9a19$var$curlywedge,
    curre: $560639d49e3c9a19$var$curre,
    curren: $560639d49e3c9a19$var$curren$1,
    curvearrowleft: $560639d49e3c9a19$var$curvearrowleft,
    curvearrowright: $560639d49e3c9a19$var$curvearrowright,
    cuvee: $560639d49e3c9a19$var$cuvee,
    cuwed: $560639d49e3c9a19$var$cuwed,
    cwconint: $560639d49e3c9a19$var$cwconint,
    cwint: $560639d49e3c9a19$var$cwint,
    cylcty: $560639d49e3c9a19$var$cylcty,
    dArr: $560639d49e3c9a19$var$dArr$1,
    dHar: $560639d49e3c9a19$var$dHar,
    dagger: $560639d49e3c9a19$var$dagger$1,
    daleth: $560639d49e3c9a19$var$daleth,
    darr: $560639d49e3c9a19$var$darr$1,
    dash: $560639d49e3c9a19$var$dash$8,
    dashv: $560639d49e3c9a19$var$dashv,
    dbkarow: $560639d49e3c9a19$var$dbkarow,
    dblac: $560639d49e3c9a19$var$dblac,
    dcaron: $560639d49e3c9a19$var$dcaron,
    dcy: $560639d49e3c9a19$var$dcy,
    dd: $560639d49e3c9a19$var$dd$1,
    ddagger: $560639d49e3c9a19$var$ddagger,
    ddarr: $560639d49e3c9a19$var$ddarr,
    ddotseq: $560639d49e3c9a19$var$ddotseq,
    de: $560639d49e3c9a19$var$de,
    deg: $560639d49e3c9a19$var$deg$1,
    delta: $560639d49e3c9a19$var$delta$1,
    demptyv: $560639d49e3c9a19$var$demptyv,
    dfisht: $560639d49e3c9a19$var$dfisht,
    dfr: $560639d49e3c9a19$var$dfr,
    dharl: $560639d49e3c9a19$var$dharl,
    dharr: $560639d49e3c9a19$var$dharr,
    diam: $560639d49e3c9a19$var$diam,
    diamond: $560639d49e3c9a19$var$diamond,
    diamondsuit: $560639d49e3c9a19$var$diamondsuit,
    diams: $560639d49e3c9a19$var$diams$1,
    die: $560639d49e3c9a19$var$die,
    digamma: $560639d49e3c9a19$var$digamma,
    disin: $560639d49e3c9a19$var$disin,
    div: $560639d49e3c9a19$var$div,
    divid: $560639d49e3c9a19$var$divid,
    divide: $560639d49e3c9a19$var$divide$1,
    divideontimes: $560639d49e3c9a19$var$divideontimes,
    divonx: $560639d49e3c9a19$var$divonx,
    djcy: $560639d49e3c9a19$var$djcy,
    dlcorn: $560639d49e3c9a19$var$dlcorn,
    dlcrop: $560639d49e3c9a19$var$dlcrop,
    dollar: $560639d49e3c9a19$var$dollar,
    dopf: $560639d49e3c9a19$var$dopf,
    dot: $560639d49e3c9a19$var$dot$4,
    doteq: $560639d49e3c9a19$var$doteq,
    doteqdot: $560639d49e3c9a19$var$doteqdot,
    dotminus: $560639d49e3c9a19$var$dotminus,
    dotplus: $560639d49e3c9a19$var$dotplus,
    dotsquare: $560639d49e3c9a19$var$dotsquare,
    doublebarwedge: $560639d49e3c9a19$var$doublebarwedge,
    downarrow: $560639d49e3c9a19$var$downarrow,
    downdownarrows: $560639d49e3c9a19$var$downdownarrows,
    downharpoonleft: $560639d49e3c9a19$var$downharpoonleft,
    downharpoonright: $560639d49e3c9a19$var$downharpoonright,
    drbkarow: $560639d49e3c9a19$var$drbkarow,
    drcorn: $560639d49e3c9a19$var$drcorn,
    drcrop: $560639d49e3c9a19$var$drcrop,
    dscr: $560639d49e3c9a19$var$dscr,
    dscy: $560639d49e3c9a19$var$dscy,
    dsol: $560639d49e3c9a19$var$dsol,
    dstrok: $560639d49e3c9a19$var$dstrok,
    dtdot: $560639d49e3c9a19$var$dtdot,
    dtri: $560639d49e3c9a19$var$dtri,
    dtrif: $560639d49e3c9a19$var$dtrif,
    duarr: $560639d49e3c9a19$var$duarr,
    duhar: $560639d49e3c9a19$var$duhar,
    dwangle: $560639d49e3c9a19$var$dwangle,
    dzcy: $560639d49e3c9a19$var$dzcy,
    dzigrarr: $560639d49e3c9a19$var$dzigrarr,
    eDDot: $560639d49e3c9a19$var$eDDot,
    eDot: $560639d49e3c9a19$var$eDot,
    eacut: $560639d49e3c9a19$var$eacut,
    eacute: $560639d49e3c9a19$var$eacute$1,
    easter: $560639d49e3c9a19$var$easter,
    ecaron: $560639d49e3c9a19$var$ecaron,
    ecir: $560639d49e3c9a19$var$ecir,
    ecirc: $560639d49e3c9a19$var$ecirc$1,
    ecolon: $560639d49e3c9a19$var$ecolon,
    ecy: $560639d49e3c9a19$var$ecy,
    edot: $560639d49e3c9a19$var$edot,
    ee: $560639d49e3c9a19$var$ee,
    efDot: $560639d49e3c9a19$var$efDot,
    efr: $560639d49e3c9a19$var$efr,
    eg: $560639d49e3c9a19$var$eg,
    egrav: $560639d49e3c9a19$var$egrav,
    egrave: $560639d49e3c9a19$var$egrave$1,
    egs: $560639d49e3c9a19$var$egs,
    egsdot: $560639d49e3c9a19$var$egsdot,
    el: $560639d49e3c9a19$var$el,
    elinters: $560639d49e3c9a19$var$elinters,
    ell: $560639d49e3c9a19$var$ell,
    els: $560639d49e3c9a19$var$els,
    elsdot: $560639d49e3c9a19$var$elsdot,
    emacr: $560639d49e3c9a19$var$emacr,
    empty: $560639d49e3c9a19$var$empty$3,
    emptyset: $560639d49e3c9a19$var$emptyset,
    emptyv: $560639d49e3c9a19$var$emptyv,
    emsp13: $560639d49e3c9a19$var$emsp13,
    emsp14: $560639d49e3c9a19$var$emsp14,
    emsp: $560639d49e3c9a19$var$emsp$1,
    eng: $560639d49e3c9a19$var$eng,
    ensp: $560639d49e3c9a19$var$ensp$1,
    eogon: $560639d49e3c9a19$var$eogon,
    eopf: $560639d49e3c9a19$var$eopf,
    epar: $560639d49e3c9a19$var$epar,
    eparsl: $560639d49e3c9a19$var$eparsl,
    eplus: $560639d49e3c9a19$var$eplus,
    epsi: $560639d49e3c9a19$var$epsi,
    epsilon: $560639d49e3c9a19$var$epsilon$1,
    epsiv: $560639d49e3c9a19$var$epsiv,
    eqcirc: $560639d49e3c9a19$var$eqcirc,
    eqcolon: $560639d49e3c9a19$var$eqcolon,
    eqsim: $560639d49e3c9a19$var$eqsim,
    eqslantgtr: $560639d49e3c9a19$var$eqslantgtr,
    eqslantless: $560639d49e3c9a19$var$eqslantless,
    equals: $560639d49e3c9a19$var$equals,
    equest: $560639d49e3c9a19$var$equest,
    equiv: $560639d49e3c9a19$var$equiv$1,
    equivDD: $560639d49e3c9a19$var$equivDD,
    eqvparsl: $560639d49e3c9a19$var$eqvparsl,
    erDot: $560639d49e3c9a19$var$erDot,
    erarr: $560639d49e3c9a19$var$erarr,
    escr: $560639d49e3c9a19$var$escr,
    esdot: $560639d49e3c9a19$var$esdot,
    esim: $560639d49e3c9a19$var$esim,
    eta: $560639d49e3c9a19$var$eta$1,
    et: $560639d49e3c9a19$var$et,
    eth: $560639d49e3c9a19$var$eth$1,
    eum: $560639d49e3c9a19$var$eum,
    euml: $560639d49e3c9a19$var$euml$1,
    euro: $560639d49e3c9a19$var$euro$1,
    excl: $560639d49e3c9a19$var$excl,
    exist: $560639d49e3c9a19$var$exist$1,
    expectation: $560639d49e3c9a19$var$expectation,
    exponentiale: $560639d49e3c9a19$var$exponentiale,
    fallingdotseq: $560639d49e3c9a19$var$fallingdotseq,
    fcy: $560639d49e3c9a19$var$fcy,
    female: $560639d49e3c9a19$var$female,
    ffilig: $560639d49e3c9a19$var$ffilig,
    fflig: $560639d49e3c9a19$var$fflig,
    ffllig: $560639d49e3c9a19$var$ffllig,
    ffr: $560639d49e3c9a19$var$ffr,
    filig: $560639d49e3c9a19$var$filig,
    fjlig: $560639d49e3c9a19$var$fjlig,
    flat: $560639d49e3c9a19$var$flat,
    fllig: $560639d49e3c9a19$var$fllig,
    fltns: $560639d49e3c9a19$var$fltns,
    fnof: $560639d49e3c9a19$var$fnof$1,
    fopf: $560639d49e3c9a19$var$fopf,
    forall: $560639d49e3c9a19$var$forall$1,
    fork: $560639d49e3c9a19$var$fork,
    forkv: $560639d49e3c9a19$var$forkv,
    fpartint: $560639d49e3c9a19$var$fpartint,
    frac1: $560639d49e3c9a19$var$frac1,
    frac12: $560639d49e3c9a19$var$frac12$1,
    frac13: $560639d49e3c9a19$var$frac13,
    frac14: $560639d49e3c9a19$var$frac14$1,
    frac15: $560639d49e3c9a19$var$frac15,
    frac16: $560639d49e3c9a19$var$frac16,
    frac18: $560639d49e3c9a19$var$frac18,
    frac23: $560639d49e3c9a19$var$frac23,
    frac25: $560639d49e3c9a19$var$frac25,
    frac3: $560639d49e3c9a19$var$frac3,
    frac34: $560639d49e3c9a19$var$frac34$1,
    frac35: $560639d49e3c9a19$var$frac35,
    frac38: $560639d49e3c9a19$var$frac38,
    frac45: $560639d49e3c9a19$var$frac45,
    frac56: $560639d49e3c9a19$var$frac56,
    frac58: $560639d49e3c9a19$var$frac58,
    frac78: $560639d49e3c9a19$var$frac78,
    frasl: $560639d49e3c9a19$var$frasl$1,
    frown: $560639d49e3c9a19$var$frown,
    fscr: $560639d49e3c9a19$var$fscr,
    gE: $560639d49e3c9a19$var$gE,
    gEl: $560639d49e3c9a19$var$gEl,
    gacute: $560639d49e3c9a19$var$gacute,
    gamma: $560639d49e3c9a19$var$gamma$1,
    gammad: $560639d49e3c9a19$var$gammad,
    gap: $560639d49e3c9a19$var$gap,
    gbreve: $560639d49e3c9a19$var$gbreve,
    gcirc: $560639d49e3c9a19$var$gcirc,
    gcy: $560639d49e3c9a19$var$gcy,
    gdot: $560639d49e3c9a19$var$gdot,
    ge: $560639d49e3c9a19$var$ge$1,
    gel: $560639d49e3c9a19$var$gel,
    geq: $560639d49e3c9a19$var$geq,
    geqq: $560639d49e3c9a19$var$geqq,
    geqslant: $560639d49e3c9a19$var$geqslant,
    ges: $560639d49e3c9a19$var$ges,
    gescc: $560639d49e3c9a19$var$gescc,
    gesdot: $560639d49e3c9a19$var$gesdot,
    gesdoto: $560639d49e3c9a19$var$gesdoto,
    gesdotol: $560639d49e3c9a19$var$gesdotol,
    gesl: $560639d49e3c9a19$var$gesl,
    gesles: $560639d49e3c9a19$var$gesles,
    gfr: $560639d49e3c9a19$var$gfr,
    gg: $560639d49e3c9a19$var$gg,
    ggg: $560639d49e3c9a19$var$ggg,
    gimel: $560639d49e3c9a19$var$gimel,
    gjcy: $560639d49e3c9a19$var$gjcy,
    gl: $560639d49e3c9a19$var$gl,
    glE: $560639d49e3c9a19$var$glE,
    gla: $560639d49e3c9a19$var$gla,
    glj: $560639d49e3c9a19$var$glj,
    gnE: $560639d49e3c9a19$var$gnE,
    gnap: $560639d49e3c9a19$var$gnap,
    gnapprox: $560639d49e3c9a19$var$gnapprox,
    gne: $560639d49e3c9a19$var$gne,
    gneq: $560639d49e3c9a19$var$gneq,
    gneqq: $560639d49e3c9a19$var$gneqq,
    gnsim: $560639d49e3c9a19$var$gnsim,
    gopf: $560639d49e3c9a19$var$gopf,
    grave: $560639d49e3c9a19$var$grave,
    gscr: $560639d49e3c9a19$var$gscr,
    gsim: $560639d49e3c9a19$var$gsim,
    gsime: $560639d49e3c9a19$var$gsime,
    gsiml: $560639d49e3c9a19$var$gsiml,
    g: $560639d49e3c9a19$var$g,
    gt: $560639d49e3c9a19$var$gt$1,
    gtcc: $560639d49e3c9a19$var$gtcc,
    gtcir: $560639d49e3c9a19$var$gtcir,
    gtdot: $560639d49e3c9a19$var$gtdot,
    gtlPar: $560639d49e3c9a19$var$gtlPar,
    gtquest: $560639d49e3c9a19$var$gtquest,
    gtrapprox: $560639d49e3c9a19$var$gtrapprox,
    gtrarr: $560639d49e3c9a19$var$gtrarr,
    gtrdot: $560639d49e3c9a19$var$gtrdot,
    gtreqless: $560639d49e3c9a19$var$gtreqless,
    gtreqqless: $560639d49e3c9a19$var$gtreqqless,
    gtrless: $560639d49e3c9a19$var$gtrless,
    gtrsim: $560639d49e3c9a19$var$gtrsim,
    gvertneqq: $560639d49e3c9a19$var$gvertneqq,
    gvnE: $560639d49e3c9a19$var$gvnE,
    hArr: $560639d49e3c9a19$var$hArr$1,
    hairsp: $560639d49e3c9a19$var$hairsp,
    half: $560639d49e3c9a19$var$half,
    hamilt: $560639d49e3c9a19$var$hamilt,
    hardcy: $560639d49e3c9a19$var$hardcy,
    harr: $560639d49e3c9a19$var$harr$1,
    harrcir: $560639d49e3c9a19$var$harrcir,
    harrw: $560639d49e3c9a19$var$harrw,
    hbar: $560639d49e3c9a19$var$hbar,
    hcirc: $560639d49e3c9a19$var$hcirc,
    hearts: $560639d49e3c9a19$var$hearts$1,
    heartsuit: $560639d49e3c9a19$var$heartsuit,
    hellip: $560639d49e3c9a19$var$hellip$1,
    hercon: $560639d49e3c9a19$var$hercon,
    hfr: $560639d49e3c9a19$var$hfr,
    hksearow: $560639d49e3c9a19$var$hksearow,
    hkswarow: $560639d49e3c9a19$var$hkswarow,
    hoarr: $560639d49e3c9a19$var$hoarr,
    homtht: $560639d49e3c9a19$var$homtht,
    hookleftarrow: $560639d49e3c9a19$var$hookleftarrow,
    hookrightarrow: $560639d49e3c9a19$var$hookrightarrow,
    hopf: $560639d49e3c9a19$var$hopf,
    horbar: $560639d49e3c9a19$var$horbar,
    hscr: $560639d49e3c9a19$var$hscr,
    hslash: $560639d49e3c9a19$var$hslash,
    hstrok: $560639d49e3c9a19$var$hstrok,
    hybull: $560639d49e3c9a19$var$hybull,
    hyphen: $560639d49e3c9a19$var$hyphen,
    iacut: $560639d49e3c9a19$var$iacut,
    iacute: $560639d49e3c9a19$var$iacute$1,
    ic: $560639d49e3c9a19$var$ic,
    icir: $560639d49e3c9a19$var$icir,
    icirc: $560639d49e3c9a19$var$icirc$1,
    icy: $560639d49e3c9a19$var$icy,
    iecy: $560639d49e3c9a19$var$iecy,
    iexc: $560639d49e3c9a19$var$iexc,
    iexcl: $560639d49e3c9a19$var$iexcl$1,
    iff: $560639d49e3c9a19$var$iff,
    ifr: $560639d49e3c9a19$var$ifr,
    igrav: $560639d49e3c9a19$var$igrav,
    igrave: $560639d49e3c9a19$var$igrave$1,
    ii: $560639d49e3c9a19$var$ii,
    iiiint: $560639d49e3c9a19$var$iiiint,
    iiint: $560639d49e3c9a19$var$iiint,
    iinfin: $560639d49e3c9a19$var$iinfin,
    iiota: $560639d49e3c9a19$var$iiota,
    ijlig: $560639d49e3c9a19$var$ijlig,
    imacr: $560639d49e3c9a19$var$imacr,
    image: $560639d49e3c9a19$var$image$3,
    imagline: $560639d49e3c9a19$var$imagline,
    imagpart: $560639d49e3c9a19$var$imagpart,
    imath: $560639d49e3c9a19$var$imath,
    imof: $560639d49e3c9a19$var$imof,
    imped: $560639d49e3c9a19$var$imped,
    "in": "\u2208",
    incare: $560639d49e3c9a19$var$incare,
    infin: $560639d49e3c9a19$var$infin$1,
    infintie: $560639d49e3c9a19$var$infintie,
    inodot: $560639d49e3c9a19$var$inodot,
    int: $560639d49e3c9a19$var$int$1,
    intcal: $560639d49e3c9a19$var$intcal,
    integers: $560639d49e3c9a19$var$integers,
    intercal: $560639d49e3c9a19$var$intercal,
    intlarhk: $560639d49e3c9a19$var$intlarhk,
    intprod: $560639d49e3c9a19$var$intprod,
    iocy: $560639d49e3c9a19$var$iocy,
    iogon: $560639d49e3c9a19$var$iogon,
    iopf: $560639d49e3c9a19$var$iopf,
    iota: $560639d49e3c9a19$var$iota$1,
    iprod: $560639d49e3c9a19$var$iprod,
    iques: $560639d49e3c9a19$var$iques,
    iquest: $560639d49e3c9a19$var$iquest$1,
    iscr: $560639d49e3c9a19$var$iscr,
    isin: $560639d49e3c9a19$var$isin$1,
    isinE: $560639d49e3c9a19$var$isinE,
    isindot: $560639d49e3c9a19$var$isindot,
    isins: $560639d49e3c9a19$var$isins,
    isinsv: $560639d49e3c9a19$var$isinsv,
    isinv: $560639d49e3c9a19$var$isinv,
    it: $560639d49e3c9a19$var$it,
    itilde: $560639d49e3c9a19$var$itilde,
    iukcy: $560639d49e3c9a19$var$iukcy,
    ium: $560639d49e3c9a19$var$ium,
    iuml: $560639d49e3c9a19$var$iuml$1,
    jcirc: $560639d49e3c9a19$var$jcirc,
    jcy: $560639d49e3c9a19$var$jcy,
    jfr: $560639d49e3c9a19$var$jfr,
    jmath: $560639d49e3c9a19$var$jmath,
    jopf: $560639d49e3c9a19$var$jopf,
    jscr: $560639d49e3c9a19$var$jscr,
    jsercy: $560639d49e3c9a19$var$jsercy,
    jukcy: $560639d49e3c9a19$var$jukcy,
    kappa: $560639d49e3c9a19$var$kappa$1,
    kappav: $560639d49e3c9a19$var$kappav,
    kcedil: $560639d49e3c9a19$var$kcedil,
    kcy: $560639d49e3c9a19$var$kcy,
    kfr: $560639d49e3c9a19$var$kfr,
    kgreen: $560639d49e3c9a19$var$kgreen,
    khcy: $560639d49e3c9a19$var$khcy,
    kjcy: $560639d49e3c9a19$var$kjcy,
    kopf: $560639d49e3c9a19$var$kopf,
    kscr: $560639d49e3c9a19$var$kscr,
    lAarr: $560639d49e3c9a19$var$lAarr,
    lArr: $560639d49e3c9a19$var$lArr$1,
    lAtail: $560639d49e3c9a19$var$lAtail,
    lBarr: $560639d49e3c9a19$var$lBarr,
    lE: $560639d49e3c9a19$var$lE,
    lEg: $560639d49e3c9a19$var$lEg,
    lHar: $560639d49e3c9a19$var$lHar,
    lacute: $560639d49e3c9a19$var$lacute,
    laemptyv: $560639d49e3c9a19$var$laemptyv,
    lagran: $560639d49e3c9a19$var$lagran,
    lambda: $560639d49e3c9a19$var$lambda$1,
    lang: $560639d49e3c9a19$var$lang$1,
    langd: $560639d49e3c9a19$var$langd,
    langle: $560639d49e3c9a19$var$langle,
    lap: $560639d49e3c9a19$var$lap,
    laqu: $560639d49e3c9a19$var$laqu,
    laquo: $560639d49e3c9a19$var$laquo$1,
    larr: $560639d49e3c9a19$var$larr$1,
    larrb: $560639d49e3c9a19$var$larrb,
    larrbfs: $560639d49e3c9a19$var$larrbfs,
    larrfs: $560639d49e3c9a19$var$larrfs,
    larrhk: $560639d49e3c9a19$var$larrhk,
    larrlp: $560639d49e3c9a19$var$larrlp,
    larrpl: $560639d49e3c9a19$var$larrpl,
    larrsim: $560639d49e3c9a19$var$larrsim,
    larrtl: $560639d49e3c9a19$var$larrtl,
    lat: $560639d49e3c9a19$var$lat,
    latail: $560639d49e3c9a19$var$latail,
    late: $560639d49e3c9a19$var$late,
    lates: $560639d49e3c9a19$var$lates,
    lbarr: $560639d49e3c9a19$var$lbarr,
    lbbrk: $560639d49e3c9a19$var$lbbrk,
    lbrace: $560639d49e3c9a19$var$lbrace,
    lbrack: $560639d49e3c9a19$var$lbrack,
    lbrke: $560639d49e3c9a19$var$lbrke,
    lbrksld: $560639d49e3c9a19$var$lbrksld,
    lbrkslu: $560639d49e3c9a19$var$lbrkslu,
    lcaron: $560639d49e3c9a19$var$lcaron,
    lcedil: $560639d49e3c9a19$var$lcedil,
    lceil: $560639d49e3c9a19$var$lceil$1,
    lcub: $560639d49e3c9a19$var$lcub,
    lcy: $560639d49e3c9a19$var$lcy,
    ldca: $560639d49e3c9a19$var$ldca,
    ldquo: $560639d49e3c9a19$var$ldquo$1,
    ldquor: $560639d49e3c9a19$var$ldquor,
    ldrdhar: $560639d49e3c9a19$var$ldrdhar,
    ldrushar: $560639d49e3c9a19$var$ldrushar,
    ldsh: $560639d49e3c9a19$var$ldsh,
    le: $560639d49e3c9a19$var$le$1,
    leftarrow: $560639d49e3c9a19$var$leftarrow,
    leftarrowtail: $560639d49e3c9a19$var$leftarrowtail,
    leftharpoondown: $560639d49e3c9a19$var$leftharpoondown,
    leftharpoonup: $560639d49e3c9a19$var$leftharpoonup,
    leftleftarrows: $560639d49e3c9a19$var$leftleftarrows,
    leftrightarrow: $560639d49e3c9a19$var$leftrightarrow,
    leftrightarrows: $560639d49e3c9a19$var$leftrightarrows,
    leftrightharpoons: $560639d49e3c9a19$var$leftrightharpoons,
    leftrightsquigarrow: $560639d49e3c9a19$var$leftrightsquigarrow,
    leftthreetimes: $560639d49e3c9a19$var$leftthreetimes,
    leg: $560639d49e3c9a19$var$leg,
    leq: $560639d49e3c9a19$var$leq,
    leqq: $560639d49e3c9a19$var$leqq,
    leqslant: $560639d49e3c9a19$var$leqslant,
    les: $560639d49e3c9a19$var$les,
    lescc: $560639d49e3c9a19$var$lescc,
    lesdot: $560639d49e3c9a19$var$lesdot,
    lesdoto: $560639d49e3c9a19$var$lesdoto,
    lesdotor: $560639d49e3c9a19$var$lesdotor,
    lesg: $560639d49e3c9a19$var$lesg,
    lesges: $560639d49e3c9a19$var$lesges,
    lessapprox: $560639d49e3c9a19$var$lessapprox,
    lessdot: $560639d49e3c9a19$var$lessdot,
    lesseqgtr: $560639d49e3c9a19$var$lesseqgtr,
    lesseqqgtr: $560639d49e3c9a19$var$lesseqqgtr,
    lessgtr: $560639d49e3c9a19$var$lessgtr,
    lesssim: $560639d49e3c9a19$var$lesssim,
    lfisht: $560639d49e3c9a19$var$lfisht,
    lfloor: $560639d49e3c9a19$var$lfloor$1,
    lfr: $560639d49e3c9a19$var$lfr,
    lg: $560639d49e3c9a19$var$lg,
    lgE: $560639d49e3c9a19$var$lgE,
    lhard: $560639d49e3c9a19$var$lhard,
    lharu: $560639d49e3c9a19$var$lharu,
    lharul: $560639d49e3c9a19$var$lharul,
    lhblk: $560639d49e3c9a19$var$lhblk,
    ljcy: $560639d49e3c9a19$var$ljcy,
    ll: $560639d49e3c9a19$var$ll,
    llarr: $560639d49e3c9a19$var$llarr,
    llcorner: $560639d49e3c9a19$var$llcorner,
    llhard: $560639d49e3c9a19$var$llhard,
    lltri: $560639d49e3c9a19$var$lltri,
    lmidot: $560639d49e3c9a19$var$lmidot,
    lmoust: $560639d49e3c9a19$var$lmoust,
    lmoustache: $560639d49e3c9a19$var$lmoustache,
    lnE: $560639d49e3c9a19$var$lnE,
    lnap: $560639d49e3c9a19$var$lnap,
    lnapprox: $560639d49e3c9a19$var$lnapprox,
    lne: $560639d49e3c9a19$var$lne,
    lneq: $560639d49e3c9a19$var$lneq,
    lneqq: $560639d49e3c9a19$var$lneqq,
    lnsim: $560639d49e3c9a19$var$lnsim,
    loang: $560639d49e3c9a19$var$loang,
    loarr: $560639d49e3c9a19$var$loarr,
    lobrk: $560639d49e3c9a19$var$lobrk,
    longleftarrow: $560639d49e3c9a19$var$longleftarrow,
    longleftrightarrow: $560639d49e3c9a19$var$longleftrightarrow,
    longmapsto: $560639d49e3c9a19$var$longmapsto,
    longrightarrow: $560639d49e3c9a19$var$longrightarrow,
    looparrowleft: $560639d49e3c9a19$var$looparrowleft,
    looparrowright: $560639d49e3c9a19$var$looparrowright,
    lopar: $560639d49e3c9a19$var$lopar,
    lopf: $560639d49e3c9a19$var$lopf,
    loplus: $560639d49e3c9a19$var$loplus,
    lotimes: $560639d49e3c9a19$var$lotimes,
    lowast: $560639d49e3c9a19$var$lowast$1,
    lowbar: $560639d49e3c9a19$var$lowbar,
    loz: $560639d49e3c9a19$var$loz$1,
    lozenge: $560639d49e3c9a19$var$lozenge,
    lozf: $560639d49e3c9a19$var$lozf,
    lpar: $560639d49e3c9a19$var$lpar,
    lparlt: $560639d49e3c9a19$var$lparlt,
    lrarr: $560639d49e3c9a19$var$lrarr,
    lrcorner: $560639d49e3c9a19$var$lrcorner,
    lrhar: $560639d49e3c9a19$var$lrhar,
    lrhard: $560639d49e3c9a19$var$lrhard,
    lrm: $560639d49e3c9a19$var$lrm$1,
    lrtri: $560639d49e3c9a19$var$lrtri,
    lsaquo: $560639d49e3c9a19$var$lsaquo$1,
    lscr: $560639d49e3c9a19$var$lscr,
    lsh: $560639d49e3c9a19$var$lsh,
    lsim: $560639d49e3c9a19$var$lsim,
    lsime: $560639d49e3c9a19$var$lsime,
    lsimg: $560639d49e3c9a19$var$lsimg,
    lsqb: $560639d49e3c9a19$var$lsqb,
    lsquo: $560639d49e3c9a19$var$lsquo$1,
    lsquor: $560639d49e3c9a19$var$lsquor,
    lstrok: $560639d49e3c9a19$var$lstrok,
    l: $560639d49e3c9a19$var$l,
    lt: $560639d49e3c9a19$var$lt$1,
    ltcc: $560639d49e3c9a19$var$ltcc,
    ltcir: $560639d49e3c9a19$var$ltcir,
    ltdot: $560639d49e3c9a19$var$ltdot,
    lthree: $560639d49e3c9a19$var$lthree,
    ltimes: $560639d49e3c9a19$var$ltimes,
    ltlarr: $560639d49e3c9a19$var$ltlarr,
    ltquest: $560639d49e3c9a19$var$ltquest,
    ltrPar: $560639d49e3c9a19$var$ltrPar,
    ltri: $560639d49e3c9a19$var$ltri,
    ltrie: $560639d49e3c9a19$var$ltrie,
    ltrif: $560639d49e3c9a19$var$ltrif,
    lurdshar: $560639d49e3c9a19$var$lurdshar,
    luruhar: $560639d49e3c9a19$var$luruhar,
    lvertneqq: $560639d49e3c9a19$var$lvertneqq,
    lvnE: $560639d49e3c9a19$var$lvnE,
    mDDot: $560639d49e3c9a19$var$mDDot,
    mac: $560639d49e3c9a19$var$mac,
    macr: $560639d49e3c9a19$var$macr$1,
    male: $560639d49e3c9a19$var$male,
    malt: $560639d49e3c9a19$var$malt,
    maltese: $560639d49e3c9a19$var$maltese,
    map: $560639d49e3c9a19$var$map$1,
    mapsto: $560639d49e3c9a19$var$mapsto,
    mapstodown: $560639d49e3c9a19$var$mapstodown,
    mapstoleft: $560639d49e3c9a19$var$mapstoleft,
    mapstoup: $560639d49e3c9a19$var$mapstoup,
    marker: $560639d49e3c9a19$var$marker,
    mcomma: $560639d49e3c9a19$var$mcomma,
    mcy: $560639d49e3c9a19$var$mcy,
    mdash: $560639d49e3c9a19$var$mdash$1,
    measuredangle: $560639d49e3c9a19$var$measuredangle,
    mfr: $560639d49e3c9a19$var$mfr,
    mho: $560639d49e3c9a19$var$mho,
    micr: $560639d49e3c9a19$var$micr,
    micro: $560639d49e3c9a19$var$micro$1,
    mid: $560639d49e3c9a19$var$mid,
    midast: $560639d49e3c9a19$var$midast,
    midcir: $560639d49e3c9a19$var$midcir,
    middo: $560639d49e3c9a19$var$middo,
    middot: $560639d49e3c9a19$var$middot$1,
    minus: $560639d49e3c9a19$var$minus$1,
    minusb: $560639d49e3c9a19$var$minusb,
    minusd: $560639d49e3c9a19$var$minusd,
    minusdu: $560639d49e3c9a19$var$minusdu,
    mlcp: $560639d49e3c9a19$var$mlcp,
    mldr: $560639d49e3c9a19$var$mldr,
    mnplus: $560639d49e3c9a19$var$mnplus,
    models: $560639d49e3c9a19$var$models,
    mopf: $560639d49e3c9a19$var$mopf,
    mp: $560639d49e3c9a19$var$mp,
    mscr: $560639d49e3c9a19$var$mscr,
    mstpos: $560639d49e3c9a19$var$mstpos,
    mu: $560639d49e3c9a19$var$mu$1,
    multimap: $560639d49e3c9a19$var$multimap,
    mumap: $560639d49e3c9a19$var$mumap,
    nGg: $560639d49e3c9a19$var$nGg,
    nGt: $560639d49e3c9a19$var$nGt,
    nGtv: $560639d49e3c9a19$var$nGtv,
    nLeftarrow: $560639d49e3c9a19$var$nLeftarrow,
    nLeftrightarrow: $560639d49e3c9a19$var$nLeftrightarrow,
    nLl: $560639d49e3c9a19$var$nLl,
    nLt: $560639d49e3c9a19$var$nLt,
    nLtv: $560639d49e3c9a19$var$nLtv,
    nRightarrow: $560639d49e3c9a19$var$nRightarrow,
    nVDash: $560639d49e3c9a19$var$nVDash,
    nVdash: $560639d49e3c9a19$var$nVdash,
    nabla: $560639d49e3c9a19$var$nabla$1,
    nacute: $560639d49e3c9a19$var$nacute,
    nang: $560639d49e3c9a19$var$nang,
    nap: $560639d49e3c9a19$var$nap,
    napE: $560639d49e3c9a19$var$napE,
    napid: $560639d49e3c9a19$var$napid,
    napos: $560639d49e3c9a19$var$napos,
    napprox: $560639d49e3c9a19$var$napprox,
    natur: $560639d49e3c9a19$var$natur,
    natural: $560639d49e3c9a19$var$natural,
    naturals: $560639d49e3c9a19$var$naturals,
    nbs: $560639d49e3c9a19$var$nbs,
    nbsp: $560639d49e3c9a19$var$nbsp$1,
    nbump: $560639d49e3c9a19$var$nbump,
    nbumpe: $560639d49e3c9a19$var$nbumpe,
    ncap: $560639d49e3c9a19$var$ncap,
    ncaron: $560639d49e3c9a19$var$ncaron,
    ncedil: $560639d49e3c9a19$var$ncedil,
    ncong: $560639d49e3c9a19$var$ncong,
    ncongdot: $560639d49e3c9a19$var$ncongdot,
    ncup: $560639d49e3c9a19$var$ncup,
    ncy: $560639d49e3c9a19$var$ncy,
    ndash: $560639d49e3c9a19$var$ndash$1,
    ne: $560639d49e3c9a19$var$ne$1,
    neArr: $560639d49e3c9a19$var$neArr,
    nearhk: $560639d49e3c9a19$var$nearhk,
    nearr: $560639d49e3c9a19$var$nearr,
    nearrow: $560639d49e3c9a19$var$nearrow,
    nedot: $560639d49e3c9a19$var$nedot,
    nequiv: $560639d49e3c9a19$var$nequiv,
    nesear: $560639d49e3c9a19$var$nesear,
    nesim: $560639d49e3c9a19$var$nesim,
    nexist: $560639d49e3c9a19$var$nexist,
    nexists: $560639d49e3c9a19$var$nexists,
    nfr: $560639d49e3c9a19$var$nfr,
    ngE: $560639d49e3c9a19$var$ngE,
    nge: $560639d49e3c9a19$var$nge,
    ngeq: $560639d49e3c9a19$var$ngeq,
    ngeqq: $560639d49e3c9a19$var$ngeqq,
    ngeqslant: $560639d49e3c9a19$var$ngeqslant,
    nges: $560639d49e3c9a19$var$nges,
    ngsim: $560639d49e3c9a19$var$ngsim,
    ngt: $560639d49e3c9a19$var$ngt,
    ngtr: $560639d49e3c9a19$var$ngtr,
    nhArr: $560639d49e3c9a19$var$nhArr,
    nharr: $560639d49e3c9a19$var$nharr,
    nhpar: $560639d49e3c9a19$var$nhpar,
    ni: $560639d49e3c9a19$var$ni$1,
    nis: $560639d49e3c9a19$var$nis,
    nisd: $560639d49e3c9a19$var$nisd,
    niv: $560639d49e3c9a19$var$niv,
    njcy: $560639d49e3c9a19$var$njcy,
    nlArr: $560639d49e3c9a19$var$nlArr,
    nlE: $560639d49e3c9a19$var$nlE,
    nlarr: $560639d49e3c9a19$var$nlarr,
    nldr: $560639d49e3c9a19$var$nldr,
    nle: $560639d49e3c9a19$var$nle,
    nleftarrow: $560639d49e3c9a19$var$nleftarrow,
    nleftrightarrow: $560639d49e3c9a19$var$nleftrightarrow,
    nleq: $560639d49e3c9a19$var$nleq,
    nleqq: $560639d49e3c9a19$var$nleqq,
    nleqslant: $560639d49e3c9a19$var$nleqslant,
    nles: $560639d49e3c9a19$var$nles,
    nless: $560639d49e3c9a19$var$nless,
    nlsim: $560639d49e3c9a19$var$nlsim,
    nlt: $560639d49e3c9a19$var$nlt,
    nltri: $560639d49e3c9a19$var$nltri,
    nltrie: $560639d49e3c9a19$var$nltrie,
    nmid: $560639d49e3c9a19$var$nmid,
    nopf: $560639d49e3c9a19$var$nopf,
    no: $560639d49e3c9a19$var$no,
    not: $560639d49e3c9a19$var$not$1,
    notin: $560639d49e3c9a19$var$notin$1,
    notinE: $560639d49e3c9a19$var$notinE,
    notindot: $560639d49e3c9a19$var$notindot,
    notinva: $560639d49e3c9a19$var$notinva,
    notinvb: $560639d49e3c9a19$var$notinvb,
    notinvc: $560639d49e3c9a19$var$notinvc,
    notni: $560639d49e3c9a19$var$notni,
    notniva: $560639d49e3c9a19$var$notniva,
    notnivb: $560639d49e3c9a19$var$notnivb,
    notnivc: $560639d49e3c9a19$var$notnivc,
    npar: $560639d49e3c9a19$var$npar,
    nparallel: $560639d49e3c9a19$var$nparallel,
    nparsl: $560639d49e3c9a19$var$nparsl,
    npart: $560639d49e3c9a19$var$npart,
    npolint: $560639d49e3c9a19$var$npolint,
    npr: $560639d49e3c9a19$var$npr,
    nprcue: $560639d49e3c9a19$var$nprcue,
    npre: $560639d49e3c9a19$var$npre,
    nprec: $560639d49e3c9a19$var$nprec,
    npreceq: $560639d49e3c9a19$var$npreceq,
    nrArr: $560639d49e3c9a19$var$nrArr,
    nrarr: $560639d49e3c9a19$var$nrarr,
    nrarrc: $560639d49e3c9a19$var$nrarrc,
    nrarrw: $560639d49e3c9a19$var$nrarrw,
    nrightarrow: $560639d49e3c9a19$var$nrightarrow,
    nrtri: $560639d49e3c9a19$var$nrtri,
    nrtrie: $560639d49e3c9a19$var$nrtrie,
    nsc: $560639d49e3c9a19$var$nsc,
    nsccue: $560639d49e3c9a19$var$nsccue,
    nsce: $560639d49e3c9a19$var$nsce,
    nscr: $560639d49e3c9a19$var$nscr,
    nshortmid: $560639d49e3c9a19$var$nshortmid,
    nshortparallel: $560639d49e3c9a19$var$nshortparallel,
    nsim: $560639d49e3c9a19$var$nsim,
    nsime: $560639d49e3c9a19$var$nsime,
    nsimeq: $560639d49e3c9a19$var$nsimeq,
    nsmid: $560639d49e3c9a19$var$nsmid,
    nspar: $560639d49e3c9a19$var$nspar,
    nsqsube: $560639d49e3c9a19$var$nsqsube,
    nsqsupe: $560639d49e3c9a19$var$nsqsupe,
    nsub: $560639d49e3c9a19$var$nsub$1,
    nsubE: $560639d49e3c9a19$var$nsubE,
    nsube: $560639d49e3c9a19$var$nsube,
    nsubset: $560639d49e3c9a19$var$nsubset,
    nsubseteq: $560639d49e3c9a19$var$nsubseteq,
    nsubseteqq: $560639d49e3c9a19$var$nsubseteqq,
    nsucc: $560639d49e3c9a19$var$nsucc,
    nsucceq: $560639d49e3c9a19$var$nsucceq,
    nsup: $560639d49e3c9a19$var$nsup,
    nsupE: $560639d49e3c9a19$var$nsupE,
    nsupe: $560639d49e3c9a19$var$nsupe,
    nsupset: $560639d49e3c9a19$var$nsupset,
    nsupseteq: $560639d49e3c9a19$var$nsupseteq,
    nsupseteqq: $560639d49e3c9a19$var$nsupseteqq,
    ntgl: $560639d49e3c9a19$var$ntgl,
    ntild: $560639d49e3c9a19$var$ntild,
    ntilde: $560639d49e3c9a19$var$ntilde$1,
    ntlg: $560639d49e3c9a19$var$ntlg,
    ntriangleleft: $560639d49e3c9a19$var$ntriangleleft,
    ntrianglelefteq: $560639d49e3c9a19$var$ntrianglelefteq,
    ntriangleright: $560639d49e3c9a19$var$ntriangleright,
    ntrianglerighteq: $560639d49e3c9a19$var$ntrianglerighteq,
    nu: $560639d49e3c9a19$var$nu$1,
    num: $560639d49e3c9a19$var$num,
    numero: $560639d49e3c9a19$var$numero,
    numsp: $560639d49e3c9a19$var$numsp,
    nvDash: $560639d49e3c9a19$var$nvDash,
    nvHarr: $560639d49e3c9a19$var$nvHarr,
    nvap: $560639d49e3c9a19$var$nvap,
    nvdash: $560639d49e3c9a19$var$nvdash,
    nvge: $560639d49e3c9a19$var$nvge,
    nvgt: $560639d49e3c9a19$var$nvgt,
    nvinfin: $560639d49e3c9a19$var$nvinfin,
    nvlArr: $560639d49e3c9a19$var$nvlArr,
    nvle: $560639d49e3c9a19$var$nvle,
    nvlt: $560639d49e3c9a19$var$nvlt,
    nvltrie: $560639d49e3c9a19$var$nvltrie,
    nvrArr: $560639d49e3c9a19$var$nvrArr,
    nvrtrie: $560639d49e3c9a19$var$nvrtrie,
    nvsim: $560639d49e3c9a19$var$nvsim,
    nwArr: $560639d49e3c9a19$var$nwArr,
    nwarhk: $560639d49e3c9a19$var$nwarhk,
    nwarr: $560639d49e3c9a19$var$nwarr,
    nwarrow: $560639d49e3c9a19$var$nwarrow,
    nwnear: $560639d49e3c9a19$var$nwnear,
    oS: $560639d49e3c9a19$var$oS,
    oacut: $560639d49e3c9a19$var$oacut,
    oacute: $560639d49e3c9a19$var$oacute$1,
    oast: $560639d49e3c9a19$var$oast,
    ocir: $560639d49e3c9a19$var$ocir,
    ocirc: $560639d49e3c9a19$var$ocirc$1,
    ocy: $560639d49e3c9a19$var$ocy,
    odash: $560639d49e3c9a19$var$odash,
    odblac: $560639d49e3c9a19$var$odblac,
    odiv: $560639d49e3c9a19$var$odiv,
    odot: $560639d49e3c9a19$var$odot,
    odsold: $560639d49e3c9a19$var$odsold,
    oelig: $560639d49e3c9a19$var$oelig$1,
    ofcir: $560639d49e3c9a19$var$ofcir,
    ofr: $560639d49e3c9a19$var$ofr,
    ogon: $560639d49e3c9a19$var$ogon,
    ograv: $560639d49e3c9a19$var$ograv,
    ograve: $560639d49e3c9a19$var$ograve$1,
    ogt: $560639d49e3c9a19$var$ogt,
    ohbar: $560639d49e3c9a19$var$ohbar,
    ohm: $560639d49e3c9a19$var$ohm,
    oint: $560639d49e3c9a19$var$oint,
    olarr: $560639d49e3c9a19$var$olarr,
    olcir: $560639d49e3c9a19$var$olcir,
    olcross: $560639d49e3c9a19$var$olcross,
    oline: $560639d49e3c9a19$var$oline$1,
    olt: $560639d49e3c9a19$var$olt,
    omacr: $560639d49e3c9a19$var$omacr,
    omega: $560639d49e3c9a19$var$omega$1,
    omicron: $560639d49e3c9a19$var$omicron$1,
    omid: $560639d49e3c9a19$var$omid,
    ominus: $560639d49e3c9a19$var$ominus,
    oopf: $560639d49e3c9a19$var$oopf,
    opar: $560639d49e3c9a19$var$opar,
    operp: $560639d49e3c9a19$var$operp,
    oplus: $560639d49e3c9a19$var$oplus$1,
    or: $560639d49e3c9a19$var$or$1,
    orarr: $560639d49e3c9a19$var$orarr,
    ord: $560639d49e3c9a19$var$ord,
    order: $560639d49e3c9a19$var$order,
    orderof: $560639d49e3c9a19$var$orderof,
    ordf: $560639d49e3c9a19$var$ordf$1,
    ordm: $560639d49e3c9a19$var$ordm$1,
    origof: $560639d49e3c9a19$var$origof,
    oror: $560639d49e3c9a19$var$oror,
    orslope: $560639d49e3c9a19$var$orslope,
    orv: $560639d49e3c9a19$var$orv,
    oscr: $560639d49e3c9a19$var$oscr,
    oslas: $560639d49e3c9a19$var$oslas,
    oslash: $560639d49e3c9a19$var$oslash$1,
    osol: $560639d49e3c9a19$var$osol,
    otild: $560639d49e3c9a19$var$otild,
    otilde: $560639d49e3c9a19$var$otilde$1,
    otimes: $560639d49e3c9a19$var$otimes$1,
    otimesas: $560639d49e3c9a19$var$otimesas,
    oum: $560639d49e3c9a19$var$oum,
    ouml: $560639d49e3c9a19$var$ouml$1,
    ovbar: $560639d49e3c9a19$var$ovbar,
    par: $560639d49e3c9a19$var$par,
    para: $560639d49e3c9a19$var$para$1,
    parallel: $560639d49e3c9a19$var$parallel,
    parsim: $560639d49e3c9a19$var$parsim,
    parsl: $560639d49e3c9a19$var$parsl,
    part: $560639d49e3c9a19$var$part$1,
    pcy: $560639d49e3c9a19$var$pcy,
    percnt: $560639d49e3c9a19$var$percnt,
    period: $560639d49e3c9a19$var$period,
    permil: $560639d49e3c9a19$var$permil$1,
    perp: $560639d49e3c9a19$var$perp$1,
    pertenk: $560639d49e3c9a19$var$pertenk,
    pfr: $560639d49e3c9a19$var$pfr,
    phi: $560639d49e3c9a19$var$phi$1,
    phiv: $560639d49e3c9a19$var$phiv,
    phmmat: $560639d49e3c9a19$var$phmmat,
    phone: $560639d49e3c9a19$var$phone,
    pi: $560639d49e3c9a19$var$pi$1,
    pitchfork: $560639d49e3c9a19$var$pitchfork,
    piv: $560639d49e3c9a19$var$piv$1,
    planck: $560639d49e3c9a19$var$planck,
    planckh: $560639d49e3c9a19$var$planckh,
    plankv: $560639d49e3c9a19$var$plankv,
    plus: $560639d49e3c9a19$var$plus,
    plusacir: $560639d49e3c9a19$var$plusacir,
    plusb: $560639d49e3c9a19$var$plusb,
    pluscir: $560639d49e3c9a19$var$pluscir,
    plusdo: $560639d49e3c9a19$var$plusdo,
    plusdu: $560639d49e3c9a19$var$plusdu,
    pluse: $560639d49e3c9a19$var$pluse,
    plusm: $560639d49e3c9a19$var$plusm,
    plusmn: $560639d49e3c9a19$var$plusmn$1,
    plussim: $560639d49e3c9a19$var$plussim,
    plustwo: $560639d49e3c9a19$var$plustwo,
    pm: $560639d49e3c9a19$var$pm,
    pointint: $560639d49e3c9a19$var$pointint,
    popf: $560639d49e3c9a19$var$popf,
    poun: $560639d49e3c9a19$var$poun,
    pound: $560639d49e3c9a19$var$pound$1,
    pr: $560639d49e3c9a19$var$pr,
    prE: $560639d49e3c9a19$var$prE,
    prap: $560639d49e3c9a19$var$prap,
    prcue: $560639d49e3c9a19$var$prcue,
    pre: $560639d49e3c9a19$var$pre,
    prec: $560639d49e3c9a19$var$prec,
    precapprox: $560639d49e3c9a19$var$precapprox,
    preccurlyeq: $560639d49e3c9a19$var$preccurlyeq,
    preceq: $560639d49e3c9a19$var$preceq,
    precnapprox: $560639d49e3c9a19$var$precnapprox,
    precneqq: $560639d49e3c9a19$var$precneqq,
    precnsim: $560639d49e3c9a19$var$precnsim,
    precsim: $560639d49e3c9a19$var$precsim,
    prime: $560639d49e3c9a19$var$prime$1,
    primes: $560639d49e3c9a19$var$primes,
    prnE: $560639d49e3c9a19$var$prnE,
    prnap: $560639d49e3c9a19$var$prnap,
    prnsim: $560639d49e3c9a19$var$prnsim,
    prod: $560639d49e3c9a19$var$prod$1,
    profalar: $560639d49e3c9a19$var$profalar,
    profline: $560639d49e3c9a19$var$profline,
    profsurf: $560639d49e3c9a19$var$profsurf,
    prop: $560639d49e3c9a19$var$prop$1,
    propto: $560639d49e3c9a19$var$propto,
    prsim: $560639d49e3c9a19$var$prsim,
    prurel: $560639d49e3c9a19$var$prurel,
    pscr: $560639d49e3c9a19$var$pscr,
    psi: $560639d49e3c9a19$var$psi$1,
    puncsp: $560639d49e3c9a19$var$puncsp,
    qfr: $560639d49e3c9a19$var$qfr,
    qint: $560639d49e3c9a19$var$qint,
    qopf: $560639d49e3c9a19$var$qopf,
    qprime: $560639d49e3c9a19$var$qprime,
    qscr: $560639d49e3c9a19$var$qscr,
    quaternions: $560639d49e3c9a19$var$quaternions,
    quatint: $560639d49e3c9a19$var$quatint,
    quest: $560639d49e3c9a19$var$quest,
    questeq: $560639d49e3c9a19$var$questeq,
    quo: $560639d49e3c9a19$var$quo,
    quot: $560639d49e3c9a19$var$quot$1,
    rAarr: $560639d49e3c9a19$var$rAarr,
    rArr: $560639d49e3c9a19$var$rArr$1,
    rAtail: $560639d49e3c9a19$var$rAtail,
    rBarr: $560639d49e3c9a19$var$rBarr,
    rHar: $560639d49e3c9a19$var$rHar,
    race: $560639d49e3c9a19$var$race,
    racute: $560639d49e3c9a19$var$racute,
    radic: $560639d49e3c9a19$var$radic$1,
    raemptyv: $560639d49e3c9a19$var$raemptyv,
    rang: $560639d49e3c9a19$var$rang$1,
    rangd: $560639d49e3c9a19$var$rangd,
    range: $560639d49e3c9a19$var$range,
    rangle: $560639d49e3c9a19$var$rangle,
    raqu: $560639d49e3c9a19$var$raqu,
    raquo: $560639d49e3c9a19$var$raquo$1,
    rarr: $560639d49e3c9a19$var$rarr$1,
    rarrap: $560639d49e3c9a19$var$rarrap,
    rarrb: $560639d49e3c9a19$var$rarrb,
    rarrbfs: $560639d49e3c9a19$var$rarrbfs,
    rarrc: $560639d49e3c9a19$var$rarrc,
    rarrfs: $560639d49e3c9a19$var$rarrfs,
    rarrhk: $560639d49e3c9a19$var$rarrhk,
    rarrlp: $560639d49e3c9a19$var$rarrlp,
    rarrpl: $560639d49e3c9a19$var$rarrpl,
    rarrsim: $560639d49e3c9a19$var$rarrsim,
    rarrtl: $560639d49e3c9a19$var$rarrtl,
    rarrw: $560639d49e3c9a19$var$rarrw,
    ratail: $560639d49e3c9a19$var$ratail,
    ratio: $560639d49e3c9a19$var$ratio,
    rationals: $560639d49e3c9a19$var$rationals,
    rbarr: $560639d49e3c9a19$var$rbarr,
    rbbrk: $560639d49e3c9a19$var$rbbrk,
    rbrace: $560639d49e3c9a19$var$rbrace,
    rbrack: $560639d49e3c9a19$var$rbrack,
    rbrke: $560639d49e3c9a19$var$rbrke,
    rbrksld: $560639d49e3c9a19$var$rbrksld,
    rbrkslu: $560639d49e3c9a19$var$rbrkslu,
    rcaron: $560639d49e3c9a19$var$rcaron,
    rcedil: $560639d49e3c9a19$var$rcedil,
    rceil: $560639d49e3c9a19$var$rceil$1,
    rcub: $560639d49e3c9a19$var$rcub,
    rcy: $560639d49e3c9a19$var$rcy,
    rdca: $560639d49e3c9a19$var$rdca,
    rdldhar: $560639d49e3c9a19$var$rdldhar,
    rdquo: $560639d49e3c9a19$var$rdquo$1,
    rdquor: $560639d49e3c9a19$var$rdquor,
    rdsh: $560639d49e3c9a19$var$rdsh,
    real: $560639d49e3c9a19$var$real$1,
    realine: $560639d49e3c9a19$var$realine,
    realpart: $560639d49e3c9a19$var$realpart,
    reals: $560639d49e3c9a19$var$reals,
    rect: $560639d49e3c9a19$var$rect,
    re: $560639d49e3c9a19$var$re$3,
    reg: $560639d49e3c9a19$var$reg$1,
    rfisht: $560639d49e3c9a19$var$rfisht,
    rfloor: $560639d49e3c9a19$var$rfloor$1,
    rfr: $560639d49e3c9a19$var$rfr,
    rhard: $560639d49e3c9a19$var$rhard,
    rharu: $560639d49e3c9a19$var$rharu,
    rharul: $560639d49e3c9a19$var$rharul,
    rho: $560639d49e3c9a19$var$rho$1,
    rhov: $560639d49e3c9a19$var$rhov,
    rightarrow: $560639d49e3c9a19$var$rightarrow,
    rightarrowtail: $560639d49e3c9a19$var$rightarrowtail,
    rightharpoondown: $560639d49e3c9a19$var$rightharpoondown,
    rightharpoonup: $560639d49e3c9a19$var$rightharpoonup,
    rightleftarrows: $560639d49e3c9a19$var$rightleftarrows,
    rightleftharpoons: $560639d49e3c9a19$var$rightleftharpoons,
    rightrightarrows: $560639d49e3c9a19$var$rightrightarrows,
    rightsquigarrow: $560639d49e3c9a19$var$rightsquigarrow,
    rightthreetimes: $560639d49e3c9a19$var$rightthreetimes,
    ring: $560639d49e3c9a19$var$ring,
    risingdotseq: $560639d49e3c9a19$var$risingdotseq,
    rlarr: $560639d49e3c9a19$var$rlarr,
    rlhar: $560639d49e3c9a19$var$rlhar,
    rlm: $560639d49e3c9a19$var$rlm$1,
    rmoust: $560639d49e3c9a19$var$rmoust,
    rmoustache: $560639d49e3c9a19$var$rmoustache,
    rnmid: $560639d49e3c9a19$var$rnmid,
    roang: $560639d49e3c9a19$var$roang,
    roarr: $560639d49e3c9a19$var$roarr,
    robrk: $560639d49e3c9a19$var$robrk,
    ropar: $560639d49e3c9a19$var$ropar,
    ropf: $560639d49e3c9a19$var$ropf,
    roplus: $560639d49e3c9a19$var$roplus,
    rotimes: $560639d49e3c9a19$var$rotimes,
    rpar: $560639d49e3c9a19$var$rpar,
    rpargt: $560639d49e3c9a19$var$rpargt,
    rppolint: $560639d49e3c9a19$var$rppolint,
    rrarr: $560639d49e3c9a19$var$rrarr,
    rsaquo: $560639d49e3c9a19$var$rsaquo$1,
    rscr: $560639d49e3c9a19$var$rscr,
    rsh: $560639d49e3c9a19$var$rsh,
    rsqb: $560639d49e3c9a19$var$rsqb,
    rsquo: $560639d49e3c9a19$var$rsquo$1,
    rsquor: $560639d49e3c9a19$var$rsquor,
    rthree: $560639d49e3c9a19$var$rthree,
    rtimes: $560639d49e3c9a19$var$rtimes,
    rtri: $560639d49e3c9a19$var$rtri,
    rtrie: $560639d49e3c9a19$var$rtrie,
    rtrif: $560639d49e3c9a19$var$rtrif,
    rtriltri: $560639d49e3c9a19$var$rtriltri,
    ruluhar: $560639d49e3c9a19$var$ruluhar,
    rx: $560639d49e3c9a19$var$rx,
    sacute: $560639d49e3c9a19$var$sacute,
    sbquo: $560639d49e3c9a19$var$sbquo$1,
    sc: $560639d49e3c9a19$var$sc,
    scE: $560639d49e3c9a19$var$scE,
    scap: $560639d49e3c9a19$var$scap,
    scaron: $560639d49e3c9a19$var$scaron$1,
    sccue: $560639d49e3c9a19$var$sccue,
    sce: $560639d49e3c9a19$var$sce,
    scedil: $560639d49e3c9a19$var$scedil,
    scirc: $560639d49e3c9a19$var$scirc,
    scnE: $560639d49e3c9a19$var$scnE,
    scnap: $560639d49e3c9a19$var$scnap,
    scnsim: $560639d49e3c9a19$var$scnsim,
    scpolint: $560639d49e3c9a19$var$scpolint,
    scsim: $560639d49e3c9a19$var$scsim,
    scy: $560639d49e3c9a19$var$scy,
    sdot: $560639d49e3c9a19$var$sdot$1,
    sdotb: $560639d49e3c9a19$var$sdotb,
    sdote: $560639d49e3c9a19$var$sdote,
    seArr: $560639d49e3c9a19$var$seArr,
    searhk: $560639d49e3c9a19$var$searhk,
    searr: $560639d49e3c9a19$var$searr,
    searrow: $560639d49e3c9a19$var$searrow,
    sec: $560639d49e3c9a19$var$sec,
    sect: $560639d49e3c9a19$var$sect$1,
    semi: $560639d49e3c9a19$var$semi,
    seswar: $560639d49e3c9a19$var$seswar,
    setminus: $560639d49e3c9a19$var$setminus,
    setmn: $560639d49e3c9a19$var$setmn,
    sext: $560639d49e3c9a19$var$sext,
    sfr: $560639d49e3c9a19$var$sfr,
    sfrown: $560639d49e3c9a19$var$sfrown,
    sharp: $560639d49e3c9a19$var$sharp,
    shchcy: $560639d49e3c9a19$var$shchcy,
    shcy: $560639d49e3c9a19$var$shcy,
    shortmid: $560639d49e3c9a19$var$shortmid,
    shortparallel: $560639d49e3c9a19$var$shortparallel,
    sh: $560639d49e3c9a19$var$sh,
    shy: $560639d49e3c9a19$var$shy$1,
    sigma: $560639d49e3c9a19$var$sigma$1,
    sigmaf: $560639d49e3c9a19$var$sigmaf$1,
    sigmav: $560639d49e3c9a19$var$sigmav,
    sim: $560639d49e3c9a19$var$sim$1,
    simdot: $560639d49e3c9a19$var$simdot,
    sime: $560639d49e3c9a19$var$sime,
    simeq: $560639d49e3c9a19$var$simeq,
    simg: $560639d49e3c9a19$var$simg,
    simgE: $560639d49e3c9a19$var$simgE,
    siml: $560639d49e3c9a19$var$siml,
    simlE: $560639d49e3c9a19$var$simlE,
    simne: $560639d49e3c9a19$var$simne,
    simplus: $560639d49e3c9a19$var$simplus,
    simrarr: $560639d49e3c9a19$var$simrarr,
    slarr: $560639d49e3c9a19$var$slarr,
    smallsetminus: $560639d49e3c9a19$var$smallsetminus,
    smashp: $560639d49e3c9a19$var$smashp,
    smeparsl: $560639d49e3c9a19$var$smeparsl,
    smid: $560639d49e3c9a19$var$smid,
    smile: $560639d49e3c9a19$var$smile,
    smt: $560639d49e3c9a19$var$smt,
    smte: $560639d49e3c9a19$var$smte,
    smtes: $560639d49e3c9a19$var$smtes,
    softcy: $560639d49e3c9a19$var$softcy,
    sol: $560639d49e3c9a19$var$sol,
    solb: $560639d49e3c9a19$var$solb,
    solbar: $560639d49e3c9a19$var$solbar,
    sopf: $560639d49e3c9a19$var$sopf,
    spades: $560639d49e3c9a19$var$spades$1,
    spadesuit: $560639d49e3c9a19$var$spadesuit,
    spar: $560639d49e3c9a19$var$spar,
    sqcap: $560639d49e3c9a19$var$sqcap,
    sqcaps: $560639d49e3c9a19$var$sqcaps,
    sqcup: $560639d49e3c9a19$var$sqcup,
    sqcups: $560639d49e3c9a19$var$sqcups,
    sqsub: $560639d49e3c9a19$var$sqsub,
    sqsube: $560639d49e3c9a19$var$sqsube,
    sqsubset: $560639d49e3c9a19$var$sqsubset,
    sqsubseteq: $560639d49e3c9a19$var$sqsubseteq,
    sqsup: $560639d49e3c9a19$var$sqsup,
    sqsupe: $560639d49e3c9a19$var$sqsupe,
    sqsupset: $560639d49e3c9a19$var$sqsupset,
    sqsupseteq: $560639d49e3c9a19$var$sqsupseteq,
    squ: $560639d49e3c9a19$var$squ,
    square: $560639d49e3c9a19$var$square,
    squarf: $560639d49e3c9a19$var$squarf,
    squf: $560639d49e3c9a19$var$squf,
    srarr: $560639d49e3c9a19$var$srarr,
    sscr: $560639d49e3c9a19$var$sscr,
    ssetmn: $560639d49e3c9a19$var$ssetmn,
    ssmile: $560639d49e3c9a19$var$ssmile,
    sstarf: $560639d49e3c9a19$var$sstarf,
    star: $560639d49e3c9a19$var$star,
    starf: $560639d49e3c9a19$var$starf,
    straightepsilon: $560639d49e3c9a19$var$straightepsilon,
    straightphi: $560639d49e3c9a19$var$straightphi,
    strns: $560639d49e3c9a19$var$strns,
    sub: $560639d49e3c9a19$var$sub$1,
    subE: $560639d49e3c9a19$var$subE,
    subdot: $560639d49e3c9a19$var$subdot,
    sube: $560639d49e3c9a19$var$sube$1,
    subedot: $560639d49e3c9a19$var$subedot,
    submult: $560639d49e3c9a19$var$submult,
    subnE: $560639d49e3c9a19$var$subnE,
    subne: $560639d49e3c9a19$var$subne,
    subplus: $560639d49e3c9a19$var$subplus,
    subrarr: $560639d49e3c9a19$var$subrarr,
    subset: $560639d49e3c9a19$var$subset,
    subseteq: $560639d49e3c9a19$var$subseteq,
    subseteqq: $560639d49e3c9a19$var$subseteqq,
    subsetneq: $560639d49e3c9a19$var$subsetneq,
    subsetneqq: $560639d49e3c9a19$var$subsetneqq,
    subsim: $560639d49e3c9a19$var$subsim,
    subsub: $560639d49e3c9a19$var$subsub,
    subsup: $560639d49e3c9a19$var$subsup,
    succ: $560639d49e3c9a19$var$succ,
    succapprox: $560639d49e3c9a19$var$succapprox,
    succcurlyeq: $560639d49e3c9a19$var$succcurlyeq,
    succeq: $560639d49e3c9a19$var$succeq,
    succnapprox: $560639d49e3c9a19$var$succnapprox,
    succneqq: $560639d49e3c9a19$var$succneqq,
    succnsim: $560639d49e3c9a19$var$succnsim,
    succsim: $560639d49e3c9a19$var$succsim,
    sum: $560639d49e3c9a19$var$sum$1,
    sung: $560639d49e3c9a19$var$sung,
    sup: $560639d49e3c9a19$var$sup$1,
    sup1: $560639d49e3c9a19$var$sup1$1,
    sup2: $560639d49e3c9a19$var$sup2$1,
    sup3: $560639d49e3c9a19$var$sup3$1,
    supE: $560639d49e3c9a19$var$supE,
    supdot: $560639d49e3c9a19$var$supdot,
    supdsub: $560639d49e3c9a19$var$supdsub,
    supe: $560639d49e3c9a19$var$supe$1,
    supedot: $560639d49e3c9a19$var$supedot,
    suphsol: $560639d49e3c9a19$var$suphsol,
    suphsub: $560639d49e3c9a19$var$suphsub,
    suplarr: $560639d49e3c9a19$var$suplarr,
    supmult: $560639d49e3c9a19$var$supmult,
    supnE: $560639d49e3c9a19$var$supnE,
    supne: $560639d49e3c9a19$var$supne,
    supplus: $560639d49e3c9a19$var$supplus,
    supset: $560639d49e3c9a19$var$supset,
    supseteq: $560639d49e3c9a19$var$supseteq,
    supseteqq: $560639d49e3c9a19$var$supseteqq,
    supsetneq: $560639d49e3c9a19$var$supsetneq,
    supsetneqq: $560639d49e3c9a19$var$supsetneqq,
    supsim: $560639d49e3c9a19$var$supsim,
    supsub: $560639d49e3c9a19$var$supsub,
    supsup: $560639d49e3c9a19$var$supsup,
    swArr: $560639d49e3c9a19$var$swArr,
    swarhk: $560639d49e3c9a19$var$swarhk,
    swarr: $560639d49e3c9a19$var$swarr,
    swarrow: $560639d49e3c9a19$var$swarrow,
    swnwar: $560639d49e3c9a19$var$swnwar,
    szli: $560639d49e3c9a19$var$szli,
    szlig: $560639d49e3c9a19$var$szlig$1,
    target: $560639d49e3c9a19$var$target,
    tau: $560639d49e3c9a19$var$tau$1,
    tbrk: $560639d49e3c9a19$var$tbrk,
    tcaron: $560639d49e3c9a19$var$tcaron,
    tcedil: $560639d49e3c9a19$var$tcedil,
    tcy: $560639d49e3c9a19$var$tcy,
    tdot: $560639d49e3c9a19$var$tdot,
    telrec: $560639d49e3c9a19$var$telrec,
    tfr: $560639d49e3c9a19$var$tfr,
    there4: $560639d49e3c9a19$var$there4$1,
    therefore: $560639d49e3c9a19$var$therefore,
    theta: $560639d49e3c9a19$var$theta$1,
    thetasym: $560639d49e3c9a19$var$thetasym$1,
    thetav: $560639d49e3c9a19$var$thetav,
    thickapprox: $560639d49e3c9a19$var$thickapprox,
    thicksim: $560639d49e3c9a19$var$thicksim,
    thinsp: $560639d49e3c9a19$var$thinsp$1,
    thkap: $560639d49e3c9a19$var$thkap,
    thksim: $560639d49e3c9a19$var$thksim,
    thor: $560639d49e3c9a19$var$thor,
    thorn: $560639d49e3c9a19$var$thorn$1,
    tilde: $560639d49e3c9a19$var$tilde$4,
    time: $560639d49e3c9a19$var$time,
    times: $560639d49e3c9a19$var$times$1,
    timesb: $560639d49e3c9a19$var$timesb,
    timesbar: $560639d49e3c9a19$var$timesbar,
    timesd: $560639d49e3c9a19$var$timesd,
    tint: $560639d49e3c9a19$var$tint,
    toea: $560639d49e3c9a19$var$toea,
    top: $560639d49e3c9a19$var$top,
    topbot: $560639d49e3c9a19$var$topbot,
    topcir: $560639d49e3c9a19$var$topcir,
    topf: $560639d49e3c9a19$var$topf,
    topfork: $560639d49e3c9a19$var$topfork,
    tosa: $560639d49e3c9a19$var$tosa,
    tprime: $560639d49e3c9a19$var$tprime,
    trade: $560639d49e3c9a19$var$trade$1,
    triangle: $560639d49e3c9a19$var$triangle,
    triangledown: $560639d49e3c9a19$var$triangledown,
    triangleleft: $560639d49e3c9a19$var$triangleleft,
    trianglelefteq: $560639d49e3c9a19$var$trianglelefteq,
    triangleq: $560639d49e3c9a19$var$triangleq,
    triangleright: $560639d49e3c9a19$var$triangleright,
    trianglerighteq: $560639d49e3c9a19$var$trianglerighteq,
    tridot: $560639d49e3c9a19$var$tridot,
    trie: $560639d49e3c9a19$var$trie,
    triminus: $560639d49e3c9a19$var$triminus,
    triplus: $560639d49e3c9a19$var$triplus,
    trisb: $560639d49e3c9a19$var$trisb,
    tritime: $560639d49e3c9a19$var$tritime,
    trpezium: $560639d49e3c9a19$var$trpezium,
    tscr: $560639d49e3c9a19$var$tscr,
    tscy: $560639d49e3c9a19$var$tscy,
    tshcy: $560639d49e3c9a19$var$tshcy,
    tstrok: $560639d49e3c9a19$var$tstrok,
    twixt: $560639d49e3c9a19$var$twixt,
    twoheadleftarrow: $560639d49e3c9a19$var$twoheadleftarrow,
    twoheadrightarrow: $560639d49e3c9a19$var$twoheadrightarrow,
    uArr: $560639d49e3c9a19$var$uArr$1,
    uHar: $560639d49e3c9a19$var$uHar,
    uacut: $560639d49e3c9a19$var$uacut,
    uacute: $560639d49e3c9a19$var$uacute$1,
    uarr: $560639d49e3c9a19$var$uarr$1,
    ubrcy: $560639d49e3c9a19$var$ubrcy,
    ubreve: $560639d49e3c9a19$var$ubreve,
    ucir: $560639d49e3c9a19$var$ucir,
    ucirc: $560639d49e3c9a19$var$ucirc$1,
    ucy: $560639d49e3c9a19$var$ucy,
    udarr: $560639d49e3c9a19$var$udarr,
    udblac: $560639d49e3c9a19$var$udblac,
    udhar: $560639d49e3c9a19$var$udhar,
    ufisht: $560639d49e3c9a19$var$ufisht,
    ufr: $560639d49e3c9a19$var$ufr,
    ugrav: $560639d49e3c9a19$var$ugrav,
    ugrave: $560639d49e3c9a19$var$ugrave$1,
    uharl: $560639d49e3c9a19$var$uharl,
    uharr: $560639d49e3c9a19$var$uharr,
    uhblk: $560639d49e3c9a19$var$uhblk,
    ulcorn: $560639d49e3c9a19$var$ulcorn,
    ulcorner: $560639d49e3c9a19$var$ulcorner,
    ulcrop: $560639d49e3c9a19$var$ulcrop,
    ultri: $560639d49e3c9a19$var$ultri,
    umacr: $560639d49e3c9a19$var$umacr,
    um: $560639d49e3c9a19$var$um,
    uml: $560639d49e3c9a19$var$uml$1,
    uogon: $560639d49e3c9a19$var$uogon,
    uopf: $560639d49e3c9a19$var$uopf,
    uparrow: $560639d49e3c9a19$var$uparrow,
    updownarrow: $560639d49e3c9a19$var$updownarrow,
    upharpoonleft: $560639d49e3c9a19$var$upharpoonleft,
    upharpoonright: $560639d49e3c9a19$var$upharpoonright,
    uplus: $560639d49e3c9a19$var$uplus,
    upsi: $560639d49e3c9a19$var$upsi,
    upsih: $560639d49e3c9a19$var$upsih$1,
    upsilon: $560639d49e3c9a19$var$upsilon$1,
    upuparrows: $560639d49e3c9a19$var$upuparrows,
    urcorn: $560639d49e3c9a19$var$urcorn,
    urcorner: $560639d49e3c9a19$var$urcorner,
    urcrop: $560639d49e3c9a19$var$urcrop,
    uring: $560639d49e3c9a19$var$uring,
    urtri: $560639d49e3c9a19$var$urtri,
    uscr: $560639d49e3c9a19$var$uscr,
    utdot: $560639d49e3c9a19$var$utdot,
    utilde: $560639d49e3c9a19$var$utilde,
    utri: $560639d49e3c9a19$var$utri,
    utrif: $560639d49e3c9a19$var$utrif,
    uuarr: $560639d49e3c9a19$var$uuarr,
    uum: $560639d49e3c9a19$var$uum,
    uuml: $560639d49e3c9a19$var$uuml$1,
    uwangle: $560639d49e3c9a19$var$uwangle,
    vArr: $560639d49e3c9a19$var$vArr,
    vBar: $560639d49e3c9a19$var$vBar,
    vBarv: $560639d49e3c9a19$var$vBarv,
    vDash: $560639d49e3c9a19$var$vDash,
    vangrt: $560639d49e3c9a19$var$vangrt,
    varepsilon: $560639d49e3c9a19$var$varepsilon,
    varkappa: $560639d49e3c9a19$var$varkappa,
    varnothing: $560639d49e3c9a19$var$varnothing,
    varphi: $560639d49e3c9a19$var$varphi,
    varpi: $560639d49e3c9a19$var$varpi,
    varpropto: $560639d49e3c9a19$var$varpropto,
    varr: $560639d49e3c9a19$var$varr,
    varrho: $560639d49e3c9a19$var$varrho,
    varsigma: $560639d49e3c9a19$var$varsigma,
    varsubsetneq: $560639d49e3c9a19$var$varsubsetneq,
    varsubsetneqq: $560639d49e3c9a19$var$varsubsetneqq,
    varsupsetneq: $560639d49e3c9a19$var$varsupsetneq,
    varsupsetneqq: $560639d49e3c9a19$var$varsupsetneqq,
    vartheta: $560639d49e3c9a19$var$vartheta,
    vartriangleleft: $560639d49e3c9a19$var$vartriangleleft,
    vartriangleright: $560639d49e3c9a19$var$vartriangleright,
    vcy: $560639d49e3c9a19$var$vcy,
    vdash: $560639d49e3c9a19$var$vdash,
    vee: $560639d49e3c9a19$var$vee,
    veebar: $560639d49e3c9a19$var$veebar,
    veeeq: $560639d49e3c9a19$var$veeeq,
    vellip: $560639d49e3c9a19$var$vellip,
    verbar: $560639d49e3c9a19$var$verbar,
    vert: $560639d49e3c9a19$var$vert,
    vfr: $560639d49e3c9a19$var$vfr,
    vltri: $560639d49e3c9a19$var$vltri,
    vnsub: $560639d49e3c9a19$var$vnsub,
    vnsup: $560639d49e3c9a19$var$vnsup,
    vopf: $560639d49e3c9a19$var$vopf,
    vprop: $560639d49e3c9a19$var$vprop,
    vrtri: $560639d49e3c9a19$var$vrtri,
    vscr: $560639d49e3c9a19$var$vscr,
    vsubnE: $560639d49e3c9a19$var$vsubnE,
    vsubne: $560639d49e3c9a19$var$vsubne,
    vsupnE: $560639d49e3c9a19$var$vsupnE,
    vsupne: $560639d49e3c9a19$var$vsupne,
    vzigzag: $560639d49e3c9a19$var$vzigzag,
    wcirc: $560639d49e3c9a19$var$wcirc,
    wedbar: $560639d49e3c9a19$var$wedbar,
    wedge: $560639d49e3c9a19$var$wedge,
    wedgeq: $560639d49e3c9a19$var$wedgeq,
    weierp: $560639d49e3c9a19$var$weierp$1,
    wfr: $560639d49e3c9a19$var$wfr,
    wopf: $560639d49e3c9a19$var$wopf,
    wp: $560639d49e3c9a19$var$wp,
    wr: $560639d49e3c9a19$var$wr,
    wreath: $560639d49e3c9a19$var$wreath,
    wscr: $560639d49e3c9a19$var$wscr,
    xcap: $560639d49e3c9a19$var$xcap,
    xcirc: $560639d49e3c9a19$var$xcirc,
    xcup: $560639d49e3c9a19$var$xcup,
    xdtri: $560639d49e3c9a19$var$xdtri,
    xfr: $560639d49e3c9a19$var$xfr,
    xhArr: $560639d49e3c9a19$var$xhArr,
    xharr: $560639d49e3c9a19$var$xharr,
    xi: $560639d49e3c9a19$var$xi$1,
    xlArr: $560639d49e3c9a19$var$xlArr,
    xlarr: $560639d49e3c9a19$var$xlarr,
    xmap: $560639d49e3c9a19$var$xmap,
    xnis: $560639d49e3c9a19$var$xnis,
    xodot: $560639d49e3c9a19$var$xodot,
    xopf: $560639d49e3c9a19$var$xopf,
    xoplus: $560639d49e3c9a19$var$xoplus,
    xotime: $560639d49e3c9a19$var$xotime,
    xrArr: $560639d49e3c9a19$var$xrArr,
    xrarr: $560639d49e3c9a19$var$xrarr,
    xscr: $560639d49e3c9a19$var$xscr,
    xsqcup: $560639d49e3c9a19$var$xsqcup,
    xuplus: $560639d49e3c9a19$var$xuplus,
    xutri: $560639d49e3c9a19$var$xutri,
    xvee: $560639d49e3c9a19$var$xvee,
    xwedge: $560639d49e3c9a19$var$xwedge,
    yacut: $560639d49e3c9a19$var$yacut,
    yacute: $560639d49e3c9a19$var$yacute$1,
    yacy: $560639d49e3c9a19$var$yacy,
    ycirc: $560639d49e3c9a19$var$ycirc,
    ycy: $560639d49e3c9a19$var$ycy,
    ye: $560639d49e3c9a19$var$ye,
    yen: $560639d49e3c9a19$var$yen$1,
    yfr: $560639d49e3c9a19$var$yfr,
    yicy: $560639d49e3c9a19$var$yicy,
    yopf: $560639d49e3c9a19$var$yopf,
    yscr: $560639d49e3c9a19$var$yscr,
    yucy: $560639d49e3c9a19$var$yucy,
    yum: $560639d49e3c9a19$var$yum,
    yuml: $560639d49e3c9a19$var$yuml$1,
    zacute: $560639d49e3c9a19$var$zacute,
    zcaron: $560639d49e3c9a19$var$zcaron,
    zcy: $560639d49e3c9a19$var$zcy,
    zdot: $560639d49e3c9a19$var$zdot,
    zeetrf: $560639d49e3c9a19$var$zeetrf,
    zeta: $560639d49e3c9a19$var$zeta$1,
    zfr: $560639d49e3c9a19$var$zfr,
    zhcy: $560639d49e3c9a19$var$zhcy,
    zigrarr: $560639d49e3c9a19$var$zigrarr,
    zopf: $560639d49e3c9a19$var$zopf,
    zscr: $560639d49e3c9a19$var$zscr,
    zwj: $560639d49e3c9a19$var$zwj$1,
    zwnj: $560639d49e3c9a19$var$zwnj$1
};
var $560639d49e3c9a19$var$characterEntities$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AEli: $560639d49e3c9a19$var$AEli,
    AElig: $560639d49e3c9a19$var$AElig$1,
    AM: $560639d49e3c9a19$var$AM,
    AMP: $560639d49e3c9a19$var$AMP$1,
    Aacut: $560639d49e3c9a19$var$Aacut,
    Aacute: $560639d49e3c9a19$var$Aacute$1,
    Abreve: $560639d49e3c9a19$var$Abreve,
    Acir: $560639d49e3c9a19$var$Acir,
    Acirc: $560639d49e3c9a19$var$Acirc$1,
    Acy: $560639d49e3c9a19$var$Acy,
    Afr: $560639d49e3c9a19$var$Afr,
    Agrav: $560639d49e3c9a19$var$Agrav,
    Agrave: $560639d49e3c9a19$var$Agrave$1,
    Alpha: $560639d49e3c9a19$var$Alpha$1,
    Amacr: $560639d49e3c9a19$var$Amacr,
    And: $560639d49e3c9a19$var$And,
    Aogon: $560639d49e3c9a19$var$Aogon,
    Aopf: $560639d49e3c9a19$var$Aopf,
    ApplyFunction: $560639d49e3c9a19$var$ApplyFunction,
    Arin: $560639d49e3c9a19$var$Arin,
    Aring: $560639d49e3c9a19$var$Aring$1,
    Ascr: $560639d49e3c9a19$var$Ascr,
    Assign: $560639d49e3c9a19$var$Assign,
    Atild: $560639d49e3c9a19$var$Atild,
    Atilde: $560639d49e3c9a19$var$Atilde$1,
    Aum: $560639d49e3c9a19$var$Aum,
    Auml: $560639d49e3c9a19$var$Auml$1,
    Backslash: $560639d49e3c9a19$var$Backslash,
    Barv: $560639d49e3c9a19$var$Barv,
    Barwed: $560639d49e3c9a19$var$Barwed,
    Bcy: $560639d49e3c9a19$var$Bcy,
    Because: $560639d49e3c9a19$var$Because,
    Bernoullis: $560639d49e3c9a19$var$Bernoullis,
    Beta: $560639d49e3c9a19$var$Beta$1,
    Bfr: $560639d49e3c9a19$var$Bfr,
    Bopf: $560639d49e3c9a19$var$Bopf,
    Breve: $560639d49e3c9a19$var$Breve,
    Bscr: $560639d49e3c9a19$var$Bscr,
    Bumpeq: $560639d49e3c9a19$var$Bumpeq,
    CHcy: $560639d49e3c9a19$var$CHcy,
    COP: $560639d49e3c9a19$var$COP,
    COPY: $560639d49e3c9a19$var$COPY,
    Cacute: $560639d49e3c9a19$var$Cacute,
    Cap: $560639d49e3c9a19$var$Cap,
    CapitalDifferentialD: $560639d49e3c9a19$var$CapitalDifferentialD,
    Cayleys: $560639d49e3c9a19$var$Cayleys,
    Ccaron: $560639d49e3c9a19$var$Ccaron,
    Ccedi: $560639d49e3c9a19$var$Ccedi,
    Ccedil: $560639d49e3c9a19$var$Ccedil$1,
    Ccirc: $560639d49e3c9a19$var$Ccirc,
    Cconint: $560639d49e3c9a19$var$Cconint,
    Cdot: $560639d49e3c9a19$var$Cdot,
    Cedilla: $560639d49e3c9a19$var$Cedilla,
    CenterDot: $560639d49e3c9a19$var$CenterDot,
    Cfr: $560639d49e3c9a19$var$Cfr,
    Chi: $560639d49e3c9a19$var$Chi$1,
    CircleDot: $560639d49e3c9a19$var$CircleDot,
    CircleMinus: $560639d49e3c9a19$var$CircleMinus,
    CirclePlus: $560639d49e3c9a19$var$CirclePlus,
    CircleTimes: $560639d49e3c9a19$var$CircleTimes,
    ClockwiseContourIntegral: $560639d49e3c9a19$var$ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: $560639d49e3c9a19$var$CloseCurlyDoubleQuote,
    CloseCurlyQuote: $560639d49e3c9a19$var$CloseCurlyQuote,
    Colon: $560639d49e3c9a19$var$Colon,
    Colone: $560639d49e3c9a19$var$Colone,
    Congruent: $560639d49e3c9a19$var$Congruent,
    Conint: $560639d49e3c9a19$var$Conint,
    ContourIntegral: $560639d49e3c9a19$var$ContourIntegral,
    Copf: $560639d49e3c9a19$var$Copf,
    Coproduct: $560639d49e3c9a19$var$Coproduct,
    CounterClockwiseContourIntegral: $560639d49e3c9a19$var$CounterClockwiseContourIntegral,
    Cross: $560639d49e3c9a19$var$Cross,
    Cscr: $560639d49e3c9a19$var$Cscr,
    Cup: $560639d49e3c9a19$var$Cup,
    CupCap: $560639d49e3c9a19$var$CupCap,
    DD: $560639d49e3c9a19$var$DD,
    DDotrahd: $560639d49e3c9a19$var$DDotrahd,
    DJcy: $560639d49e3c9a19$var$DJcy,
    DScy: $560639d49e3c9a19$var$DScy,
    DZcy: $560639d49e3c9a19$var$DZcy,
    Dagger: $560639d49e3c9a19$var$Dagger$1,
    Darr: $560639d49e3c9a19$var$Darr,
    Dashv: $560639d49e3c9a19$var$Dashv,
    Dcaron: $560639d49e3c9a19$var$Dcaron,
    Dcy: $560639d49e3c9a19$var$Dcy,
    Del: $560639d49e3c9a19$var$Del,
    Delta: $560639d49e3c9a19$var$Delta$1,
    Dfr: $560639d49e3c9a19$var$Dfr,
    DiacriticalAcute: $560639d49e3c9a19$var$DiacriticalAcute,
    DiacriticalDot: $560639d49e3c9a19$var$DiacriticalDot,
    DiacriticalDoubleAcute: $560639d49e3c9a19$var$DiacriticalDoubleAcute,
    DiacriticalGrave: $560639d49e3c9a19$var$DiacriticalGrave,
    DiacriticalTilde: $560639d49e3c9a19$var$DiacriticalTilde,
    Diamond: $560639d49e3c9a19$var$Diamond,
    DifferentialD: $560639d49e3c9a19$var$DifferentialD,
    Dopf: $560639d49e3c9a19$var$Dopf,
    Dot: $560639d49e3c9a19$var$Dot,
    DotDot: $560639d49e3c9a19$var$DotDot,
    DotEqual: $560639d49e3c9a19$var$DotEqual,
    DoubleContourIntegral: $560639d49e3c9a19$var$DoubleContourIntegral,
    DoubleDot: $560639d49e3c9a19$var$DoubleDot,
    DoubleDownArrow: $560639d49e3c9a19$var$DoubleDownArrow,
    DoubleLeftArrow: $560639d49e3c9a19$var$DoubleLeftArrow,
    DoubleLeftRightArrow: $560639d49e3c9a19$var$DoubleLeftRightArrow,
    DoubleLeftTee: $560639d49e3c9a19$var$DoubleLeftTee,
    DoubleLongLeftArrow: $560639d49e3c9a19$var$DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: $560639d49e3c9a19$var$DoubleLongLeftRightArrow,
    DoubleLongRightArrow: $560639d49e3c9a19$var$DoubleLongRightArrow,
    DoubleRightArrow: $560639d49e3c9a19$var$DoubleRightArrow,
    DoubleRightTee: $560639d49e3c9a19$var$DoubleRightTee,
    DoubleUpArrow: $560639d49e3c9a19$var$DoubleUpArrow,
    DoubleUpDownArrow: $560639d49e3c9a19$var$DoubleUpDownArrow,
    DoubleVerticalBar: $560639d49e3c9a19$var$DoubleVerticalBar,
    DownArrow: $560639d49e3c9a19$var$DownArrow,
    DownArrowBar: $560639d49e3c9a19$var$DownArrowBar,
    DownArrowUpArrow: $560639d49e3c9a19$var$DownArrowUpArrow,
    DownBreve: $560639d49e3c9a19$var$DownBreve,
    DownLeftRightVector: $560639d49e3c9a19$var$DownLeftRightVector,
    DownLeftTeeVector: $560639d49e3c9a19$var$DownLeftTeeVector,
    DownLeftVector: $560639d49e3c9a19$var$DownLeftVector,
    DownLeftVectorBar: $560639d49e3c9a19$var$DownLeftVectorBar,
    DownRightTeeVector: $560639d49e3c9a19$var$DownRightTeeVector,
    DownRightVector: $560639d49e3c9a19$var$DownRightVector,
    DownRightVectorBar: $560639d49e3c9a19$var$DownRightVectorBar,
    DownTee: $560639d49e3c9a19$var$DownTee,
    DownTeeArrow: $560639d49e3c9a19$var$DownTeeArrow,
    Downarrow: $560639d49e3c9a19$var$Downarrow,
    Dscr: $560639d49e3c9a19$var$Dscr,
    Dstrok: $560639d49e3c9a19$var$Dstrok,
    ENG: $560639d49e3c9a19$var$ENG,
    ET: $560639d49e3c9a19$var$ET,
    ETH: $560639d49e3c9a19$var$ETH$1,
    Eacut: $560639d49e3c9a19$var$Eacut,
    Eacute: $560639d49e3c9a19$var$Eacute$1,
    Ecaron: $560639d49e3c9a19$var$Ecaron,
    Ecir: $560639d49e3c9a19$var$Ecir,
    Ecirc: $560639d49e3c9a19$var$Ecirc$1,
    Ecy: $560639d49e3c9a19$var$Ecy,
    Edot: $560639d49e3c9a19$var$Edot,
    Efr: $560639d49e3c9a19$var$Efr,
    Egrav: $560639d49e3c9a19$var$Egrav,
    Egrave: $560639d49e3c9a19$var$Egrave$1,
    Element: $560639d49e3c9a19$var$Element,
    Emacr: $560639d49e3c9a19$var$Emacr,
    EmptySmallSquare: $560639d49e3c9a19$var$EmptySmallSquare,
    EmptyVerySmallSquare: $560639d49e3c9a19$var$EmptyVerySmallSquare,
    Eogon: $560639d49e3c9a19$var$Eogon,
    Eopf: $560639d49e3c9a19$var$Eopf,
    Epsilon: $560639d49e3c9a19$var$Epsilon$1,
    Equal: $560639d49e3c9a19$var$Equal,
    EqualTilde: $560639d49e3c9a19$var$EqualTilde,
    Equilibrium: $560639d49e3c9a19$var$Equilibrium,
    Escr: $560639d49e3c9a19$var$Escr,
    Esim: $560639d49e3c9a19$var$Esim,
    Eta: $560639d49e3c9a19$var$Eta$1,
    Eum: $560639d49e3c9a19$var$Eum,
    Euml: $560639d49e3c9a19$var$Euml$1,
    Exists: $560639d49e3c9a19$var$Exists,
    ExponentialE: $560639d49e3c9a19$var$ExponentialE,
    Fcy: $560639d49e3c9a19$var$Fcy,
    Ffr: $560639d49e3c9a19$var$Ffr,
    FilledSmallSquare: $560639d49e3c9a19$var$FilledSmallSquare,
    FilledVerySmallSquare: $560639d49e3c9a19$var$FilledVerySmallSquare,
    Fopf: $560639d49e3c9a19$var$Fopf,
    ForAll: $560639d49e3c9a19$var$ForAll,
    Fouriertrf: $560639d49e3c9a19$var$Fouriertrf,
    Fscr: $560639d49e3c9a19$var$Fscr,
    GJcy: $560639d49e3c9a19$var$GJcy,
    G: $560639d49e3c9a19$var$G,
    GT: $560639d49e3c9a19$var$GT$1,
    Gamma: $560639d49e3c9a19$var$Gamma$1,
    Gammad: $560639d49e3c9a19$var$Gammad,
    Gbreve: $560639d49e3c9a19$var$Gbreve,
    Gcedil: $560639d49e3c9a19$var$Gcedil,
    Gcirc: $560639d49e3c9a19$var$Gcirc,
    Gcy: $560639d49e3c9a19$var$Gcy,
    Gdot: $560639d49e3c9a19$var$Gdot,
    Gfr: $560639d49e3c9a19$var$Gfr,
    Gg: $560639d49e3c9a19$var$Gg,
    Gopf: $560639d49e3c9a19$var$Gopf,
    GreaterEqual: $560639d49e3c9a19$var$GreaterEqual,
    GreaterEqualLess: $560639d49e3c9a19$var$GreaterEqualLess,
    GreaterFullEqual: $560639d49e3c9a19$var$GreaterFullEqual,
    GreaterGreater: $560639d49e3c9a19$var$GreaterGreater,
    GreaterLess: $560639d49e3c9a19$var$GreaterLess,
    GreaterSlantEqual: $560639d49e3c9a19$var$GreaterSlantEqual,
    GreaterTilde: $560639d49e3c9a19$var$GreaterTilde,
    Gscr: $560639d49e3c9a19$var$Gscr,
    Gt: $560639d49e3c9a19$var$Gt,
    HARDcy: $560639d49e3c9a19$var$HARDcy,
    Hacek: $560639d49e3c9a19$var$Hacek,
    Hat: $560639d49e3c9a19$var$Hat,
    Hcirc: $560639d49e3c9a19$var$Hcirc,
    Hfr: $560639d49e3c9a19$var$Hfr,
    HilbertSpace: $560639d49e3c9a19$var$HilbertSpace,
    Hopf: $560639d49e3c9a19$var$Hopf,
    HorizontalLine: $560639d49e3c9a19$var$HorizontalLine,
    Hscr: $560639d49e3c9a19$var$Hscr,
    Hstrok: $560639d49e3c9a19$var$Hstrok,
    HumpDownHump: $560639d49e3c9a19$var$HumpDownHump,
    HumpEqual: $560639d49e3c9a19$var$HumpEqual,
    IEcy: $560639d49e3c9a19$var$IEcy,
    IJlig: $560639d49e3c9a19$var$IJlig,
    IOcy: $560639d49e3c9a19$var$IOcy,
    Iacut: $560639d49e3c9a19$var$Iacut,
    Iacute: $560639d49e3c9a19$var$Iacute$1,
    Icir: $560639d49e3c9a19$var$Icir,
    Icirc: $560639d49e3c9a19$var$Icirc$1,
    Icy: $560639d49e3c9a19$var$Icy,
    Idot: $560639d49e3c9a19$var$Idot,
    Ifr: $560639d49e3c9a19$var$Ifr,
    Igrav: $560639d49e3c9a19$var$Igrav,
    Igrave: $560639d49e3c9a19$var$Igrave$1,
    Im: $560639d49e3c9a19$var$Im,
    Imacr: $560639d49e3c9a19$var$Imacr,
    ImaginaryI: $560639d49e3c9a19$var$ImaginaryI,
    Implies: $560639d49e3c9a19$var$Implies,
    Int: $560639d49e3c9a19$var$Int,
    Integral: $560639d49e3c9a19$var$Integral,
    Intersection: $560639d49e3c9a19$var$Intersection,
    InvisibleComma: $560639d49e3c9a19$var$InvisibleComma,
    InvisibleTimes: $560639d49e3c9a19$var$InvisibleTimes,
    Iogon: $560639d49e3c9a19$var$Iogon,
    Iopf: $560639d49e3c9a19$var$Iopf,
    Iota: $560639d49e3c9a19$var$Iota$1,
    Iscr: $560639d49e3c9a19$var$Iscr,
    Itilde: $560639d49e3c9a19$var$Itilde,
    Iukcy: $560639d49e3c9a19$var$Iukcy,
    Ium: $560639d49e3c9a19$var$Ium,
    Iuml: $560639d49e3c9a19$var$Iuml$1,
    Jcirc: $560639d49e3c9a19$var$Jcirc,
    Jcy: $560639d49e3c9a19$var$Jcy,
    Jfr: $560639d49e3c9a19$var$Jfr,
    Jopf: $560639d49e3c9a19$var$Jopf,
    Jscr: $560639d49e3c9a19$var$Jscr,
    Jsercy: $560639d49e3c9a19$var$Jsercy,
    Jukcy: $560639d49e3c9a19$var$Jukcy,
    KHcy: $560639d49e3c9a19$var$KHcy,
    KJcy: $560639d49e3c9a19$var$KJcy,
    Kappa: $560639d49e3c9a19$var$Kappa$1,
    Kcedil: $560639d49e3c9a19$var$Kcedil,
    Kcy: $560639d49e3c9a19$var$Kcy,
    Kfr: $560639d49e3c9a19$var$Kfr,
    Kopf: $560639d49e3c9a19$var$Kopf,
    Kscr: $560639d49e3c9a19$var$Kscr,
    LJcy: $560639d49e3c9a19$var$LJcy,
    L: $560639d49e3c9a19$var$L,
    LT: $560639d49e3c9a19$var$LT$1,
    Lacute: $560639d49e3c9a19$var$Lacute,
    Lambda: $560639d49e3c9a19$var$Lambda$1,
    Lang: $560639d49e3c9a19$var$Lang,
    Laplacetrf: $560639d49e3c9a19$var$Laplacetrf,
    Larr: $560639d49e3c9a19$var$Larr,
    Lcaron: $560639d49e3c9a19$var$Lcaron,
    Lcedil: $560639d49e3c9a19$var$Lcedil,
    Lcy: $560639d49e3c9a19$var$Lcy,
    LeftAngleBracket: $560639d49e3c9a19$var$LeftAngleBracket,
    LeftArrow: $560639d49e3c9a19$var$LeftArrow,
    LeftArrowBar: $560639d49e3c9a19$var$LeftArrowBar,
    LeftArrowRightArrow: $560639d49e3c9a19$var$LeftArrowRightArrow,
    LeftCeiling: $560639d49e3c9a19$var$LeftCeiling,
    LeftDoubleBracket: $560639d49e3c9a19$var$LeftDoubleBracket,
    LeftDownTeeVector: $560639d49e3c9a19$var$LeftDownTeeVector,
    LeftDownVector: $560639d49e3c9a19$var$LeftDownVector,
    LeftDownVectorBar: $560639d49e3c9a19$var$LeftDownVectorBar,
    LeftFloor: $560639d49e3c9a19$var$LeftFloor,
    LeftRightArrow: $560639d49e3c9a19$var$LeftRightArrow,
    LeftRightVector: $560639d49e3c9a19$var$LeftRightVector,
    LeftTee: $560639d49e3c9a19$var$LeftTee,
    LeftTeeArrow: $560639d49e3c9a19$var$LeftTeeArrow,
    LeftTeeVector: $560639d49e3c9a19$var$LeftTeeVector,
    LeftTriangle: $560639d49e3c9a19$var$LeftTriangle,
    LeftTriangleBar: $560639d49e3c9a19$var$LeftTriangleBar,
    LeftTriangleEqual: $560639d49e3c9a19$var$LeftTriangleEqual,
    LeftUpDownVector: $560639d49e3c9a19$var$LeftUpDownVector,
    LeftUpTeeVector: $560639d49e3c9a19$var$LeftUpTeeVector,
    LeftUpVector: $560639d49e3c9a19$var$LeftUpVector,
    LeftUpVectorBar: $560639d49e3c9a19$var$LeftUpVectorBar,
    LeftVector: $560639d49e3c9a19$var$LeftVector,
    LeftVectorBar: $560639d49e3c9a19$var$LeftVectorBar,
    Leftarrow: $560639d49e3c9a19$var$Leftarrow,
    Leftrightarrow: $560639d49e3c9a19$var$Leftrightarrow,
    LessEqualGreater: $560639d49e3c9a19$var$LessEqualGreater,
    LessFullEqual: $560639d49e3c9a19$var$LessFullEqual,
    LessGreater: $560639d49e3c9a19$var$LessGreater,
    LessLess: $560639d49e3c9a19$var$LessLess,
    LessSlantEqual: $560639d49e3c9a19$var$LessSlantEqual,
    LessTilde: $560639d49e3c9a19$var$LessTilde,
    Lfr: $560639d49e3c9a19$var$Lfr,
    Ll: $560639d49e3c9a19$var$Ll,
    Lleftarrow: $560639d49e3c9a19$var$Lleftarrow,
    Lmidot: $560639d49e3c9a19$var$Lmidot,
    LongLeftArrow: $560639d49e3c9a19$var$LongLeftArrow,
    LongLeftRightArrow: $560639d49e3c9a19$var$LongLeftRightArrow,
    LongRightArrow: $560639d49e3c9a19$var$LongRightArrow,
    Longleftarrow: $560639d49e3c9a19$var$Longleftarrow,
    Longleftrightarrow: $560639d49e3c9a19$var$Longleftrightarrow,
    Longrightarrow: $560639d49e3c9a19$var$Longrightarrow,
    Lopf: $560639d49e3c9a19$var$Lopf,
    LowerLeftArrow: $560639d49e3c9a19$var$LowerLeftArrow,
    LowerRightArrow: $560639d49e3c9a19$var$LowerRightArrow,
    Lscr: $560639d49e3c9a19$var$Lscr,
    Lsh: $560639d49e3c9a19$var$Lsh,
    Lstrok: $560639d49e3c9a19$var$Lstrok,
    Lt: $560639d49e3c9a19$var$Lt,
    Mcy: $560639d49e3c9a19$var$Mcy,
    MediumSpace: $560639d49e3c9a19$var$MediumSpace,
    Mellintrf: $560639d49e3c9a19$var$Mellintrf,
    Mfr: $560639d49e3c9a19$var$Mfr,
    MinusPlus: $560639d49e3c9a19$var$MinusPlus,
    Mopf: $560639d49e3c9a19$var$Mopf,
    Mscr: $560639d49e3c9a19$var$Mscr,
    Mu: $560639d49e3c9a19$var$Mu$1,
    NJcy: $560639d49e3c9a19$var$NJcy,
    Nacute: $560639d49e3c9a19$var$Nacute,
    Ncaron: $560639d49e3c9a19$var$Ncaron,
    Ncedil: $560639d49e3c9a19$var$Ncedil,
    Ncy: $560639d49e3c9a19$var$Ncy,
    NegativeMediumSpace: $560639d49e3c9a19$var$NegativeMediumSpace,
    NegativeThickSpace: $560639d49e3c9a19$var$NegativeThickSpace,
    NegativeThinSpace: $560639d49e3c9a19$var$NegativeThinSpace,
    NegativeVeryThinSpace: $560639d49e3c9a19$var$NegativeVeryThinSpace,
    NestedGreaterGreater: $560639d49e3c9a19$var$NestedGreaterGreater,
    NestedLessLess: $560639d49e3c9a19$var$NestedLessLess,
    NewLine: $560639d49e3c9a19$var$NewLine,
    Nfr: $560639d49e3c9a19$var$Nfr,
    NoBreak: $560639d49e3c9a19$var$NoBreak,
    NonBreakingSpace: $560639d49e3c9a19$var$NonBreakingSpace,
    Nopf: $560639d49e3c9a19$var$Nopf,
    Not: $560639d49e3c9a19$var$Not,
    NotCongruent: $560639d49e3c9a19$var$NotCongruent,
    NotCupCap: $560639d49e3c9a19$var$NotCupCap,
    NotDoubleVerticalBar: $560639d49e3c9a19$var$NotDoubleVerticalBar,
    NotElement: $560639d49e3c9a19$var$NotElement,
    NotEqual: $560639d49e3c9a19$var$NotEqual,
    NotEqualTilde: $560639d49e3c9a19$var$NotEqualTilde,
    NotExists: $560639d49e3c9a19$var$NotExists,
    NotGreater: $560639d49e3c9a19$var$NotGreater,
    NotGreaterEqual: $560639d49e3c9a19$var$NotGreaterEqual,
    NotGreaterFullEqual: $560639d49e3c9a19$var$NotGreaterFullEqual,
    NotGreaterGreater: $560639d49e3c9a19$var$NotGreaterGreater,
    NotGreaterLess: $560639d49e3c9a19$var$NotGreaterLess,
    NotGreaterSlantEqual: $560639d49e3c9a19$var$NotGreaterSlantEqual,
    NotGreaterTilde: $560639d49e3c9a19$var$NotGreaterTilde,
    NotHumpDownHump: $560639d49e3c9a19$var$NotHumpDownHump,
    NotHumpEqual: $560639d49e3c9a19$var$NotHumpEqual,
    NotLeftTriangle: $560639d49e3c9a19$var$NotLeftTriangle,
    NotLeftTriangleBar: $560639d49e3c9a19$var$NotLeftTriangleBar,
    NotLeftTriangleEqual: $560639d49e3c9a19$var$NotLeftTriangleEqual,
    NotLess: $560639d49e3c9a19$var$NotLess,
    NotLessEqual: $560639d49e3c9a19$var$NotLessEqual,
    NotLessGreater: $560639d49e3c9a19$var$NotLessGreater,
    NotLessLess: $560639d49e3c9a19$var$NotLessLess,
    NotLessSlantEqual: $560639d49e3c9a19$var$NotLessSlantEqual,
    NotLessTilde: $560639d49e3c9a19$var$NotLessTilde,
    NotNestedGreaterGreater: $560639d49e3c9a19$var$NotNestedGreaterGreater,
    NotNestedLessLess: $560639d49e3c9a19$var$NotNestedLessLess,
    NotPrecedes: $560639d49e3c9a19$var$NotPrecedes,
    NotPrecedesEqual: $560639d49e3c9a19$var$NotPrecedesEqual,
    NotPrecedesSlantEqual: $560639d49e3c9a19$var$NotPrecedesSlantEqual,
    NotReverseElement: $560639d49e3c9a19$var$NotReverseElement,
    NotRightTriangle: $560639d49e3c9a19$var$NotRightTriangle,
    NotRightTriangleBar: $560639d49e3c9a19$var$NotRightTriangleBar,
    NotRightTriangleEqual: $560639d49e3c9a19$var$NotRightTriangleEqual,
    NotSquareSubset: $560639d49e3c9a19$var$NotSquareSubset,
    NotSquareSubsetEqual: $560639d49e3c9a19$var$NotSquareSubsetEqual,
    NotSquareSuperset: $560639d49e3c9a19$var$NotSquareSuperset,
    NotSquareSupersetEqual: $560639d49e3c9a19$var$NotSquareSupersetEqual,
    NotSubset: $560639d49e3c9a19$var$NotSubset,
    NotSubsetEqual: $560639d49e3c9a19$var$NotSubsetEqual,
    NotSucceeds: $560639d49e3c9a19$var$NotSucceeds,
    NotSucceedsEqual: $560639d49e3c9a19$var$NotSucceedsEqual,
    NotSucceedsSlantEqual: $560639d49e3c9a19$var$NotSucceedsSlantEqual,
    NotSucceedsTilde: $560639d49e3c9a19$var$NotSucceedsTilde,
    NotSuperset: $560639d49e3c9a19$var$NotSuperset,
    NotSupersetEqual: $560639d49e3c9a19$var$NotSupersetEqual,
    NotTilde: $560639d49e3c9a19$var$NotTilde,
    NotTildeEqual: $560639d49e3c9a19$var$NotTildeEqual,
    NotTildeFullEqual: $560639d49e3c9a19$var$NotTildeFullEqual,
    NotTildeTilde: $560639d49e3c9a19$var$NotTildeTilde,
    NotVerticalBar: $560639d49e3c9a19$var$NotVerticalBar,
    Nscr: $560639d49e3c9a19$var$Nscr,
    Ntild: $560639d49e3c9a19$var$Ntild,
    Ntilde: $560639d49e3c9a19$var$Ntilde$1,
    Nu: $560639d49e3c9a19$var$Nu$1,
    OElig: $560639d49e3c9a19$var$OElig$1,
    Oacut: $560639d49e3c9a19$var$Oacut,
    Oacute: $560639d49e3c9a19$var$Oacute$1,
    Ocir: $560639d49e3c9a19$var$Ocir,
    Ocirc: $560639d49e3c9a19$var$Ocirc$1,
    Ocy: $560639d49e3c9a19$var$Ocy,
    Odblac: $560639d49e3c9a19$var$Odblac,
    Ofr: $560639d49e3c9a19$var$Ofr,
    Ograv: $560639d49e3c9a19$var$Ograv,
    Ograve: $560639d49e3c9a19$var$Ograve$1,
    Omacr: $560639d49e3c9a19$var$Omacr,
    Omega: $560639d49e3c9a19$var$Omega$1,
    Omicron: $560639d49e3c9a19$var$Omicron$1,
    Oopf: $560639d49e3c9a19$var$Oopf,
    OpenCurlyDoubleQuote: $560639d49e3c9a19$var$OpenCurlyDoubleQuote,
    OpenCurlyQuote: $560639d49e3c9a19$var$OpenCurlyQuote,
    Or: $560639d49e3c9a19$var$Or,
    Oscr: $560639d49e3c9a19$var$Oscr,
    Oslas: $560639d49e3c9a19$var$Oslas,
    Oslash: $560639d49e3c9a19$var$Oslash$1,
    Otild: $560639d49e3c9a19$var$Otild,
    Otilde: $560639d49e3c9a19$var$Otilde$1,
    Otimes: $560639d49e3c9a19$var$Otimes,
    Oum: $560639d49e3c9a19$var$Oum,
    Ouml: $560639d49e3c9a19$var$Ouml$1,
    OverBar: $560639d49e3c9a19$var$OverBar,
    OverBrace: $560639d49e3c9a19$var$OverBrace,
    OverBracket: $560639d49e3c9a19$var$OverBracket,
    OverParenthesis: $560639d49e3c9a19$var$OverParenthesis,
    PartialD: $560639d49e3c9a19$var$PartialD,
    Pcy: $560639d49e3c9a19$var$Pcy,
    Pfr: $560639d49e3c9a19$var$Pfr,
    Phi: $560639d49e3c9a19$var$Phi$1,
    Pi: $560639d49e3c9a19$var$Pi$1,
    PlusMinus: $560639d49e3c9a19$var$PlusMinus,
    Poincareplane: $560639d49e3c9a19$var$Poincareplane,
    Popf: $560639d49e3c9a19$var$Popf,
    Pr: $560639d49e3c9a19$var$Pr,
    Precedes: $560639d49e3c9a19$var$Precedes,
    PrecedesEqual: $560639d49e3c9a19$var$PrecedesEqual,
    PrecedesSlantEqual: $560639d49e3c9a19$var$PrecedesSlantEqual,
    PrecedesTilde: $560639d49e3c9a19$var$PrecedesTilde,
    Prime: $560639d49e3c9a19$var$Prime$1,
    Product: $560639d49e3c9a19$var$Product,
    Proportion: $560639d49e3c9a19$var$Proportion,
    Proportional: $560639d49e3c9a19$var$Proportional,
    Pscr: $560639d49e3c9a19$var$Pscr,
    Psi: $560639d49e3c9a19$var$Psi$1,
    QUO: $560639d49e3c9a19$var$QUO,
    QUOT: $560639d49e3c9a19$var$QUOT,
    Qfr: $560639d49e3c9a19$var$Qfr,
    Qopf: $560639d49e3c9a19$var$Qopf,
    Qscr: $560639d49e3c9a19$var$Qscr,
    RBarr: $560639d49e3c9a19$var$RBarr,
    RE: $560639d49e3c9a19$var$RE,
    REG: $560639d49e3c9a19$var$REG,
    Racute: $560639d49e3c9a19$var$Racute,
    Rang: $560639d49e3c9a19$var$Rang,
    Rarr: $560639d49e3c9a19$var$Rarr,
    Rarrtl: $560639d49e3c9a19$var$Rarrtl,
    Rcaron: $560639d49e3c9a19$var$Rcaron,
    Rcedil: $560639d49e3c9a19$var$Rcedil,
    Rcy: $560639d49e3c9a19$var$Rcy,
    Re: $560639d49e3c9a19$var$Re,
    ReverseElement: $560639d49e3c9a19$var$ReverseElement,
    ReverseEquilibrium: $560639d49e3c9a19$var$ReverseEquilibrium,
    ReverseUpEquilibrium: $560639d49e3c9a19$var$ReverseUpEquilibrium,
    Rfr: $560639d49e3c9a19$var$Rfr,
    Rho: $560639d49e3c9a19$var$Rho$1,
    RightAngleBracket: $560639d49e3c9a19$var$RightAngleBracket,
    RightArrow: $560639d49e3c9a19$var$RightArrow,
    RightArrowBar: $560639d49e3c9a19$var$RightArrowBar,
    RightArrowLeftArrow: $560639d49e3c9a19$var$RightArrowLeftArrow,
    RightCeiling: $560639d49e3c9a19$var$RightCeiling,
    RightDoubleBracket: $560639d49e3c9a19$var$RightDoubleBracket,
    RightDownTeeVector: $560639d49e3c9a19$var$RightDownTeeVector,
    RightDownVector: $560639d49e3c9a19$var$RightDownVector,
    RightDownVectorBar: $560639d49e3c9a19$var$RightDownVectorBar,
    RightFloor: $560639d49e3c9a19$var$RightFloor,
    RightTee: $560639d49e3c9a19$var$RightTee,
    RightTeeArrow: $560639d49e3c9a19$var$RightTeeArrow,
    RightTeeVector: $560639d49e3c9a19$var$RightTeeVector,
    RightTriangle: $560639d49e3c9a19$var$RightTriangle,
    RightTriangleBar: $560639d49e3c9a19$var$RightTriangleBar,
    RightTriangleEqual: $560639d49e3c9a19$var$RightTriangleEqual,
    RightUpDownVector: $560639d49e3c9a19$var$RightUpDownVector,
    RightUpTeeVector: $560639d49e3c9a19$var$RightUpTeeVector,
    RightUpVector: $560639d49e3c9a19$var$RightUpVector,
    RightUpVectorBar: $560639d49e3c9a19$var$RightUpVectorBar,
    RightVector: $560639d49e3c9a19$var$RightVector,
    RightVectorBar: $560639d49e3c9a19$var$RightVectorBar,
    Rightarrow: $560639d49e3c9a19$var$Rightarrow,
    Ropf: $560639d49e3c9a19$var$Ropf,
    RoundImplies: $560639d49e3c9a19$var$RoundImplies,
    Rrightarrow: $560639d49e3c9a19$var$Rrightarrow,
    Rscr: $560639d49e3c9a19$var$Rscr,
    Rsh: $560639d49e3c9a19$var$Rsh,
    RuleDelayed: $560639d49e3c9a19$var$RuleDelayed,
    SHCHcy: $560639d49e3c9a19$var$SHCHcy,
    SHcy: $560639d49e3c9a19$var$SHcy,
    SOFTcy: $560639d49e3c9a19$var$SOFTcy,
    Sacute: $560639d49e3c9a19$var$Sacute,
    Sc: $560639d49e3c9a19$var$Sc,
    Scaron: $560639d49e3c9a19$var$Scaron$1,
    Scedil: $560639d49e3c9a19$var$Scedil,
    Scirc: $560639d49e3c9a19$var$Scirc,
    Scy: $560639d49e3c9a19$var$Scy,
    Sfr: $560639d49e3c9a19$var$Sfr,
    ShortDownArrow: $560639d49e3c9a19$var$ShortDownArrow,
    ShortLeftArrow: $560639d49e3c9a19$var$ShortLeftArrow,
    ShortRightArrow: $560639d49e3c9a19$var$ShortRightArrow,
    ShortUpArrow: $560639d49e3c9a19$var$ShortUpArrow,
    Sigma: $560639d49e3c9a19$var$Sigma$1,
    SmallCircle: $560639d49e3c9a19$var$SmallCircle,
    Sopf: $560639d49e3c9a19$var$Sopf,
    Sqrt: $560639d49e3c9a19$var$Sqrt,
    Square: $560639d49e3c9a19$var$Square,
    SquareIntersection: $560639d49e3c9a19$var$SquareIntersection,
    SquareSubset: $560639d49e3c9a19$var$SquareSubset,
    SquareSubsetEqual: $560639d49e3c9a19$var$SquareSubsetEqual,
    SquareSuperset: $560639d49e3c9a19$var$SquareSuperset,
    SquareSupersetEqual: $560639d49e3c9a19$var$SquareSupersetEqual,
    SquareUnion: $560639d49e3c9a19$var$SquareUnion,
    Sscr: $560639d49e3c9a19$var$Sscr,
    Star: $560639d49e3c9a19$var$Star,
    Sub: $560639d49e3c9a19$var$Sub,
    Subset: $560639d49e3c9a19$var$Subset,
    SubsetEqual: $560639d49e3c9a19$var$SubsetEqual,
    Succeeds: $560639d49e3c9a19$var$Succeeds,
    SucceedsEqual: $560639d49e3c9a19$var$SucceedsEqual,
    SucceedsSlantEqual: $560639d49e3c9a19$var$SucceedsSlantEqual,
    SucceedsTilde: $560639d49e3c9a19$var$SucceedsTilde,
    SuchThat: $560639d49e3c9a19$var$SuchThat,
    Sum: $560639d49e3c9a19$var$Sum,
    Sup: $560639d49e3c9a19$var$Sup,
    Superset: $560639d49e3c9a19$var$Superset,
    SupersetEqual: $560639d49e3c9a19$var$SupersetEqual,
    Supset: $560639d49e3c9a19$var$Supset,
    THOR: $560639d49e3c9a19$var$THOR,
    THORN: $560639d49e3c9a19$var$THORN$1,
    TRADE: $560639d49e3c9a19$var$TRADE,
    TSHcy: $560639d49e3c9a19$var$TSHcy,
    TScy: $560639d49e3c9a19$var$TScy,
    Tab: $560639d49e3c9a19$var$Tab,
    Tau: $560639d49e3c9a19$var$Tau$1,
    Tcaron: $560639d49e3c9a19$var$Tcaron,
    Tcedil: $560639d49e3c9a19$var$Tcedil,
    Tcy: $560639d49e3c9a19$var$Tcy,
    Tfr: $560639d49e3c9a19$var$Tfr,
    Therefore: $560639d49e3c9a19$var$Therefore,
    Theta: $560639d49e3c9a19$var$Theta$1,
    ThickSpace: $560639d49e3c9a19$var$ThickSpace,
    ThinSpace: $560639d49e3c9a19$var$ThinSpace,
    Tilde: $560639d49e3c9a19$var$Tilde,
    TildeEqual: $560639d49e3c9a19$var$TildeEqual,
    TildeFullEqual: $560639d49e3c9a19$var$TildeFullEqual,
    TildeTilde: $560639d49e3c9a19$var$TildeTilde,
    Topf: $560639d49e3c9a19$var$Topf,
    TripleDot: $560639d49e3c9a19$var$TripleDot,
    Tscr: $560639d49e3c9a19$var$Tscr,
    Tstrok: $560639d49e3c9a19$var$Tstrok,
    Uacut: $560639d49e3c9a19$var$Uacut,
    Uacute: $560639d49e3c9a19$var$Uacute$1,
    Uarr: $560639d49e3c9a19$var$Uarr,
    Uarrocir: $560639d49e3c9a19$var$Uarrocir,
    Ubrcy: $560639d49e3c9a19$var$Ubrcy,
    Ubreve: $560639d49e3c9a19$var$Ubreve,
    Ucir: $560639d49e3c9a19$var$Ucir,
    Ucirc: $560639d49e3c9a19$var$Ucirc$1,
    Ucy: $560639d49e3c9a19$var$Ucy,
    Udblac: $560639d49e3c9a19$var$Udblac,
    Ufr: $560639d49e3c9a19$var$Ufr,
    Ugrav: $560639d49e3c9a19$var$Ugrav,
    Ugrave: $560639d49e3c9a19$var$Ugrave$1,
    Umacr: $560639d49e3c9a19$var$Umacr,
    UnderBar: $560639d49e3c9a19$var$UnderBar,
    UnderBrace: $560639d49e3c9a19$var$UnderBrace,
    UnderBracket: $560639d49e3c9a19$var$UnderBracket,
    UnderParenthesis: $560639d49e3c9a19$var$UnderParenthesis,
    Union: $560639d49e3c9a19$var$Union,
    UnionPlus: $560639d49e3c9a19$var$UnionPlus,
    Uogon: $560639d49e3c9a19$var$Uogon,
    Uopf: $560639d49e3c9a19$var$Uopf,
    UpArrow: $560639d49e3c9a19$var$UpArrow,
    UpArrowBar: $560639d49e3c9a19$var$UpArrowBar,
    UpArrowDownArrow: $560639d49e3c9a19$var$UpArrowDownArrow,
    UpDownArrow: $560639d49e3c9a19$var$UpDownArrow,
    UpEquilibrium: $560639d49e3c9a19$var$UpEquilibrium,
    UpTee: $560639d49e3c9a19$var$UpTee,
    UpTeeArrow: $560639d49e3c9a19$var$UpTeeArrow,
    Uparrow: $560639d49e3c9a19$var$Uparrow,
    Updownarrow: $560639d49e3c9a19$var$Updownarrow,
    UpperLeftArrow: $560639d49e3c9a19$var$UpperLeftArrow,
    UpperRightArrow: $560639d49e3c9a19$var$UpperRightArrow,
    Upsi: $560639d49e3c9a19$var$Upsi,
    Upsilon: $560639d49e3c9a19$var$Upsilon$1,
    Uring: $560639d49e3c9a19$var$Uring,
    Uscr: $560639d49e3c9a19$var$Uscr,
    Utilde: $560639d49e3c9a19$var$Utilde,
    Uum: $560639d49e3c9a19$var$Uum,
    Uuml: $560639d49e3c9a19$var$Uuml$1,
    VDash: $560639d49e3c9a19$var$VDash,
    Vbar: $560639d49e3c9a19$var$Vbar,
    Vcy: $560639d49e3c9a19$var$Vcy,
    Vdash: $560639d49e3c9a19$var$Vdash,
    Vdashl: $560639d49e3c9a19$var$Vdashl,
    Vee: $560639d49e3c9a19$var$Vee,
    Verbar: $560639d49e3c9a19$var$Verbar,
    Vert: $560639d49e3c9a19$var$Vert,
    VerticalBar: $560639d49e3c9a19$var$VerticalBar,
    VerticalLine: $560639d49e3c9a19$var$VerticalLine,
    VerticalSeparator: $560639d49e3c9a19$var$VerticalSeparator,
    VerticalTilde: $560639d49e3c9a19$var$VerticalTilde,
    VeryThinSpace: $560639d49e3c9a19$var$VeryThinSpace,
    Vfr: $560639d49e3c9a19$var$Vfr,
    Vopf: $560639d49e3c9a19$var$Vopf,
    Vscr: $560639d49e3c9a19$var$Vscr,
    Vvdash: $560639d49e3c9a19$var$Vvdash,
    Wcirc: $560639d49e3c9a19$var$Wcirc,
    Wedge: $560639d49e3c9a19$var$Wedge,
    Wfr: $560639d49e3c9a19$var$Wfr,
    Wopf: $560639d49e3c9a19$var$Wopf,
    Wscr: $560639d49e3c9a19$var$Wscr,
    Xfr: $560639d49e3c9a19$var$Xfr,
    Xi: $560639d49e3c9a19$var$Xi$1,
    Xopf: $560639d49e3c9a19$var$Xopf,
    Xscr: $560639d49e3c9a19$var$Xscr,
    YAcy: $560639d49e3c9a19$var$YAcy,
    YIcy: $560639d49e3c9a19$var$YIcy,
    YUcy: $560639d49e3c9a19$var$YUcy,
    Yacut: $560639d49e3c9a19$var$Yacut,
    Yacute: $560639d49e3c9a19$var$Yacute$1,
    Ycirc: $560639d49e3c9a19$var$Ycirc,
    Ycy: $560639d49e3c9a19$var$Ycy,
    Yfr: $560639d49e3c9a19$var$Yfr,
    Yopf: $560639d49e3c9a19$var$Yopf,
    Yscr: $560639d49e3c9a19$var$Yscr,
    Yuml: $560639d49e3c9a19$var$Yuml$1,
    ZHcy: $560639d49e3c9a19$var$ZHcy,
    Zacute: $560639d49e3c9a19$var$Zacute,
    Zcaron: $560639d49e3c9a19$var$Zcaron,
    Zcy: $560639d49e3c9a19$var$Zcy,
    Zdot: $560639d49e3c9a19$var$Zdot,
    ZeroWidthSpace: $560639d49e3c9a19$var$ZeroWidthSpace,
    Zeta: $560639d49e3c9a19$var$Zeta$1,
    Zfr: $560639d49e3c9a19$var$Zfr,
    Zopf: $560639d49e3c9a19$var$Zopf,
    Zscr: $560639d49e3c9a19$var$Zscr,
    aacut: $560639d49e3c9a19$var$aacut,
    aacute: $560639d49e3c9a19$var$aacute$1,
    abreve: $560639d49e3c9a19$var$abreve,
    ac: $560639d49e3c9a19$var$ac,
    acE: $560639d49e3c9a19$var$acE,
    acd: $560639d49e3c9a19$var$acd,
    acir: $560639d49e3c9a19$var$acir,
    acirc: $560639d49e3c9a19$var$acirc$1,
    acut: $560639d49e3c9a19$var$acut,
    acute: $560639d49e3c9a19$var$acute$1,
    acy: $560639d49e3c9a19$var$acy,
    aeli: $560639d49e3c9a19$var$aeli,
    aelig: $560639d49e3c9a19$var$aelig$1,
    af: $560639d49e3c9a19$var$af,
    afr: $560639d49e3c9a19$var$afr,
    agrav: $560639d49e3c9a19$var$agrav,
    agrave: $560639d49e3c9a19$var$agrave$1,
    alefsym: $560639d49e3c9a19$var$alefsym$1,
    aleph: $560639d49e3c9a19$var$aleph,
    alpha: $560639d49e3c9a19$var$alpha$1,
    amacr: $560639d49e3c9a19$var$amacr,
    amalg: $560639d49e3c9a19$var$amalg,
    am: $560639d49e3c9a19$var$am,
    amp: $560639d49e3c9a19$var$amp$1,
    and: $560639d49e3c9a19$var$and$1,
    andand: $560639d49e3c9a19$var$andand,
    andd: $560639d49e3c9a19$var$andd,
    andslope: $560639d49e3c9a19$var$andslope,
    andv: $560639d49e3c9a19$var$andv,
    ang: $560639d49e3c9a19$var$ang$1,
    ange: $560639d49e3c9a19$var$ange,
    angle: $560639d49e3c9a19$var$angle,
    angmsd: $560639d49e3c9a19$var$angmsd,
    angmsdaa: $560639d49e3c9a19$var$angmsdaa,
    angmsdab: $560639d49e3c9a19$var$angmsdab,
    angmsdac: $560639d49e3c9a19$var$angmsdac,
    angmsdad: $560639d49e3c9a19$var$angmsdad,
    angmsdae: $560639d49e3c9a19$var$angmsdae,
    angmsdaf: $560639d49e3c9a19$var$angmsdaf,
    angmsdag: $560639d49e3c9a19$var$angmsdag,
    angmsdah: $560639d49e3c9a19$var$angmsdah,
    angrt: $560639d49e3c9a19$var$angrt,
    angrtvb: $560639d49e3c9a19$var$angrtvb,
    angrtvbd: $560639d49e3c9a19$var$angrtvbd,
    angsph: $560639d49e3c9a19$var$angsph,
    angst: $560639d49e3c9a19$var$angst,
    angzarr: $560639d49e3c9a19$var$angzarr,
    aogon: $560639d49e3c9a19$var$aogon,
    aopf: $560639d49e3c9a19$var$aopf,
    ap: $560639d49e3c9a19$var$ap,
    apE: $560639d49e3c9a19$var$apE,
    apacir: $560639d49e3c9a19$var$apacir,
    ape: $560639d49e3c9a19$var$ape,
    apid: $560639d49e3c9a19$var$apid,
    apos: $560639d49e3c9a19$var$apos,
    approx: $560639d49e3c9a19$var$approx,
    approxeq: $560639d49e3c9a19$var$approxeq,
    arin: $560639d49e3c9a19$var$arin,
    aring: $560639d49e3c9a19$var$aring$1,
    ascr: $560639d49e3c9a19$var$ascr,
    ast: $560639d49e3c9a19$var$ast,
    asymp: $560639d49e3c9a19$var$asymp$1,
    asympeq: $560639d49e3c9a19$var$asympeq,
    atild: $560639d49e3c9a19$var$atild,
    atilde: $560639d49e3c9a19$var$atilde$1,
    aum: $560639d49e3c9a19$var$aum,
    auml: $560639d49e3c9a19$var$auml$1,
    awconint: $560639d49e3c9a19$var$awconint,
    awint: $560639d49e3c9a19$var$awint,
    bNot: $560639d49e3c9a19$var$bNot,
    backcong: $560639d49e3c9a19$var$backcong,
    backepsilon: $560639d49e3c9a19$var$backepsilon,
    backprime: $560639d49e3c9a19$var$backprime,
    backsim: $560639d49e3c9a19$var$backsim,
    backsimeq: $560639d49e3c9a19$var$backsimeq,
    barvee: $560639d49e3c9a19$var$barvee,
    barwed: $560639d49e3c9a19$var$barwed,
    barwedge: $560639d49e3c9a19$var$barwedge,
    bbrk: $560639d49e3c9a19$var$bbrk,
    bbrktbrk: $560639d49e3c9a19$var$bbrktbrk,
    bcong: $560639d49e3c9a19$var$bcong,
    bcy: $560639d49e3c9a19$var$bcy,
    bdquo: $560639d49e3c9a19$var$bdquo$1,
    becaus: $560639d49e3c9a19$var$becaus,
    because: $560639d49e3c9a19$var$because,
    bemptyv: $560639d49e3c9a19$var$bemptyv,
    bepsi: $560639d49e3c9a19$var$bepsi,
    bernou: $560639d49e3c9a19$var$bernou,
    beta: $560639d49e3c9a19$var$beta$1,
    beth: $560639d49e3c9a19$var$beth,
    between: $560639d49e3c9a19$var$between,
    bfr: $560639d49e3c9a19$var$bfr,
    bigcap: $560639d49e3c9a19$var$bigcap,
    bigcirc: $560639d49e3c9a19$var$bigcirc,
    bigcup: $560639d49e3c9a19$var$bigcup,
    bigodot: $560639d49e3c9a19$var$bigodot,
    bigoplus: $560639d49e3c9a19$var$bigoplus,
    bigotimes: $560639d49e3c9a19$var$bigotimes,
    bigsqcup: $560639d49e3c9a19$var$bigsqcup,
    bigstar: $560639d49e3c9a19$var$bigstar,
    bigtriangledown: $560639d49e3c9a19$var$bigtriangledown,
    bigtriangleup: $560639d49e3c9a19$var$bigtriangleup,
    biguplus: $560639d49e3c9a19$var$biguplus,
    bigvee: $560639d49e3c9a19$var$bigvee,
    bigwedge: $560639d49e3c9a19$var$bigwedge,
    bkarow: $560639d49e3c9a19$var$bkarow,
    blacklozenge: $560639d49e3c9a19$var$blacklozenge,
    blacksquare: $560639d49e3c9a19$var$blacksquare,
    blacktriangle: $560639d49e3c9a19$var$blacktriangle,
    blacktriangledown: $560639d49e3c9a19$var$blacktriangledown,
    blacktriangleleft: $560639d49e3c9a19$var$blacktriangleleft,
    blacktriangleright: $560639d49e3c9a19$var$blacktriangleright,
    blank: $560639d49e3c9a19$var$blank,
    blk12: $560639d49e3c9a19$var$blk12,
    blk14: $560639d49e3c9a19$var$blk14,
    blk34: $560639d49e3c9a19$var$blk34,
    block: $560639d49e3c9a19$var$block,
    bne: $560639d49e3c9a19$var$bne,
    bnequiv: $560639d49e3c9a19$var$bnequiv,
    bnot: $560639d49e3c9a19$var$bnot,
    bopf: $560639d49e3c9a19$var$bopf,
    bot: $560639d49e3c9a19$var$bot,
    bottom: $560639d49e3c9a19$var$bottom,
    bowtie: $560639d49e3c9a19$var$bowtie,
    boxDL: $560639d49e3c9a19$var$boxDL,
    boxDR: $560639d49e3c9a19$var$boxDR,
    boxDl: $560639d49e3c9a19$var$boxDl,
    boxDr: $560639d49e3c9a19$var$boxDr,
    boxH: $560639d49e3c9a19$var$boxH,
    boxHD: $560639d49e3c9a19$var$boxHD,
    boxHU: $560639d49e3c9a19$var$boxHU,
    boxHd: $560639d49e3c9a19$var$boxHd,
    boxHu: $560639d49e3c9a19$var$boxHu,
    boxUL: $560639d49e3c9a19$var$boxUL,
    boxUR: $560639d49e3c9a19$var$boxUR,
    boxUl: $560639d49e3c9a19$var$boxUl,
    boxUr: $560639d49e3c9a19$var$boxUr,
    boxV: $560639d49e3c9a19$var$boxV,
    boxVH: $560639d49e3c9a19$var$boxVH,
    boxVL: $560639d49e3c9a19$var$boxVL,
    boxVR: $560639d49e3c9a19$var$boxVR,
    boxVh: $560639d49e3c9a19$var$boxVh,
    boxVl: $560639d49e3c9a19$var$boxVl,
    boxVr: $560639d49e3c9a19$var$boxVr,
    boxbox: $560639d49e3c9a19$var$boxbox,
    boxdL: $560639d49e3c9a19$var$boxdL,
    boxdR: $560639d49e3c9a19$var$boxdR,
    boxdl: $560639d49e3c9a19$var$boxdl,
    boxdr: $560639d49e3c9a19$var$boxdr,
    boxh: $560639d49e3c9a19$var$boxh,
    boxhD: $560639d49e3c9a19$var$boxhD,
    boxhU: $560639d49e3c9a19$var$boxhU,
    boxhd: $560639d49e3c9a19$var$boxhd,
    boxhu: $560639d49e3c9a19$var$boxhu,
    boxminus: $560639d49e3c9a19$var$boxminus,
    boxplus: $560639d49e3c9a19$var$boxplus,
    boxtimes: $560639d49e3c9a19$var$boxtimes,
    boxuL: $560639d49e3c9a19$var$boxuL,
    boxuR: $560639d49e3c9a19$var$boxuR,
    boxul: $560639d49e3c9a19$var$boxul,
    boxur: $560639d49e3c9a19$var$boxur,
    boxv: $560639d49e3c9a19$var$boxv,
    boxvH: $560639d49e3c9a19$var$boxvH,
    boxvL: $560639d49e3c9a19$var$boxvL,
    boxvR: $560639d49e3c9a19$var$boxvR,
    boxvh: $560639d49e3c9a19$var$boxvh,
    boxvl: $560639d49e3c9a19$var$boxvl,
    boxvr: $560639d49e3c9a19$var$boxvr,
    bprime: $560639d49e3c9a19$var$bprime,
    breve: $560639d49e3c9a19$var$breve,
    brvba: $560639d49e3c9a19$var$brvba,
    brvbar: $560639d49e3c9a19$var$brvbar$1,
    bscr: $560639d49e3c9a19$var$bscr,
    bsemi: $560639d49e3c9a19$var$bsemi,
    bsim: $560639d49e3c9a19$var$bsim,
    bsime: $560639d49e3c9a19$var$bsime,
    bsol: $560639d49e3c9a19$var$bsol,
    bsolb: $560639d49e3c9a19$var$bsolb,
    bsolhsub: $560639d49e3c9a19$var$bsolhsub,
    bull: $560639d49e3c9a19$var$bull$1,
    bullet: $560639d49e3c9a19$var$bullet,
    bump: $560639d49e3c9a19$var$bump,
    bumpE: $560639d49e3c9a19$var$bumpE,
    bumpe: $560639d49e3c9a19$var$bumpe,
    bumpeq: $560639d49e3c9a19$var$bumpeq,
    cacute: $560639d49e3c9a19$var$cacute,
    cap: $560639d49e3c9a19$var$cap$2,
    capand: $560639d49e3c9a19$var$capand,
    capbrcup: $560639d49e3c9a19$var$capbrcup,
    capcap: $560639d49e3c9a19$var$capcap,
    capcup: $560639d49e3c9a19$var$capcup,
    capdot: $560639d49e3c9a19$var$capdot,
    caps: $560639d49e3c9a19$var$caps,
    caret: $560639d49e3c9a19$var$caret,
    caron: $560639d49e3c9a19$var$caron,
    ccaps: $560639d49e3c9a19$var$ccaps,
    ccaron: $560639d49e3c9a19$var$ccaron,
    ccedi: $560639d49e3c9a19$var$ccedi,
    ccedil: $560639d49e3c9a19$var$ccedil$1,
    ccirc: $560639d49e3c9a19$var$ccirc,
    ccups: $560639d49e3c9a19$var$ccups,
    ccupssm: $560639d49e3c9a19$var$ccupssm,
    cdot: $560639d49e3c9a19$var$cdot,
    cedi: $560639d49e3c9a19$var$cedi,
    cedil: $560639d49e3c9a19$var$cedil$1,
    cemptyv: $560639d49e3c9a19$var$cemptyv,
    cen: $560639d49e3c9a19$var$cen,
    cent: $560639d49e3c9a19$var$cent$1,
    centerdot: $560639d49e3c9a19$var$centerdot,
    cfr: $560639d49e3c9a19$var$cfr,
    chcy: $560639d49e3c9a19$var$chcy,
    check: $560639d49e3c9a19$var$check,
    checkmark: $560639d49e3c9a19$var$checkmark,
    chi: $560639d49e3c9a19$var$chi$1,
    cir: $560639d49e3c9a19$var$cir,
    cirE: $560639d49e3c9a19$var$cirE,
    circ: $560639d49e3c9a19$var$circ$1,
    circeq: $560639d49e3c9a19$var$circeq,
    circlearrowleft: $560639d49e3c9a19$var$circlearrowleft,
    circlearrowright: $560639d49e3c9a19$var$circlearrowright,
    circledR: $560639d49e3c9a19$var$circledR,
    circledS: $560639d49e3c9a19$var$circledS,
    circledast: $560639d49e3c9a19$var$circledast,
    circledcirc: $560639d49e3c9a19$var$circledcirc,
    circleddash: $560639d49e3c9a19$var$circleddash,
    cire: $560639d49e3c9a19$var$cire,
    cirfnint: $560639d49e3c9a19$var$cirfnint,
    cirmid: $560639d49e3c9a19$var$cirmid,
    cirscir: $560639d49e3c9a19$var$cirscir,
    clubs: $560639d49e3c9a19$var$clubs$1,
    clubsuit: $560639d49e3c9a19$var$clubsuit,
    colon: $560639d49e3c9a19$var$colon$3,
    colone: $560639d49e3c9a19$var$colone,
    coloneq: $560639d49e3c9a19$var$coloneq,
    comma: $560639d49e3c9a19$var$comma$2,
    commat: $560639d49e3c9a19$var$commat,
    comp: $560639d49e3c9a19$var$comp,
    compfn: $560639d49e3c9a19$var$compfn,
    complement: $560639d49e3c9a19$var$complement,
    complexes: $560639d49e3c9a19$var$complexes,
    cong: $560639d49e3c9a19$var$cong$1,
    congdot: $560639d49e3c9a19$var$congdot,
    conint: $560639d49e3c9a19$var$conint,
    copf: $560639d49e3c9a19$var$copf,
    coprod: $560639d49e3c9a19$var$coprod,
    cop: $560639d49e3c9a19$var$cop,
    copy: $560639d49e3c9a19$var$copy$1,
    copysr: $560639d49e3c9a19$var$copysr,
    crarr: $560639d49e3c9a19$var$crarr$1,
    cross: $560639d49e3c9a19$var$cross,
    cscr: $560639d49e3c9a19$var$cscr,
    csub: $560639d49e3c9a19$var$csub,
    csube: $560639d49e3c9a19$var$csube,
    csup: $560639d49e3c9a19$var$csup,
    csupe: $560639d49e3c9a19$var$csupe,
    ctdot: $560639d49e3c9a19$var$ctdot,
    cudarrl: $560639d49e3c9a19$var$cudarrl,
    cudarrr: $560639d49e3c9a19$var$cudarrr,
    cuepr: $560639d49e3c9a19$var$cuepr,
    cuesc: $560639d49e3c9a19$var$cuesc,
    cularr: $560639d49e3c9a19$var$cularr,
    cularrp: $560639d49e3c9a19$var$cularrp,
    cup: $560639d49e3c9a19$var$cup$1,
    cupbrcap: $560639d49e3c9a19$var$cupbrcap,
    cupcap: $560639d49e3c9a19$var$cupcap,
    cupcup: $560639d49e3c9a19$var$cupcup,
    cupdot: $560639d49e3c9a19$var$cupdot,
    cupor: $560639d49e3c9a19$var$cupor,
    cups: $560639d49e3c9a19$var$cups,
    curarr: $560639d49e3c9a19$var$curarr,
    curarrm: $560639d49e3c9a19$var$curarrm,
    curlyeqprec: $560639d49e3c9a19$var$curlyeqprec,
    curlyeqsucc: $560639d49e3c9a19$var$curlyeqsucc,
    curlyvee: $560639d49e3c9a19$var$curlyvee,
    curlywedge: $560639d49e3c9a19$var$curlywedge,
    curre: $560639d49e3c9a19$var$curre,
    curren: $560639d49e3c9a19$var$curren$1,
    curvearrowleft: $560639d49e3c9a19$var$curvearrowleft,
    curvearrowright: $560639d49e3c9a19$var$curvearrowright,
    cuvee: $560639d49e3c9a19$var$cuvee,
    cuwed: $560639d49e3c9a19$var$cuwed,
    cwconint: $560639d49e3c9a19$var$cwconint,
    cwint: $560639d49e3c9a19$var$cwint,
    cylcty: $560639d49e3c9a19$var$cylcty,
    dArr: $560639d49e3c9a19$var$dArr$1,
    dHar: $560639d49e3c9a19$var$dHar,
    dagger: $560639d49e3c9a19$var$dagger$1,
    daleth: $560639d49e3c9a19$var$daleth,
    darr: $560639d49e3c9a19$var$darr$1,
    dash: $560639d49e3c9a19$var$dash$8,
    dashv: $560639d49e3c9a19$var$dashv,
    dbkarow: $560639d49e3c9a19$var$dbkarow,
    dblac: $560639d49e3c9a19$var$dblac,
    dcaron: $560639d49e3c9a19$var$dcaron,
    dcy: $560639d49e3c9a19$var$dcy,
    dd: $560639d49e3c9a19$var$dd$1,
    ddagger: $560639d49e3c9a19$var$ddagger,
    ddarr: $560639d49e3c9a19$var$ddarr,
    ddotseq: $560639d49e3c9a19$var$ddotseq,
    de: $560639d49e3c9a19$var$de,
    deg: $560639d49e3c9a19$var$deg$1,
    delta: $560639d49e3c9a19$var$delta$1,
    demptyv: $560639d49e3c9a19$var$demptyv,
    dfisht: $560639d49e3c9a19$var$dfisht,
    dfr: $560639d49e3c9a19$var$dfr,
    dharl: $560639d49e3c9a19$var$dharl,
    dharr: $560639d49e3c9a19$var$dharr,
    diam: $560639d49e3c9a19$var$diam,
    diamond: $560639d49e3c9a19$var$diamond,
    diamondsuit: $560639d49e3c9a19$var$diamondsuit,
    diams: $560639d49e3c9a19$var$diams$1,
    die: $560639d49e3c9a19$var$die,
    digamma: $560639d49e3c9a19$var$digamma,
    disin: $560639d49e3c9a19$var$disin,
    div: $560639d49e3c9a19$var$div,
    divid: $560639d49e3c9a19$var$divid,
    divide: $560639d49e3c9a19$var$divide$1,
    divideontimes: $560639d49e3c9a19$var$divideontimes,
    divonx: $560639d49e3c9a19$var$divonx,
    djcy: $560639d49e3c9a19$var$djcy,
    dlcorn: $560639d49e3c9a19$var$dlcorn,
    dlcrop: $560639d49e3c9a19$var$dlcrop,
    dollar: $560639d49e3c9a19$var$dollar,
    dopf: $560639d49e3c9a19$var$dopf,
    dot: $560639d49e3c9a19$var$dot$4,
    doteq: $560639d49e3c9a19$var$doteq,
    doteqdot: $560639d49e3c9a19$var$doteqdot,
    dotminus: $560639d49e3c9a19$var$dotminus,
    dotplus: $560639d49e3c9a19$var$dotplus,
    dotsquare: $560639d49e3c9a19$var$dotsquare,
    doublebarwedge: $560639d49e3c9a19$var$doublebarwedge,
    downarrow: $560639d49e3c9a19$var$downarrow,
    downdownarrows: $560639d49e3c9a19$var$downdownarrows,
    downharpoonleft: $560639d49e3c9a19$var$downharpoonleft,
    downharpoonright: $560639d49e3c9a19$var$downharpoonright,
    drbkarow: $560639d49e3c9a19$var$drbkarow,
    drcorn: $560639d49e3c9a19$var$drcorn,
    drcrop: $560639d49e3c9a19$var$drcrop,
    dscr: $560639d49e3c9a19$var$dscr,
    dscy: $560639d49e3c9a19$var$dscy,
    dsol: $560639d49e3c9a19$var$dsol,
    dstrok: $560639d49e3c9a19$var$dstrok,
    dtdot: $560639d49e3c9a19$var$dtdot,
    dtri: $560639d49e3c9a19$var$dtri,
    dtrif: $560639d49e3c9a19$var$dtrif,
    duarr: $560639d49e3c9a19$var$duarr,
    duhar: $560639d49e3c9a19$var$duhar,
    dwangle: $560639d49e3c9a19$var$dwangle,
    dzcy: $560639d49e3c9a19$var$dzcy,
    dzigrarr: $560639d49e3c9a19$var$dzigrarr,
    eDDot: $560639d49e3c9a19$var$eDDot,
    eDot: $560639d49e3c9a19$var$eDot,
    eacut: $560639d49e3c9a19$var$eacut,
    eacute: $560639d49e3c9a19$var$eacute$1,
    easter: $560639d49e3c9a19$var$easter,
    ecaron: $560639d49e3c9a19$var$ecaron,
    ecir: $560639d49e3c9a19$var$ecir,
    ecirc: $560639d49e3c9a19$var$ecirc$1,
    ecolon: $560639d49e3c9a19$var$ecolon,
    ecy: $560639d49e3c9a19$var$ecy,
    edot: $560639d49e3c9a19$var$edot,
    ee: $560639d49e3c9a19$var$ee,
    efDot: $560639d49e3c9a19$var$efDot,
    efr: $560639d49e3c9a19$var$efr,
    eg: $560639d49e3c9a19$var$eg,
    egrav: $560639d49e3c9a19$var$egrav,
    egrave: $560639d49e3c9a19$var$egrave$1,
    egs: $560639d49e3c9a19$var$egs,
    egsdot: $560639d49e3c9a19$var$egsdot,
    el: $560639d49e3c9a19$var$el,
    elinters: $560639d49e3c9a19$var$elinters,
    ell: $560639d49e3c9a19$var$ell,
    els: $560639d49e3c9a19$var$els,
    elsdot: $560639d49e3c9a19$var$elsdot,
    emacr: $560639d49e3c9a19$var$emacr,
    empty: $560639d49e3c9a19$var$empty$3,
    emptyset: $560639d49e3c9a19$var$emptyset,
    emptyv: $560639d49e3c9a19$var$emptyv,
    emsp13: $560639d49e3c9a19$var$emsp13,
    emsp14: $560639d49e3c9a19$var$emsp14,
    emsp: $560639d49e3c9a19$var$emsp$1,
    eng: $560639d49e3c9a19$var$eng,
    ensp: $560639d49e3c9a19$var$ensp$1,
    eogon: $560639d49e3c9a19$var$eogon,
    eopf: $560639d49e3c9a19$var$eopf,
    epar: $560639d49e3c9a19$var$epar,
    eparsl: $560639d49e3c9a19$var$eparsl,
    eplus: $560639d49e3c9a19$var$eplus,
    epsi: $560639d49e3c9a19$var$epsi,
    epsilon: $560639d49e3c9a19$var$epsilon$1,
    epsiv: $560639d49e3c9a19$var$epsiv,
    eqcirc: $560639d49e3c9a19$var$eqcirc,
    eqcolon: $560639d49e3c9a19$var$eqcolon,
    eqsim: $560639d49e3c9a19$var$eqsim,
    eqslantgtr: $560639d49e3c9a19$var$eqslantgtr,
    eqslantless: $560639d49e3c9a19$var$eqslantless,
    equals: $560639d49e3c9a19$var$equals,
    equest: $560639d49e3c9a19$var$equest,
    equiv: $560639d49e3c9a19$var$equiv$1,
    equivDD: $560639d49e3c9a19$var$equivDD,
    eqvparsl: $560639d49e3c9a19$var$eqvparsl,
    erDot: $560639d49e3c9a19$var$erDot,
    erarr: $560639d49e3c9a19$var$erarr,
    escr: $560639d49e3c9a19$var$escr,
    esdot: $560639d49e3c9a19$var$esdot,
    esim: $560639d49e3c9a19$var$esim,
    eta: $560639d49e3c9a19$var$eta$1,
    et: $560639d49e3c9a19$var$et,
    eth: $560639d49e3c9a19$var$eth$1,
    eum: $560639d49e3c9a19$var$eum,
    euml: $560639d49e3c9a19$var$euml$1,
    euro: $560639d49e3c9a19$var$euro$1,
    excl: $560639d49e3c9a19$var$excl,
    exist: $560639d49e3c9a19$var$exist$1,
    expectation: $560639d49e3c9a19$var$expectation,
    exponentiale: $560639d49e3c9a19$var$exponentiale,
    fallingdotseq: $560639d49e3c9a19$var$fallingdotseq,
    fcy: $560639d49e3c9a19$var$fcy,
    female: $560639d49e3c9a19$var$female,
    ffilig: $560639d49e3c9a19$var$ffilig,
    fflig: $560639d49e3c9a19$var$fflig,
    ffllig: $560639d49e3c9a19$var$ffllig,
    ffr: $560639d49e3c9a19$var$ffr,
    filig: $560639d49e3c9a19$var$filig,
    fjlig: $560639d49e3c9a19$var$fjlig,
    flat: $560639d49e3c9a19$var$flat,
    fllig: $560639d49e3c9a19$var$fllig,
    fltns: $560639d49e3c9a19$var$fltns,
    fnof: $560639d49e3c9a19$var$fnof$1,
    fopf: $560639d49e3c9a19$var$fopf,
    forall: $560639d49e3c9a19$var$forall$1,
    fork: $560639d49e3c9a19$var$fork,
    forkv: $560639d49e3c9a19$var$forkv,
    fpartint: $560639d49e3c9a19$var$fpartint,
    frac1: $560639d49e3c9a19$var$frac1,
    frac12: $560639d49e3c9a19$var$frac12$1,
    frac13: $560639d49e3c9a19$var$frac13,
    frac14: $560639d49e3c9a19$var$frac14$1,
    frac15: $560639d49e3c9a19$var$frac15,
    frac16: $560639d49e3c9a19$var$frac16,
    frac18: $560639d49e3c9a19$var$frac18,
    frac23: $560639d49e3c9a19$var$frac23,
    frac25: $560639d49e3c9a19$var$frac25,
    frac3: $560639d49e3c9a19$var$frac3,
    frac34: $560639d49e3c9a19$var$frac34$1,
    frac35: $560639d49e3c9a19$var$frac35,
    frac38: $560639d49e3c9a19$var$frac38,
    frac45: $560639d49e3c9a19$var$frac45,
    frac56: $560639d49e3c9a19$var$frac56,
    frac58: $560639d49e3c9a19$var$frac58,
    frac78: $560639d49e3c9a19$var$frac78,
    frasl: $560639d49e3c9a19$var$frasl$1,
    frown: $560639d49e3c9a19$var$frown,
    fscr: $560639d49e3c9a19$var$fscr,
    gE: $560639d49e3c9a19$var$gE,
    gEl: $560639d49e3c9a19$var$gEl,
    gacute: $560639d49e3c9a19$var$gacute,
    gamma: $560639d49e3c9a19$var$gamma$1,
    gammad: $560639d49e3c9a19$var$gammad,
    gap: $560639d49e3c9a19$var$gap,
    gbreve: $560639d49e3c9a19$var$gbreve,
    gcirc: $560639d49e3c9a19$var$gcirc,
    gcy: $560639d49e3c9a19$var$gcy,
    gdot: $560639d49e3c9a19$var$gdot,
    ge: $560639d49e3c9a19$var$ge$1,
    gel: $560639d49e3c9a19$var$gel,
    geq: $560639d49e3c9a19$var$geq,
    geqq: $560639d49e3c9a19$var$geqq,
    geqslant: $560639d49e3c9a19$var$geqslant,
    ges: $560639d49e3c9a19$var$ges,
    gescc: $560639d49e3c9a19$var$gescc,
    gesdot: $560639d49e3c9a19$var$gesdot,
    gesdoto: $560639d49e3c9a19$var$gesdoto,
    gesdotol: $560639d49e3c9a19$var$gesdotol,
    gesl: $560639d49e3c9a19$var$gesl,
    gesles: $560639d49e3c9a19$var$gesles,
    gfr: $560639d49e3c9a19$var$gfr,
    gg: $560639d49e3c9a19$var$gg,
    ggg: $560639d49e3c9a19$var$ggg,
    gimel: $560639d49e3c9a19$var$gimel,
    gjcy: $560639d49e3c9a19$var$gjcy,
    gl: $560639d49e3c9a19$var$gl,
    glE: $560639d49e3c9a19$var$glE,
    gla: $560639d49e3c9a19$var$gla,
    glj: $560639d49e3c9a19$var$glj,
    gnE: $560639d49e3c9a19$var$gnE,
    gnap: $560639d49e3c9a19$var$gnap,
    gnapprox: $560639d49e3c9a19$var$gnapprox,
    gne: $560639d49e3c9a19$var$gne,
    gneq: $560639d49e3c9a19$var$gneq,
    gneqq: $560639d49e3c9a19$var$gneqq,
    gnsim: $560639d49e3c9a19$var$gnsim,
    gopf: $560639d49e3c9a19$var$gopf,
    grave: $560639d49e3c9a19$var$grave,
    gscr: $560639d49e3c9a19$var$gscr,
    gsim: $560639d49e3c9a19$var$gsim,
    gsime: $560639d49e3c9a19$var$gsime,
    gsiml: $560639d49e3c9a19$var$gsiml,
    g: $560639d49e3c9a19$var$g,
    gt: $560639d49e3c9a19$var$gt$1,
    gtcc: $560639d49e3c9a19$var$gtcc,
    gtcir: $560639d49e3c9a19$var$gtcir,
    gtdot: $560639d49e3c9a19$var$gtdot,
    gtlPar: $560639d49e3c9a19$var$gtlPar,
    gtquest: $560639d49e3c9a19$var$gtquest,
    gtrapprox: $560639d49e3c9a19$var$gtrapprox,
    gtrarr: $560639d49e3c9a19$var$gtrarr,
    gtrdot: $560639d49e3c9a19$var$gtrdot,
    gtreqless: $560639d49e3c9a19$var$gtreqless,
    gtreqqless: $560639d49e3c9a19$var$gtreqqless,
    gtrless: $560639d49e3c9a19$var$gtrless,
    gtrsim: $560639d49e3c9a19$var$gtrsim,
    gvertneqq: $560639d49e3c9a19$var$gvertneqq,
    gvnE: $560639d49e3c9a19$var$gvnE,
    hArr: $560639d49e3c9a19$var$hArr$1,
    hairsp: $560639d49e3c9a19$var$hairsp,
    half: $560639d49e3c9a19$var$half,
    hamilt: $560639d49e3c9a19$var$hamilt,
    hardcy: $560639d49e3c9a19$var$hardcy,
    harr: $560639d49e3c9a19$var$harr$1,
    harrcir: $560639d49e3c9a19$var$harrcir,
    harrw: $560639d49e3c9a19$var$harrw,
    hbar: $560639d49e3c9a19$var$hbar,
    hcirc: $560639d49e3c9a19$var$hcirc,
    hearts: $560639d49e3c9a19$var$hearts$1,
    heartsuit: $560639d49e3c9a19$var$heartsuit,
    hellip: $560639d49e3c9a19$var$hellip$1,
    hercon: $560639d49e3c9a19$var$hercon,
    hfr: $560639d49e3c9a19$var$hfr,
    hksearow: $560639d49e3c9a19$var$hksearow,
    hkswarow: $560639d49e3c9a19$var$hkswarow,
    hoarr: $560639d49e3c9a19$var$hoarr,
    homtht: $560639d49e3c9a19$var$homtht,
    hookleftarrow: $560639d49e3c9a19$var$hookleftarrow,
    hookrightarrow: $560639d49e3c9a19$var$hookrightarrow,
    hopf: $560639d49e3c9a19$var$hopf,
    horbar: $560639d49e3c9a19$var$horbar,
    hscr: $560639d49e3c9a19$var$hscr,
    hslash: $560639d49e3c9a19$var$hslash,
    hstrok: $560639d49e3c9a19$var$hstrok,
    hybull: $560639d49e3c9a19$var$hybull,
    hyphen: $560639d49e3c9a19$var$hyphen,
    iacut: $560639d49e3c9a19$var$iacut,
    iacute: $560639d49e3c9a19$var$iacute$1,
    ic: $560639d49e3c9a19$var$ic,
    icir: $560639d49e3c9a19$var$icir,
    icirc: $560639d49e3c9a19$var$icirc$1,
    icy: $560639d49e3c9a19$var$icy,
    iecy: $560639d49e3c9a19$var$iecy,
    iexc: $560639d49e3c9a19$var$iexc,
    iexcl: $560639d49e3c9a19$var$iexcl$1,
    iff: $560639d49e3c9a19$var$iff,
    ifr: $560639d49e3c9a19$var$ifr,
    igrav: $560639d49e3c9a19$var$igrav,
    igrave: $560639d49e3c9a19$var$igrave$1,
    ii: $560639d49e3c9a19$var$ii,
    iiiint: $560639d49e3c9a19$var$iiiint,
    iiint: $560639d49e3c9a19$var$iiint,
    iinfin: $560639d49e3c9a19$var$iinfin,
    iiota: $560639d49e3c9a19$var$iiota,
    ijlig: $560639d49e3c9a19$var$ijlig,
    imacr: $560639d49e3c9a19$var$imacr,
    image: $560639d49e3c9a19$var$image$3,
    imagline: $560639d49e3c9a19$var$imagline,
    imagpart: $560639d49e3c9a19$var$imagpart,
    imath: $560639d49e3c9a19$var$imath,
    imof: $560639d49e3c9a19$var$imof,
    imped: $560639d49e3c9a19$var$imped,
    incare: $560639d49e3c9a19$var$incare,
    infin: $560639d49e3c9a19$var$infin$1,
    infintie: $560639d49e3c9a19$var$infintie,
    inodot: $560639d49e3c9a19$var$inodot,
    int: $560639d49e3c9a19$var$int$1,
    intcal: $560639d49e3c9a19$var$intcal,
    integers: $560639d49e3c9a19$var$integers,
    intercal: $560639d49e3c9a19$var$intercal,
    intlarhk: $560639d49e3c9a19$var$intlarhk,
    intprod: $560639d49e3c9a19$var$intprod,
    iocy: $560639d49e3c9a19$var$iocy,
    iogon: $560639d49e3c9a19$var$iogon,
    iopf: $560639d49e3c9a19$var$iopf,
    iota: $560639d49e3c9a19$var$iota$1,
    iprod: $560639d49e3c9a19$var$iprod,
    iques: $560639d49e3c9a19$var$iques,
    iquest: $560639d49e3c9a19$var$iquest$1,
    iscr: $560639d49e3c9a19$var$iscr,
    isin: $560639d49e3c9a19$var$isin$1,
    isinE: $560639d49e3c9a19$var$isinE,
    isindot: $560639d49e3c9a19$var$isindot,
    isins: $560639d49e3c9a19$var$isins,
    isinsv: $560639d49e3c9a19$var$isinsv,
    isinv: $560639d49e3c9a19$var$isinv,
    it: $560639d49e3c9a19$var$it,
    itilde: $560639d49e3c9a19$var$itilde,
    iukcy: $560639d49e3c9a19$var$iukcy,
    ium: $560639d49e3c9a19$var$ium,
    iuml: $560639d49e3c9a19$var$iuml$1,
    jcirc: $560639d49e3c9a19$var$jcirc,
    jcy: $560639d49e3c9a19$var$jcy,
    jfr: $560639d49e3c9a19$var$jfr,
    jmath: $560639d49e3c9a19$var$jmath,
    jopf: $560639d49e3c9a19$var$jopf,
    jscr: $560639d49e3c9a19$var$jscr,
    jsercy: $560639d49e3c9a19$var$jsercy,
    jukcy: $560639d49e3c9a19$var$jukcy,
    kappa: $560639d49e3c9a19$var$kappa$1,
    kappav: $560639d49e3c9a19$var$kappav,
    kcedil: $560639d49e3c9a19$var$kcedil,
    kcy: $560639d49e3c9a19$var$kcy,
    kfr: $560639d49e3c9a19$var$kfr,
    kgreen: $560639d49e3c9a19$var$kgreen,
    khcy: $560639d49e3c9a19$var$khcy,
    kjcy: $560639d49e3c9a19$var$kjcy,
    kopf: $560639d49e3c9a19$var$kopf,
    kscr: $560639d49e3c9a19$var$kscr,
    lAarr: $560639d49e3c9a19$var$lAarr,
    lArr: $560639d49e3c9a19$var$lArr$1,
    lAtail: $560639d49e3c9a19$var$lAtail,
    lBarr: $560639d49e3c9a19$var$lBarr,
    lE: $560639d49e3c9a19$var$lE,
    lEg: $560639d49e3c9a19$var$lEg,
    lHar: $560639d49e3c9a19$var$lHar,
    lacute: $560639d49e3c9a19$var$lacute,
    laemptyv: $560639d49e3c9a19$var$laemptyv,
    lagran: $560639d49e3c9a19$var$lagran,
    lambda: $560639d49e3c9a19$var$lambda$1,
    lang: $560639d49e3c9a19$var$lang$1,
    langd: $560639d49e3c9a19$var$langd,
    langle: $560639d49e3c9a19$var$langle,
    lap: $560639d49e3c9a19$var$lap,
    laqu: $560639d49e3c9a19$var$laqu,
    laquo: $560639d49e3c9a19$var$laquo$1,
    larr: $560639d49e3c9a19$var$larr$1,
    larrb: $560639d49e3c9a19$var$larrb,
    larrbfs: $560639d49e3c9a19$var$larrbfs,
    larrfs: $560639d49e3c9a19$var$larrfs,
    larrhk: $560639d49e3c9a19$var$larrhk,
    larrlp: $560639d49e3c9a19$var$larrlp,
    larrpl: $560639d49e3c9a19$var$larrpl,
    larrsim: $560639d49e3c9a19$var$larrsim,
    larrtl: $560639d49e3c9a19$var$larrtl,
    lat: $560639d49e3c9a19$var$lat,
    latail: $560639d49e3c9a19$var$latail,
    late: $560639d49e3c9a19$var$late,
    lates: $560639d49e3c9a19$var$lates,
    lbarr: $560639d49e3c9a19$var$lbarr,
    lbbrk: $560639d49e3c9a19$var$lbbrk,
    lbrace: $560639d49e3c9a19$var$lbrace,
    lbrack: $560639d49e3c9a19$var$lbrack,
    lbrke: $560639d49e3c9a19$var$lbrke,
    lbrksld: $560639d49e3c9a19$var$lbrksld,
    lbrkslu: $560639d49e3c9a19$var$lbrkslu,
    lcaron: $560639d49e3c9a19$var$lcaron,
    lcedil: $560639d49e3c9a19$var$lcedil,
    lceil: $560639d49e3c9a19$var$lceil$1,
    lcub: $560639d49e3c9a19$var$lcub,
    lcy: $560639d49e3c9a19$var$lcy,
    ldca: $560639d49e3c9a19$var$ldca,
    ldquo: $560639d49e3c9a19$var$ldquo$1,
    ldquor: $560639d49e3c9a19$var$ldquor,
    ldrdhar: $560639d49e3c9a19$var$ldrdhar,
    ldrushar: $560639d49e3c9a19$var$ldrushar,
    ldsh: $560639d49e3c9a19$var$ldsh,
    le: $560639d49e3c9a19$var$le$1,
    leftarrow: $560639d49e3c9a19$var$leftarrow,
    leftarrowtail: $560639d49e3c9a19$var$leftarrowtail,
    leftharpoondown: $560639d49e3c9a19$var$leftharpoondown,
    leftharpoonup: $560639d49e3c9a19$var$leftharpoonup,
    leftleftarrows: $560639d49e3c9a19$var$leftleftarrows,
    leftrightarrow: $560639d49e3c9a19$var$leftrightarrow,
    leftrightarrows: $560639d49e3c9a19$var$leftrightarrows,
    leftrightharpoons: $560639d49e3c9a19$var$leftrightharpoons,
    leftrightsquigarrow: $560639d49e3c9a19$var$leftrightsquigarrow,
    leftthreetimes: $560639d49e3c9a19$var$leftthreetimes,
    leg: $560639d49e3c9a19$var$leg,
    leq: $560639d49e3c9a19$var$leq,
    leqq: $560639d49e3c9a19$var$leqq,
    leqslant: $560639d49e3c9a19$var$leqslant,
    les: $560639d49e3c9a19$var$les,
    lescc: $560639d49e3c9a19$var$lescc,
    lesdot: $560639d49e3c9a19$var$lesdot,
    lesdoto: $560639d49e3c9a19$var$lesdoto,
    lesdotor: $560639d49e3c9a19$var$lesdotor,
    lesg: $560639d49e3c9a19$var$lesg,
    lesges: $560639d49e3c9a19$var$lesges,
    lessapprox: $560639d49e3c9a19$var$lessapprox,
    lessdot: $560639d49e3c9a19$var$lessdot,
    lesseqgtr: $560639d49e3c9a19$var$lesseqgtr,
    lesseqqgtr: $560639d49e3c9a19$var$lesseqqgtr,
    lessgtr: $560639d49e3c9a19$var$lessgtr,
    lesssim: $560639d49e3c9a19$var$lesssim,
    lfisht: $560639d49e3c9a19$var$lfisht,
    lfloor: $560639d49e3c9a19$var$lfloor$1,
    lfr: $560639d49e3c9a19$var$lfr,
    lg: $560639d49e3c9a19$var$lg,
    lgE: $560639d49e3c9a19$var$lgE,
    lhard: $560639d49e3c9a19$var$lhard,
    lharu: $560639d49e3c9a19$var$lharu,
    lharul: $560639d49e3c9a19$var$lharul,
    lhblk: $560639d49e3c9a19$var$lhblk,
    ljcy: $560639d49e3c9a19$var$ljcy,
    ll: $560639d49e3c9a19$var$ll,
    llarr: $560639d49e3c9a19$var$llarr,
    llcorner: $560639d49e3c9a19$var$llcorner,
    llhard: $560639d49e3c9a19$var$llhard,
    lltri: $560639d49e3c9a19$var$lltri,
    lmidot: $560639d49e3c9a19$var$lmidot,
    lmoust: $560639d49e3c9a19$var$lmoust,
    lmoustache: $560639d49e3c9a19$var$lmoustache,
    lnE: $560639d49e3c9a19$var$lnE,
    lnap: $560639d49e3c9a19$var$lnap,
    lnapprox: $560639d49e3c9a19$var$lnapprox,
    lne: $560639d49e3c9a19$var$lne,
    lneq: $560639d49e3c9a19$var$lneq,
    lneqq: $560639d49e3c9a19$var$lneqq,
    lnsim: $560639d49e3c9a19$var$lnsim,
    loang: $560639d49e3c9a19$var$loang,
    loarr: $560639d49e3c9a19$var$loarr,
    lobrk: $560639d49e3c9a19$var$lobrk,
    longleftarrow: $560639d49e3c9a19$var$longleftarrow,
    longleftrightarrow: $560639d49e3c9a19$var$longleftrightarrow,
    longmapsto: $560639d49e3c9a19$var$longmapsto,
    longrightarrow: $560639d49e3c9a19$var$longrightarrow,
    looparrowleft: $560639d49e3c9a19$var$looparrowleft,
    looparrowright: $560639d49e3c9a19$var$looparrowright,
    lopar: $560639d49e3c9a19$var$lopar,
    lopf: $560639d49e3c9a19$var$lopf,
    loplus: $560639d49e3c9a19$var$loplus,
    lotimes: $560639d49e3c9a19$var$lotimes,
    lowast: $560639d49e3c9a19$var$lowast$1,
    lowbar: $560639d49e3c9a19$var$lowbar,
    loz: $560639d49e3c9a19$var$loz$1,
    lozenge: $560639d49e3c9a19$var$lozenge,
    lozf: $560639d49e3c9a19$var$lozf,
    lpar: $560639d49e3c9a19$var$lpar,
    lparlt: $560639d49e3c9a19$var$lparlt,
    lrarr: $560639d49e3c9a19$var$lrarr,
    lrcorner: $560639d49e3c9a19$var$lrcorner,
    lrhar: $560639d49e3c9a19$var$lrhar,
    lrhard: $560639d49e3c9a19$var$lrhard,
    lrm: $560639d49e3c9a19$var$lrm$1,
    lrtri: $560639d49e3c9a19$var$lrtri,
    lsaquo: $560639d49e3c9a19$var$lsaquo$1,
    lscr: $560639d49e3c9a19$var$lscr,
    lsh: $560639d49e3c9a19$var$lsh,
    lsim: $560639d49e3c9a19$var$lsim,
    lsime: $560639d49e3c9a19$var$lsime,
    lsimg: $560639d49e3c9a19$var$lsimg,
    lsqb: $560639d49e3c9a19$var$lsqb,
    lsquo: $560639d49e3c9a19$var$lsquo$1,
    lsquor: $560639d49e3c9a19$var$lsquor,
    lstrok: $560639d49e3c9a19$var$lstrok,
    l: $560639d49e3c9a19$var$l,
    lt: $560639d49e3c9a19$var$lt$1,
    ltcc: $560639d49e3c9a19$var$ltcc,
    ltcir: $560639d49e3c9a19$var$ltcir,
    ltdot: $560639d49e3c9a19$var$ltdot,
    lthree: $560639d49e3c9a19$var$lthree,
    ltimes: $560639d49e3c9a19$var$ltimes,
    ltlarr: $560639d49e3c9a19$var$ltlarr,
    ltquest: $560639d49e3c9a19$var$ltquest,
    ltrPar: $560639d49e3c9a19$var$ltrPar,
    ltri: $560639d49e3c9a19$var$ltri,
    ltrie: $560639d49e3c9a19$var$ltrie,
    ltrif: $560639d49e3c9a19$var$ltrif,
    lurdshar: $560639d49e3c9a19$var$lurdshar,
    luruhar: $560639d49e3c9a19$var$luruhar,
    lvertneqq: $560639d49e3c9a19$var$lvertneqq,
    lvnE: $560639d49e3c9a19$var$lvnE,
    mDDot: $560639d49e3c9a19$var$mDDot,
    mac: $560639d49e3c9a19$var$mac,
    macr: $560639d49e3c9a19$var$macr$1,
    male: $560639d49e3c9a19$var$male,
    malt: $560639d49e3c9a19$var$malt,
    maltese: $560639d49e3c9a19$var$maltese,
    map: $560639d49e3c9a19$var$map$1,
    mapsto: $560639d49e3c9a19$var$mapsto,
    mapstodown: $560639d49e3c9a19$var$mapstodown,
    mapstoleft: $560639d49e3c9a19$var$mapstoleft,
    mapstoup: $560639d49e3c9a19$var$mapstoup,
    marker: $560639d49e3c9a19$var$marker,
    mcomma: $560639d49e3c9a19$var$mcomma,
    mcy: $560639d49e3c9a19$var$mcy,
    mdash: $560639d49e3c9a19$var$mdash$1,
    measuredangle: $560639d49e3c9a19$var$measuredangle,
    mfr: $560639d49e3c9a19$var$mfr,
    mho: $560639d49e3c9a19$var$mho,
    micr: $560639d49e3c9a19$var$micr,
    micro: $560639d49e3c9a19$var$micro$1,
    mid: $560639d49e3c9a19$var$mid,
    midast: $560639d49e3c9a19$var$midast,
    midcir: $560639d49e3c9a19$var$midcir,
    middo: $560639d49e3c9a19$var$middo,
    middot: $560639d49e3c9a19$var$middot$1,
    minus: $560639d49e3c9a19$var$minus$1,
    minusb: $560639d49e3c9a19$var$minusb,
    minusd: $560639d49e3c9a19$var$minusd,
    minusdu: $560639d49e3c9a19$var$minusdu,
    mlcp: $560639d49e3c9a19$var$mlcp,
    mldr: $560639d49e3c9a19$var$mldr,
    mnplus: $560639d49e3c9a19$var$mnplus,
    models: $560639d49e3c9a19$var$models,
    mopf: $560639d49e3c9a19$var$mopf,
    mp: $560639d49e3c9a19$var$mp,
    mscr: $560639d49e3c9a19$var$mscr,
    mstpos: $560639d49e3c9a19$var$mstpos,
    mu: $560639d49e3c9a19$var$mu$1,
    multimap: $560639d49e3c9a19$var$multimap,
    mumap: $560639d49e3c9a19$var$mumap,
    nGg: $560639d49e3c9a19$var$nGg,
    nGt: $560639d49e3c9a19$var$nGt,
    nGtv: $560639d49e3c9a19$var$nGtv,
    nLeftarrow: $560639d49e3c9a19$var$nLeftarrow,
    nLeftrightarrow: $560639d49e3c9a19$var$nLeftrightarrow,
    nLl: $560639d49e3c9a19$var$nLl,
    nLt: $560639d49e3c9a19$var$nLt,
    nLtv: $560639d49e3c9a19$var$nLtv,
    nRightarrow: $560639d49e3c9a19$var$nRightarrow,
    nVDash: $560639d49e3c9a19$var$nVDash,
    nVdash: $560639d49e3c9a19$var$nVdash,
    nabla: $560639d49e3c9a19$var$nabla$1,
    nacute: $560639d49e3c9a19$var$nacute,
    nang: $560639d49e3c9a19$var$nang,
    nap: $560639d49e3c9a19$var$nap,
    napE: $560639d49e3c9a19$var$napE,
    napid: $560639d49e3c9a19$var$napid,
    napos: $560639d49e3c9a19$var$napos,
    napprox: $560639d49e3c9a19$var$napprox,
    natur: $560639d49e3c9a19$var$natur,
    natural: $560639d49e3c9a19$var$natural,
    naturals: $560639d49e3c9a19$var$naturals,
    nbs: $560639d49e3c9a19$var$nbs,
    nbsp: $560639d49e3c9a19$var$nbsp$1,
    nbump: $560639d49e3c9a19$var$nbump,
    nbumpe: $560639d49e3c9a19$var$nbumpe,
    ncap: $560639d49e3c9a19$var$ncap,
    ncaron: $560639d49e3c9a19$var$ncaron,
    ncedil: $560639d49e3c9a19$var$ncedil,
    ncong: $560639d49e3c9a19$var$ncong,
    ncongdot: $560639d49e3c9a19$var$ncongdot,
    ncup: $560639d49e3c9a19$var$ncup,
    ncy: $560639d49e3c9a19$var$ncy,
    ndash: $560639d49e3c9a19$var$ndash$1,
    ne: $560639d49e3c9a19$var$ne$1,
    neArr: $560639d49e3c9a19$var$neArr,
    nearhk: $560639d49e3c9a19$var$nearhk,
    nearr: $560639d49e3c9a19$var$nearr,
    nearrow: $560639d49e3c9a19$var$nearrow,
    nedot: $560639d49e3c9a19$var$nedot,
    nequiv: $560639d49e3c9a19$var$nequiv,
    nesear: $560639d49e3c9a19$var$nesear,
    nesim: $560639d49e3c9a19$var$nesim,
    nexist: $560639d49e3c9a19$var$nexist,
    nexists: $560639d49e3c9a19$var$nexists,
    nfr: $560639d49e3c9a19$var$nfr,
    ngE: $560639d49e3c9a19$var$ngE,
    nge: $560639d49e3c9a19$var$nge,
    ngeq: $560639d49e3c9a19$var$ngeq,
    ngeqq: $560639d49e3c9a19$var$ngeqq,
    ngeqslant: $560639d49e3c9a19$var$ngeqslant,
    nges: $560639d49e3c9a19$var$nges,
    ngsim: $560639d49e3c9a19$var$ngsim,
    ngt: $560639d49e3c9a19$var$ngt,
    ngtr: $560639d49e3c9a19$var$ngtr,
    nhArr: $560639d49e3c9a19$var$nhArr,
    nharr: $560639d49e3c9a19$var$nharr,
    nhpar: $560639d49e3c9a19$var$nhpar,
    ni: $560639d49e3c9a19$var$ni$1,
    nis: $560639d49e3c9a19$var$nis,
    nisd: $560639d49e3c9a19$var$nisd,
    niv: $560639d49e3c9a19$var$niv,
    njcy: $560639d49e3c9a19$var$njcy,
    nlArr: $560639d49e3c9a19$var$nlArr,
    nlE: $560639d49e3c9a19$var$nlE,
    nlarr: $560639d49e3c9a19$var$nlarr,
    nldr: $560639d49e3c9a19$var$nldr,
    nle: $560639d49e3c9a19$var$nle,
    nleftarrow: $560639d49e3c9a19$var$nleftarrow,
    nleftrightarrow: $560639d49e3c9a19$var$nleftrightarrow,
    nleq: $560639d49e3c9a19$var$nleq,
    nleqq: $560639d49e3c9a19$var$nleqq,
    nleqslant: $560639d49e3c9a19$var$nleqslant,
    nles: $560639d49e3c9a19$var$nles,
    nless: $560639d49e3c9a19$var$nless,
    nlsim: $560639d49e3c9a19$var$nlsim,
    nlt: $560639d49e3c9a19$var$nlt,
    nltri: $560639d49e3c9a19$var$nltri,
    nltrie: $560639d49e3c9a19$var$nltrie,
    nmid: $560639d49e3c9a19$var$nmid,
    nopf: $560639d49e3c9a19$var$nopf,
    no: $560639d49e3c9a19$var$no,
    not: $560639d49e3c9a19$var$not$1,
    notin: $560639d49e3c9a19$var$notin$1,
    notinE: $560639d49e3c9a19$var$notinE,
    notindot: $560639d49e3c9a19$var$notindot,
    notinva: $560639d49e3c9a19$var$notinva,
    notinvb: $560639d49e3c9a19$var$notinvb,
    notinvc: $560639d49e3c9a19$var$notinvc,
    notni: $560639d49e3c9a19$var$notni,
    notniva: $560639d49e3c9a19$var$notniva,
    notnivb: $560639d49e3c9a19$var$notnivb,
    notnivc: $560639d49e3c9a19$var$notnivc,
    npar: $560639d49e3c9a19$var$npar,
    nparallel: $560639d49e3c9a19$var$nparallel,
    nparsl: $560639d49e3c9a19$var$nparsl,
    npart: $560639d49e3c9a19$var$npart,
    npolint: $560639d49e3c9a19$var$npolint,
    npr: $560639d49e3c9a19$var$npr,
    nprcue: $560639d49e3c9a19$var$nprcue,
    npre: $560639d49e3c9a19$var$npre,
    nprec: $560639d49e3c9a19$var$nprec,
    npreceq: $560639d49e3c9a19$var$npreceq,
    nrArr: $560639d49e3c9a19$var$nrArr,
    nrarr: $560639d49e3c9a19$var$nrarr,
    nrarrc: $560639d49e3c9a19$var$nrarrc,
    nrarrw: $560639d49e3c9a19$var$nrarrw,
    nrightarrow: $560639d49e3c9a19$var$nrightarrow,
    nrtri: $560639d49e3c9a19$var$nrtri,
    nrtrie: $560639d49e3c9a19$var$nrtrie,
    nsc: $560639d49e3c9a19$var$nsc,
    nsccue: $560639d49e3c9a19$var$nsccue,
    nsce: $560639d49e3c9a19$var$nsce,
    nscr: $560639d49e3c9a19$var$nscr,
    nshortmid: $560639d49e3c9a19$var$nshortmid,
    nshortparallel: $560639d49e3c9a19$var$nshortparallel,
    nsim: $560639d49e3c9a19$var$nsim,
    nsime: $560639d49e3c9a19$var$nsime,
    nsimeq: $560639d49e3c9a19$var$nsimeq,
    nsmid: $560639d49e3c9a19$var$nsmid,
    nspar: $560639d49e3c9a19$var$nspar,
    nsqsube: $560639d49e3c9a19$var$nsqsube,
    nsqsupe: $560639d49e3c9a19$var$nsqsupe,
    nsub: $560639d49e3c9a19$var$nsub$1,
    nsubE: $560639d49e3c9a19$var$nsubE,
    nsube: $560639d49e3c9a19$var$nsube,
    nsubset: $560639d49e3c9a19$var$nsubset,
    nsubseteq: $560639d49e3c9a19$var$nsubseteq,
    nsubseteqq: $560639d49e3c9a19$var$nsubseteqq,
    nsucc: $560639d49e3c9a19$var$nsucc,
    nsucceq: $560639d49e3c9a19$var$nsucceq,
    nsup: $560639d49e3c9a19$var$nsup,
    nsupE: $560639d49e3c9a19$var$nsupE,
    nsupe: $560639d49e3c9a19$var$nsupe,
    nsupset: $560639d49e3c9a19$var$nsupset,
    nsupseteq: $560639d49e3c9a19$var$nsupseteq,
    nsupseteqq: $560639d49e3c9a19$var$nsupseteqq,
    ntgl: $560639d49e3c9a19$var$ntgl,
    ntild: $560639d49e3c9a19$var$ntild,
    ntilde: $560639d49e3c9a19$var$ntilde$1,
    ntlg: $560639d49e3c9a19$var$ntlg,
    ntriangleleft: $560639d49e3c9a19$var$ntriangleleft,
    ntrianglelefteq: $560639d49e3c9a19$var$ntrianglelefteq,
    ntriangleright: $560639d49e3c9a19$var$ntriangleright,
    ntrianglerighteq: $560639d49e3c9a19$var$ntrianglerighteq,
    nu: $560639d49e3c9a19$var$nu$1,
    num: $560639d49e3c9a19$var$num,
    numero: $560639d49e3c9a19$var$numero,
    numsp: $560639d49e3c9a19$var$numsp,
    nvDash: $560639d49e3c9a19$var$nvDash,
    nvHarr: $560639d49e3c9a19$var$nvHarr,
    nvap: $560639d49e3c9a19$var$nvap,
    nvdash: $560639d49e3c9a19$var$nvdash,
    nvge: $560639d49e3c9a19$var$nvge,
    nvgt: $560639d49e3c9a19$var$nvgt,
    nvinfin: $560639d49e3c9a19$var$nvinfin,
    nvlArr: $560639d49e3c9a19$var$nvlArr,
    nvle: $560639d49e3c9a19$var$nvle,
    nvlt: $560639d49e3c9a19$var$nvlt,
    nvltrie: $560639d49e3c9a19$var$nvltrie,
    nvrArr: $560639d49e3c9a19$var$nvrArr,
    nvrtrie: $560639d49e3c9a19$var$nvrtrie,
    nvsim: $560639d49e3c9a19$var$nvsim,
    nwArr: $560639d49e3c9a19$var$nwArr,
    nwarhk: $560639d49e3c9a19$var$nwarhk,
    nwarr: $560639d49e3c9a19$var$nwarr,
    nwarrow: $560639d49e3c9a19$var$nwarrow,
    nwnear: $560639d49e3c9a19$var$nwnear,
    oS: $560639d49e3c9a19$var$oS,
    oacut: $560639d49e3c9a19$var$oacut,
    oacute: $560639d49e3c9a19$var$oacute$1,
    oast: $560639d49e3c9a19$var$oast,
    ocir: $560639d49e3c9a19$var$ocir,
    ocirc: $560639d49e3c9a19$var$ocirc$1,
    ocy: $560639d49e3c9a19$var$ocy,
    odash: $560639d49e3c9a19$var$odash,
    odblac: $560639d49e3c9a19$var$odblac,
    odiv: $560639d49e3c9a19$var$odiv,
    odot: $560639d49e3c9a19$var$odot,
    odsold: $560639d49e3c9a19$var$odsold,
    oelig: $560639d49e3c9a19$var$oelig$1,
    ofcir: $560639d49e3c9a19$var$ofcir,
    ofr: $560639d49e3c9a19$var$ofr,
    ogon: $560639d49e3c9a19$var$ogon,
    ograv: $560639d49e3c9a19$var$ograv,
    ograve: $560639d49e3c9a19$var$ograve$1,
    ogt: $560639d49e3c9a19$var$ogt,
    ohbar: $560639d49e3c9a19$var$ohbar,
    ohm: $560639d49e3c9a19$var$ohm,
    oint: $560639d49e3c9a19$var$oint,
    olarr: $560639d49e3c9a19$var$olarr,
    olcir: $560639d49e3c9a19$var$olcir,
    olcross: $560639d49e3c9a19$var$olcross,
    oline: $560639d49e3c9a19$var$oline$1,
    olt: $560639d49e3c9a19$var$olt,
    omacr: $560639d49e3c9a19$var$omacr,
    omega: $560639d49e3c9a19$var$omega$1,
    omicron: $560639d49e3c9a19$var$omicron$1,
    omid: $560639d49e3c9a19$var$omid,
    ominus: $560639d49e3c9a19$var$ominus,
    oopf: $560639d49e3c9a19$var$oopf,
    opar: $560639d49e3c9a19$var$opar,
    operp: $560639d49e3c9a19$var$operp,
    oplus: $560639d49e3c9a19$var$oplus$1,
    or: $560639d49e3c9a19$var$or$1,
    orarr: $560639d49e3c9a19$var$orarr,
    ord: $560639d49e3c9a19$var$ord,
    order: $560639d49e3c9a19$var$order,
    orderof: $560639d49e3c9a19$var$orderof,
    ordf: $560639d49e3c9a19$var$ordf$1,
    ordm: $560639d49e3c9a19$var$ordm$1,
    origof: $560639d49e3c9a19$var$origof,
    oror: $560639d49e3c9a19$var$oror,
    orslope: $560639d49e3c9a19$var$orslope,
    orv: $560639d49e3c9a19$var$orv,
    oscr: $560639d49e3c9a19$var$oscr,
    oslas: $560639d49e3c9a19$var$oslas,
    oslash: $560639d49e3c9a19$var$oslash$1,
    osol: $560639d49e3c9a19$var$osol,
    otild: $560639d49e3c9a19$var$otild,
    otilde: $560639d49e3c9a19$var$otilde$1,
    otimes: $560639d49e3c9a19$var$otimes$1,
    otimesas: $560639d49e3c9a19$var$otimesas,
    oum: $560639d49e3c9a19$var$oum,
    ouml: $560639d49e3c9a19$var$ouml$1,
    ovbar: $560639d49e3c9a19$var$ovbar,
    par: $560639d49e3c9a19$var$par,
    para: $560639d49e3c9a19$var$para$1,
    parallel: $560639d49e3c9a19$var$parallel,
    parsim: $560639d49e3c9a19$var$parsim,
    parsl: $560639d49e3c9a19$var$parsl,
    part: $560639d49e3c9a19$var$part$1,
    pcy: $560639d49e3c9a19$var$pcy,
    percnt: $560639d49e3c9a19$var$percnt,
    period: $560639d49e3c9a19$var$period,
    permil: $560639d49e3c9a19$var$permil$1,
    perp: $560639d49e3c9a19$var$perp$1,
    pertenk: $560639d49e3c9a19$var$pertenk,
    pfr: $560639d49e3c9a19$var$pfr,
    phi: $560639d49e3c9a19$var$phi$1,
    phiv: $560639d49e3c9a19$var$phiv,
    phmmat: $560639d49e3c9a19$var$phmmat,
    phone: $560639d49e3c9a19$var$phone,
    pi: $560639d49e3c9a19$var$pi$1,
    pitchfork: $560639d49e3c9a19$var$pitchfork,
    piv: $560639d49e3c9a19$var$piv$1,
    planck: $560639d49e3c9a19$var$planck,
    planckh: $560639d49e3c9a19$var$planckh,
    plankv: $560639d49e3c9a19$var$plankv,
    plus: $560639d49e3c9a19$var$plus,
    plusacir: $560639d49e3c9a19$var$plusacir,
    plusb: $560639d49e3c9a19$var$plusb,
    pluscir: $560639d49e3c9a19$var$pluscir,
    plusdo: $560639d49e3c9a19$var$plusdo,
    plusdu: $560639d49e3c9a19$var$plusdu,
    pluse: $560639d49e3c9a19$var$pluse,
    plusm: $560639d49e3c9a19$var$plusm,
    plusmn: $560639d49e3c9a19$var$plusmn$1,
    plussim: $560639d49e3c9a19$var$plussim,
    plustwo: $560639d49e3c9a19$var$plustwo,
    pm: $560639d49e3c9a19$var$pm,
    pointint: $560639d49e3c9a19$var$pointint,
    popf: $560639d49e3c9a19$var$popf,
    poun: $560639d49e3c9a19$var$poun,
    pound: $560639d49e3c9a19$var$pound$1,
    pr: $560639d49e3c9a19$var$pr,
    prE: $560639d49e3c9a19$var$prE,
    prap: $560639d49e3c9a19$var$prap,
    prcue: $560639d49e3c9a19$var$prcue,
    pre: $560639d49e3c9a19$var$pre,
    prec: $560639d49e3c9a19$var$prec,
    precapprox: $560639d49e3c9a19$var$precapprox,
    preccurlyeq: $560639d49e3c9a19$var$preccurlyeq,
    preceq: $560639d49e3c9a19$var$preceq,
    precnapprox: $560639d49e3c9a19$var$precnapprox,
    precneqq: $560639d49e3c9a19$var$precneqq,
    precnsim: $560639d49e3c9a19$var$precnsim,
    precsim: $560639d49e3c9a19$var$precsim,
    prime: $560639d49e3c9a19$var$prime$1,
    primes: $560639d49e3c9a19$var$primes,
    prnE: $560639d49e3c9a19$var$prnE,
    prnap: $560639d49e3c9a19$var$prnap,
    prnsim: $560639d49e3c9a19$var$prnsim,
    prod: $560639d49e3c9a19$var$prod$1,
    profalar: $560639d49e3c9a19$var$profalar,
    profline: $560639d49e3c9a19$var$profline,
    profsurf: $560639d49e3c9a19$var$profsurf,
    prop: $560639d49e3c9a19$var$prop$1,
    propto: $560639d49e3c9a19$var$propto,
    prsim: $560639d49e3c9a19$var$prsim,
    prurel: $560639d49e3c9a19$var$prurel,
    pscr: $560639d49e3c9a19$var$pscr,
    psi: $560639d49e3c9a19$var$psi$1,
    puncsp: $560639d49e3c9a19$var$puncsp,
    qfr: $560639d49e3c9a19$var$qfr,
    qint: $560639d49e3c9a19$var$qint,
    qopf: $560639d49e3c9a19$var$qopf,
    qprime: $560639d49e3c9a19$var$qprime,
    qscr: $560639d49e3c9a19$var$qscr,
    quaternions: $560639d49e3c9a19$var$quaternions,
    quatint: $560639d49e3c9a19$var$quatint,
    quest: $560639d49e3c9a19$var$quest,
    questeq: $560639d49e3c9a19$var$questeq,
    quo: $560639d49e3c9a19$var$quo,
    quot: $560639d49e3c9a19$var$quot$1,
    rAarr: $560639d49e3c9a19$var$rAarr,
    rArr: $560639d49e3c9a19$var$rArr$1,
    rAtail: $560639d49e3c9a19$var$rAtail,
    rBarr: $560639d49e3c9a19$var$rBarr,
    rHar: $560639d49e3c9a19$var$rHar,
    race: $560639d49e3c9a19$var$race,
    racute: $560639d49e3c9a19$var$racute,
    radic: $560639d49e3c9a19$var$radic$1,
    raemptyv: $560639d49e3c9a19$var$raemptyv,
    rang: $560639d49e3c9a19$var$rang$1,
    rangd: $560639d49e3c9a19$var$rangd,
    range: $560639d49e3c9a19$var$range,
    rangle: $560639d49e3c9a19$var$rangle,
    raqu: $560639d49e3c9a19$var$raqu,
    raquo: $560639d49e3c9a19$var$raquo$1,
    rarr: $560639d49e3c9a19$var$rarr$1,
    rarrap: $560639d49e3c9a19$var$rarrap,
    rarrb: $560639d49e3c9a19$var$rarrb,
    rarrbfs: $560639d49e3c9a19$var$rarrbfs,
    rarrc: $560639d49e3c9a19$var$rarrc,
    rarrfs: $560639d49e3c9a19$var$rarrfs,
    rarrhk: $560639d49e3c9a19$var$rarrhk,
    rarrlp: $560639d49e3c9a19$var$rarrlp,
    rarrpl: $560639d49e3c9a19$var$rarrpl,
    rarrsim: $560639d49e3c9a19$var$rarrsim,
    rarrtl: $560639d49e3c9a19$var$rarrtl,
    rarrw: $560639d49e3c9a19$var$rarrw,
    ratail: $560639d49e3c9a19$var$ratail,
    ratio: $560639d49e3c9a19$var$ratio,
    rationals: $560639d49e3c9a19$var$rationals,
    rbarr: $560639d49e3c9a19$var$rbarr,
    rbbrk: $560639d49e3c9a19$var$rbbrk,
    rbrace: $560639d49e3c9a19$var$rbrace,
    rbrack: $560639d49e3c9a19$var$rbrack,
    rbrke: $560639d49e3c9a19$var$rbrke,
    rbrksld: $560639d49e3c9a19$var$rbrksld,
    rbrkslu: $560639d49e3c9a19$var$rbrkslu,
    rcaron: $560639d49e3c9a19$var$rcaron,
    rcedil: $560639d49e3c9a19$var$rcedil,
    rceil: $560639d49e3c9a19$var$rceil$1,
    rcub: $560639d49e3c9a19$var$rcub,
    rcy: $560639d49e3c9a19$var$rcy,
    rdca: $560639d49e3c9a19$var$rdca,
    rdldhar: $560639d49e3c9a19$var$rdldhar,
    rdquo: $560639d49e3c9a19$var$rdquo$1,
    rdquor: $560639d49e3c9a19$var$rdquor,
    rdsh: $560639d49e3c9a19$var$rdsh,
    real: $560639d49e3c9a19$var$real$1,
    realine: $560639d49e3c9a19$var$realine,
    realpart: $560639d49e3c9a19$var$realpart,
    reals: $560639d49e3c9a19$var$reals,
    rect: $560639d49e3c9a19$var$rect,
    re: $560639d49e3c9a19$var$re$3,
    reg: $560639d49e3c9a19$var$reg$1,
    rfisht: $560639d49e3c9a19$var$rfisht,
    rfloor: $560639d49e3c9a19$var$rfloor$1,
    rfr: $560639d49e3c9a19$var$rfr,
    rhard: $560639d49e3c9a19$var$rhard,
    rharu: $560639d49e3c9a19$var$rharu,
    rharul: $560639d49e3c9a19$var$rharul,
    rho: $560639d49e3c9a19$var$rho$1,
    rhov: $560639d49e3c9a19$var$rhov,
    rightarrow: $560639d49e3c9a19$var$rightarrow,
    rightarrowtail: $560639d49e3c9a19$var$rightarrowtail,
    rightharpoondown: $560639d49e3c9a19$var$rightharpoondown,
    rightharpoonup: $560639d49e3c9a19$var$rightharpoonup,
    rightleftarrows: $560639d49e3c9a19$var$rightleftarrows,
    rightleftharpoons: $560639d49e3c9a19$var$rightleftharpoons,
    rightrightarrows: $560639d49e3c9a19$var$rightrightarrows,
    rightsquigarrow: $560639d49e3c9a19$var$rightsquigarrow,
    rightthreetimes: $560639d49e3c9a19$var$rightthreetimes,
    ring: $560639d49e3c9a19$var$ring,
    risingdotseq: $560639d49e3c9a19$var$risingdotseq,
    rlarr: $560639d49e3c9a19$var$rlarr,
    rlhar: $560639d49e3c9a19$var$rlhar,
    rlm: $560639d49e3c9a19$var$rlm$1,
    rmoust: $560639d49e3c9a19$var$rmoust,
    rmoustache: $560639d49e3c9a19$var$rmoustache,
    rnmid: $560639d49e3c9a19$var$rnmid,
    roang: $560639d49e3c9a19$var$roang,
    roarr: $560639d49e3c9a19$var$roarr,
    robrk: $560639d49e3c9a19$var$robrk,
    ropar: $560639d49e3c9a19$var$ropar,
    ropf: $560639d49e3c9a19$var$ropf,
    roplus: $560639d49e3c9a19$var$roplus,
    rotimes: $560639d49e3c9a19$var$rotimes,
    rpar: $560639d49e3c9a19$var$rpar,
    rpargt: $560639d49e3c9a19$var$rpargt,
    rppolint: $560639d49e3c9a19$var$rppolint,
    rrarr: $560639d49e3c9a19$var$rrarr,
    rsaquo: $560639d49e3c9a19$var$rsaquo$1,
    rscr: $560639d49e3c9a19$var$rscr,
    rsh: $560639d49e3c9a19$var$rsh,
    rsqb: $560639d49e3c9a19$var$rsqb,
    rsquo: $560639d49e3c9a19$var$rsquo$1,
    rsquor: $560639d49e3c9a19$var$rsquor,
    rthree: $560639d49e3c9a19$var$rthree,
    rtimes: $560639d49e3c9a19$var$rtimes,
    rtri: $560639d49e3c9a19$var$rtri,
    rtrie: $560639d49e3c9a19$var$rtrie,
    rtrif: $560639d49e3c9a19$var$rtrif,
    rtriltri: $560639d49e3c9a19$var$rtriltri,
    ruluhar: $560639d49e3c9a19$var$ruluhar,
    rx: $560639d49e3c9a19$var$rx,
    sacute: $560639d49e3c9a19$var$sacute,
    sbquo: $560639d49e3c9a19$var$sbquo$1,
    sc: $560639d49e3c9a19$var$sc,
    scE: $560639d49e3c9a19$var$scE,
    scap: $560639d49e3c9a19$var$scap,
    scaron: $560639d49e3c9a19$var$scaron$1,
    sccue: $560639d49e3c9a19$var$sccue,
    sce: $560639d49e3c9a19$var$sce,
    scedil: $560639d49e3c9a19$var$scedil,
    scirc: $560639d49e3c9a19$var$scirc,
    scnE: $560639d49e3c9a19$var$scnE,
    scnap: $560639d49e3c9a19$var$scnap,
    scnsim: $560639d49e3c9a19$var$scnsim,
    scpolint: $560639d49e3c9a19$var$scpolint,
    scsim: $560639d49e3c9a19$var$scsim,
    scy: $560639d49e3c9a19$var$scy,
    sdot: $560639d49e3c9a19$var$sdot$1,
    sdotb: $560639d49e3c9a19$var$sdotb,
    sdote: $560639d49e3c9a19$var$sdote,
    seArr: $560639d49e3c9a19$var$seArr,
    searhk: $560639d49e3c9a19$var$searhk,
    searr: $560639d49e3c9a19$var$searr,
    searrow: $560639d49e3c9a19$var$searrow,
    sec: $560639d49e3c9a19$var$sec,
    sect: $560639d49e3c9a19$var$sect$1,
    semi: $560639d49e3c9a19$var$semi,
    seswar: $560639d49e3c9a19$var$seswar,
    setminus: $560639d49e3c9a19$var$setminus,
    setmn: $560639d49e3c9a19$var$setmn,
    sext: $560639d49e3c9a19$var$sext,
    sfr: $560639d49e3c9a19$var$sfr,
    sfrown: $560639d49e3c9a19$var$sfrown,
    sharp: $560639d49e3c9a19$var$sharp,
    shchcy: $560639d49e3c9a19$var$shchcy,
    shcy: $560639d49e3c9a19$var$shcy,
    shortmid: $560639d49e3c9a19$var$shortmid,
    shortparallel: $560639d49e3c9a19$var$shortparallel,
    sh: $560639d49e3c9a19$var$sh,
    shy: $560639d49e3c9a19$var$shy$1,
    sigma: $560639d49e3c9a19$var$sigma$1,
    sigmaf: $560639d49e3c9a19$var$sigmaf$1,
    sigmav: $560639d49e3c9a19$var$sigmav,
    sim: $560639d49e3c9a19$var$sim$1,
    simdot: $560639d49e3c9a19$var$simdot,
    sime: $560639d49e3c9a19$var$sime,
    simeq: $560639d49e3c9a19$var$simeq,
    simg: $560639d49e3c9a19$var$simg,
    simgE: $560639d49e3c9a19$var$simgE,
    siml: $560639d49e3c9a19$var$siml,
    simlE: $560639d49e3c9a19$var$simlE,
    simne: $560639d49e3c9a19$var$simne,
    simplus: $560639d49e3c9a19$var$simplus,
    simrarr: $560639d49e3c9a19$var$simrarr,
    slarr: $560639d49e3c9a19$var$slarr,
    smallsetminus: $560639d49e3c9a19$var$smallsetminus,
    smashp: $560639d49e3c9a19$var$smashp,
    smeparsl: $560639d49e3c9a19$var$smeparsl,
    smid: $560639d49e3c9a19$var$smid,
    smile: $560639d49e3c9a19$var$smile,
    smt: $560639d49e3c9a19$var$smt,
    smte: $560639d49e3c9a19$var$smte,
    smtes: $560639d49e3c9a19$var$smtes,
    softcy: $560639d49e3c9a19$var$softcy,
    sol: $560639d49e3c9a19$var$sol,
    solb: $560639d49e3c9a19$var$solb,
    solbar: $560639d49e3c9a19$var$solbar,
    sopf: $560639d49e3c9a19$var$sopf,
    spades: $560639d49e3c9a19$var$spades$1,
    spadesuit: $560639d49e3c9a19$var$spadesuit,
    spar: $560639d49e3c9a19$var$spar,
    sqcap: $560639d49e3c9a19$var$sqcap,
    sqcaps: $560639d49e3c9a19$var$sqcaps,
    sqcup: $560639d49e3c9a19$var$sqcup,
    sqcups: $560639d49e3c9a19$var$sqcups,
    sqsub: $560639d49e3c9a19$var$sqsub,
    sqsube: $560639d49e3c9a19$var$sqsube,
    sqsubset: $560639d49e3c9a19$var$sqsubset,
    sqsubseteq: $560639d49e3c9a19$var$sqsubseteq,
    sqsup: $560639d49e3c9a19$var$sqsup,
    sqsupe: $560639d49e3c9a19$var$sqsupe,
    sqsupset: $560639d49e3c9a19$var$sqsupset,
    sqsupseteq: $560639d49e3c9a19$var$sqsupseteq,
    squ: $560639d49e3c9a19$var$squ,
    square: $560639d49e3c9a19$var$square,
    squarf: $560639d49e3c9a19$var$squarf,
    squf: $560639d49e3c9a19$var$squf,
    srarr: $560639d49e3c9a19$var$srarr,
    sscr: $560639d49e3c9a19$var$sscr,
    ssetmn: $560639d49e3c9a19$var$ssetmn,
    ssmile: $560639d49e3c9a19$var$ssmile,
    sstarf: $560639d49e3c9a19$var$sstarf,
    star: $560639d49e3c9a19$var$star,
    starf: $560639d49e3c9a19$var$starf,
    straightepsilon: $560639d49e3c9a19$var$straightepsilon,
    straightphi: $560639d49e3c9a19$var$straightphi,
    strns: $560639d49e3c9a19$var$strns,
    sub: $560639d49e3c9a19$var$sub$1,
    subE: $560639d49e3c9a19$var$subE,
    subdot: $560639d49e3c9a19$var$subdot,
    sube: $560639d49e3c9a19$var$sube$1,
    subedot: $560639d49e3c9a19$var$subedot,
    submult: $560639d49e3c9a19$var$submult,
    subnE: $560639d49e3c9a19$var$subnE,
    subne: $560639d49e3c9a19$var$subne,
    subplus: $560639d49e3c9a19$var$subplus,
    subrarr: $560639d49e3c9a19$var$subrarr,
    subset: $560639d49e3c9a19$var$subset,
    subseteq: $560639d49e3c9a19$var$subseteq,
    subseteqq: $560639d49e3c9a19$var$subseteqq,
    subsetneq: $560639d49e3c9a19$var$subsetneq,
    subsetneqq: $560639d49e3c9a19$var$subsetneqq,
    subsim: $560639d49e3c9a19$var$subsim,
    subsub: $560639d49e3c9a19$var$subsub,
    subsup: $560639d49e3c9a19$var$subsup,
    succ: $560639d49e3c9a19$var$succ,
    succapprox: $560639d49e3c9a19$var$succapprox,
    succcurlyeq: $560639d49e3c9a19$var$succcurlyeq,
    succeq: $560639d49e3c9a19$var$succeq,
    succnapprox: $560639d49e3c9a19$var$succnapprox,
    succneqq: $560639d49e3c9a19$var$succneqq,
    succnsim: $560639d49e3c9a19$var$succnsim,
    succsim: $560639d49e3c9a19$var$succsim,
    sum: $560639d49e3c9a19$var$sum$1,
    sung: $560639d49e3c9a19$var$sung,
    sup: $560639d49e3c9a19$var$sup$1,
    sup1: $560639d49e3c9a19$var$sup1$1,
    sup2: $560639d49e3c9a19$var$sup2$1,
    sup3: $560639d49e3c9a19$var$sup3$1,
    supE: $560639d49e3c9a19$var$supE,
    supdot: $560639d49e3c9a19$var$supdot,
    supdsub: $560639d49e3c9a19$var$supdsub,
    supe: $560639d49e3c9a19$var$supe$1,
    supedot: $560639d49e3c9a19$var$supedot,
    suphsol: $560639d49e3c9a19$var$suphsol,
    suphsub: $560639d49e3c9a19$var$suphsub,
    suplarr: $560639d49e3c9a19$var$suplarr,
    supmult: $560639d49e3c9a19$var$supmult,
    supnE: $560639d49e3c9a19$var$supnE,
    supne: $560639d49e3c9a19$var$supne,
    supplus: $560639d49e3c9a19$var$supplus,
    supset: $560639d49e3c9a19$var$supset,
    supseteq: $560639d49e3c9a19$var$supseteq,
    supseteqq: $560639d49e3c9a19$var$supseteqq,
    supsetneq: $560639d49e3c9a19$var$supsetneq,
    supsetneqq: $560639d49e3c9a19$var$supsetneqq,
    supsim: $560639d49e3c9a19$var$supsim,
    supsub: $560639d49e3c9a19$var$supsub,
    supsup: $560639d49e3c9a19$var$supsup,
    swArr: $560639d49e3c9a19$var$swArr,
    swarhk: $560639d49e3c9a19$var$swarhk,
    swarr: $560639d49e3c9a19$var$swarr,
    swarrow: $560639d49e3c9a19$var$swarrow,
    swnwar: $560639d49e3c9a19$var$swnwar,
    szli: $560639d49e3c9a19$var$szli,
    szlig: $560639d49e3c9a19$var$szlig$1,
    target: $560639d49e3c9a19$var$target,
    tau: $560639d49e3c9a19$var$tau$1,
    tbrk: $560639d49e3c9a19$var$tbrk,
    tcaron: $560639d49e3c9a19$var$tcaron,
    tcedil: $560639d49e3c9a19$var$tcedil,
    tcy: $560639d49e3c9a19$var$tcy,
    tdot: $560639d49e3c9a19$var$tdot,
    telrec: $560639d49e3c9a19$var$telrec,
    tfr: $560639d49e3c9a19$var$tfr,
    there4: $560639d49e3c9a19$var$there4$1,
    therefore: $560639d49e3c9a19$var$therefore,
    theta: $560639d49e3c9a19$var$theta$1,
    thetasym: $560639d49e3c9a19$var$thetasym$1,
    thetav: $560639d49e3c9a19$var$thetav,
    thickapprox: $560639d49e3c9a19$var$thickapprox,
    thicksim: $560639d49e3c9a19$var$thicksim,
    thinsp: $560639d49e3c9a19$var$thinsp$1,
    thkap: $560639d49e3c9a19$var$thkap,
    thksim: $560639d49e3c9a19$var$thksim,
    thor: $560639d49e3c9a19$var$thor,
    thorn: $560639d49e3c9a19$var$thorn$1,
    tilde: $560639d49e3c9a19$var$tilde$4,
    time: $560639d49e3c9a19$var$time,
    times: $560639d49e3c9a19$var$times$1,
    timesb: $560639d49e3c9a19$var$timesb,
    timesbar: $560639d49e3c9a19$var$timesbar,
    timesd: $560639d49e3c9a19$var$timesd,
    tint: $560639d49e3c9a19$var$tint,
    toea: $560639d49e3c9a19$var$toea,
    top: $560639d49e3c9a19$var$top,
    topbot: $560639d49e3c9a19$var$topbot,
    topcir: $560639d49e3c9a19$var$topcir,
    topf: $560639d49e3c9a19$var$topf,
    topfork: $560639d49e3c9a19$var$topfork,
    tosa: $560639d49e3c9a19$var$tosa,
    tprime: $560639d49e3c9a19$var$tprime,
    trade: $560639d49e3c9a19$var$trade$1,
    triangle: $560639d49e3c9a19$var$triangle,
    triangledown: $560639d49e3c9a19$var$triangledown,
    triangleleft: $560639d49e3c9a19$var$triangleleft,
    trianglelefteq: $560639d49e3c9a19$var$trianglelefteq,
    triangleq: $560639d49e3c9a19$var$triangleq,
    triangleright: $560639d49e3c9a19$var$triangleright,
    trianglerighteq: $560639d49e3c9a19$var$trianglerighteq,
    tridot: $560639d49e3c9a19$var$tridot,
    trie: $560639d49e3c9a19$var$trie,
    triminus: $560639d49e3c9a19$var$triminus,
    triplus: $560639d49e3c9a19$var$triplus,
    trisb: $560639d49e3c9a19$var$trisb,
    tritime: $560639d49e3c9a19$var$tritime,
    trpezium: $560639d49e3c9a19$var$trpezium,
    tscr: $560639d49e3c9a19$var$tscr,
    tscy: $560639d49e3c9a19$var$tscy,
    tshcy: $560639d49e3c9a19$var$tshcy,
    tstrok: $560639d49e3c9a19$var$tstrok,
    twixt: $560639d49e3c9a19$var$twixt,
    twoheadleftarrow: $560639d49e3c9a19$var$twoheadleftarrow,
    twoheadrightarrow: $560639d49e3c9a19$var$twoheadrightarrow,
    uArr: $560639d49e3c9a19$var$uArr$1,
    uHar: $560639d49e3c9a19$var$uHar,
    uacut: $560639d49e3c9a19$var$uacut,
    uacute: $560639d49e3c9a19$var$uacute$1,
    uarr: $560639d49e3c9a19$var$uarr$1,
    ubrcy: $560639d49e3c9a19$var$ubrcy,
    ubreve: $560639d49e3c9a19$var$ubreve,
    ucir: $560639d49e3c9a19$var$ucir,
    ucirc: $560639d49e3c9a19$var$ucirc$1,
    ucy: $560639d49e3c9a19$var$ucy,
    udarr: $560639d49e3c9a19$var$udarr,
    udblac: $560639d49e3c9a19$var$udblac,
    udhar: $560639d49e3c9a19$var$udhar,
    ufisht: $560639d49e3c9a19$var$ufisht,
    ufr: $560639d49e3c9a19$var$ufr,
    ugrav: $560639d49e3c9a19$var$ugrav,
    ugrave: $560639d49e3c9a19$var$ugrave$1,
    uharl: $560639d49e3c9a19$var$uharl,
    uharr: $560639d49e3c9a19$var$uharr,
    uhblk: $560639d49e3c9a19$var$uhblk,
    ulcorn: $560639d49e3c9a19$var$ulcorn,
    ulcorner: $560639d49e3c9a19$var$ulcorner,
    ulcrop: $560639d49e3c9a19$var$ulcrop,
    ultri: $560639d49e3c9a19$var$ultri,
    umacr: $560639d49e3c9a19$var$umacr,
    um: $560639d49e3c9a19$var$um,
    uml: $560639d49e3c9a19$var$uml$1,
    uogon: $560639d49e3c9a19$var$uogon,
    uopf: $560639d49e3c9a19$var$uopf,
    uparrow: $560639d49e3c9a19$var$uparrow,
    updownarrow: $560639d49e3c9a19$var$updownarrow,
    upharpoonleft: $560639d49e3c9a19$var$upharpoonleft,
    upharpoonright: $560639d49e3c9a19$var$upharpoonright,
    uplus: $560639d49e3c9a19$var$uplus,
    upsi: $560639d49e3c9a19$var$upsi,
    upsih: $560639d49e3c9a19$var$upsih$1,
    upsilon: $560639d49e3c9a19$var$upsilon$1,
    upuparrows: $560639d49e3c9a19$var$upuparrows,
    urcorn: $560639d49e3c9a19$var$urcorn,
    urcorner: $560639d49e3c9a19$var$urcorner,
    urcrop: $560639d49e3c9a19$var$urcrop,
    uring: $560639d49e3c9a19$var$uring,
    urtri: $560639d49e3c9a19$var$urtri,
    uscr: $560639d49e3c9a19$var$uscr,
    utdot: $560639d49e3c9a19$var$utdot,
    utilde: $560639d49e3c9a19$var$utilde,
    utri: $560639d49e3c9a19$var$utri,
    utrif: $560639d49e3c9a19$var$utrif,
    uuarr: $560639d49e3c9a19$var$uuarr,
    uum: $560639d49e3c9a19$var$uum,
    uuml: $560639d49e3c9a19$var$uuml$1,
    uwangle: $560639d49e3c9a19$var$uwangle,
    vArr: $560639d49e3c9a19$var$vArr,
    vBar: $560639d49e3c9a19$var$vBar,
    vBarv: $560639d49e3c9a19$var$vBarv,
    vDash: $560639d49e3c9a19$var$vDash,
    vangrt: $560639d49e3c9a19$var$vangrt,
    varepsilon: $560639d49e3c9a19$var$varepsilon,
    varkappa: $560639d49e3c9a19$var$varkappa,
    varnothing: $560639d49e3c9a19$var$varnothing,
    varphi: $560639d49e3c9a19$var$varphi,
    varpi: $560639d49e3c9a19$var$varpi,
    varpropto: $560639d49e3c9a19$var$varpropto,
    varr: $560639d49e3c9a19$var$varr,
    varrho: $560639d49e3c9a19$var$varrho,
    varsigma: $560639d49e3c9a19$var$varsigma,
    varsubsetneq: $560639d49e3c9a19$var$varsubsetneq,
    varsubsetneqq: $560639d49e3c9a19$var$varsubsetneqq,
    varsupsetneq: $560639d49e3c9a19$var$varsupsetneq,
    varsupsetneqq: $560639d49e3c9a19$var$varsupsetneqq,
    vartheta: $560639d49e3c9a19$var$vartheta,
    vartriangleleft: $560639d49e3c9a19$var$vartriangleleft,
    vartriangleright: $560639d49e3c9a19$var$vartriangleright,
    vcy: $560639d49e3c9a19$var$vcy,
    vdash: $560639d49e3c9a19$var$vdash,
    vee: $560639d49e3c9a19$var$vee,
    veebar: $560639d49e3c9a19$var$veebar,
    veeeq: $560639d49e3c9a19$var$veeeq,
    vellip: $560639d49e3c9a19$var$vellip,
    verbar: $560639d49e3c9a19$var$verbar,
    vert: $560639d49e3c9a19$var$vert,
    vfr: $560639d49e3c9a19$var$vfr,
    vltri: $560639d49e3c9a19$var$vltri,
    vnsub: $560639d49e3c9a19$var$vnsub,
    vnsup: $560639d49e3c9a19$var$vnsup,
    vopf: $560639d49e3c9a19$var$vopf,
    vprop: $560639d49e3c9a19$var$vprop,
    vrtri: $560639d49e3c9a19$var$vrtri,
    vscr: $560639d49e3c9a19$var$vscr,
    vsubnE: $560639d49e3c9a19$var$vsubnE,
    vsubne: $560639d49e3c9a19$var$vsubne,
    vsupnE: $560639d49e3c9a19$var$vsupnE,
    vsupne: $560639d49e3c9a19$var$vsupne,
    vzigzag: $560639d49e3c9a19$var$vzigzag,
    wcirc: $560639d49e3c9a19$var$wcirc,
    wedbar: $560639d49e3c9a19$var$wedbar,
    wedge: $560639d49e3c9a19$var$wedge,
    wedgeq: $560639d49e3c9a19$var$wedgeq,
    weierp: $560639d49e3c9a19$var$weierp$1,
    wfr: $560639d49e3c9a19$var$wfr,
    wopf: $560639d49e3c9a19$var$wopf,
    wp: $560639d49e3c9a19$var$wp,
    wr: $560639d49e3c9a19$var$wr,
    wreath: $560639d49e3c9a19$var$wreath,
    wscr: $560639d49e3c9a19$var$wscr,
    xcap: $560639d49e3c9a19$var$xcap,
    xcirc: $560639d49e3c9a19$var$xcirc,
    xcup: $560639d49e3c9a19$var$xcup,
    xdtri: $560639d49e3c9a19$var$xdtri,
    xfr: $560639d49e3c9a19$var$xfr,
    xhArr: $560639d49e3c9a19$var$xhArr,
    xharr: $560639d49e3c9a19$var$xharr,
    xi: $560639d49e3c9a19$var$xi$1,
    xlArr: $560639d49e3c9a19$var$xlArr,
    xlarr: $560639d49e3c9a19$var$xlarr,
    xmap: $560639d49e3c9a19$var$xmap,
    xnis: $560639d49e3c9a19$var$xnis,
    xodot: $560639d49e3c9a19$var$xodot,
    xopf: $560639d49e3c9a19$var$xopf,
    xoplus: $560639d49e3c9a19$var$xoplus,
    xotime: $560639d49e3c9a19$var$xotime,
    xrArr: $560639d49e3c9a19$var$xrArr,
    xrarr: $560639d49e3c9a19$var$xrarr,
    xscr: $560639d49e3c9a19$var$xscr,
    xsqcup: $560639d49e3c9a19$var$xsqcup,
    xuplus: $560639d49e3c9a19$var$xuplus,
    xutri: $560639d49e3c9a19$var$xutri,
    xvee: $560639d49e3c9a19$var$xvee,
    xwedge: $560639d49e3c9a19$var$xwedge,
    yacut: $560639d49e3c9a19$var$yacut,
    yacute: $560639d49e3c9a19$var$yacute$1,
    yacy: $560639d49e3c9a19$var$yacy,
    ycirc: $560639d49e3c9a19$var$ycirc,
    ycy: $560639d49e3c9a19$var$ycy,
    ye: $560639d49e3c9a19$var$ye,
    yen: $560639d49e3c9a19$var$yen$1,
    yfr: $560639d49e3c9a19$var$yfr,
    yicy: $560639d49e3c9a19$var$yicy,
    yopf: $560639d49e3c9a19$var$yopf,
    yscr: $560639d49e3c9a19$var$yscr,
    yucy: $560639d49e3c9a19$var$yucy,
    yum: $560639d49e3c9a19$var$yum,
    yuml: $560639d49e3c9a19$var$yuml$1,
    zacute: $560639d49e3c9a19$var$zacute,
    zcaron: $560639d49e3c9a19$var$zcaron,
    zcy: $560639d49e3c9a19$var$zcy,
    zdot: $560639d49e3c9a19$var$zdot,
    zeetrf: $560639d49e3c9a19$var$zeetrf,
    zeta: $560639d49e3c9a19$var$zeta$1,
    zfr: $560639d49e3c9a19$var$zfr,
    zhcy: $560639d49e3c9a19$var$zhcy,
    zigrarr: $560639d49e3c9a19$var$zigrarr,
    zopf: $560639d49e3c9a19$var$zopf,
    zscr: $560639d49e3c9a19$var$zscr,
    zwj: $560639d49e3c9a19$var$zwj$1,
    zwnj: $560639d49e3c9a19$var$zwnj$1,
    "default": $560639d49e3c9a19$var$index$3
});
var $560639d49e3c9a19$var$characterEntities = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntities$1);
var $560639d49e3c9a19$var$decodeEntity_1 = $560639d49e3c9a19$var$decodeEntity;
var $560639d49e3c9a19$var$own$c = {}.hasOwnProperty;
function $560639d49e3c9a19$var$decodeEntity(characters) {
    return $560639d49e3c9a19$var$own$c.call($560639d49e3c9a19$var$characterEntities, characters) ? $560639d49e3c9a19$var$characterEntities[characters] : false;
}
var $560639d49e3c9a19$var$legacy = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntitiesLegacy);
var $560639d49e3c9a19$var$invalid = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterReferenceInvalid);
var $560639d49e3c9a19$var$parseEntities_1 = $560639d49e3c9a19$var$parseEntities;
var $560639d49e3c9a19$var$own$b = {}.hasOwnProperty;
var $560639d49e3c9a19$var$fromCharCode = String.fromCharCode;
var $560639d49e3c9a19$var$noop = Function.prototype;
// Default settings.
var $560639d49e3c9a19$var$defaults$3 = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
};
// Characters.
var $560639d49e3c9a19$var$tab$e = 9; // '\t'
var $560639d49e3c9a19$var$lineFeed$j = 10; // '\n'
var $560639d49e3c9a19$var$formFeed = 12; // '\f'
var $560639d49e3c9a19$var$space$j = 32; // ' '
var $560639d49e3c9a19$var$ampersand$1 = 38; // '&'
var $560639d49e3c9a19$var$semicolon$1 = 59; // ';'
var $560639d49e3c9a19$var$lessThan$8 = 60; // '<'
var $560639d49e3c9a19$var$equalsTo$2 = 61; // '='
var $560639d49e3c9a19$var$numberSign$1 = 35; // '#'
var $560639d49e3c9a19$var$uppercaseX = 88; // 'X'
var $560639d49e3c9a19$var$lowercaseX$1 = 120; // 'x'
var $560639d49e3c9a19$var$replacementCharacter = 65533; // '�'
// Reference types.
var $560639d49e3c9a19$var$name$1 = "named";
var $560639d49e3c9a19$var$hexa = "hexadecimal";
var $560639d49e3c9a19$var$deci = "decimal";
// Map of bases.
var $560639d49e3c9a19$var$bases = {};
$560639d49e3c9a19$var$bases[$560639d49e3c9a19$var$hexa] = 16;
$560639d49e3c9a19$var$bases[$560639d49e3c9a19$var$deci] = 10;
// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var $560639d49e3c9a19$var$tests = {};
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$name$1] = $560639d49e3c9a19$var$isAlphanumerical;
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$deci] = $560639d49e3c9a19$var$isDecimal;
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$hexa] = $560639d49e3c9a19$var$isHexadecimal;
// Warning types.
var $560639d49e3c9a19$var$namedNotTerminated = 1;
var $560639d49e3c9a19$var$numericNotTerminated = 2;
var $560639d49e3c9a19$var$namedEmpty = 3;
var $560639d49e3c9a19$var$numericEmpty = 4;
var $560639d49e3c9a19$var$namedUnknown = 5;
var $560639d49e3c9a19$var$numericDisallowed = 6;
var $560639d49e3c9a19$var$numericProhibited = 7;
// Warning messages.
var $560639d49e3c9a19$var$messages = {};
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedEmpty] = "Named character references cannot be empty";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericEmpty] = "Numeric character references cannot be empty";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedUnknown] = "Named character references must be known";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
// Wrap to ensure clean parameters are given to `parse`.
function $560639d49e3c9a19$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) options = {};
    for(key in $560639d49e3c9a19$var$defaults$3){
        option = options[key];
        settings[key] = option === null || option === undefined ? $560639d49e3c9a19$var$defaults$3[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }
    return $560639d49e3c9a19$var$parse$7(value, settings);
}
// Parse entities.
// eslint-disable-next-line complexity
function $560639d49e3c9a19$var$parse$7(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") additional = additional.charCodeAt(0);
    // Cache the current point.
    prev = now();
    // Wrap `handleWarning`.
    warning = handleWarning ? parseError : $560639d49e3c9a19$var$noop;
    // Ensure the algorithm walks over the first character and the end
    // (inclusive).
    index--;
    length++;
    while(++index < length){
        // If the previous character was a newline.
        if (character === $560639d49e3c9a19$var$lineFeed$j) column = indent[lines] || 1;
        character = value.charCodeAt(index);
        if (character === $560639d49e3c9a19$var$ampersand$1) {
            following = value.charCodeAt(index + 1);
            // The behaviour depends on the identity of the next character.
            if (following === $560639d49e3c9a19$var$tab$e || following === $560639d49e3c9a19$var$lineFeed$j || following === $560639d49e3c9a19$var$formFeed || following === $560639d49e3c9a19$var$space$j || following === $560639d49e3c9a19$var$ampersand$1 || following === $560639d49e3c9a19$var$lessThan$8 || following !== following || additional && following === additional) {
                // Not a character reference.
                // No characters are consumed, and nothing is returned.
                // This is not an error, either.
                queue += $560639d49e3c9a19$var$fromCharCode(character);
                column++;
                continue;
            }
            start = index + 1;
            begin = start;
            end = start;
            if (following === $560639d49e3c9a19$var$numberSign$1) {
                // Numerical entity.
                end = ++begin;
                // The behaviour further depends on the next character.
                following = value.charCodeAt(end);
                if (following === $560639d49e3c9a19$var$uppercaseX || following === $560639d49e3c9a19$var$lowercaseX$1) {
                    // ASCII hex digits.
                    type = $560639d49e3c9a19$var$hexa;
                    end = ++begin;
                } else // ASCII digits.
                type = $560639d49e3c9a19$var$deci;
            } else // Named entity.
            type = $560639d49e3c9a19$var$name$1;
            entityCharacters = "";
            entity = "";
            characters = "";
            test = $560639d49e3c9a19$var$tests[type];
            end--;
            while(++end < length){
                following = value.charCodeAt(end);
                if (!test(following)) break;
                characters += $560639d49e3c9a19$var$fromCharCode(following);
                // Check if we can match a legacy named reference.
                // If so, we cache that as the last viable named reference.
                // This ensures we do not need to walk backwards later.
                if (type === $560639d49e3c9a19$var$name$1 && $560639d49e3c9a19$var$own$b.call($560639d49e3c9a19$var$legacy, characters)) {
                    entityCharacters = characters;
                    entity = $560639d49e3c9a19$var$legacy[characters];
                }
            }
            terminated = value.charCodeAt(end) === $560639d49e3c9a19$var$semicolon$1;
            if (terminated) {
                end++;
                namedEntity = type === $560639d49e3c9a19$var$name$1 ? $560639d49e3c9a19$var$decodeEntity_1(characters) : false;
                if (namedEntity) {
                    entityCharacters = characters;
                    entity = namedEntity;
                }
            }
            diff = 1 + end - start;
            if (!terminated && !nonTerminated) ;
            else if (!characters) // An empty (possible) entity is valid, unless it’s numeric (thus an
            // ampersand followed by an octothorp).
            {
                if (type !== $560639d49e3c9a19$var$name$1) warning($560639d49e3c9a19$var$numericEmpty, diff);
            } else if (type === $560639d49e3c9a19$var$name$1) {
                // An ampersand followed by anything unknown, and not terminated, is
                // invalid.
                if (terminated && !entity) warning($560639d49e3c9a19$var$namedUnknown, 1);
                else {
                    // If theres something after an entity name which is not known, cap
                    // the reference.
                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }
                    // If the reference is not terminated, warn.
                    if (!terminated) {
                        reason = entityCharacters ? $560639d49e3c9a19$var$namedNotTerminated : $560639d49e3c9a19$var$namedEmpty;
                        if (settings.attribute) {
                            following = value.charCodeAt(end);
                            if (following === $560639d49e3c9a19$var$equalsTo$2) {
                                warning(reason, diff);
                                entity = null;
                            } else if ($560639d49e3c9a19$var$isAlphanumerical(following)) entity = null;
                            else warning(reason, diff);
                        } else warning(reason, diff);
                    }
                }
                reference = entity;
            } else {
                if (!terminated) // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning($560639d49e3c9a19$var$numericNotTerminated, diff);
                // When terminated and number, parse as either hexadecimal or decimal.
                reference = parseInt(characters, $560639d49e3c9a19$var$bases[type]);
                // Trigger a warning when the parsed number is prohibited, and replace
                // with replacement character.
                if ($560639d49e3c9a19$var$prohibited(reference)) {
                    warning($560639d49e3c9a19$var$numericProhibited, diff);
                    reference = $560639d49e3c9a19$var$fromCharCode($560639d49e3c9a19$var$replacementCharacter);
                } else if (reference in $560639d49e3c9a19$var$invalid) {
                    // Trigger a warning when the parsed number is disallowed, and replace
                    // by an alternative.
                    warning($560639d49e3c9a19$var$numericDisallowed, diff);
                    reference = $560639d49e3c9a19$var$invalid[reference];
                } else {
                    // Parse the number.
                    output = "";
                    // Trigger a warning when the parsed number should not be used.
                    if ($560639d49e3c9a19$var$disallowed(reference)) warning($560639d49e3c9a19$var$numericDisallowed, diff);
                    // Stringify the number.
                    if (reference > 0xffff) {
                        reference -= 0x10000;
                        output += $560639d49e3c9a19$var$fromCharCode(reference >>> 10 | 0xd800);
                        reference = 0xdc00 | reference & 0x3ff;
                    }
                    reference = output + $560639d49e3c9a19$var$fromCharCode(reference);
                }
            }
            // Found it!
            // First eat the queued characters as normal text, then eat an entity.
            if (reference) {
                flush();
                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;
                if (handleReference) handleReference.call(referenceContext, reference, {
                    start: prev,
                    end: next
                }, value.slice(start - 1, end));
                prev = next;
            } else {
                // If we could not find a reference, queue the checked characters (as
                // normal characters), and move the pointer to their end.
                // This is possible because we can be certain neither newlines nor
                // ampersands are included.
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            }
        } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
            }
            if (character === character) {
                queue += $560639d49e3c9a19$var$fromCharCode(character);
                column++;
            } else flush();
        }
    }
    // Return the reduced nodes.
    return result.join("");
    // Get current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
        };
    }
    // “Throw” a parse-error: a warning.
    function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, $560639d49e3c9a19$var$messages[code], position, code);
    }
    // Flush `queue` (normal text).
    // Macro invoked before each entity and at the end of `value`.
    // Does nothing when `queue` is empty.
    function flush() {
        if (queue) {
            result.push(queue);
            if (handleText) handleText.call(textContext, queue, {
                start: prev,
                end: now()
            });
            queue = "";
        }
    }
}
// Check if `character` is outside the permissible unicode range.
function $560639d49e3c9a19$var$prohibited(code) {
    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
}
// Check if `character` is disallowed.
function $560639d49e3c9a19$var$disallowed(code) {
    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
}
var $560639d49e3c9a19$var$decode = $560639d49e3c9a19$var$factory$3;
// Factory to create an entity decoder.
function $560639d49e3c9a19$var$factory$3(ctx) {
    decoder.raw = decodeRaw;
    return decoder;
    // Normalize `position` to add an `indent`.
    function normalize(position) {
        var offsets = ctx.offset;
        var line = position.line;
        var result = [];
        while(++line){
            if (!(line in offsets)) break;
            result.push((offsets[line] || 0) + 1);
        }
        return {
            start: position,
            indent: result
        };
    }
    // Decode `value` (at `position`) into text-nodes.
    function decoder(value, position, handler) {
        $560639d49e3c9a19$var$parseEntities_1(value, {
            position: normalize(position),
            warning: handleWarning,
            text: handler,
            reference: handler,
            textContext: ctx,
            referenceContext: ctx
        });
    }
    // Decode `value` (at `position`) into a string.
    function decodeRaw(value, position, options) {
        return $560639d49e3c9a19$var$parseEntities_1(value, $560639d49e3c9a19$var$immutable(options, {
            position: normalize(position),
            warning: handleWarning
        }));
    }
    // Handle a warning.
    // See <https://github.com/wooorm/parse-entities> for the warnings.
    function handleWarning(reason, position, code) {
        if (code !== 3) ctx.file.message(reason, position);
    }
}
var $560639d49e3c9a19$var$tokenizer$1 = $560639d49e3c9a19$var$factory$2;
// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
function $560639d49e3c9a19$var$factory$2(type) {
    return tokenize;
    // Tokenizer for a bound `type`.
    function tokenize(value, location) {
        var self = this;
        var offset = self.offset;
        var tokens = [];
        var methods = self[type + "Methods"];
        var tokenizers = self[type + "Tokenizers"];
        var line = location.line;
        var column = location.column;
        var index;
        var length;
        var method;
        var name;
        var matched;
        var valueLength;
        // Trim white space only lines.
        if (!value) return tokens;
        // Expose on `eat`.
        eat.now = now;
        eat.file = self.file;
        // Sync initial offset.
        updatePosition("");
        // Iterate over `value`, and iterate over all tokenizers.  When one eats
        // something, re-iterate with the remaining value.  If no tokenizer eats,
        // something failed (should not happen) and an exception is thrown.
        while(value){
            index = -1;
            length = methods.length;
            matched = false;
            while(++index < length){
                name = methods[index];
                method = tokenizers[name];
                // Previously, we had constructs such as footnotes and YAML that used
                // these properties.
                // Those are now external (plus there are userland extensions), that may
                // still use them.
                if (method && /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) && /* istanbul ignore next */ (!method.notInList || !self.inList) && /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {
                    valueLength = value.length;
                    method.apply(self, [
                        eat,
                        value
                    ]);
                    matched = valueLength !== value.length;
                    if (matched) break;
                }
            }
            /* istanbul ignore if */ if (!matched) self.file.fail(new Error("Infinite loop"), eat.now());
        }
        self.eof = now();
        return tokens;
        // Update line, column, and offset based on `value`.
        function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf("\n");
            while(index !== -1){
                line++;
                lastIndex = index;
                index = subvalue.indexOf("\n", index + 1);
            }
            if (lastIndex === -1) column += subvalue.length;
            else column = subvalue.length - lastIndex;
            if (line in offset) {
                if (lastIndex !== -1) column += offset[line];
                else if (column <= offset[line]) column = offset[line] + 1;
            }
        }
        // Get offset.  Called before the first character is eaten to retrieve the
        // range’s offsets.
        function getOffset() {
            var indentation = [];
            var pos = line + 1;
            // Done.  Called when the last character is eaten to retrieve the range’s
            // offsets.
            return function() {
                var last = line + 1;
                while(pos < last){
                    indentation.push((offset[pos] || 0) + 1);
                    pos++;
                }
                return indentation;
            };
        }
        // Get the current position.
        function now() {
            var pos = {
                line: line,
                column: column
            };
            pos.offset = self.toOffset(pos);
            return pos;
        }
        // Store position information for a node.
        function Position(start) {
            this.start = start;
            this.end = now();
        }
        // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
        // throw on new, incorrect rules.
        function validateEat(subvalue) {
            /* istanbul ignore if */ if (value.slice(0, subvalue.length) !== subvalue) // Capture stack-trace.
            self.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
        }
        // Mark position and patch `node.position`.
        function position() {
            var before = now();
            return update;
            // Add the position to a node.
            function update(node, indent) {
                var previous = node.position;
                var start = previous ? previous.start : before;
                var combined = [];
                var n = previous && previous.end.line;
                var l = before.line;
                node.position = new Position(start);
                // If there was already a `position`, this node was merged.  Fixing
                // `start` wasn’t hard, but the indent is different.  Especially
                // because some information, the indent between `n` and `l` wasn’t
                // tracked.  Luckily, that space is (should be?) empty, so we can
                // safely check for it now.
                if (previous && indent && previous.indent) {
                    combined = previous.indent;
                    if (n < l) {
                        while(++n < l)combined.push((offset[n] || 0) + 1);
                        combined.push(before.column);
                    }
                    indent = combined.concat(indent);
                }
                node.position.indent = indent || [];
                return node;
            }
        }
        // Add `node` to `parent`s children or to `tokens`.  Performs merges where
        // possible.
        function add(node, parent) {
            var children = parent ? parent.children : tokens;
            var previous = children[children.length - 1];
            var fn;
            if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $560639d49e3c9a19$var$mergeable(previous) && $560639d49e3c9a19$var$mergeable(node)) {
                fn = node.type === "text" ? $560639d49e3c9a19$var$mergeText : $560639d49e3c9a19$var$mergeBlockquote;
                node = fn.call(self, previous, node);
            }
            if (node !== previous) children.push(node);
            if (self.atStart && tokens.length !== 0) self.exitStart();
            return node;
        }
        // Remove `subvalue` from `value`.  `subvalue` must be at the start of
        // `value`.
        function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();
            validateEat(subvalue);
            apply.reset = reset;
            reset.test = test;
            apply.test = test;
            value = value.slice(subvalue.length);
            updatePosition(subvalue);
            indent = indent();
            return apply;
            // Add the given arguments, add `position` to the returned node, and
            // return the node.
            function apply(node, parent) {
                return pos(add(pos(node), parent), indent);
            }
            // Functions just like apply, but resets the content: the line and
            // column are reversed, and the eaten value is re-added.   This is
            // useful for nodes with a single type of content, such as lists and
            // tables.  See `apply` above for what parameters are expected.
            function reset() {
                var node = apply.apply(null, arguments);
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return node;
            }
            // Test the position, after eating, and reverse to a not-eaten state.
            function test() {
                var result = pos({});
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return result.position;
            }
        }
    }
}
// Check whether a node is mergeable with adjacent nodes.
function $560639d49e3c9a19$var$mergeable(node) {
    var start;
    var end;
    if (node.type !== "text" || !node.position) return true;
    start = node.position.start;
    end = node.position.end;
    // Only merge nodes which occupy the same size as their `value`.
    return start.line !== end.line || end.column - start.column === node.value.length;
}
// Merge two text nodes: `node` into `prev`.
function $560639d49e3c9a19$var$mergeText(previous, node) {
    previous.value += node.value;
    return previous;
}
// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
function $560639d49e3c9a19$var$mergeBlockquote(previous, node) {
    if (this.options.commonmark || this.options.gfm) return node;
    previous.children = previous.children.concat(node.children);
    return previous;
}
var $560639d49e3c9a19$var$markdownEscapes = $560639d49e3c9a19$var$escapes$1;
var $560639d49e3c9a19$var$defaults$2 = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
];
var $560639d49e3c9a19$var$gfm = $560639d49e3c9a19$var$defaults$2.concat([
    "~",
    "|"
]);
var $560639d49e3c9a19$var$commonmark = $560639d49e3c9a19$var$gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
]);
$560639d49e3c9a19$var$escapes$1.default = $560639d49e3c9a19$var$defaults$2;
$560639d49e3c9a19$var$escapes$1.gfm = $560639d49e3c9a19$var$gfm;
$560639d49e3c9a19$var$escapes$1.commonmark = $560639d49e3c9a19$var$commonmark;
// Get markdown escapes.
function $560639d49e3c9a19$var$escapes$1(options) {
    var settings = options || {};
    if (settings.commonmark) return $560639d49e3c9a19$var$commonmark;
    return settings.gfm ? $560639d49e3c9a19$var$gfm : $560639d49e3c9a19$var$defaults$2;
}
var $560639d49e3c9a19$var$blockElements = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
];
var $560639d49e3c9a19$var$defaults$1 = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: $560639d49e3c9a19$var$blockElements
};
var $560639d49e3c9a19$var$setOptions_1 = $560639d49e3c9a19$var$setOptions;
function $560639d49e3c9a19$var$setOptions(options) {
    var self = this;
    var current = self.options;
    var key;
    var value;
    if (options == null) options = {};
    else if (typeof options === "object") options = $560639d49e3c9a19$var$immutable(options);
    else throw new Error("Invalid value `" + options + "` for setting `options`");
    for(key in $560639d49e3c9a19$var$defaults$1){
        value = options[key];
        if (value == null) value = current[key];
        if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
        options[key] = value;
    }
    self.options = options;
    self.escape = $560639d49e3c9a19$var$markdownEscapes(options);
    return self;
}
var $560639d49e3c9a19$var$convert_1 = $560639d49e3c9a19$var$convert$1;
function $560639d49e3c9a19$var$convert$1(test) {
    if (test == null) return $560639d49e3c9a19$var$ok$1;
    if (typeof test === "string") return $560639d49e3c9a19$var$typeFactory$1(test);
    if (typeof test === "object") return "length" in test ? $560639d49e3c9a19$var$anyFactory$1(test) : $560639d49e3c9a19$var$allFactory(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $560639d49e3c9a19$var$allFactory(test) {
    return all;
    function all(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $560639d49e3c9a19$var$anyFactory$1(tests) {
    var checks = [];
    var index = -1;
    while(++index < tests.length)checks[index] = $560639d49e3c9a19$var$convert$1(tests[index]);
    return any;
    function any() {
        var index = -1;
        while(++index < checks.length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $560639d49e3c9a19$var$typeFactory$1(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $560639d49e3c9a19$var$ok$1() {
    return true;
}
var $560639d49e3c9a19$var$color_1 = $560639d49e3c9a19$var$color;
function $560639d49e3c9a19$var$color(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}
var $560639d49e3c9a19$var$unistUtilVisitParents = $560639d49e3c9a19$var$visitParents;
var $560639d49e3c9a19$var$CONTINUE$1 = true;
var $560639d49e3c9a19$var$SKIP$1 = "skip";
var $560639d49e3c9a19$var$EXIT$1 = false;
$560639d49e3c9a19$var$visitParents.CONTINUE = $560639d49e3c9a19$var$CONTINUE$1;
$560639d49e3c9a19$var$visitParents.SKIP = $560639d49e3c9a19$var$SKIP$1;
$560639d49e3c9a19$var$visitParents.EXIT = $560639d49e3c9a19$var$EXIT$1;
function $560639d49e3c9a19$var$visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    is = $560639d49e3c9a19$var$convert_1(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name;
        if (typeof value.type === "string") {
            name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            visit.displayName = "node (" + $560639d49e3c9a19$var$color_1(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
            var grandparents = parents.concat(node);
            var result = [];
            var subresult;
            var offset;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $560639d49e3c9a19$var$toResult(visitor(node, parents));
                if (result[0] === $560639d49e3c9a19$var$EXIT$1) return result;
            }
            if (node.children && result[0] !== $560639d49e3c9a19$var$SKIP$1) {
                offset = (reverse ? node.children.length : -1) + step;
                while(offset > -1 && offset < node.children.length){
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $560639d49e3c9a19$var$EXIT$1) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
}
function $560639d49e3c9a19$var$toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) return value;
    if (typeof value === "number") return [
        $560639d49e3c9a19$var$CONTINUE$1,
        value
    ];
    return [
        value
    ];
}
var $560639d49e3c9a19$var$unistUtilVisit = $560639d49e3c9a19$var$visit;
var $560639d49e3c9a19$var$CONTINUE = $560639d49e3c9a19$var$unistUtilVisitParents.CONTINUE;
var $560639d49e3c9a19$var$SKIP = $560639d49e3c9a19$var$unistUtilVisitParents.SKIP;
var $560639d49e3c9a19$var$EXIT = $560639d49e3c9a19$var$unistUtilVisitParents.EXIT;
$560639d49e3c9a19$var$visit.CONTINUE = $560639d49e3c9a19$var$CONTINUE;
$560639d49e3c9a19$var$visit.SKIP = $560639d49e3c9a19$var$SKIP;
$560639d49e3c9a19$var$visit.EXIT = $560639d49e3c9a19$var$EXIT;
function $560639d49e3c9a19$var$visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    $560639d49e3c9a19$var$unistUtilVisitParents(tree, test, overload, reverse);
    function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index, parent);
    }
}
var $560639d49e3c9a19$var$unistUtilRemovePosition = $560639d49e3c9a19$var$removePosition;
function $560639d49e3c9a19$var$removePosition(node, force) {
    $560639d49e3c9a19$var$unistUtilVisit(node, force ? $560639d49e3c9a19$var$hard : $560639d49e3c9a19$var$soft);
    return node;
}
function $560639d49e3c9a19$var$hard(node) {
    delete node.position;
}
function $560639d49e3c9a19$var$soft(node) {
    node.position = undefined;
}
var $560639d49e3c9a19$var$parse_1$2 = $560639d49e3c9a19$var$parse$6;
var $560639d49e3c9a19$var$lineFeed$i = "\n";
var $560639d49e3c9a19$var$lineBreaksExpression = /\r\n|\r/g;
// Parse the bound file.
function $560639d49e3c9a19$var$parse$6() {
    var self = this;
    var value = String(self.file);
    var start = {
        line: 1,
        column: 1,
        offset: 0
    };
    var content = $560639d49e3c9a19$var$immutable(start);
    var node;
    // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
    // This should not affect positional information.
    value = value.replace($560639d49e3c9a19$var$lineBreaksExpression, $560639d49e3c9a19$var$lineFeed$i);
    // BOM.
    if (value.charCodeAt(0) === 0xfeff) {
        value = value.slice(1);
        content.column++;
        content.offset++;
    }
    node = {
        type: "root",
        children: self.tokenizeBlock(value, content),
        position: {
            start: start,
            end: self.eof || $560639d49e3c9a19$var$immutable(start)
        }
    };
    if (!self.options.position) $560639d49e3c9a19$var$unistUtilRemovePosition(node, true);
    return node;
}
// A line containing no characters, or a line containing only spaces (U+0020) or
// tabs (U+0009), is called a blank line.
// See <https://spec.commonmark.org/0.29/#blank-line>.
var $560639d49e3c9a19$var$reBlankLine = /^[ \t]*(\n|$)/;
// Note that though blank lines play a special role in lists to determine
// whether the list is tight or loose
// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
// tokenizer and this blank line tokenizer does not have to be responsible for
// that.
// Therefore, configs such as `blankLine.notInList` do not have to be set here.
var $560639d49e3c9a19$var$blankLine_1 = $560639d49e3c9a19$var$blankLine;
function $560639d49e3c9a19$var$blankLine(eat, value, silent) {
    var match;
    var subvalue = "";
    var index = 0;
    var length = value.length;
    while(index < length){
        match = $560639d49e3c9a19$var$reBlankLine.exec(value.slice(index));
        if (match == null) break;
        index += match[0].length;
        subvalue += match[0];
    }
    if (subvalue === "") return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    eat(subvalue);
}
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ /**
 * Results cache
 */ var $560639d49e3c9a19$var$res = "";
var $560639d49e3c9a19$var$cache;
/**
 * Expose `repeat`
 */ var $560639d49e3c9a19$var$repeatString = $560639d49e3c9a19$var$repeat$1;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */ function $560639d49e3c9a19$var$repeat$1(str, num) {
    if (typeof str !== "string") throw new TypeError("expected a string");
    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;
    var max = str.length * num;
    if ($560639d49e3c9a19$var$cache !== str || typeof $560639d49e3c9a19$var$cache === "undefined") {
        $560639d49e3c9a19$var$cache = str;
        $560639d49e3c9a19$var$res = "";
    } else if ($560639d49e3c9a19$var$res.length >= max) return $560639d49e3c9a19$var$res.substr(0, max);
    while(max > $560639d49e3c9a19$var$res.length && num > 1){
        if (num & 1) $560639d49e3c9a19$var$res += str;
        num >>= 1;
        str += str;
    }
    $560639d49e3c9a19$var$res += str;
    $560639d49e3c9a19$var$res = $560639d49e3c9a19$var$res.substr(0, max);
    return $560639d49e3c9a19$var$res;
}
var $560639d49e3c9a19$var$trimTrailingLines_1 = $560639d49e3c9a19$var$trimTrailingLines;
var $560639d49e3c9a19$var$line = "\n";
// Remove final newline characters from `value`.
function $560639d49e3c9a19$var$trimTrailingLines(value) {
    var val = String(value);
    var index = val.length;
    while(val.charAt(--index) === $560639d49e3c9a19$var$line);
    return val.slice(0, index + 1);
}
var $560639d49e3c9a19$var$codeIndented = $560639d49e3c9a19$var$indentedCode$1;
var $560639d49e3c9a19$var$lineFeed$h = "\n";
var $560639d49e3c9a19$var$tab$d = "	";
var $560639d49e3c9a19$var$space$i = " ";
var $560639d49e3c9a19$var$tabSize$4 = 4;
var $560639d49e3c9a19$var$codeIndent = $560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$i, $560639d49e3c9a19$var$tabSize$4);
function $560639d49e3c9a19$var$indentedCode$1(eat, value, silent) {
    var index = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent;
    while(++index < length){
        character = value.charAt(index);
        if (indent) {
            indent = false;
            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = "";
            contentQueue = "";
            if (character === $560639d49e3c9a19$var$lineFeed$h) {
                subvalueQueue = character;
                contentQueue = character;
            } else {
                subvalue += character;
                content += character;
                while(++index < length){
                    character = value.charAt(index);
                    if (!character || character === $560639d49e3c9a19$var$lineFeed$h) {
                        contentQueue = character;
                        subvalueQueue = character;
                        break;
                    }
                    subvalue += character;
                    content += character;
                }
            }
        } else if (character === $560639d49e3c9a19$var$space$i && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
            subvalueQueue += $560639d49e3c9a19$var$codeIndent;
            index += 3;
            indent = true;
        } else if (character === $560639d49e3c9a19$var$tab$d) {
            subvalueQueue += character;
            indent = true;
        } else {
            blankQueue = "";
            while(character === $560639d49e3c9a19$var$tab$d || character === $560639d49e3c9a19$var$space$i){
                blankQueue += character;
                character = value.charAt(++index);
            }
            if (character !== $560639d49e3c9a19$var$lineFeed$h) break;
            subvalueQueue += blankQueue + character;
            contentQueue += character;
        }
    }
    if (content) {
        if (silent) return true;
        return eat(subvalue)({
            type: "code",
            lang: null,
            meta: null,
            value: $560639d49e3c9a19$var$trimTrailingLines_1(content)
        });
    }
}
var $560639d49e3c9a19$var$codeFenced = $560639d49e3c9a19$var$fencedCode;
var $560639d49e3c9a19$var$lineFeed$g = "\n";
var $560639d49e3c9a19$var$tab$c = "	";
var $560639d49e3c9a19$var$space$h = " ";
var $560639d49e3c9a19$var$tilde$3 = "~";
var $560639d49e3c9a19$var$graveAccent$2 = "`";
var $560639d49e3c9a19$var$minFenceCount = 3;
var $560639d49e3c9a19$var$tabSize$3 = 4;
function $560639d49e3c9a19$var$fencedCode(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var length = value.length + 1;
    var index = 0;
    var subvalue = "";
    var fenceCount;
    var marker;
    var character;
    var flag;
    var lang;
    var meta;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;
    if (!gfm) return;
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c) break;
        subvalue += character;
        index++;
    }
    indent = index;
    // Eat the fence.
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tilde$3 && character !== $560639d49e3c9a19$var$graveAccent$2) return;
    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;
    while(index < length){
        character = value.charAt(index);
        if (character !== marker) break;
        subvalue += character;
        fenceCount++;
        index++;
    }
    if (fenceCount < $560639d49e3c9a19$var$minFenceCount) return;
    // Eat spacing before flag.
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c) break;
        subvalue += character;
        index++;
    }
    // Eat flag.
    flag = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$lineFeed$g || marker === $560639d49e3c9a19$var$graveAccent$2 && character === marker) break;
        if (character === $560639d49e3c9a19$var$space$h || character === $560639d49e3c9a19$var$tab$c) queue += character;
        else {
            flag += queue + character;
            queue = "";
        }
        index++;
    }
    character = value.charAt(index);
    if (character && character !== $560639d49e3c9a19$var$lineFeed$g) return;
    if (silent) return true;
    now = eat.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self.decode.raw(self.unescape(flag), now);
    if (queue) subvalue += queue;
    queue = "";
    closing = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    // Eat content.
    while(index < length){
        character = value.charAt(index);
        content += closing;
        exdentedContent += exdentedClosing;
        closing = "";
        exdentedClosing = "";
        if (character !== $560639d49e3c9a19$var$lineFeed$g) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
        }
        // The first line feed is ignored. Others aren’t.
        if (skip) {
            subvalue += character;
            skip = false;
        } else {
            closing += character;
            exdentedClosing += character;
        }
        queue = "";
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character !== $560639d49e3c9a19$var$space$h) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue.slice(indent);
        if (queue.length >= $560639d49e3c9a19$var$tabSize$3) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== marker) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue;
        if (queue.length < fenceCount) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c) break;
            closing += character;
            exdentedClosing += character;
            index++;
        }
        if (!character || character === $560639d49e3c9a19$var$lineFeed$g) break;
    }
    subvalue += content + closing;
    // Get lang and meta from the flag.
    index = -1;
    length = flag.length;
    while(++index < length){
        character = flag.charAt(index);
        if (character === $560639d49e3c9a19$var$space$h || character === $560639d49e3c9a19$var$tab$c) {
            if (!lang) lang = flag.slice(0, index);
        } else if (lang) {
            meta = flag.slice(index);
            break;
        }
    }
    return eat(subvalue)({
        type: "code",
        lang: lang || flag || null,
        meta: meta || null,
        value: exdentedContent
    });
}
var $560639d49e3c9a19$var$trim_1 = $560639d49e3c9a19$var$createCommonjsModule(function(module, exports) {
    exports = module.exports = trim;
    function trim(str) {
        return str.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str) {
        return str.replace(/^\s*/, "");
    };
    exports.right = function(str) {
        return str.replace(/\s*$/, "");
    };
});
$560639d49e3c9a19$var$trim_1.left;
$560639d49e3c9a19$var$trim_1.right;
var $560639d49e3c9a19$var$interrupt_1 = $560639d49e3c9a19$var$interrupt;
function $560639d49e3c9a19$var$interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index = -1;
    var interruptor;
    var config;
    while(++index < length){
        interruptor = interruptors[index];
        config = interruptor[1] || {};
        if (config.pedantic !== undefined && config.pedantic !== ctx.options.pedantic) continue;
        if (config.commonmark !== undefined && config.commonmark !== ctx.options.commonmark) continue;
        if (tokenizers[interruptor[0]].apply(ctx, parameters)) return true;
    }
    return false;
}
var $560639d49e3c9a19$var$blockquote_1$1 = $560639d49e3c9a19$var$blockquote$1;
var $560639d49e3c9a19$var$lineFeed$f = "\n";
var $560639d49e3c9a19$var$tab$b = "	";
var $560639d49e3c9a19$var$space$g = " ";
var $560639d49e3c9a19$var$greaterThan$4 = ">";
function $560639d49e3c9a19$var$blockquote$1(eat, value, silent) {
    var self = this;
    var offsets = self.offset;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptBlockquote;
    var now = eat.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$g && character !== $560639d49e3c9a19$var$tab$b) break;
        index++;
    }
    if (value.charAt(index) !== $560639d49e3c9a19$var$greaterThan$4) return;
    if (silent) return true;
    index = 0;
    while(index < length){
        nextIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$f, index);
        startIndex = index;
        prefixed = false;
        if (nextIndex === -1) nextIndex = length;
        while(index < length){
            character = value.charAt(index);
            if (character !== $560639d49e3c9a19$var$space$g && character !== $560639d49e3c9a19$var$tab$b) break;
            index++;
        }
        if (value.charAt(index) === $560639d49e3c9a19$var$greaterThan$4) {
            index++;
            prefixed = true;
            if (value.charAt(index) === $560639d49e3c9a19$var$space$g) index++;
        } else index = startIndex;
        content = value.slice(index, nextIndex);
        if (!prefixed && !$560639d49e3c9a19$var$trim_1(content)) {
            index = startIndex;
            break;
        }
        if (!prefixed) {
            rest = value.slice(index);
            // Check if the following code contains a possible block.
            if ($560639d49e3c9a19$var$interrupt_1(interruptors, tokenizers, self, [
                eat,
                rest,
                true
            ])) break;
        }
        line = startIndex === index ? content : value.slice(startIndex, nextIndex);
        indents.push(index - startIndex);
        values.push(line);
        contents.push(content);
        index = nextIndex + 1;
    }
    index = -1;
    length = indents.length;
    add = eat(values.join($560639d49e3c9a19$var$lineFeed$f));
    while(++index < length){
        offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
        currentLine++;
    }
    exit = self.enterBlock();
    contents = self.tokenizeBlock(contents.join($560639d49e3c9a19$var$lineFeed$f), now);
    exit();
    return add({
        type: "blockquote",
        children: contents
    });
}
var $560639d49e3c9a19$var$headingAtx = $560639d49e3c9a19$var$atxHeading;
var $560639d49e3c9a19$var$lineFeed$e = "\n";
var $560639d49e3c9a19$var$tab$a = "	";
var $560639d49e3c9a19$var$space$f = " ";
var $560639d49e3c9a19$var$numberSign = "#";
var $560639d49e3c9a19$var$maxFenceCount = 6;
function $560639d49e3c9a19$var$atxHeading(eat, value, silent) {
    var self = this;
    var pedantic = self.options.pedantic;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    // Eat initial spacing.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat hashes.
    depth = 0;
    while(++index <= length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$numberSign) {
            index--;
            break;
        }
        subvalue += character;
        depth++;
    }
    if (depth > $560639d49e3c9a19$var$maxFenceCount) return;
    if (!depth || !pedantic && value.charAt(index + 1) === $560639d49e3c9a19$var$numberSign) return;
    length = value.length + 1;
    // Eat intermediate white-space.
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a) {
            index--;
            break;
        }
        queue += character;
    }
    // Exit when not in pedantic mode without spacing.
    if (!pedantic && queue.length === 0 && character && character !== $560639d49e3c9a19$var$lineFeed$e) return;
    if (silent) return true;
    // Eat content.
    subvalue += queue;
    queue = "";
    content = "";
    while(++index < length){
        character = value.charAt(index);
        if (!character || character === $560639d49e3c9a19$var$lineFeed$e) break;
        if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a && character !== $560639d49e3c9a19$var$numberSign) {
            content += queue + character;
            queue = "";
            continue;
        }
        while(character === $560639d49e3c9a19$var$space$f || character === $560639d49e3c9a19$var$tab$a){
            queue += character;
            character = value.charAt(++index);
        }
        // `#` without a queue is part of the content.
        if (!pedantic && content && !queue && character === $560639d49e3c9a19$var$numberSign) {
            content += character;
            continue;
        }
        while(character === $560639d49e3c9a19$var$numberSign){
            queue += character;
            character = value.charAt(++index);
        }
        while(character === $560639d49e3c9a19$var$space$f || character === $560639d49e3c9a19$var$tab$a){
            queue += character;
            character = value.charAt(++index);
        }
        index--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat(subvalue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}
var $560639d49e3c9a19$var$thematicBreak_1$1 = $560639d49e3c9a19$var$thematicBreak$1;
var $560639d49e3c9a19$var$tab$9 = "	";
var $560639d49e3c9a19$var$lineFeed$d = "\n";
var $560639d49e3c9a19$var$space$e = " ";
var $560639d49e3c9a19$var$asterisk$4 = "*";
var $560639d49e3c9a19$var$dash$7 = "-";
var $560639d49e3c9a19$var$underscore$6 = "_";
var $560639d49e3c9a19$var$maxCount = 3;
function $560639d49e3c9a19$var$thematicBreak$1(eat, value, silent) {
    var index = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker;
    var markerCount;
    var queue;
    while(++index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$9 && character !== $560639d49e3c9a19$var$space$e) break;
        subvalue += character;
    }
    if (character !== $560639d49e3c9a19$var$asterisk$4 && character !== $560639d49e3c9a19$var$dash$7 && character !== $560639d49e3c9a19$var$underscore$6) return;
    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = "";
        } else if (character === $560639d49e3c9a19$var$space$e) queue += character;
        else if (markerCount >= $560639d49e3c9a19$var$maxCount && (!character || character === $560639d49e3c9a19$var$lineFeed$d)) {
            subvalue += queue;
            if (silent) return true;
            return eat(subvalue)({
                type: "thematicBreak"
            });
        } else return;
    }
}
var $560639d49e3c9a19$var$getIndentation = $560639d49e3c9a19$var$indentation$1;
var $560639d49e3c9a19$var$tab$8 = "	";
var $560639d49e3c9a19$var$space$d = " ";
var $560639d49e3c9a19$var$spaceSize = 1;
var $560639d49e3c9a19$var$tabSize$2 = 4;
// Gets indentation information for a line.
function $560639d49e3c9a19$var$indentation$1(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;
    var lastIndent = 0;
    while(character === $560639d49e3c9a19$var$tab$8 || character === $560639d49e3c9a19$var$space$d){
        size = character === $560639d49e3c9a19$var$tab$8 ? $560639d49e3c9a19$var$tabSize$2 : $560639d49e3c9a19$var$spaceSize;
        indent += size;
        if (size > 1) indent = Math.floor(indent / size) * size;
        while(lastIndent < indent)stops[++lastIndent] = index;
        character = value.charAt(++index);
    }
    return {
        indent: indent,
        stops: stops
    };
}
var $560639d49e3c9a19$var$removeIndentation = $560639d49e3c9a19$var$indentation;
var $560639d49e3c9a19$var$lineFeed$c = "\n";
var $560639d49e3c9a19$var$space$c = " ";
var $560639d49e3c9a19$var$exclamationMark$4 = "!";
// Remove the minimum indent from every line in `value`.  Supports both tab,
// spaced, and mixed indentation (as well as possible).
function $560639d49e3c9a19$var$indentation(value, maximum) {
    var values = value.split($560639d49e3c9a19$var$lineFeed$c);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    values.unshift($560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$c, maximum) + $560639d49e3c9a19$var$exclamationMark$4);
    while(position--){
        indentation = $560639d49e3c9a19$var$getIndentation(values[position]);
        matrix[position] = indentation.stops;
        if ($560639d49e3c9a19$var$trim_1(values[position]).length === 0) continue;
        if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) minIndent = indentation.indent;
        } else {
            minIndent = Infinity;
            break;
        }
    }
    if (minIndent !== Infinity) {
        position = values.length;
        while(position--){
            stops = matrix[position];
            index = minIndent;
            while(index && !(index in stops))index--;
            values[position] = values[position].slice(stops[index] + 1);
        }
    }
    values.shift();
    return values.join($560639d49e3c9a19$var$lineFeed$c);
}
var $560639d49e3c9a19$var$list_1$1 = $560639d49e3c9a19$var$list$1;
var $560639d49e3c9a19$var$asterisk$3 = "*";
var $560639d49e3c9a19$var$underscore$5 = "_";
var $560639d49e3c9a19$var$plusSign$2 = "+";
var $560639d49e3c9a19$var$dash$6 = "-";
var $560639d49e3c9a19$var$dot$3 = ".";
var $560639d49e3c9a19$var$space$b = " ";
var $560639d49e3c9a19$var$lineFeed$b = "\n";
var $560639d49e3c9a19$var$tab$7 = "	";
var $560639d49e3c9a19$var$rightParenthesis$3 = ")";
var $560639d49e3c9a19$var$lowercaseX = "x";
var $560639d49e3c9a19$var$tabSize$1 = 4;
var $560639d49e3c9a19$var$looseListItemExpression = /\n\n(?!\s*$)/;
var $560639d49e3c9a19$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
var $560639d49e3c9a19$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var $560639d49e3c9a19$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var $560639d49e3c9a19$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
function $560639d49e3c9a19$var$list$1(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var pedantic = self.options.pedantic;
    var tokenizers = self.blockTokenizers;
    var interuptors = self.interruptList;
    var index = 0;
    var length = value.length;
    var start = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread = false;
    var node;
    var now;
    var end;
    var indented;
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$7 && character !== $560639d49e3c9a19$var$space$b) break;
        index++;
    }
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$asterisk$3 || character === $560639d49e3c9a19$var$plusSign$2 || character === $560639d49e3c9a19$var$dash$6) {
        marker = character;
        ordered = false;
    } else {
        ordered = true;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (!$560639d49e3c9a19$var$isDecimal(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (!queue || !(character === $560639d49e3c9a19$var$dot$3 || commonmark && character === $560639d49e3c9a19$var$rightParenthesis$3)) return;
        /* Slightly abusing `silent` mode, whose goal is to make interrupting
     * paragraphs work.
     * Well, that’s exactly what we want to do here: don’t interrupt:
     * 2. here, because the “list” doesn’t start with `1`. */ if (silent && queue !== "1") return;
        start = parseInt(queue, 10);
        marker = character;
    }
    character = value.charAt(++index);
    if (character !== $560639d49e3c9a19$var$space$b && character !== $560639d49e3c9a19$var$tab$7 && (pedantic || character !== $560639d49e3c9a19$var$lineFeed$b && character !== "")) return;
    if (silent) return true;
    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while(index < length){
        nextIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$b, index);
        startIndex = index;
        prefixed = false;
        indented = false;
        if (nextIndex === -1) nextIndex = length;
        size = 0;
        while(index < length){
            character = value.charAt(index);
            if (character === $560639d49e3c9a19$var$tab$7) size += $560639d49e3c9a19$var$tabSize$1 - size % $560639d49e3c9a19$var$tabSize$1;
            else if (character === $560639d49e3c9a19$var$space$b) size++;
            else break;
            index++;
        }
        if (item && size >= item.indent) indented = true;
        character = value.charAt(index);
        currentMarker = null;
        if (!indented) {
            if (character === $560639d49e3c9a19$var$asterisk$3 || character === $560639d49e3c9a19$var$plusSign$2 || character === $560639d49e3c9a19$var$dash$6) {
                currentMarker = character;
                index++;
                size++;
            } else {
                queue = "";
                while(index < length){
                    character = value.charAt(index);
                    if (!$560639d49e3c9a19$var$isDecimal(character)) break;
                    queue += character;
                    index++;
                }
                character = value.charAt(index);
                index++;
                if (queue && (character === $560639d49e3c9a19$var$dot$3 || commonmark && character === $560639d49e3c9a19$var$rightParenthesis$3)) {
                    currentMarker = character;
                    size += queue.length + 1;
                }
            }
            if (currentMarker) {
                character = value.charAt(index);
                if (character === $560639d49e3c9a19$var$tab$7) {
                    size += $560639d49e3c9a19$var$tabSize$1 - size % $560639d49e3c9a19$var$tabSize$1;
                    index++;
                } else if (character === $560639d49e3c9a19$var$space$b) {
                    end = index + $560639d49e3c9a19$var$tabSize$1;
                    while(index < end){
                        if (value.charAt(index) !== $560639d49e3c9a19$var$space$b) break;
                        index++;
                        size++;
                    }
                    if (index === end && value.charAt(index) === $560639d49e3c9a19$var$space$b) {
                        index -= $560639d49e3c9a19$var$tabSize$1 - 1;
                        size -= $560639d49e3c9a19$var$tabSize$1 - 1;
                    }
                } else if (character !== $560639d49e3c9a19$var$lineFeed$b && character !== "") currentMarker = null;
            }
        }
        if (currentMarker) {
            if (!pedantic && marker !== currentMarker) break;
            prefixed = true;
        } else {
            if (!commonmark && !indented && value.charAt(startIndex) === $560639d49e3c9a19$var$space$b) indented = true;
            else if (commonmark && item) indented = size >= item.indent || size > $560639d49e3c9a19$var$tabSize$1;
            prefixed = false;
            index = startIndex;
        }
        line = value.slice(startIndex, nextIndex);
        content = startIndex === index ? line : value.slice(index, nextIndex);
        if (currentMarker === $560639d49e3c9a19$var$asterisk$3 || currentMarker === $560639d49e3c9a19$var$underscore$5 || currentMarker === $560639d49e3c9a19$var$dash$6) {
            if (tokenizers.thematicBreak.call(self, eat, line, true)) break;
        }
        previousEmpty = empty;
        empty = !prefixed && !$560639d49e3c9a19$var$trim_1(content).length;
        if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (prefixed) {
            if (emptyLines.length !== 0) {
                spread = true;
                item.value.push("");
                item.trail = emptyLines.concat();
            }
            item = {
                value: [
                    line
                ],
                indent: size,
                trail: []
            };
            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (empty) {
            if (previousEmpty && !commonmark) break;
            emptyLines.push(line);
        } else {
            if (previousEmpty) break;
            if ($560639d49e3c9a19$var$interrupt_1(interuptors, tokenizers, self, [
                eat,
                line,
                true
            ])) break;
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        }
        index = nextIndex + 1;
    }
    node = eat(allLines.join($560639d49e3c9a19$var$lineFeed$b)).reset({
        type: "list",
        ordered: ordered,
        start: start,
        spread: spread,
        children: []
    });
    enterTop = self.enterList();
    exitBlockquote = self.enterBlock();
    index = -1;
    length = items.length;
    while(++index < length){
        item = items[index].value.join($560639d49e3c9a19$var$lineFeed$b);
        now = eat.now();
        eat(item)($560639d49e3c9a19$var$listItem$2(self, item, now), node);
        item = items[index].trail.join($560639d49e3c9a19$var$lineFeed$b);
        if (index !== length - 1) item += $560639d49e3c9a19$var$lineFeed$b;
        eat(item);
    }
    enterTop();
    exitBlockquote();
    return node;
}
function $560639d49e3c9a19$var$listItem$2(ctx, value, position) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? $560639d49e3c9a19$var$pedanticListItem : $560639d49e3c9a19$var$normalListItem;
    var checked = null;
    var task;
    var indent;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
        task = value.match($560639d49e3c9a19$var$taskItemExpression);
        if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === $560639d49e3c9a19$var$lowercaseX;
            offsets[position.line] += indent;
            value = value.slice(indent);
        }
    }
    return {
        type: "listItem",
        spread: $560639d49e3c9a19$var$looseListItemExpression.test(value),
        checked: checked,
        children: ctx.tokenizeBlock(value, position)
    };
}
// Create a list-item using overly simple mechanics.
function $560639d49e3c9a19$var$pedanticListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    // Remove the list-item’s bullet.
    value = value.replace($560639d49e3c9a19$var$pedanticBulletExpression, replacer);
    // The initial line was also matched by the below, so we reset the `line`.
    line = position.line;
    return value.replace($560639d49e3c9a19$var$initialIndentExpression, replacer);
    // A simple replacer which removed all matches, and adds their length to
    // `offset`.
    function replacer($0) {
        offsets[line] = (offsets[line] || 0) + $0.length;
        line++;
        return "";
    }
}
// Create a list-item using sane mechanics.
function $560639d49e3c9a19$var$normalListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;
    // Remove the list-item’s bullet.
    value = value.replace($560639d49e3c9a19$var$bulletExpression, replacer);
    lines = value.split($560639d49e3c9a19$var$lineFeed$b);
    trimmedLines = $560639d49e3c9a19$var$removeIndentation(value, $560639d49e3c9a19$var$getIndentation(max).indent).split($560639d49e3c9a19$var$lineFeed$b);
    // We replaced the initial bullet with something else above, which was used
    // to trick `removeIndentation` into removing some more characters when
    // possible.  However, that could result in the initial line to be stripped
    // more than it should be.
    trimmedLines[0] = rest;
    offsets[line] = (offsets[line] || 0) + bullet.length;
    line++;
    index = 0;
    length = lines.length;
    while(++index < length){
        offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
        line++;
    }
    return trimmedLines.join($560639d49e3c9a19$var$lineFeed$b);
    /* eslint-disable-next-line max-params */ function replacer($0, $1, $2, $3, $4) {
        bullet = $1 + $2 + $3;
        rest = $4;
        // Make sure that the first nine numbered list items can indent with an
        // extra space.  That is, when the bullet did not receive an extra final
        // space.
        if (Number($2) < 10 && bullet.length % 2 === 1) $2 = $560639d49e3c9a19$var$space$b + $2;
        max = $1 + $560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$b, $2.length) + $3;
        return max + rest;
    }
}
var $560639d49e3c9a19$var$headingSetext = $560639d49e3c9a19$var$setextHeading;
var $560639d49e3c9a19$var$lineFeed$a = "\n";
var $560639d49e3c9a19$var$tab$6 = "	";
var $560639d49e3c9a19$var$space$a = " ";
var $560639d49e3c9a19$var$equalsTo$1 = "=";
var $560639d49e3c9a19$var$dash$5 = "-";
var $560639d49e3c9a19$var$maxIndent = 3;
var $560639d49e3c9a19$var$equalsToDepth = 1;
var $560639d49e3c9a19$var$dashDepth = 2;
function $560639d49e3c9a19$var$setextHeading(eat, value, silent) {
    var self = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker;
    var depth;
    // Eat initial indentation.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$a || index >= $560639d49e3c9a19$var$maxIndent) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat content.
    content = "";
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$lineFeed$a) {
            index--;
            break;
        }
        if (character === $560639d49e3c9a19$var$space$a || character === $560639d49e3c9a19$var$tab$6) queue += character;
        else {
            content += queue + character;
            queue = "";
        }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    // Ensure the content is followed by a newline and a valid marker.
    character = value.charAt(++index);
    marker = value.charAt(++index);
    if (character !== $560639d49e3c9a19$var$lineFeed$a || marker !== $560639d49e3c9a19$var$equalsTo$1 && marker !== $560639d49e3c9a19$var$dash$5) return;
    subvalue += character;
    // Eat Setext-line.
    queue = marker;
    depth = marker === $560639d49e3c9a19$var$equalsTo$1 ? $560639d49e3c9a19$var$equalsToDepth : $560639d49e3c9a19$var$dashDepth;
    while(++index < length){
        character = value.charAt(index);
        if (character !== marker) {
            if (character !== $560639d49e3c9a19$var$lineFeed$a) return;
            index--;
            break;
        }
        queue += character;
    }
    if (silent) return true;
    return eat(subvalue + queue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}
var $560639d49e3c9a19$var$attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var $560639d49e3c9a19$var$unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
var $560639d49e3c9a19$var$singleQuoted$2 = "'[^']*'";
var $560639d49e3c9a19$var$doubleQuoted$2 = '"[^"]*"';
var $560639d49e3c9a19$var$attributeValue$2 = "(?:" + $560639d49e3c9a19$var$unquoted$2 + "|" + $560639d49e3c9a19$var$singleQuoted$2 + "|" + $560639d49e3c9a19$var$doubleQuoted$2 + ")";
var $560639d49e3c9a19$var$attribute$2 = "(?:\\s+" + $560639d49e3c9a19$var$attributeName$2 + "(?:\\s*=\\s*" + $560639d49e3c9a19$var$attributeValue$2 + ")?)";
var $560639d49e3c9a19$var$openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + $560639d49e3c9a19$var$attribute$2 + "*\\s*\\/?>";
var $560639d49e3c9a19$var$closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var $560639d49e3c9a19$var$comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var $560639d49e3c9a19$var$processing = "<[?].*?[?]>";
var $560639d49e3c9a19$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
var $560639d49e3c9a19$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var $560639d49e3c9a19$var$openCloseTag$2 = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag$1 + "|" + $560639d49e3c9a19$var$closeTag$1 + ")");
var $560639d49e3c9a19$var$tag$2 = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag$1 + "|" + $560639d49e3c9a19$var$closeTag$1 + "|" + $560639d49e3c9a19$var$comment$1 + "|" + $560639d49e3c9a19$var$processing + "|" + $560639d49e3c9a19$var$declaration + "|" + $560639d49e3c9a19$var$cdata + ")");
var $560639d49e3c9a19$var$html$4 = {
    openCloseTag: $560639d49e3c9a19$var$openCloseTag$2,
    tag: $560639d49e3c9a19$var$tag$2
};
var $560639d49e3c9a19$var$openCloseTag$1 = $560639d49e3c9a19$var$html$4.openCloseTag;
var $560639d49e3c9a19$var$htmlBlock = $560639d49e3c9a19$var$blockHtml$1;
var $560639d49e3c9a19$var$tab$5 = "	";
var $560639d49e3c9a19$var$space$9 = " ";
var $560639d49e3c9a19$var$lineFeed$9 = "\n";
var $560639d49e3c9a19$var$lessThan$7 = "<";
var $560639d49e3c9a19$var$rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var $560639d49e3c9a19$var$rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var $560639d49e3c9a19$var$commentOpenExpression$1 = /^<!--/;
var $560639d49e3c9a19$var$commentCloseExpression$1 = /-->/;
var $560639d49e3c9a19$var$instructionOpenExpression$1 = /^<\?/;
var $560639d49e3c9a19$var$instructionCloseExpression$1 = /\?>/;
var $560639d49e3c9a19$var$directiveOpenExpression$1 = /^<![A-Za-z]/;
var $560639d49e3c9a19$var$directiveCloseExpression$1 = />/;
var $560639d49e3c9a19$var$cdataOpenExpression$1 = /^<!\[CDATA\[/;
var $560639d49e3c9a19$var$cdataCloseExpression$1 = /]]>/;
var $560639d49e3c9a19$var$elementCloseExpression$1 = /^$/;
var $560639d49e3c9a19$var$otherElementOpenExpression$1 = new RegExp($560639d49e3c9a19$var$openCloseTag$1.source + "\\s*$");
function $560639d49e3c9a19$var$blockHtml$1(eat, value, silent) {
    var self = this;
    var blocks = self.options.blocks.join("|");
    var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    var length = value.length;
    var index = 0;
    var next;
    var line;
    var offset;
    var character;
    var count;
    var sequence;
    var subvalue;
    var sequences = [
        [
            $560639d49e3c9a19$var$rawOpenExpression$1,
            $560639d49e3c9a19$var$rawCloseExpression$1,
            true
        ],
        [
            $560639d49e3c9a19$var$commentOpenExpression$1,
            $560639d49e3c9a19$var$commentCloseExpression$1,
            true
        ],
        [
            $560639d49e3c9a19$var$instructionOpenExpression$1,
            $560639d49e3c9a19$var$instructionCloseExpression$1,
            true
        ],
        [
            $560639d49e3c9a19$var$directiveOpenExpression$1,
            $560639d49e3c9a19$var$directiveCloseExpression$1,
            true
        ],
        [
            $560639d49e3c9a19$var$cdataOpenExpression$1,
            $560639d49e3c9a19$var$cdataCloseExpression$1,
            true
        ],
        [
            elementOpenExpression,
            $560639d49e3c9a19$var$elementCloseExpression$1,
            true
        ],
        [
            $560639d49e3c9a19$var$otherElementOpenExpression$1,
            $560639d49e3c9a19$var$elementCloseExpression$1,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$5 && character !== $560639d49e3c9a19$var$space$9) break;
        index++;
    }
    if (value.charAt(index) !== $560639d49e3c9a19$var$lessThan$7) return;
    next = value.indexOf($560639d49e3c9a19$var$lineFeed$9, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($560639d49e3c9a19$var$lineFeed$9, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
var $560639d49e3c9a19$var$isWhitespaceCharacter = $560639d49e3c9a19$var$whitespace$1;
var $560639d49e3c9a19$var$fromCode$1 = String.fromCharCode;
var $560639d49e3c9a19$var$re$2 = /\s/;
// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function $560639d49e3c9a19$var$whitespace$1(character) {
    return $560639d49e3c9a19$var$re$2.test(typeof character === "number" ? $560639d49e3c9a19$var$fromCode$1(character) : character.charAt(0));
}
var $560639d49e3c9a19$var$collapseWhiteSpace = $560639d49e3c9a19$var$collapse;
// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function $560639d49e3c9a19$var$collapse(value) {
    return String(value).replace(/\s+/g, " ");
}
var $560639d49e3c9a19$var$normalize_1$1 = $560639d49e3c9a19$var$normalize$1;
// Normalize an identifier.  Collapses multiple white space characters into a
// single space, and removes casing.
function $560639d49e3c9a19$var$normalize$1(value) {
    return $560639d49e3c9a19$var$collapseWhiteSpace(value).toLowerCase();
}
var $560639d49e3c9a19$var$definition_1 = $560639d49e3c9a19$var$definition;
var $560639d49e3c9a19$var$quotationMark$2 = '"';
var $560639d49e3c9a19$var$apostrophe$3 = "'";
var $560639d49e3c9a19$var$backslash$6 = "\\";
var $560639d49e3c9a19$var$lineFeed$8 = "\n";
var $560639d49e3c9a19$var$tab$4 = "	";
var $560639d49e3c9a19$var$space$8 = " ";
var $560639d49e3c9a19$var$leftSquareBracket$2 = "[";
var $560639d49e3c9a19$var$rightSquareBracket$2 = "]";
var $560639d49e3c9a19$var$leftParenthesis$1 = "(";
var $560639d49e3c9a19$var$rightParenthesis$2 = ")";
var $560639d49e3c9a19$var$colon$2 = ":";
var $560639d49e3c9a19$var$lessThan$6 = "<";
var $560639d49e3c9a19$var$greaterThan$3 = ">";
function $560639d49e3c9a19$var$definition(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$tab$4) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$leftSquareBracket$2) return;
    index++;
    subvalue += character;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$rightSquareBracket$2) break;
        else if (character === $560639d49e3c9a19$var$backslash$6) {
            queue += character;
            index++;
            character = value.charAt(index);
        }
        queue += character;
        index++;
    }
    if (!queue || value.charAt(index) !== $560639d49e3c9a19$var$rightSquareBracket$2 || value.charAt(index + 1) !== $560639d49e3c9a19$var$colon$2) return;
    identifier = queue;
    subvalue += queue + $560639d49e3c9a19$var$rightSquareBracket$2 + $560639d49e3c9a19$var$colon$2;
    index = subvalue.length;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$lineFeed$8) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $560639d49e3c9a19$var$lessThan$6) {
        index++;
        while(index < length){
            character = value.charAt(index);
            if (!$560639d49e3c9a19$var$isEnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$isEnclosedURLCharacter.delimiter) {
            subvalue += $560639d49e3c9a19$var$lessThan$6 + queue + character;
            index++;
        } else {
            if (commonmark) return;
            index -= queue.length + 1;
            queue = "";
        }
    }
    if (!queue) {
        while(index < length){
            character = value.charAt(index);
            if (!$560639d49e3c9a19$var$isUnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        subvalue += queue;
    }
    if (!queue) return;
    url = queue;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$lineFeed$8) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    test = null;
    if (character === $560639d49e3c9a19$var$quotationMark$2) test = $560639d49e3c9a19$var$quotationMark$2;
    else if (character === $560639d49e3c9a19$var$apostrophe$3) test = $560639d49e3c9a19$var$apostrophe$3;
    else if (character === $560639d49e3c9a19$var$leftParenthesis$1) test = $560639d49e3c9a19$var$rightParenthesis$2;
    if (!test) {
        queue = "";
        index = subvalue.length;
    } else if (queue) {
        subvalue += queue + character;
        index = subvalue.length;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character === test) break;
            if (character === $560639d49e3c9a19$var$lineFeed$8) {
                index++;
                character = value.charAt(index);
                if (character === $560639d49e3c9a19$var$lineFeed$8 || character === test) return;
                queue += $560639d49e3c9a19$var$lineFeed$8;
            }
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character !== test) return;
        beforeTitle = subvalue;
        subvalue += queue + character;
        index++;
        title = queue;
        queue = "";
    } else return;
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (!character || character === $560639d49e3c9a19$var$lineFeed$8) {
        if (silent) return true;
        beforeURL = eat(beforeURL).test().end;
        url = self.decode.raw(self.unescape(url), beforeURL, {
            nonTerminated: false
        });
        if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.unescape(title), beforeTitle);
        }
        return eat(subvalue)({
            type: "definition",
            identifier: $560639d49e3c9a19$var$normalize_1$1(identifier),
            label: identifier,
            title: title || null,
            url: url
        });
    }
}
// Check if `character` can be inside an enclosed URI.
function $560639d49e3c9a19$var$isEnclosedURLCharacter(character) {
    return character !== $560639d49e3c9a19$var$greaterThan$3 && character !== $560639d49e3c9a19$var$leftSquareBracket$2 && character !== $560639d49e3c9a19$var$rightSquareBracket$2;
}
$560639d49e3c9a19$var$isEnclosedURLCharacter.delimiter = $560639d49e3c9a19$var$greaterThan$3;
// Check if `character` can be inside an unclosed URI.
function $560639d49e3c9a19$var$isUnclosedURLCharacter(character) {
    return character !== $560639d49e3c9a19$var$leftSquareBracket$2 && character !== $560639d49e3c9a19$var$rightSquareBracket$2 && !$560639d49e3c9a19$var$isWhitespaceCharacter(character);
}
var $560639d49e3c9a19$var$table_1$1 = $560639d49e3c9a19$var$table$1;
var $560639d49e3c9a19$var$tab$3 = "	";
var $560639d49e3c9a19$var$lineFeed$7 = "\n";
var $560639d49e3c9a19$var$space$7 = " ";
var $560639d49e3c9a19$var$dash$4 = "-";
var $560639d49e3c9a19$var$colon$1 = ":";
var $560639d49e3c9a19$var$backslash$5 = "\\";
var $560639d49e3c9a19$var$verticalBar = "|";
var $560639d49e3c9a19$var$minColumns = 1;
var $560639d49e3c9a19$var$minRows = 2;
var $560639d49e3c9a19$var$left = "left";
var $560639d49e3c9a19$var$center = "center";
var $560639d49e3c9a19$var$right = "right";
function $560639d49e3c9a19$var$table$1(eat, value, silent) {
    var self = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;
    // Exit when not in gfm-mode.
    if (!self.options.gfm) return;
    // Get the rows.
    // Detecting tables soon is hard, so there are some checks for performance
    // here, such as the minimum number of rows, and allowed characters in the
    // alignment row.
    index = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while(index < length){
        lineIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$7, index);
        pipeIndex = value.indexOf($560639d49e3c9a19$var$verticalBar, index + 1);
        if (lineIndex === -1) lineIndex = value.length;
        if (pipeIndex === -1 || pipeIndex > lineIndex) {
            if (lineCount < $560639d49e3c9a19$var$minRows) return;
            break;
        }
        lines.push(value.slice(index, lineIndex));
        lineCount++;
        index = lineIndex + 1;
    }
    // Parse the alignment row.
    subvalue = lines.join($560639d49e3c9a19$var$lineFeed$7);
    alignments = lines.splice(1, 1)[0] || [];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while(index < length){
        character = alignments.charAt(index);
        if (character === $560639d49e3c9a19$var$verticalBar) {
            hasDash = null;
            if (alignment === false) {
                if (first === false) return;
            } else {
                align.push(alignment);
                alignment = false;
            }
            first = false;
        } else if (character === $560639d49e3c9a19$var$dash$4) {
            hasDash = true;
            alignment = alignment || null;
        } else if (character === $560639d49e3c9a19$var$colon$1) {
            if (alignment === $560639d49e3c9a19$var$left) alignment = $560639d49e3c9a19$var$center;
            else if (hasDash && alignment === null) alignment = $560639d49e3c9a19$var$right;
            else alignment = $560639d49e3c9a19$var$left;
        } else if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character)) return;
        index++;
    }
    if (alignment !== false) align.push(alignment);
    // Exit when without enough columns.
    if (align.length < $560639d49e3c9a19$var$minColumns) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Parse the rows.
    position = -1;
    rows = [];
    table = eat(subvalue).reset({
        type: "table",
        align: align,
        children: rows
    });
    while(++position < lineCount){
        line = lines[position];
        row = {
            type: "tableRow",
            children: []
        };
        // Eat a newline character when this is not the first row.
        if (position) eat($560639d49e3c9a19$var$lineFeed$7);
        // Eat the row.
        eat(line).reset(row, table);
        length = line.length + 1;
        index = 0;
        queue = "";
        cell = "";
        preamble = true;
        while(index < length){
            character = line.charAt(index);
            if (character === $560639d49e3c9a19$var$tab$3 || character === $560639d49e3c9a19$var$space$7) {
                if (cell) queue += character;
                else eat(character);
                index++;
                continue;
            }
            if (character === "" || character === $560639d49e3c9a19$var$verticalBar) {
                if (preamble) eat(character);
                else {
                    if ((cell || character) && !preamble) {
                        subvalue = cell;
                        if (queue.length > 1) {
                            if (character) {
                                subvalue += queue.slice(0, -1);
                                queue = queue.charAt(queue.length - 1);
                            } else {
                                subvalue += queue;
                                queue = "";
                            }
                        }
                        now = eat.now();
                        eat(subvalue)({
                            type: "tableCell",
                            children: self.tokenizeInline(cell, now)
                        }, row);
                    }
                    eat(queue + character);
                    queue = "";
                    cell = "";
                }
            } else {
                if (queue) {
                    cell += queue;
                    queue = "";
                }
                cell += character;
                if (character === $560639d49e3c9a19$var$backslash$5 && index !== length - 2) {
                    cell += line.charAt(index + 1);
                    index++;
                }
            }
            preamble = false;
            index++;
        }
        // Eat the alignment row.
        if (!position) eat($560639d49e3c9a19$var$lineFeed$7 + alignments);
    }
    return table;
}
var $560639d49e3c9a19$var$paragraph_1$1 = $560639d49e3c9a19$var$paragraph$1;
var $560639d49e3c9a19$var$tab$2 = "	";
var $560639d49e3c9a19$var$lineFeed$6 = "\n";
var $560639d49e3c9a19$var$space$6 = " ";
var $560639d49e3c9a19$var$tabSize = 4;
// Tokenise paragraph.
function $560639d49e3c9a19$var$paragraph$1(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var commonmark = settings.commonmark;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptParagraph;
    var index = value.indexOf($560639d49e3c9a19$var$lineFeed$6);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;
    while(index < length){
        // Eat everything if there’s no following newline.
        if (index === -1) {
            index = length;
            break;
        }
        // Stop if the next character is NEWLINE.
        if (value.charAt(index + 1) === $560639d49e3c9a19$var$lineFeed$6) break;
        // In commonmark-mode, following indented lines are part of the paragraph.
        if (commonmark) {
            size = 0;
            position = index + 1;
            while(position < length){
                character = value.charAt(position);
                if (character === $560639d49e3c9a19$var$tab$2) {
                    size = $560639d49e3c9a19$var$tabSize;
                    break;
                } else if (character === $560639d49e3c9a19$var$space$6) size++;
                else break;
                position++;
            }
            if (size >= $560639d49e3c9a19$var$tabSize && character !== $560639d49e3c9a19$var$lineFeed$6) {
                index = value.indexOf($560639d49e3c9a19$var$lineFeed$6, index + 1);
                continue;
            }
        }
        subvalue = value.slice(index + 1);
        // Check if the following code contains a possible block.
        if ($560639d49e3c9a19$var$interrupt_1(interruptors, tokenizers, self, [
            eat,
            subvalue,
            true
        ])) break;
        position = index;
        index = value.indexOf($560639d49e3c9a19$var$lineFeed$6, index + 1);
        if (index !== -1 && $560639d49e3c9a19$var$trim_1(value.slice(position, index)) === "") {
            index = position;
            break;
        }
    }
    subvalue = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    subvalue = $560639d49e3c9a19$var$trimTrailingLines_1(subvalue);
    return eat(subvalue)({
        type: "paragraph",
        children: self.tokenizeInline(subvalue, now)
    });
}
var $560639d49e3c9a19$var$_escape$1 = $560639d49e3c9a19$var$locate$9;
function $560639d49e3c9a19$var$locate$9(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
}
var $560639d49e3c9a19$var$_escape = $560639d49e3c9a19$var$escape$1;
$560639d49e3c9a19$var$escape$1.locator = $560639d49e3c9a19$var$_escape$1;
var $560639d49e3c9a19$var$lineFeed$5 = "\n";
var $560639d49e3c9a19$var$backslash$4 = "\\";
function $560639d49e3c9a19$var$escape$1(eat, value, silent) {
    var self = this;
    var character;
    var node;
    if (value.charAt(0) === $560639d49e3c9a19$var$backslash$4) {
        character = value.charAt(1);
        if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            if (character === $560639d49e3c9a19$var$lineFeed$5) node = {
                type: "break"
            };
            else node = {
                type: "text",
                value: character
            };
            return eat($560639d49e3c9a19$var$backslash$4 + character)(node);
        }
    }
}
var $560639d49e3c9a19$var$tag$1 = $560639d49e3c9a19$var$locate$8;
function $560639d49e3c9a19$var$locate$8(value, fromIndex) {
    return value.indexOf("<", fromIndex);
}
var $560639d49e3c9a19$var$autoLink_1 = $560639d49e3c9a19$var$autoLink;
$560639d49e3c9a19$var$autoLink.locator = $560639d49e3c9a19$var$tag$1;
$560639d49e3c9a19$var$autoLink.notInLink = true;
var $560639d49e3c9a19$var$lessThan$5 = "<";
var $560639d49e3c9a19$var$greaterThan$2 = ">";
var $560639d49e3c9a19$var$atSign$1 = "@";
var $560639d49e3c9a19$var$slash$3 = "/";
var $560639d49e3c9a19$var$mailto = "mailto:";
var $560639d49e3c9a19$var$mailtoLength = $560639d49e3c9a19$var$mailto.length;
function $560639d49e3c9a19$var$autoLink(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var length = value.length;
    var index = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== $560639d49e3c9a19$var$lessThan$5) return;
    index++;
    subvalue = $560639d49e3c9a19$var$lessThan$5;
    while(index < length){
        character = value.charAt(index);
        if ($560639d49e3c9a19$var$isWhitespaceCharacter(character) || character === $560639d49e3c9a19$var$greaterThan$2 || character === $560639d49e3c9a19$var$atSign$1 || character === ":" && value.charAt(index + 1) === $560639d49e3c9a19$var$slash$3) break;
        queue += character;
        index++;
    }
    if (!queue) return;
    link += queue;
    queue = "";
    character = value.charAt(index);
    link += character;
    index++;
    if (character === $560639d49e3c9a19$var$atSign$1) hasAtCharacter = true;
    else {
        if (character !== ":" || value.charAt(index + 1) !== $560639d49e3c9a19$var$slash$3) return;
        link += $560639d49e3c9a19$var$slash$3;
        index++;
    }
    while(index < length){
        character = value.charAt(index);
        if ($560639d49e3c9a19$var$isWhitespaceCharacter(character) || character === $560639d49e3c9a19$var$greaterThan$2) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (!queue || character !== $560639d49e3c9a19$var$greaterThan$2) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
        if (link.slice(0, $560639d49e3c9a19$var$mailtoLength).toLowerCase() === $560639d49e3c9a19$var$mailto) {
            content = content.slice($560639d49e3c9a19$var$mailtoLength);
            now.column += $560639d49e3c9a19$var$mailtoLength;
            now.offset += $560639d49e3c9a19$var$mailtoLength;
        } else link = $560639d49e3c9a19$var$mailto + link;
    }
    // Temporarily remove all tokenizers except text in autolinks.
    tokenizers = self.inlineTokenizers;
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    exit = self.enterLink();
    content = self.tokenizeInline(content, now);
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(subvalue)({
        type: "link",
        title: null,
        url: $560639d49e3c9a19$var$parseEntities_1(link, {
            nonTerminated: false
        }),
        children: content
    });
}
var $560639d49e3c9a19$var$ccount_1 = $560639d49e3c9a19$var$ccount;
function $560639d49e3c9a19$var$ccount(value, character) {
    var val = String(value);
    var count = 0;
    var index;
    if (typeof character !== "string" || character.length !== 1) throw new Error("Expected character");
    index = val.indexOf(character);
    while(index !== -1){
        count++;
        index = val.indexOf(character, index + 1);
    }
    return count;
}
var $560639d49e3c9a19$var$url$1 = $560639d49e3c9a19$var$locate$7;
var $560639d49e3c9a19$var$values = [
    "www.",
    "http://",
    "https://"
];
function $560639d49e3c9a19$var$locate$7(value, fromIndex) {
    var min = -1;
    var index;
    var length;
    var position;
    if (!this.options.gfm) return min;
    length = $560639d49e3c9a19$var$values.length;
    index = -1;
    while(++index < length){
        position = value.indexOf($560639d49e3c9a19$var$values[index], fromIndex);
        if (position !== -1 && (min === -1 || position < min)) min = position;
    }
    return min;
}
var $560639d49e3c9a19$var$url_1 = $560639d49e3c9a19$var$url;
$560639d49e3c9a19$var$url.locator = $560639d49e3c9a19$var$url$1;
$560639d49e3c9a19$var$url.notInLink = true;
var $560639d49e3c9a19$var$exclamationMark$3 = 33; // '!'
var $560639d49e3c9a19$var$ampersand = 38; // '&'
var $560639d49e3c9a19$var$rightParenthesis$1 = 41; // ')'
var $560639d49e3c9a19$var$asterisk$2 = 42; // '*'
var $560639d49e3c9a19$var$comma$1 = 44; // ','
var $560639d49e3c9a19$var$dash$3 = 45; // '-'
var $560639d49e3c9a19$var$dot$2 = 46; // '.'
var $560639d49e3c9a19$var$colon = 58; // ':'
var $560639d49e3c9a19$var$semicolon = 59; // ';'
var $560639d49e3c9a19$var$questionMark$1 = 63; // '?'
var $560639d49e3c9a19$var$lessThan$4 = 60; // '<'
var $560639d49e3c9a19$var$underscore$4 = 95; // '_'
var $560639d49e3c9a19$var$tilde$2 = 126; // '~'
var $560639d49e3c9a19$var$leftParenthesisCharacter = "(";
var $560639d49e3c9a19$var$rightParenthesisCharacter = ")";
function $560639d49e3c9a19$var$url(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start;
    var index;
    var pathStart;
    var path;
    var code;
    var end;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url;
    var exit;
    if (!gfm) return;
    // `WWW.` doesn’t work.
    if (value.slice(0, 4) === "www.") {
        protocolless = true;
        index = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://") index = 7;
    else if (value.slice(0, 8).toLowerCase() === "https://") index = 8;
    else return;
    // Act as if the starting boundary is a dot.
    previousDot = index - 1;
    // Parse a valid domain.
    start = index;
    dots = [];
    while(index < length){
        code = value.charCodeAt(index);
        if (code === $560639d49e3c9a19$var$dot$2) {
            // Dots may not appear after each other.
            if (previousDot === index - 1) break;
            dots.push(index);
            previousDot = index;
            index++;
            continue;
        }
        if ($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$dash$3 || code === $560639d49e3c9a19$var$underscore$4) {
            index++;
            continue;
        }
        break;
    }
    // Ignore a final dot:
    if (code === $560639d49e3c9a19$var$dot$2) {
        dots.pop();
        index--;
    }
    // If there are not dots, exit.
    if (dots[0] === undefined) return;
    // If there is an underscore in the last two domain parts, exit:
    // `www.example.c_m` and `www.ex_ample.com` are not OK, but
    // `www.sub_domain.example.com` is.
    lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    end = index;
    pathStart = index;
    // Parse a path.
    while(index < length){
        code = value.charCodeAt(index);
        if ($560639d49e3c9a19$var$isWhitespaceCharacter(code) || code === $560639d49e3c9a19$var$lessThan$4) break;
        index++;
        if (code === $560639d49e3c9a19$var$exclamationMark$3 || code === $560639d49e3c9a19$var$asterisk$2 || code === $560639d49e3c9a19$var$comma$1 || code === $560639d49e3c9a19$var$dot$2 || code === $560639d49e3c9a19$var$colon || code === $560639d49e3c9a19$var$questionMark$1 || code === $560639d49e3c9a19$var$underscore$4 || code === $560639d49e3c9a19$var$tilde$2) ;
        else end = index;
    }
    index = end;
    // If the path ends in a closing paren, and the count of closing parens is
    // higher than the opening count, then remove the supefluous closing parens.
    if (value.charCodeAt(index - 1) === $560639d49e3c9a19$var$rightParenthesis$1) {
        path = value.slice(pathStart, index);
        leftCount = $560639d49e3c9a19$var$ccount_1(path, $560639d49e3c9a19$var$leftParenthesisCharacter);
        rightCount = $560639d49e3c9a19$var$ccount_1(path, $560639d49e3c9a19$var$rightParenthesisCharacter);
        while(rightCount > leftCount){
            index = pathStart + path.lastIndexOf($560639d49e3c9a19$var$rightParenthesisCharacter);
            path = value.slice(pathStart, index);
            rightCount--;
        }
    }
    if (value.charCodeAt(index - 1) === $560639d49e3c9a19$var$semicolon) {
        // GitHub doesn’t document this, but final semicolons aren’t paret of the
        // URL either.
        index--;
        // // If the path ends in what looks like an entity, it’s not part of the path.
        if ($560639d49e3c9a19$var$isAlphabetical(value.charCodeAt(index - 1))) {
            end = index - 2;
            while($560639d49e3c9a19$var$isAlphabetical(value.charCodeAt(end)))end--;
            if (value.charCodeAt(end) === $560639d49e3c9a19$var$ampersand) index = end;
        }
    }
    content = value.slice(0, index);
    url = $560639d49e3c9a19$var$parseEntities_1(content, {
        nonTerminated: false
    });
    if (protocolless) url = "http://" + url;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: url,
        children: children
    });
}
var $560639d49e3c9a19$var$plusSign$1 = 43; // '+'
var $560639d49e3c9a19$var$dash$2 = 45; // '-'
var $560639d49e3c9a19$var$dot$1 = 46; // '.'
var $560639d49e3c9a19$var$underscore$3 = 95; // '_'
var $560639d49e3c9a19$var$email$1 = $560639d49e3c9a19$var$locate$6;
// See: <https://github.github.com/gfm/#extended-email-autolink>
function $560639d49e3c9a19$var$locate$6(value, fromIndex) {
    var self = this;
    var at;
    var position;
    if (!this.options.gfm) return -1;
    at = value.indexOf("@", fromIndex);
    if (at === -1) return -1;
    position = at;
    if (position === fromIndex || !$560639d49e3c9a19$var$isGfmAtext(value.charCodeAt(position - 1))) return $560639d49e3c9a19$var$locate$6.call(self, value, at + 1);
    while(position > fromIndex && $560639d49e3c9a19$var$isGfmAtext(value.charCodeAt(position - 1)))position--;
    return position;
}
function $560639d49e3c9a19$var$isGfmAtext(code) {
    return $560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$plusSign$1 || code === $560639d49e3c9a19$var$dash$2 || code === $560639d49e3c9a19$var$dot$1 || code === $560639d49e3c9a19$var$underscore$3;
}
var $560639d49e3c9a19$var$email_1 = $560639d49e3c9a19$var$email;
$560639d49e3c9a19$var$email.locator = $560639d49e3c9a19$var$email$1;
$560639d49e3c9a19$var$email.notInLink = true;
var $560639d49e3c9a19$var$plusSign = 43; // '+'
var $560639d49e3c9a19$var$dash$1 = 45; // '-'
var $560639d49e3c9a19$var$dot = 46; // '.'
var $560639d49e3c9a19$var$atSign = 64; // '@'
var $560639d49e3c9a19$var$underscore$2 = 95; // '_'
function $560639d49e3c9a19$var$email(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var index = 0;
    var length = value.length;
    var firstDot = -1;
    var code;
    var content;
    var children;
    var exit;
    if (!gfm) return;
    code = value.charCodeAt(index);
    while($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$plusSign || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$dot || code === $560639d49e3c9a19$var$underscore$2)code = value.charCodeAt(++index);
    if (index === 0) return;
    if (code !== $560639d49e3c9a19$var$atSign) return;
    index++;
    while(index < length){
        code = value.charCodeAt(index);
        if ($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$dot || code === $560639d49e3c9a19$var$underscore$2) {
            index++;
            if (firstDot === -1 && code === $560639d49e3c9a19$var$dot) firstDot = index;
            continue;
        }
        break;
    }
    if (firstDot === -1 || firstDot === index || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$underscore$2) return;
    if (code === $560639d49e3c9a19$var$dot) index--;
    content = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: "mailto:" + $560639d49e3c9a19$var$parseEntities_1(content, {
            nonTerminated: false
        }),
        children: children
    });
}
var $560639d49e3c9a19$var$tag = $560639d49e3c9a19$var$html$4.tag;
var $560639d49e3c9a19$var$htmlInline = $560639d49e3c9a19$var$inlineHTML;
$560639d49e3c9a19$var$inlineHTML.locator = $560639d49e3c9a19$var$tag$1;
var $560639d49e3c9a19$var$lessThan$3 = "<";
var $560639d49e3c9a19$var$questionMark = "?";
var $560639d49e3c9a19$var$exclamationMark$2 = "!";
var $560639d49e3c9a19$var$slash$2 = "/";
var $560639d49e3c9a19$var$htmlLinkOpenExpression = /^<a /i;
var $560639d49e3c9a19$var$htmlLinkCloseExpression = /^<\/a>/i;
function $560639d49e3c9a19$var$inlineHTML(eat, value, silent) {
    var self = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== $560639d49e3c9a19$var$lessThan$3 || length < 3) return;
    character = value.charAt(1);
    if (!$560639d49e3c9a19$var$isAlphabetical(character) && character !== $560639d49e3c9a19$var$questionMark && character !== $560639d49e3c9a19$var$exclamationMark$2 && character !== $560639d49e3c9a19$var$slash$2) return;
    subvalue = value.match($560639d49e3c9a19$var$tag);
    if (!subvalue) return;
    /* istanbul ignore if - not used yet. */ if (silent) return true;
    subvalue = subvalue[0];
    if (!self.inLink && $560639d49e3c9a19$var$htmlLinkOpenExpression.test(subvalue)) self.inLink = true;
    else if (self.inLink && $560639d49e3c9a19$var$htmlLinkCloseExpression.test(subvalue)) self.inLink = false;
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
var $560639d49e3c9a19$var$link$3 = $560639d49e3c9a19$var$locate$5;
function $560639d49e3c9a19$var$locate$5(value, fromIndex) {
    var link = value.indexOf("[", fromIndex);
    var image = value.indexOf("![", fromIndex);
    if (image === -1) return link;
    // Link can never be `-1` if an image is found, so we don’t need to check
    // for that :)
    return link < image ? link : image;
}
var $560639d49e3c9a19$var$link_1$1 = $560639d49e3c9a19$var$link$2;
$560639d49e3c9a19$var$link$2.locator = $560639d49e3c9a19$var$link$3;
var $560639d49e3c9a19$var$lineFeed$4 = "\n";
var $560639d49e3c9a19$var$exclamationMark$1 = "!";
var $560639d49e3c9a19$var$quotationMark$1 = '"';
var $560639d49e3c9a19$var$apostrophe$2 = "'";
var $560639d49e3c9a19$var$leftParenthesis = "(";
var $560639d49e3c9a19$var$rightParenthesis = ")";
var $560639d49e3c9a19$var$lessThan$2 = "<";
var $560639d49e3c9a19$var$greaterThan$1 = ">";
var $560639d49e3c9a19$var$leftSquareBracket$1 = "[";
var $560639d49e3c9a19$var$backslash$3 = "\\";
var $560639d49e3c9a19$var$rightSquareBracket$1 = "]";
var $560639d49e3c9a19$var$graveAccent$1 = "`";
function $560639d49e3c9a19$var$link$2(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var index = 0;
    var character = value.charAt(0);
    var pedantic = self.options.pedantic;
    var commonmark = self.options.commonmark;
    var gfm = self.options.gfm;
    var closed;
    var count;
    var opening;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;
    var exit;
    var node;
    // Detect whether this is an image.
    if (character === $560639d49e3c9a19$var$exclamationMark$1) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }
    // Eat the opening.
    if (character !== $560639d49e3c9a19$var$leftSquareBracket$1) return;
    // Exit when this is a link and we’re already inside a link.
    if (!isImage && self.inLink) return;
    subvalue += character;
    queue = "";
    index++;
    // Eat the content.
    length = value.length;
    now = eat.now();
    depth = 0;
    now.column += index;
    now.offset += index;
    while(index < length){
        character = value.charAt(index);
        subqueue = character;
        if (character === $560639d49e3c9a19$var$graveAccent$1) {
            // Inline-code in link content.
            count = 1;
            while(value.charAt(index + 1) === $560639d49e3c9a19$var$graveAccent$1){
                subqueue += character;
                index++;
                count++;
            }
            if (!opening) opening = count;
            else if (count >= opening) opening = 0;
        } else if (character === $560639d49e3c9a19$var$backslash$3) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
        } else if ((!opening || gfm) && character === $560639d49e3c9a19$var$leftSquareBracket$1) // In GFM mode, brackets in code still count.  In all other modes,
        // they don’t.
        depth++;
        else if ((!opening || gfm) && character === $560639d49e3c9a19$var$rightSquareBracket$1) {
            if (depth) depth--;
            else {
                if (value.charAt(index + 1) !== $560639d49e3c9a19$var$leftParenthesis) return;
                subqueue += $560639d49e3c9a19$var$leftParenthesis;
                closed = true;
                index++;
                break;
            }
        }
        queue += subqueue;
        subqueue = "";
        index++;
    }
    // Eat the content closing.
    if (!closed) return;
    content = queue;
    subvalue += queue + subqueue;
    index++;
    // Eat white-space.
    while(index < length){
        character = value.charAt(index);
        if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character)) break;
        subvalue += character;
        index++;
    }
    // Eat the URL.
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $560639d49e3c9a19$var$lessThan$2) {
        index++;
        beforeURL += $560639d49e3c9a19$var$lessThan$2;
        while(index < length){
            character = value.charAt(index);
            if (character === $560639d49e3c9a19$var$greaterThan$1) break;
            if (commonmark && character === $560639d49e3c9a19$var$lineFeed$4) return;
            queue += character;
            index++;
        }
        if (value.charAt(index) !== $560639d49e3c9a19$var$greaterThan$1) return;
        subvalue += $560639d49e3c9a19$var$lessThan$2 + queue + $560639d49e3c9a19$var$greaterThan$1;
        url = queue;
        index++;
    } else {
        character = null;
        subqueue = "";
        while(index < length){
            character = value.charAt(index);
            if (subqueue && (character === $560639d49e3c9a19$var$quotationMark$1 || character === $560639d49e3c9a19$var$apostrophe$2 || commonmark && character === $560639d49e3c9a19$var$leftParenthesis)) break;
            if ($560639d49e3c9a19$var$isWhitespaceCharacter(character)) {
                if (!pedantic) break;
                subqueue += character;
            } else {
                if (character === $560639d49e3c9a19$var$leftParenthesis) depth++;
                else if (character === $560639d49e3c9a19$var$rightParenthesis) {
                    if (depth === 0) break;
                    depth--;
                }
                queue += subqueue;
                subqueue = "";
                if (character === $560639d49e3c9a19$var$backslash$3) {
                    queue += $560639d49e3c9a19$var$backslash$3;
                    character = value.charAt(++index);
                }
                queue += character;
            }
            index++;
        }
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }
    // Eat white-space.
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    subvalue += queue;
    // Eat the title.
    if (queue && (character === $560639d49e3c9a19$var$quotationMark$1 || character === $560639d49e3c9a19$var$apostrophe$2 || commonmark && character === $560639d49e3c9a19$var$leftParenthesis)) {
        index++;
        subvalue += character;
        queue = "";
        marker = character === $560639d49e3c9a19$var$leftParenthesis ? $560639d49e3c9a19$var$rightParenthesis : character;
        beforeTitle = subvalue;
        // In commonmark-mode, things are pretty easy: the marker cannot occur
        // inside the title.  Non-commonmark does, however, support nested
        // delimiters.
        if (commonmark) {
            while(index < length){
                character = value.charAt(index);
                if (character === marker) break;
                if (character === $560639d49e3c9a19$var$backslash$3) {
                    queue += $560639d49e3c9a19$var$backslash$3;
                    character = value.charAt(++index);
                }
                index++;
                queue += character;
            }
            character = value.charAt(index);
            if (character !== marker) return;
            title = queue;
            subvalue += queue + character;
            index++;
            while(index < length){
                character = value.charAt(index);
                if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character)) break;
                subvalue += character;
                index++;
            }
        } else {
            subqueue = "";
            while(index < length){
                character = value.charAt(index);
                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + subqueue;
                        subqueue = "";
                    }
                    hasMarker = true;
                } else if (!hasMarker) queue += character;
                else if (character === $560639d49e3c9a19$var$rightParenthesis) {
                    subvalue += queue + marker + subqueue;
                    title = queue;
                    break;
                } else if ($560639d49e3c9a19$var$isWhitespaceCharacter(character)) subqueue += character;
                else {
                    queue += marker + subqueue + character;
                    subqueue = "";
                    hasMarker = false;
                }
                index++;
            }
        }
    }
    if (value.charAt(index) !== $560639d49e3c9a19$var$rightParenthesis) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    subvalue += $560639d49e3c9a19$var$rightParenthesis;
    url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
        nonTerminated: false
    });
    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self.decode.raw(self.unescape(title), beforeTitle);
    }
    node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url
    };
    if (isImage) node.alt = self.decode.raw(self.unescape(content), now) || null;
    else {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    }
    return eat(subvalue)(node);
}
var $560639d49e3c9a19$var$reference_1 = $560639d49e3c9a19$var$reference;
$560639d49e3c9a19$var$reference.locator = $560639d49e3c9a19$var$link$3;
var $560639d49e3c9a19$var$link$1 = "link";
var $560639d49e3c9a19$var$image$2 = "image";
var $560639d49e3c9a19$var$shortcut = "shortcut";
var $560639d49e3c9a19$var$collapsed = "collapsed";
var $560639d49e3c9a19$var$full = "full";
var $560639d49e3c9a19$var$exclamationMark = "!";
var $560639d49e3c9a19$var$leftSquareBracket = "[";
var $560639d49e3c9a19$var$backslash$2 = "\\";
var $560639d49e3c9a19$var$rightSquareBracket = "]";
function $560639d49e3c9a19$var$reference(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type = $560639d49e3c9a19$var$link$1;
    var referenceType = $560639d49e3c9a19$var$shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    // Check whether we’re eating an image.
    if (character === $560639d49e3c9a19$var$exclamationMark) {
        type = $560639d49e3c9a19$var$image$2;
        intro = character;
        character = value.charAt(++index);
    }
    if (character !== $560639d49e3c9a19$var$leftSquareBracket) return;
    index++;
    intro += character;
    queue = "";
    // Eat the text.
    depth = 0;
    while(index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$leftSquareBracket) {
            bracketed = true;
            depth++;
        } else if (character === $560639d49e3c9a19$var$rightSquareBracket) {
            if (!depth) break;
            depth--;
        }
        if (character === $560639d49e3c9a19$var$backslash$2) {
            queue += $560639d49e3c9a19$var$backslash$2;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$rightSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    if (!commonmark) // The original markdown syntax definition explicitly allows for whitespace
    // between the link text and link label; commonmark departs from this, in
    // part to improve support for shortcut reference links
    while(index < length){
        character = value.charAt(index);
        if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$leftSquareBracket) {
        identifier = "";
        queue += character;
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character === $560639d49e3c9a19$var$leftSquareBracket || character === $560639d49e3c9a19$var$rightSquareBracket) break;
            if (character === $560639d49e3c9a19$var$backslash$2) {
                identifier += $560639d49e3c9a19$var$backslash$2;
                character = value.charAt(++index);
            }
            identifier += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$rightSquareBracket) {
            referenceType = identifier ? $560639d49e3c9a19$var$full : $560639d49e3c9a19$var$collapsed;
            queue += identifier + character;
            index++;
        } else identifier = "";
        subvalue += queue;
        queue = "";
    } else {
        if (!content) return;
        identifier = content;
    }
    // Brackets cannot be inside the identifier.
    if (referenceType !== $560639d49e3c9a19$var$full && bracketed) return;
    subvalue = intro + subvalue;
    if (type === $560639d49e3c9a19$var$link$1 && self.inLink) return null;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === $560639d49e3c9a19$var$full ? identifier : content;
    node = {
        type: type + "Reference",
        identifier: $560639d49e3c9a19$var$normalize_1$1(identifier),
        label: identifier,
        referenceType: referenceType
    };
    if (type === $560639d49e3c9a19$var$link$1) {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    } else node.alt = self.decode.raw(self.unescape(content), now) || null;
    return eat(subvalue)(node);
}
var $560639d49e3c9a19$var$strong$2 = $560639d49e3c9a19$var$locate$4;
function $560639d49e3c9a19$var$locate$4(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}
var $560639d49e3c9a19$var$strong_1$1 = $560639d49e3c9a19$var$strong$1;
$560639d49e3c9a19$var$strong$1.locator = $560639d49e3c9a19$var$strong$2;
var $560639d49e3c9a19$var$backslash$1 = "\\";
var $560639d49e3c9a19$var$asterisk$1 = "*";
var $560639d49e3c9a19$var$underscore$1 = "_";
function $560639d49e3c9a19$var$strong$1(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $560639d49e3c9a19$var$asterisk$1 && character !== $560639d49e3c9a19$var$underscore$1 || value.charAt(++index) !== character) return;
    pedantic = self.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$560639d49e3c9a19$var$isWhitespaceCharacter(previous))) {
            character = value.charAt(index + 2);
            if (character !== marker) {
                if (!$560639d49e3c9a19$var$trim_1(queue)) return;
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column += 2;
                now.offset += 2;
                return eat(subvalue + queue + subvalue)({
                    type: "strong",
                    children: self.tokenizeInline(queue, now)
                });
            }
        }
        if (!pedantic && character === $560639d49e3c9a19$var$backslash$1) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}
var $560639d49e3c9a19$var$isWordCharacter = $560639d49e3c9a19$var$wordCharacter;
var $560639d49e3c9a19$var$fromCode = String.fromCharCode;
var $560639d49e3c9a19$var$re$1 = /\w/;
// Check if the given character code, or the character code at the first
// character, is a word character.
function $560639d49e3c9a19$var$wordCharacter(character) {
    return $560639d49e3c9a19$var$re$1.test(typeof character === "number" ? $560639d49e3c9a19$var$fromCode(character) : character.charAt(0));
}
var $560639d49e3c9a19$var$emphasis$2 = $560639d49e3c9a19$var$locate$3;
function $560639d49e3c9a19$var$locate$3(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}
var $560639d49e3c9a19$var$emphasis_1$1 = $560639d49e3c9a19$var$emphasis$1;
$560639d49e3c9a19$var$emphasis$1.locator = $560639d49e3c9a19$var$emphasis$2;
var $560639d49e3c9a19$var$asterisk = "*";
var $560639d49e3c9a19$var$underscore = "_";
var $560639d49e3c9a19$var$backslash = "\\";
function $560639d49e3c9a19$var$emphasis$1(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $560639d49e3c9a19$var$asterisk && character !== $560639d49e3c9a19$var$underscore) return;
    pedantic = self.options.pedantic;
    subvalue = character;
    marker = character;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && (!pedantic || !$560639d49e3c9a19$var$isWhitespaceCharacter(previous))) {
            character = value.charAt(++index);
            if (character !== marker) {
                if (!$560639d49e3c9a19$var$trim_1(queue) || previous === marker) return;
                if (!pedantic && marker === $560639d49e3c9a19$var$underscore && $560639d49e3c9a19$var$isWordCharacter(character)) {
                    queue += marker;
                    continue;
                }
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column++;
                now.offset++;
                return eat(subvalue + queue + marker)({
                    type: "emphasis",
                    children: self.tokenizeInline(queue, now)
                });
            }
            queue += marker;
        }
        if (!pedantic && character === $560639d49e3c9a19$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}
var $560639d49e3c9a19$var$_delete$2 = $560639d49e3c9a19$var$locate$2;
function $560639d49e3c9a19$var$locate$2(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
}
var $560639d49e3c9a19$var$_delete$1 = $560639d49e3c9a19$var$strikethrough$1;
$560639d49e3c9a19$var$strikethrough$1.locator = $560639d49e3c9a19$var$_delete$2;
var $560639d49e3c9a19$var$tilde$1 = "~";
var $560639d49e3c9a19$var$fence$1 = "~~";
function $560639d49e3c9a19$var$strikethrough$1(eat, value, silent) {
    var self = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index;
    var length;
    var now;
    if (!self.options.gfm || value.charAt(0) !== $560639d49e3c9a19$var$tilde$1 || value.charAt(1) !== $560639d49e3c9a19$var$tilde$1 || $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(2))) return;
    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;
    now.offset += 2;
    while(++index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$tilde$1 && previous === $560639d49e3c9a19$var$tilde$1 && (!preceding || !$560639d49e3c9a19$var$isWhitespaceCharacter(preceding))) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat($560639d49e3c9a19$var$fence$1 + subvalue + $560639d49e3c9a19$var$fence$1)({
                type: "delete",
                children: self.tokenizeInline(subvalue, now)
            });
        }
        subvalue += previous;
        preceding = previous;
        previous = character;
    }
}
var $560639d49e3c9a19$var$codeInline$1 = $560639d49e3c9a19$var$locate$1;
function $560639d49e3c9a19$var$locate$1(value, fromIndex) {
    return value.indexOf("`", fromIndex);
}
var $560639d49e3c9a19$var$codeInline = $560639d49e3c9a19$var$inlineCode$1;
$560639d49e3c9a19$var$inlineCode$1.locator = $560639d49e3c9a19$var$codeInline$1;
var $560639d49e3c9a19$var$lineFeed$3 = 10; //  '\n'
var $560639d49e3c9a19$var$space$5 = 32; // ' '
var $560639d49e3c9a19$var$graveAccent = 96; //  '`'
function $560639d49e3c9a19$var$inlineCode$1(eat, value, silent) {
    var length = value.length;
    var index = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code;
    var next;
    var found;
    while(index < length){
        if (value.charCodeAt(index) !== $560639d49e3c9a19$var$graveAccent) break;
        index++;
    }
    if (index === 0 || index === length) return;
    openingFenceEnd = index;
    next = value.charCodeAt(index);
    while(index < length){
        code = next;
        next = value.charCodeAt(index + 1);
        if (code === $560639d49e3c9a19$var$graveAccent) {
            if (closingFenceStart === undefined) closingFenceStart = index;
            closingFenceEnd = index + 1;
            if (next !== $560639d49e3c9a19$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
                found = true;
                break;
            }
        } else if (closingFenceStart !== undefined) {
            closingFenceStart = undefined;
            closingFenceEnd = undefined;
        }
        index++;
    }
    if (!found) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Remove the initial and final space (or line feed), iff they exist and there
    // are non-space characters in the content.
    index = openingFenceEnd;
    length = closingFenceStart;
    code = value.charCodeAt(index);
    next = value.charCodeAt(length - 1);
    found = false;
    if (length - index > 2 && (code === $560639d49e3c9a19$var$space$5 || code === $560639d49e3c9a19$var$lineFeed$3) && (next === $560639d49e3c9a19$var$space$5 || next === $560639d49e3c9a19$var$lineFeed$3)) {
        index++;
        length--;
        while(index < length){
            code = value.charCodeAt(index);
            if (code !== $560639d49e3c9a19$var$space$5 && code !== $560639d49e3c9a19$var$lineFeed$3) {
                found = true;
                break;
            }
            index++;
        }
        if (found === true) {
            openingFenceEnd++;
            closingFenceStart--;
        }
    }
    return eat(value.slice(0, closingFenceEnd))({
        type: "inlineCode",
        value: value.slice(openingFenceEnd, closingFenceStart)
    });
}
var $560639d49e3c9a19$var$_break$2 = $560639d49e3c9a19$var$locate;
function $560639d49e3c9a19$var$locate(value, fromIndex) {
    var index = value.indexOf("\n", fromIndex);
    while(index > fromIndex){
        if (value.charAt(index - 1) !== " ") break;
        index--;
    }
    return index;
}
var $560639d49e3c9a19$var$_break$1 = $560639d49e3c9a19$var$hardBreak$1;
$560639d49e3c9a19$var$hardBreak$1.locator = $560639d49e3c9a19$var$_break$2;
var $560639d49e3c9a19$var$space$4 = " ";
var $560639d49e3c9a19$var$lineFeed$2 = "\n";
var $560639d49e3c9a19$var$minBreakLength = 2;
function $560639d49e3c9a19$var$hardBreak$1(eat, value, silent) {
    var length = value.length;
    var index = -1;
    var queue = "";
    var character;
    while(++index < length){
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$lineFeed$2) {
            if (index < $560639d49e3c9a19$var$minBreakLength) return;
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            queue += character;
            return eat(queue)({
                type: "break"
            });
        }
        if (character !== $560639d49e3c9a19$var$space$4) return;
        queue += character;
    }
}
var $560639d49e3c9a19$var$text_1$2 = $560639d49e3c9a19$var$text$3;
function $560639d49e3c9a19$var$text$3(eat, value, silent) {
    var self = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    methods = self.inlineMethods;
    length = methods.length;
    tokenizers = self.inlineTokenizers;
    index = -1;
    min = value.length;
    while(++index < length){
        name = methods[index];
        if (name === "text" || !tokenizers[name]) continue;
        tokenizer = tokenizers[name].locator;
        if (!tokenizer) eat.file.fail("Missing locator: `" + name + "`");
        position = tokenizer.call(self, value, 1);
        if (position !== -1 && position < min) min = position;
    }
    subvalue = value.slice(0, min);
    now = eat.now();
    self.decode(subvalue, now, handler);
    function handler(content, position, source) {
        eat(source || content)({
            type: "text",
            value: content
        });
    }
}
var $560639d49e3c9a19$var$parser$1 = $560639d49e3c9a19$var$Parser;
function $560639d49e3c9a19$var$Parser(doc, file) {
    this.file = file;
    this.offset = {};
    this.options = $560639d49e3c9a19$var$immutable(this.options);
    this.setOptions({});
    this.inList = false;
    this.inBlock = false;
    this.inLink = false;
    this.atStart = true;
    this.toOffset = $560639d49e3c9a19$var$vfileLocation(file).toOffset;
    this.unescape = $560639d49e3c9a19$var$_unescape(this, "escape");
    this.decode = $560639d49e3c9a19$var$decode(this);
}
var $560639d49e3c9a19$var$proto$3 = $560639d49e3c9a19$var$Parser.prototype;
// Expose core.
$560639d49e3c9a19$var$proto$3.setOptions = $560639d49e3c9a19$var$setOptions_1;
$560639d49e3c9a19$var$proto$3.parse = $560639d49e3c9a19$var$parse_1$2;
// Expose `defaults`.
$560639d49e3c9a19$var$proto$3.options = $560639d49e3c9a19$var$defaults$1;
// Enter and exit helpers.
$560639d49e3c9a19$var$proto$3.exitStart = $560639d49e3c9a19$var$stateToggle("atStart", true);
$560639d49e3c9a19$var$proto$3.enterList = $560639d49e3c9a19$var$stateToggle("inList", false);
$560639d49e3c9a19$var$proto$3.enterLink = $560639d49e3c9a19$var$stateToggle("inLink", false);
$560639d49e3c9a19$var$proto$3.enterBlock = $560639d49e3c9a19$var$stateToggle("inBlock", false);
// Nodes that can interupt a paragraph:
//
// ```markdown
// A paragraph, followed by a thematic break.
// ___
// ```
//
// In the above example, the thematic break “interupts” the paragraph.
$560639d49e3c9a19$var$proto$3.interruptParagraph = [
    [
        "thematicBreak"
    ],
    [
        "list"
    ],
    [
        "atxHeading"
    ],
    [
        "fencedCode"
    ],
    [
        "blockquote"
    ],
    [
        "html"
    ],
    [
        "setextHeading",
        {
            commonmark: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a list:
//
// ```markdown
// - One
// ___
// ```
//
// In the above example, the thematic break “interupts” the list.
$560639d49e3c9a19$var$proto$3.interruptList = [
    [
        "atxHeading",
        {
            pedantic: false
        }
    ],
    [
        "fencedCode",
        {
            pedantic: false
        }
    ],
    [
        "thematicBreak",
        {
            pedantic: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a blockquote:
//
// ```markdown
// > A paragraph.
// ___
// ```
//
// In the above example, the thematic break “interupts” the blockquote.
$560639d49e3c9a19$var$proto$3.interruptBlockquote = [
    [
        "indentedCode",
        {
            commonmark: true
        }
    ],
    [
        "fencedCode",
        {
            commonmark: true
        }
    ],
    [
        "atxHeading",
        {
            commonmark: true
        }
    ],
    [
        "setextHeading",
        {
            commonmark: true
        }
    ],
    [
        "thematicBreak",
        {
            commonmark: true
        }
    ],
    [
        "html",
        {
            commonmark: true
        }
    ],
    [
        "list",
        {
            commonmark: true
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Handlers.
$560639d49e3c9a19$var$proto$3.blockTokenizers = {
    blankLine: $560639d49e3c9a19$var$blankLine_1,
    indentedCode: $560639d49e3c9a19$var$codeIndented,
    fencedCode: $560639d49e3c9a19$var$codeFenced,
    blockquote: $560639d49e3c9a19$var$blockquote_1$1,
    atxHeading: $560639d49e3c9a19$var$headingAtx,
    thematicBreak: $560639d49e3c9a19$var$thematicBreak_1$1,
    list: $560639d49e3c9a19$var$list_1$1,
    setextHeading: $560639d49e3c9a19$var$headingSetext,
    html: $560639d49e3c9a19$var$htmlBlock,
    definition: $560639d49e3c9a19$var$definition_1,
    table: $560639d49e3c9a19$var$table_1$1,
    paragraph: $560639d49e3c9a19$var$paragraph_1$1
};
$560639d49e3c9a19$var$proto$3.inlineTokenizers = {
    escape: $560639d49e3c9a19$var$_escape,
    autoLink: $560639d49e3c9a19$var$autoLink_1,
    url: $560639d49e3c9a19$var$url_1,
    email: $560639d49e3c9a19$var$email_1,
    html: $560639d49e3c9a19$var$htmlInline,
    link: $560639d49e3c9a19$var$link_1$1,
    reference: $560639d49e3c9a19$var$reference_1,
    strong: $560639d49e3c9a19$var$strong_1$1,
    emphasis: $560639d49e3c9a19$var$emphasis_1$1,
    deletion: $560639d49e3c9a19$var$_delete$1,
    code: $560639d49e3c9a19$var$codeInline,
    break: $560639d49e3c9a19$var$_break$1,
    text: $560639d49e3c9a19$var$text_1$2
};
// Expose precedence.
$560639d49e3c9a19$var$proto$3.blockMethods = $560639d49e3c9a19$var$keys$1($560639d49e3c9a19$var$proto$3.blockTokenizers);
$560639d49e3c9a19$var$proto$3.inlineMethods = $560639d49e3c9a19$var$keys$1($560639d49e3c9a19$var$proto$3.inlineTokenizers);
// Tokenizers.
$560639d49e3c9a19$var$proto$3.tokenizeBlock = $560639d49e3c9a19$var$tokenizer$1("block");
$560639d49e3c9a19$var$proto$3.tokenizeInline = $560639d49e3c9a19$var$tokenizer$1("inline");
$560639d49e3c9a19$var$proto$3.tokenizeFactory = $560639d49e3c9a19$var$tokenizer$1;
// Get all keys in `value`.
function $560639d49e3c9a19$var$keys$1(value) {
    var result = [];
    var key;
    for(key in value)result.push(key);
    return result;
}
var $560639d49e3c9a19$var$remarkParse = $560639d49e3c9a19$var$parse$5;
$560639d49e3c9a19$var$parse$5.Parser = $560639d49e3c9a19$var$parser$1;
function $560639d49e3c9a19$var$parse$5(options) {
    var settings = this.data("settings");
    var Local = $560639d49e3c9a19$var$unherit_1($560639d49e3c9a19$var$parser$1);
    Local.prototype.options = $560639d49e3c9a19$var$immutable(Local.prototype.options, settings, options);
    this.Parser = Local;
}
var $560639d49e3c9a19$var$mdastUtilDefinitions$1 = $560639d49e3c9a19$var$getDefinitionFactory$1;
var $560639d49e3c9a19$var$own$a = {}.hasOwnProperty;
// Get a definition in `node` by `identifier`.
function $560639d49e3c9a19$var$getDefinitionFactory$1(node, options) {
    return $560639d49e3c9a19$var$getterFactory$1($560639d49e3c9a19$var$gather$1(node, options));
}
// Gather all definitions in `node`
function $560639d49e3c9a19$var$gather$1(node, options) {
    var cache = {};
    if (!node || !node.type) throw new Error("mdast-util-definitions expected node");
    $560639d49e3c9a19$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
    return cache;
    function commonmark(definition) {
        var id = $560639d49e3c9a19$var$normalise$1(definition.identifier);
        if (!$560639d49e3c9a19$var$own$a.call(cache, id)) cache[id] = definition;
    }
    function normal(definition) {
        cache[$560639d49e3c9a19$var$normalise$1(definition.identifier)] = definition;
    }
}
// Factory to get a node from the given definition-cache.
function $560639d49e3c9a19$var$getterFactory$1(cache) {
    return getter;
    // Get a node from the bound definition-cache.
    function getter(identifier) {
        var id = identifier && $560639d49e3c9a19$var$normalise$1(identifier);
        return id && $560639d49e3c9a19$var$own$a.call(cache, id) ? cache[id] : null;
    }
}
function $560639d49e3c9a19$var$normalise$1(identifier) {
    return identifier.toUpperCase();
}
var $560639d49e3c9a19$var$parse_1$1 = $560639d49e3c9a19$var$parse$4;
var $560639d49e3c9a19$var$stringify_1$1 = $560639d49e3c9a19$var$stringify$3;
var $560639d49e3c9a19$var$empty$2 = "";
var $560639d49e3c9a19$var$space$3 = " ";
var $560639d49e3c9a19$var$whiteSpace$1 = /[ \t\n\r\f]+/g;
function $560639d49e3c9a19$var$parse$4(value) {
    var input = String(value || $560639d49e3c9a19$var$empty$2).trim();
    return input === $560639d49e3c9a19$var$empty$2 ? [] : input.split($560639d49e3c9a19$var$whiteSpace$1);
}
function $560639d49e3c9a19$var$stringify$3(values) {
    return values.join($560639d49e3c9a19$var$space$3).trim();
}
var $560639d49e3c9a19$var$spaceSeparatedTokens = {
    parse: $560639d49e3c9a19$var$parse_1$1,
    stringify: $560639d49e3c9a19$var$stringify_1$1
};
var $560639d49e3c9a19$var$isAbsoluteUrl = (url)=>{
    if (typeof url !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
    // Don't match Windows paths `c:\`
    if (/^[a-zA-Z]:\\/.test(url)) return false;
    // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
    // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
    return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
};
var $560639d49e3c9a19$var$spaceSeparated$4 = $560639d49e3c9a19$var$spaceSeparatedTokens.parse;
var $560639d49e3c9a19$var$remarkExternalLinks = $560639d49e3c9a19$var$externalLinks;
var $560639d49e3c9a19$var$defaultTarget = "_blank";
var $560639d49e3c9a19$var$defaultRel = [
    "nofollow",
    "noopener",
    "noreferrer"
];
var $560639d49e3c9a19$var$defaultProtocols = [
    "http",
    "https"
];
function $560639d49e3c9a19$var$externalLinks(options) {
    var settings = options || {};
    var target = settings.target;
    var rel = settings.rel;
    var protocols = settings.protocols || $560639d49e3c9a19$var$defaultProtocols;
    var content = settings.content;
    var contentProperties = settings.contentProperties || {};
    if (typeof rel === "string") rel = $560639d49e3c9a19$var$spaceSeparated$4(rel);
    if (content && typeof content === "object" && !("length" in content)) content = [
        content
    ];
    return transform;
    function transform(tree) {
        var definition = $560639d49e3c9a19$var$mdastUtilDefinitions$1(tree);
        $560639d49e3c9a19$var$unistUtilVisit(tree, [
            "link",
            "linkReference"
        ], visitor);
        function visitor(node) {
            var ctx = node.type === "link" ? node : definition(node.identifier);
            var protocol;
            var data;
            var props;
            if (!ctx) return;
            protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
            if ($560639d49e3c9a19$var$isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
                data = node.data || (node.data = {});
                props = data.hProperties || (data.hProperties = {});
                if (target !== false) props.target = target || $560639d49e3c9a19$var$defaultTarget;
                if (rel !== false) props.rel = (rel || $560639d49e3c9a19$var$defaultRel).concat();
                if (content) // `fragment` is not a known mdast node, but unknown nodes with
                // children are handled as elements by `mdast-util-to-hast`:
                // See: <https://github.com/syntax-tree/mdast-util-to-hast#notes>.
                node.children.push({
                    type: "fragment",
                    children: [],
                    data: {
                        hName: "span",
                        hProperties: $560639d49e3c9a19$var$extend$2(true, contentProperties),
                        hChildren: $560639d49e3c9a19$var$extend$2(true, content)
                    }
                });
            }
        }
    }
}
var $560639d49e3c9a19$var$format = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
    (function() {
        //// Export the API
        var namespace;
        namespace = module.exports = format;
        namespace.format = format;
        namespace.vsprintf = vsprintf;
        if (typeof console !== "undefined" && typeof console.log === "function") namespace.printf = printf;
        function printf() {
            console.log(format.apply(null, arguments));
        }
        function vsprintf(fmt, replacements) {
            return format.apply(null, [
                fmt
            ].concat(replacements));
        }
        function format(fmt) {
            var argIndex = 1 // skip initial format argument
            , args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
                return args[argIndex++];
            }, slurpNumber = function() {
                var digits = "";
                while(/\d/.test(fmt[i])){
                    digits += fmt[i++];
                    c = fmt[i];
                }
                return digits.length > 0 ? parseInt(digits) : null;
            };
            for(; i < n; ++i){
                c = fmt[i];
                if (escaped) {
                    escaped = false;
                    if (c == ".") {
                        leadingZero = false;
                        c = fmt[++i];
                    } else if (c == "0" && fmt[i + 1] == ".") {
                        leadingZero = true;
                        i += 2;
                        c = fmt[i];
                    } else leadingZero = true;
                    precision = slurpNumber();
                    switch(c){
                        case "b":
                            result += parseInt(nextArg(), 10).toString(2);
                            break;
                        case "c":
                            arg = nextArg();
                            if (typeof arg === "string" || arg instanceof String) result += arg;
                            else result += String.fromCharCode(parseInt(arg, 10));
                            break;
                        case "d":
                            result += parseInt(nextArg(), 10);
                            break;
                        case "f":
                            tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                            result += leadingZero ? tmp : tmp.replace(/^0/, "");
                            break;
                        case "j":
                            result += JSON.stringify(nextArg());
                            break;
                        case "o":
                            result += "0" + parseInt(nextArg(), 10).toString(8);
                            break;
                        case "s":
                            result += nextArg();
                            break;
                        case "x":
                            result += "0x" + parseInt(nextArg(), 10).toString(16);
                            break;
                        case "X":
                            result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                            break;
                        default:
                            result += c;
                            break;
                    }
                } else if (c === "%") escaped = true;
                else result += c;
            }
            return result;
        }
    })();
});
var $560639d49e3c9a19$var$fault = $560639d49e3c9a19$var$create$3(Error);
var $560639d49e3c9a19$var$fault_1 = $560639d49e3c9a19$var$fault;
$560639d49e3c9a19$var$fault.eval = $560639d49e3c9a19$var$create$3(EvalError);
$560639d49e3c9a19$var$fault.range = $560639d49e3c9a19$var$create$3(RangeError);
$560639d49e3c9a19$var$fault.reference = $560639d49e3c9a19$var$create$3(ReferenceError);
$560639d49e3c9a19$var$fault.syntax = $560639d49e3c9a19$var$create$3(SyntaxError);
$560639d49e3c9a19$var$fault.type = $560639d49e3c9a19$var$create$3(TypeError);
$560639d49e3c9a19$var$fault.uri = $560639d49e3c9a19$var$create$3(URIError);
$560639d49e3c9a19$var$fault.create = $560639d49e3c9a19$var$create$3;
// Create a new `EConstructor`, with the formatted `format` as a first argument.
function $560639d49e3c9a19$var$create$3(EConstructor) {
    FormattedError.displayName = EConstructor.displayName || EConstructor.name;
    return FormattedError;
    function FormattedError(format$1) {
        if (format$1) format$1 = $560639d49e3c9a19$var$format.apply(null, arguments);
        return new EConstructor(format$1);
    }
}
var $560639d49e3c9a19$var$matters_1 = $560639d49e3c9a19$var$matters;
var $560639d49e3c9a19$var$own$9 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$markers = {
    yaml: "-",
    toml: "+"
};
function $560639d49e3c9a19$var$matters(options) {
    var results = [];
    var index = -1;
    var length;
    // One preset or matter.
    if (typeof options === "string" || !("length" in options)) options = [
        options
    ];
    length = options.length;
    while(++index < length)results[index] = $560639d49e3c9a19$var$matter(options[index]);
    return results;
}
function $560639d49e3c9a19$var$matter(option) {
    var result = option;
    if (typeof result === "string") {
        if (!$560639d49e3c9a19$var$own$9.call($560639d49e3c9a19$var$markers, result)) throw $560639d49e3c9a19$var$fault_1("Missing matter definition for `%s`", result);
        result = {
            type: result,
            marker: $560639d49e3c9a19$var$markers[result]
        };
    } else if (typeof result !== "object") throw $560639d49e3c9a19$var$fault_1("Expected matter to be an object, not `%j`", result);
    if (!$560639d49e3c9a19$var$own$9.call(result, "type")) throw $560639d49e3c9a19$var$fault_1("Missing `type` in matter `%j`", result);
    if (!$560639d49e3c9a19$var$own$9.call(result, "fence") && !$560639d49e3c9a19$var$own$9.call(result, "marker")) throw $560639d49e3c9a19$var$fault_1("Missing `marker` or `fence` in matter `%j`", result);
    return result;
}
var $560639d49e3c9a19$var$fence_1 = $560639d49e3c9a19$var$fence;
function $560639d49e3c9a19$var$fence(matter, prop) {
    var marker;
    if (matter.marker) {
        marker = $560639d49e3c9a19$var$pick(matter.marker, prop);
        return marker + marker + marker;
    }
    return $560639d49e3c9a19$var$pick(matter.fence, prop);
}
function $560639d49e3c9a19$var$pick(schema, prop) {
    return typeof schema === "string" ? schema : schema[prop];
}
var $560639d49e3c9a19$var$parse$3 = $560639d49e3c9a19$var$create$2;
function $560639d49e3c9a19$var$create$2(matter) {
    var name = matter.type + "FrontMatter";
    var open = $560639d49e3c9a19$var$fence_1(matter, "open");
    var close = $560639d49e3c9a19$var$fence_1(matter, "close");
    var newline = "\n";
    var anywhere = matter.anywhere;
    frontmatter.displayName = name;
    frontmatter.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
    return [
        name,
        frontmatter
    ];
    function frontmatter(eat, value, silent) {
        var index = open.length;
        var offset;
        if (value.slice(0, index) !== open || value.charAt(index) !== newline) return;
        offset = value.indexOf(close, index);
        while(offset !== -1 && value.charAt(offset - 1) !== newline){
            index = offset + close.length;
            offset = value.indexOf(close, index);
        }
        if (offset !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat(value.slice(0, offset + close.length))({
                type: matter.type,
                value: value.slice(open.length + 1, offset - 1)
            });
        }
    }
}
var $560639d49e3c9a19$var$compile = $560639d49e3c9a19$var$create$1;
function $560639d49e3c9a19$var$create$1(matter) {
    var type = matter.type;
    var open = $560639d49e3c9a19$var$fence_1(matter, "open");
    var close = $560639d49e3c9a19$var$fence_1(matter, "close");
    frontmatter.displayName = type + "FrontMatter";
    return [
        type,
        frontmatter
    ];
    function frontmatter(node) {
        return open + (node.value ? "\n" + node.value : "") + "\n" + close;
    }
}
var $560639d49e3c9a19$var$remarkFrontmatter = $560639d49e3c9a19$var$frontmatter;
function $560639d49e3c9a19$var$frontmatter(options) {
    var parser = this.Parser;
    var compiler = this.Compiler;
    var config = $560639d49e3c9a19$var$matters_1(options || [
        "yaml"
    ]);
    if ($560639d49e3c9a19$var$isRemarkParser(parser)) $560639d49e3c9a19$var$attachParser(parser, config);
    if ($560639d49e3c9a19$var$isRemarkCompiler(compiler)) $560639d49e3c9a19$var$attachCompiler(compiler, config);
}
function $560639d49e3c9a19$var$attachParser(parser, matters) {
    var proto = parser.prototype;
    var tokenizers = $560639d49e3c9a19$var$wrap$1($560639d49e3c9a19$var$parse$3, matters);
    var names = [];
    var key;
    for(key in tokenizers)names.push(key);
    proto.blockMethods = names.concat(proto.blockMethods);
    proto.blockTokenizers = Object.assign({}, tokenizers, proto.blockTokenizers);
}
function $560639d49e3c9a19$var$attachCompiler(compiler, matters) {
    var proto = compiler.prototype;
    proto.visitors = Object.assign({}, $560639d49e3c9a19$var$wrap$1($560639d49e3c9a19$var$compile, matters), proto.visitors);
}
function $560639d49e3c9a19$var$wrap$1(func, matters) {
    var result = {};
    var length = matters.length;
    var index = -1;
    var tuple;
    while(++index < length){
        tuple = func(matters[index]);
        result[tuple[0]] = tuple[1];
    }
    return result;
}
function $560639d49e3c9a19$var$isRemarkParser(parser) {
    return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers);
}
function $560639d49e3c9a19$var$isRemarkCompiler(compiler) {
    return Boolean(compiler && compiler.prototype && compiler.prototype.visitors);
}
var $560639d49e3c9a19$var$unistBuilder = $560639d49e3c9a19$var$u;
function $560639d49e3c9a19$var$u(type, props, value) {
    var node;
    if ((value === null || value === undefined) && (typeof props !== "object" || Array.isArray(props))) {
        value = props;
        props = {};
    }
    node = Object.assign({
        type: String(type)
    }, props);
    if (Array.isArray(value)) node.children = value;
    else if (value !== null && value !== undefined) node.value = String(value);
    return node;
}
var $560639d49e3c9a19$var$start = $560639d49e3c9a19$var$factory$1("start");
var $560639d49e3c9a19$var$end = $560639d49e3c9a19$var$factory$1("end");
var $560639d49e3c9a19$var$unistUtilPosition = $560639d49e3c9a19$var$position;
$560639d49e3c9a19$var$position.start = $560639d49e3c9a19$var$start;
$560639d49e3c9a19$var$position.end = $560639d49e3c9a19$var$end;
function $560639d49e3c9a19$var$position(node) {
    return {
        start: $560639d49e3c9a19$var$start(node),
        end: $560639d49e3c9a19$var$end(node)
    };
}
function $560639d49e3c9a19$var$factory$1(type) {
    point.displayName = type;
    return point;
    function point(node) {
        var point = node && node.position && node.position[type] || {};
        return {
            line: point.line || null,
            column: point.column || null,
            offset: isNaN(point.offset) ? null : point.offset
        };
    }
}
var $560639d49e3c9a19$var$unistUtilGenerated = $560639d49e3c9a19$var$generated;
function $560639d49e3c9a19$var$generated(node) {
    var position = $560639d49e3c9a19$var$optional($560639d49e3c9a19$var$optional(node).position);
    var start = $560639d49e3c9a19$var$optional(position.start);
    var end = $560639d49e3c9a19$var$optional(position.end);
    return !start.line || !start.column || !end.line || !end.column;
}
function $560639d49e3c9a19$var$optional(value) {
    return value && typeof value === "object" ? value : {};
}
var $560639d49e3c9a19$var$mdastUtilDefinitions = $560639d49e3c9a19$var$getDefinitionFactory;
var $560639d49e3c9a19$var$own$8 = {}.hasOwnProperty;
// Get a definition in `node` by `identifier`.
function $560639d49e3c9a19$var$getDefinitionFactory(node, options) {
    return $560639d49e3c9a19$var$getterFactory($560639d49e3c9a19$var$gather(node, options));
}
// Gather all definitions in `node`
function $560639d49e3c9a19$var$gather(node, options) {
    var cache = {};
    if (!node || !node.type) throw new Error("mdast-util-definitions expected node");
    $560639d49e3c9a19$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
    return cache;
    function commonmark(definition) {
        var id = $560639d49e3c9a19$var$normalise(definition.identifier);
        if (!$560639d49e3c9a19$var$own$8.call(cache, id)) cache[id] = definition;
    }
    function normal(definition) {
        cache[$560639d49e3c9a19$var$normalise(definition.identifier)] = definition;
    }
}
// Factory to get a node from the given definition-cache.
function $560639d49e3c9a19$var$getterFactory(cache) {
    return getter;
    // Get a node from the bound definition-cache.
    function getter(identifier) {
        var id = identifier && $560639d49e3c9a19$var$normalise(identifier);
        return id && $560639d49e3c9a19$var$own$8.call(cache, id) ? cache[id] : null;
    }
}
function $560639d49e3c9a19$var$normalise(identifier) {
    return identifier.toUpperCase();
}
var $560639d49e3c9a19$var$all_1$1 = $560639d49e3c9a19$var$all$2;
function $560639d49e3c9a19$var$all$2(h, parent) {
    var nodes = parent.children || [];
    var length = nodes.length;
    var values = [];
    var index = -1;
    var result;
    var head;
    while(++index < length){
        result = $560639d49e3c9a19$var$one_1$1(h, nodes[index], parent);
        if (result) {
            if (index && nodes[index - 1].type === "break") {
                if (result.value) result.value = result.value.replace(/^\s+/, "");
                head = result.children && result.children[0];
                if (head && head.value) head.value = head.value.replace(/^\s+/, "");
            }
            values = values.concat(result);
        }
    }
    return values;
}
var $560639d49e3c9a19$var$one_1$1 = $560639d49e3c9a19$var$one$2;
var $560639d49e3c9a19$var$own$7 = {}.hasOwnProperty;
// Transform an unknown node.
function $560639d49e3c9a19$var$unknown(h, node) {
    if ($560639d49e3c9a19$var$text$2(node)) return h.augment(node, $560639d49e3c9a19$var$unistBuilder("text", node.value));
    return h(node, "div", $560639d49e3c9a19$var$all_1$1(h, node));
}
// Visit a node.
function $560639d49e3c9a19$var$one$2(h, node, parent) {
    var type = node && node.type;
    var fn = $560639d49e3c9a19$var$own$7.call(h.handlers, type) ? h.handlers[type] : h.unknownHandler;
    // Fail on non-nodes.
    if (!type) throw new Error("Expected node, got `" + node + "`");
    return (typeof fn === "function" ? fn : $560639d49e3c9a19$var$unknown)(h, node, parent);
}
// Check if the node should be renderered as a text node.
function $560639d49e3c9a19$var$text$2(node) {
    var data = node.data || {};
    if ($560639d49e3c9a19$var$own$7.call(data, "hName") || $560639d49e3c9a19$var$own$7.call(data, "hProperties") || $560639d49e3c9a19$var$own$7.call(data, "hChildren")) return false;
    return "value" in node;
}
var $560639d49e3c9a19$var$thematicBreak_1 = $560639d49e3c9a19$var$thematicBreak;
function $560639d49e3c9a19$var$thematicBreak(h, node) {
    return h(node, "hr");
}
var $560639d49e3c9a19$var$wrap_1 = $560639d49e3c9a19$var$wrap;
// Wrap `nodes` with line feeds between each entry.
// Optionally adds line feeds at the start and end.
function $560639d49e3c9a19$var$wrap(nodes, loose) {
    var result = [];
    var index = -1;
    var length = nodes.length;
    if (loose) result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
    while(++index < length){
        if (index) result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
        result.push(nodes[index]);
    }
    if (loose && nodes.length !== 0) result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
    return result;
}
var $560639d49e3c9a19$var$list_1 = $560639d49e3c9a19$var$list;
function $560639d49e3c9a19$var$list(h, node) {
    var props = {};
    var name = node.ordered ? "ol" : "ul";
    var items;
    var index = -1;
    var length;
    if (typeof node.start === "number" && node.start !== 1) props.start = node.start;
    items = $560639d49e3c9a19$var$all_1$1(h, node);
    length = items.length;
    // Like GitHub, add a class for custom styling.
    while(++index < length)if (items[index].properties.className && items[index].properties.className.indexOf("task-list-item") !== -1) {
        props.className = [
            "contains-task-list"
        ];
        break;
    }
    return h(node, name, props, $560639d49e3c9a19$var$wrap_1(items, true));
}
var $560639d49e3c9a19$var$footer = $560639d49e3c9a19$var$generateFootnotes;
function $560639d49e3c9a19$var$generateFootnotes(h) {
    var footnoteById = h.footnoteById;
    var footnoteOrder = h.footnoteOrder;
    var length = footnoteOrder.length;
    var index = -1;
    var listItems = [];
    var def;
    var backReference;
    var content;
    var tail;
    while(++index < length){
        def = footnoteById[footnoteOrder[index].toUpperCase()];
        if (!def) continue;
        content = def.children.concat();
        tail = content[content.length - 1];
        backReference = {
            type: "link",
            url: "#fnref-" + def.identifier,
            data: {
                hProperties: {
                    className: [
                        "footnote-backref"
                    ]
                }
            },
            children: [
                {
                    type: "text",
                    value: "\u21A9"
                }
            ]
        };
        if (!tail || tail.type !== "paragraph") {
            tail = {
                type: "paragraph",
                children: []
            };
            content.push(tail);
        }
        tail.children.push(backReference);
        listItems.push({
            type: "listItem",
            data: {
                hProperties: {
                    id: "fn-" + def.identifier
                }
            },
            children: content,
            position: def.position
        });
    }
    if (listItems.length === 0) return null;
    return h(null, "div", {
        className: [
            "footnotes"
        ]
    }, $560639d49e3c9a19$var$wrap_1([
        $560639d49e3c9a19$var$thematicBreak_1(h),
        $560639d49e3c9a19$var$list_1(h, {
            type: "list",
            ordered: true,
            children: listItems
        })
    ], true));
}
var $560639d49e3c9a19$var$blockquote_1 = $560639d49e3c9a19$var$blockquote;
function $560639d49e3c9a19$var$blockquote(h, node) {
    return h(node, "blockquote", $560639d49e3c9a19$var$wrap_1($560639d49e3c9a19$var$all_1$1(h, node), true));
}
var $560639d49e3c9a19$var$_break = $560639d49e3c9a19$var$hardBreak;
function $560639d49e3c9a19$var$hardBreak(h, node) {
    return [
        h(node, "br"),
        $560639d49e3c9a19$var$unistBuilder("text", "\n")
    ];
}
var $560639d49e3c9a19$var$detab_1 = $560639d49e3c9a19$var$detab;
var $560639d49e3c9a19$var$tab$1 = 0x09;
var $560639d49e3c9a19$var$lineFeed$1 = 0x0a;
var $560639d49e3c9a19$var$carriageReturn = 0x0d;
// Replace tabs with spaces, being smart about which column the tab is at and
// which size should be used.
function $560639d49e3c9a19$var$detab(value, size) {
    var string = typeof value === "string";
    var length = string && value.length;
    var start = 0;
    var index = -1;
    var column = -1;
    var tabSize = size || 4;
    var results = [];
    var code;
    var add;
    if (!string) throw new Error("detab expected string");
    while(++index < length){
        code = value.charCodeAt(index);
        if (code === $560639d49e3c9a19$var$tab$1) {
            add = tabSize - (column + 1) % tabSize;
            column += add;
            results.push(value.slice(start, index) + $560639d49e3c9a19$var$repeatString(" ", add));
            start = index + 1;
        } else if (code === $560639d49e3c9a19$var$lineFeed$1 || code === $560639d49e3c9a19$var$carriageReturn) column = -1;
        else column++;
    }
    results.push(value.slice(start));
    return results.join("");
}
var $560639d49e3c9a19$var$code_1 = $560639d49e3c9a19$var$code;
function $560639d49e3c9a19$var$code(h, node) {
    var value = node.value ? $560639d49e3c9a19$var$detab_1(node.value + "\n") : "";
    var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
    var props = {};
    if (lang) props.className = [
        "language-" + lang
    ];
    return h(node.position, "pre", [
        h(node, "code", props, [
            $560639d49e3c9a19$var$unistBuilder("text", value)
        ])
    ]);
}
var $560639d49e3c9a19$var$_delete = $560639d49e3c9a19$var$strikethrough;
function $560639d49e3c9a19$var$strikethrough(h, node) {
    return h(node, "del", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$emphasis_1 = $560639d49e3c9a19$var$emphasis;
function $560639d49e3c9a19$var$emphasis(h, node) {
    return h(node, "em", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$footnoteReference_1 = $560639d49e3c9a19$var$footnoteReference;
function $560639d49e3c9a19$var$footnoteReference(h, node) {
    var footnoteOrder = h.footnoteOrder;
    var identifier = String(node.identifier);
    if (footnoteOrder.indexOf(identifier) === -1) footnoteOrder.push(identifier);
    return h(node.position, "sup", {
        id: "fnref-" + identifier
    }, [
        h(node, "a", {
            href: "#fn-" + identifier,
            className: [
                "footnote-ref"
            ]
        }, [
            $560639d49e3c9a19$var$unistBuilder("text", node.label || identifier)
        ])
    ]);
}
var $560639d49e3c9a19$var$footnote_1 = $560639d49e3c9a19$var$footnote;
function $560639d49e3c9a19$var$footnote(h, node) {
    var footnoteById = h.footnoteById;
    var footnoteOrder = h.footnoteOrder;
    var identifier = 1;
    while(identifier in footnoteById)identifier++;
    identifier = String(identifier);
    // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
    // to not exist because we just generated it.
    footnoteOrder.push(identifier);
    footnoteById[identifier] = {
        type: "footnoteDefinition",
        identifier: identifier,
        children: [
            {
                type: "paragraph",
                children: node.children
            }
        ],
        position: node.position
    };
    return $560639d49e3c9a19$var$footnoteReference_1(h, {
        type: "footnoteReference",
        identifier: identifier,
        position: node.position
    });
}
var $560639d49e3c9a19$var$heading_1 = $560639d49e3c9a19$var$heading;
function $560639d49e3c9a19$var$heading(h, node) {
    return h(node, "h" + node.depth, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$html_1$1 = $560639d49e3c9a19$var$html$3;
// Return either a `raw` node in dangerous mode, otherwise nothing.
function $560639d49e3c9a19$var$html$3(h, node) {
    return h.dangerous ? h.augment(node, $560639d49e3c9a19$var$unistBuilder("raw", node.value)) : null;
}
var $560639d49e3c9a19$var$encodeCache = {};
// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function $560639d49e3c9a19$var$getEncodeCache(exclude) {
    var i, ch, cache = $560639d49e3c9a19$var$encodeCache[exclude];
    if (cache) return cache;
    cache = $560639d49e3c9a19$var$encodeCache[exclude] = [];
    for(i = 0; i < 128; i++){
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) // always allow unencoded alphanumeric characters
        cache.push(ch);
        else cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
    for(i = 0; i < exclude.length; i++)cache[exclude.charCodeAt(i)] = exclude[i];
    return cache;
}
// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function $560639d49e3c9a19$var$encode$1(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache, result = "";
    if (typeof exclude !== "string") {
        // encode(string, keepEscaped)
        keepEscaped = exclude;
        exclude = $560639d49e3c9a19$var$encode$1.defaultChars;
    }
    if (typeof keepEscaped === "undefined") keepEscaped = true;
    cache = $560639d49e3c9a19$var$getEncodeCache(exclude);
    for(i = 0, l = string.length; i < l; i++){
        code = string.charCodeAt(i);
        if (keepEscaped && code === 0x25 /* % */  && i + 2 < l) {
            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                result += string.slice(i, i + 3);
                i += 2;
                continue;
            }
        }
        if (code < 128) {
            result += cache[code];
            continue;
        }
        if (code >= 0xD800 && code <= 0xDFFF) {
            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
                nextCode = string.charCodeAt(i + 1);
                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
                    result += encodeURIComponent(string[i] + string[i + 1]);
                    i++;
                    continue;
                }
            }
            result += "%EF%BF%BD";
            continue;
        }
        result += encodeURIComponent(string[i]);
    }
    return result;
}
$560639d49e3c9a19$var$encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
$560639d49e3c9a19$var$encode$1.componentChars = "-_.!~*'()";
var $560639d49e3c9a19$var$encode_1 = $560639d49e3c9a19$var$encode$1;
var $560639d49e3c9a19$var$revert_1 = $560639d49e3c9a19$var$revert;
// Return the content of a reference without definition as Markdown.
function $560639d49e3c9a19$var$revert(h, node) {
    var subtype = node.referenceType;
    var suffix = "]";
    var contents;
    var head;
    var tail;
    if (subtype === "collapsed") suffix += "[]";
    else if (subtype === "full") suffix += "[" + (node.label || node.identifier) + "]";
    if (node.type === "imageReference") return $560639d49e3c9a19$var$unistBuilder("text", "![" + node.alt + suffix);
    contents = $560639d49e3c9a19$var$all_1$1(h, node);
    head = contents[0];
    if (head && head.type === "text") head.value = "[" + head.value;
    else contents.unshift($560639d49e3c9a19$var$unistBuilder("text", "["));
    tail = contents[contents.length - 1];
    if (tail && tail.type === "text") tail.value += suffix;
    else contents.push($560639d49e3c9a19$var$unistBuilder("text", suffix));
    return contents;
}
var $560639d49e3c9a19$var$imageReference_1 = $560639d49e3c9a19$var$imageReference;
function $560639d49e3c9a19$var$imageReference(h, node) {
    var def = h.definition(node.identifier);
    var props;
    if (!def) return $560639d49e3c9a19$var$revert_1(h, node);
    props = {
        src: $560639d49e3c9a19$var$encode_1(def.url || ""),
        alt: node.alt
    };
    if (def.title !== null && def.title !== undefined) props.title = def.title;
    return h(node, "img", props);
}
var $560639d49e3c9a19$var$image_1 = $560639d49e3c9a19$var$image$1;
function $560639d49e3c9a19$var$image$1(h, node) {
    var props = {
        src: $560639d49e3c9a19$var$encode_1(node.url),
        alt: node.alt
    };
    if (node.title !== null && node.title !== undefined) props.title = node.title;
    return h(node, "img", props);
}
var $560639d49e3c9a19$var$inlineCode_1 = $560639d49e3c9a19$var$inlineCode;
function $560639d49e3c9a19$var$inlineCode(h, node) {
    return h(node, "code", [
        $560639d49e3c9a19$var$unistBuilder("text", $560639d49e3c9a19$var$collapseWhiteSpace(node.value))
    ]);
}
var $560639d49e3c9a19$var$linkReference_1 = $560639d49e3c9a19$var$linkReference;
function $560639d49e3c9a19$var$linkReference(h, node) {
    var def = h.definition(node.identifier);
    var props;
    if (!def) return $560639d49e3c9a19$var$revert_1(h, node);
    props = {
        href: $560639d49e3c9a19$var$encode_1(def.url || "")
    };
    if (def.title !== null && def.title !== undefined) props.title = def.title;
    return h(node, "a", props, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$link_1 = $560639d49e3c9a19$var$link;
function $560639d49e3c9a19$var$link(h, node) {
    var props = {
        href: $560639d49e3c9a19$var$encode_1(node.url)
    };
    if (node.title !== null && node.title !== undefined) props.title = node.title;
    return h(node, "a", props, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$listItem_1 = $560639d49e3c9a19$var$listItem$1;
function $560639d49e3c9a19$var$listItem$1(h, node, parent) {
    var children = node.children;
    var head = children[0];
    var raw = $560639d49e3c9a19$var$all_1$1(h, node);
    var loose = parent ? $560639d49e3c9a19$var$listLoose(parent) : $560639d49e3c9a19$var$listItemLoose(node);
    var props = {};
    var result;
    var container;
    var index;
    var length;
    var child;
    // Tight lists should not render `paragraph` nodes as `p` elements.
    if (loose) result = raw;
    else {
        result = [];
        length = raw.length;
        index = -1;
        while(++index < length){
            child = raw[index];
            if (child.tagName === "p") result = result.concat(child.children);
            else result.push(child);
        }
    }
    if (typeof node.checked === "boolean") {
        if (loose && (!head || head.type !== "paragraph")) result.unshift(h(null, "p", []));
        container = loose ? result[0].children : result;
        if (container.length !== 0) container.unshift($560639d49e3c9a19$var$unistBuilder("text", " "));
        container.unshift(h(null, "input", {
            type: "checkbox",
            checked: node.checked,
            disabled: true
        }));
        // According to github-markdown-css, this class hides bullet.
        // See: <https://github.com/sindresorhus/github-markdown-css>.
        props.className = [
            "task-list-item"
        ];
    }
    if (loose && result.length !== 0) result = $560639d49e3c9a19$var$wrap_1(result, true);
    return h(node, "li", props, result);
}
function $560639d49e3c9a19$var$listLoose(node) {
    var loose = node.spread;
    var children = node.children;
    var length = children.length;
    var index = -1;
    while(!loose && ++index < length)loose = $560639d49e3c9a19$var$listItemLoose(children[index]);
    return loose;
}
function $560639d49e3c9a19$var$listItemLoose(node) {
    var spread = node.spread;
    return spread === undefined || spread === null ? node.children.length > 1 : spread;
}
var $560639d49e3c9a19$var$paragraph_1 = $560639d49e3c9a19$var$paragraph;
function $560639d49e3c9a19$var$paragraph(h, node) {
    return h(node, "p", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$root_1 = $560639d49e3c9a19$var$root;
function $560639d49e3c9a19$var$root(h, node) {
    return h.augment(node, $560639d49e3c9a19$var$unistBuilder("root", $560639d49e3c9a19$var$wrap_1($560639d49e3c9a19$var$all_1$1(h, node))));
}
var $560639d49e3c9a19$var$strong_1 = $560639d49e3c9a19$var$strong;
function $560639d49e3c9a19$var$strong(h, node) {
    return h(node, "strong", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$table_1 = $560639d49e3c9a19$var$table;
function $560639d49e3c9a19$var$table(h, node) {
    var rows = node.children;
    var index = rows.length;
    var align = node.align;
    var alignLength = align.length;
    var result = [];
    var pos;
    var row;
    var out;
    var name;
    var cell;
    while(index--){
        row = rows[index].children;
        name = index === 0 ? "th" : "td";
        pos = alignLength;
        out = [];
        while(pos--){
            cell = row[pos];
            out[pos] = h(cell, name, {
                align: align[pos]
            }, cell ? $560639d49e3c9a19$var$all_1$1(h, cell) : []);
        }
        result[index] = h(rows[index], "tr", $560639d49e3c9a19$var$wrap_1(out, true));
    }
    return h(node, "table", $560639d49e3c9a19$var$wrap_1([
        h(result[0].position, "thead", $560639d49e3c9a19$var$wrap_1([
            result[0]
        ], true)),
        h({
            start: $560639d49e3c9a19$var$unistUtilPosition.start(result[1]),
            end: $560639d49e3c9a19$var$unistUtilPosition.end(result[result.length - 1])
        }, "tbody", $560639d49e3c9a19$var$wrap_1(result.slice(1), true))
    ], true));
}
var $560639d49e3c9a19$var$trimLines_1 = $560639d49e3c9a19$var$trimLines;
var $560639d49e3c9a19$var$ws = /[ \t]*\n+[ \t]*/g;
var $560639d49e3c9a19$var$newline$1 = "\n";
function $560639d49e3c9a19$var$trimLines(value) {
    return String(value).replace($560639d49e3c9a19$var$ws, $560639d49e3c9a19$var$newline$1);
}
var $560639d49e3c9a19$var$text_1$1 = $560639d49e3c9a19$var$text$1;
function $560639d49e3c9a19$var$text$1(h, node) {
    return h.augment(node, $560639d49e3c9a19$var$unistBuilder("text", $560639d49e3c9a19$var$trimLines_1(node.value)));
}
var $560639d49e3c9a19$var$handlers$1 = {
    blockquote: $560639d49e3c9a19$var$blockquote_1,
    break: $560639d49e3c9a19$var$_break,
    code: $560639d49e3c9a19$var$code_1,
    delete: $560639d49e3c9a19$var$_delete,
    emphasis: $560639d49e3c9a19$var$emphasis_1,
    footnoteReference: $560639d49e3c9a19$var$footnoteReference_1,
    footnote: $560639d49e3c9a19$var$footnote_1,
    heading: $560639d49e3c9a19$var$heading_1,
    html: $560639d49e3c9a19$var$html_1$1,
    imageReference: $560639d49e3c9a19$var$imageReference_1,
    image: $560639d49e3c9a19$var$image_1,
    inlineCode: $560639d49e3c9a19$var$inlineCode_1,
    linkReference: $560639d49e3c9a19$var$linkReference_1,
    link: $560639d49e3c9a19$var$link_1,
    listItem: $560639d49e3c9a19$var$listItem_1,
    list: $560639d49e3c9a19$var$list_1,
    paragraph: $560639d49e3c9a19$var$paragraph_1,
    root: $560639d49e3c9a19$var$root_1,
    strong: $560639d49e3c9a19$var$strong_1,
    table: $560639d49e3c9a19$var$table_1,
    text: $560639d49e3c9a19$var$text_1$1,
    thematicBreak: $560639d49e3c9a19$var$thematicBreak_1,
    toml: $560639d49e3c9a19$var$ignore,
    yaml: $560639d49e3c9a19$var$ignore,
    definition: $560639d49e3c9a19$var$ignore,
    footnoteDefinition: $560639d49e3c9a19$var$ignore
};
// Return nothing for nodes that are ignored.
function $560639d49e3c9a19$var$ignore() {
    return null;
}
var $560639d49e3c9a19$var$lib$2 = $560639d49e3c9a19$var$toHast;
var $560639d49e3c9a19$var$own$6 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$deprecationWarningIssued = false;
// Factory to transform.
function $560639d49e3c9a19$var$factory(tree, options) {
    var settings = options || {};
    // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
    if (settings.allowDangerousHTML !== undefined && !$560639d49e3c9a19$var$deprecationWarningIssued) {
        $560639d49e3c9a19$var$deprecationWarningIssued = true;
        console.warn("mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead");
    }
    var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
    var footnoteById = {};
    h.dangerous = dangerous;
    h.definition = $560639d49e3c9a19$var$mdastUtilDefinitions(tree, settings);
    h.footnoteById = footnoteById;
    h.footnoteOrder = [];
    h.augment = augment;
    h.handlers = Object.assign({}, $560639d49e3c9a19$var$handlers$1, settings.handlers);
    h.unknownHandler = settings.unknownHandler;
    $560639d49e3c9a19$var$unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
    return h;
    // Finalise the created `right`, a hast node, from `left`, an mdast node.
    function augment(left, right) {
        var data;
        var ctx;
        // Handle `data.hName`, `data.hProperties, `data.hChildren`.
        if (left && "data" in left) {
            data = left.data;
            if (right.type === "element" && data.hName) right.tagName = data.hName;
            if (right.type === "element" && data.hProperties) right.properties = Object.assign({}, right.properties, data.hProperties);
            if (right.children && data.hChildren) right.children = data.hChildren;
        }
        ctx = left && left.position ? left : {
            position: left
        };
        if (!$560639d49e3c9a19$var$unistUtilGenerated(ctx)) right.position = {
            start: $560639d49e3c9a19$var$unistUtilPosition.start(ctx),
            end: $560639d49e3c9a19$var$unistUtilPosition.end(ctx)
        };
        return right;
    }
    // Create an element for `node`.
    function h(node, tagName, props, children) {
        if ((children === undefined || children === null) && typeof props === "object" && "length" in props) {
            children = props;
            props = {};
        }
        return augment(node, {
            type: "element",
            tagName: tagName,
            properties: props || {},
            children: children || []
        });
    }
    function onfootnotedefinition(definition) {
        var id = String(definition.identifier).toUpperCase();
        // Mimick CM behavior of link definitions.
        // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8d48e57/index.js#L26>.
        if (!$560639d49e3c9a19$var$own$6.call(footnoteById, id)) footnoteById[id] = definition;
    }
}
// Transform `tree`, which is an mdast node, to a hast node.
function $560639d49e3c9a19$var$toHast(tree, options) {
    var h = $560639d49e3c9a19$var$factory(tree, options);
    var node = $560639d49e3c9a19$var$one_1$1(h, tree);
    var foot = $560639d49e3c9a19$var$footer(h);
    if (foot) node.children = node.children.concat($560639d49e3c9a19$var$unistBuilder("text", "\n"), foot);
    return node;
}
var $560639d49e3c9a19$var$mdastUtilToHast = $560639d49e3c9a19$var$lib$2;
var $560639d49e3c9a19$var$remarkRehype = $560639d49e3c9a19$var$remark2rehype;
// Attacher.
// If a destination is given, runs the destination with the new hast tree
// (bridge mode).
// Without destination, returns the tree: further plugins run on that tree
// (mutate mode).
function $560639d49e3c9a19$var$remark2rehype(destination, options) {
    if (destination && !destination.process) {
        options = destination;
        destination = null;
    }
    return destination ? $560639d49e3c9a19$var$bridge(destination, options) : $560639d49e3c9a19$var$mutate(options);
}
// Bridge mode.
// Runs the destination with the new hast tree.
function $560639d49e3c9a19$var$bridge(destination, options) {
    return transformer;
    function transformer(node, file, next) {
        destination.run($560639d49e3c9a19$var$mdastUtilToHast(node, options), file, done);
        function done(err) {
            next(err);
        }
    }
}
// Mutate-mode.
// Further transformers run on the hast tree.
function $560639d49e3c9a19$var$mutate(options) {
    return transformer;
    function transformer(node) {
        return $560639d49e3c9a19$var$mdastUtilToHast(node, options);
    }
}
var $560639d49e3c9a19$var$schema$1 = $560639d49e3c9a19$var$Schema$2;
var $560639d49e3c9a19$var$proto$2 = $560639d49e3c9a19$var$Schema$2.prototype;
$560639d49e3c9a19$var$proto$2.space = null;
$560639d49e3c9a19$var$proto$2.normal = {};
$560639d49e3c9a19$var$proto$2.property = {};
function $560639d49e3c9a19$var$Schema$2(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) this.space = space;
}
var $560639d49e3c9a19$var$merge_1 = $560639d49e3c9a19$var$merge$1;
function $560639d49e3c9a19$var$merge$1(definitions) {
    var length = definitions.length;
    var property = [];
    var normal = [];
    var index = -1;
    var info;
    var space;
    while(++index < length){
        info = definitions[index];
        property.push(info.property);
        normal.push(info.normal);
        space = info.space;
    }
    return new $560639d49e3c9a19$var$schema$1($560639d49e3c9a19$var$immutable.apply(null, property), $560639d49e3c9a19$var$immutable.apply(null, normal), space);
}
var $560639d49e3c9a19$var$normalize_1 = $560639d49e3c9a19$var$normalize;
function $560639d49e3c9a19$var$normalize(value) {
    return value.toLowerCase();
}
var $560639d49e3c9a19$var$info = $560639d49e3c9a19$var$Info;
var $560639d49e3c9a19$var$proto$1 = $560639d49e3c9a19$var$Info.prototype;
$560639d49e3c9a19$var$proto$1.space = null;
$560639d49e3c9a19$var$proto$1.attribute = null;
$560639d49e3c9a19$var$proto$1.property = null;
$560639d49e3c9a19$var$proto$1.boolean = false;
$560639d49e3c9a19$var$proto$1.booleanish = false;
$560639d49e3c9a19$var$proto$1.overloadedBoolean = false;
$560639d49e3c9a19$var$proto$1.number = false;
$560639d49e3c9a19$var$proto$1.commaSeparated = false;
$560639d49e3c9a19$var$proto$1.spaceSeparated = false;
$560639d49e3c9a19$var$proto$1.commaOrSpaceSeparated = false;
$560639d49e3c9a19$var$proto$1.mustUseProperty = false;
$560639d49e3c9a19$var$proto$1.defined = false;
function $560639d49e3c9a19$var$Info(property, attribute) {
    this.property = property;
    this.attribute = attribute;
}
var $560639d49e3c9a19$var$powers = 0;
var $560639d49e3c9a19$var$boolean_1 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$booleanish$2 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$overloadedBoolean$1 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$number$3 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$spaceSeparated$3 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$commaSeparated$2 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$commaOrSpaceSeparated$1 = $560639d49e3c9a19$var$increment();
function $560639d49e3c9a19$var$increment() {
    return Math.pow(2, ++$560639d49e3c9a19$var$powers);
}
var $560639d49e3c9a19$var$types = {
    boolean: $560639d49e3c9a19$var$boolean_1,
    booleanish: $560639d49e3c9a19$var$booleanish$2,
    overloadedBoolean: $560639d49e3c9a19$var$overloadedBoolean$1,
    number: $560639d49e3c9a19$var$number$3,
    spaceSeparated: $560639d49e3c9a19$var$spaceSeparated$3,
    commaSeparated: $560639d49e3c9a19$var$commaSeparated$2,
    commaOrSpaceSeparated: $560639d49e3c9a19$var$commaOrSpaceSeparated$1
};
var $560639d49e3c9a19$var$definedInfo = $560639d49e3c9a19$var$DefinedInfo;
$560639d49e3c9a19$var$DefinedInfo.prototype = new $560639d49e3c9a19$var$info();
$560639d49e3c9a19$var$DefinedInfo.prototype.defined = true;
var $560639d49e3c9a19$var$checks = [
    "boolean",
    "booleanish",
    "overloadedBoolean",
    "number",
    "commaSeparated",
    "spaceSeparated",
    "commaOrSpaceSeparated"
];
var $560639d49e3c9a19$var$checksLength = $560639d49e3c9a19$var$checks.length;
function $560639d49e3c9a19$var$DefinedInfo(property, attribute, mask, space) {
    var index = -1;
    var check;
    $560639d49e3c9a19$var$mark$1(this, "space", space);
    $560639d49e3c9a19$var$info.call(this, property, attribute);
    while(++index < $560639d49e3c9a19$var$checksLength){
        check = $560639d49e3c9a19$var$checks[index];
        $560639d49e3c9a19$var$mark$1(this, check, (mask & $560639d49e3c9a19$var$types[check]) === $560639d49e3c9a19$var$types[check]);
    }
}
function $560639d49e3c9a19$var$mark$1(values, key, value) {
    if (value) values[key] = value;
}
var $560639d49e3c9a19$var$create_1 = $560639d49e3c9a19$var$create;
function $560639d49e3c9a19$var$create(definition) {
    var space = definition.space;
    var mustUseProperty = definition.mustUseProperty || [];
    var attributes = definition.attributes || {};
    var props = definition.properties;
    var transform = definition.transform;
    var property = {};
    var normal = {};
    var prop;
    var info;
    for(prop in props){
        info = new $560639d49e3c9a19$var$definedInfo(prop, transform(attributes, prop), props[prop], space);
        if (mustUseProperty.indexOf(prop) !== -1) info.mustUseProperty = true;
        property[prop] = info;
        normal[$560639d49e3c9a19$var$normalize_1(prop)] = prop;
        normal[$560639d49e3c9a19$var$normalize_1(info.attribute)] = prop;
    }
    return new $560639d49e3c9a19$var$schema$1(property, normal, space);
}
var $560639d49e3c9a19$var$xlink = $560639d49e3c9a19$var$create_1({
    space: "xlink",
    transform: $560639d49e3c9a19$var$xlinkTransform,
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
});
function $560639d49e3c9a19$var$xlinkTransform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
}
var $560639d49e3c9a19$var$xml = $560639d49e3c9a19$var$create_1({
    space: "xml",
    transform: $560639d49e3c9a19$var$xmlTransform,
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function $560639d49e3c9a19$var$xmlTransform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
}
var $560639d49e3c9a19$var$caseSensitiveTransform_1 = $560639d49e3c9a19$var$caseSensitiveTransform;
function $560639d49e3c9a19$var$caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
}
var $560639d49e3c9a19$var$caseInsensitiveTransform_1 = $560639d49e3c9a19$var$caseInsensitiveTransform;
function $560639d49e3c9a19$var$caseInsensitiveTransform(attributes, property) {
    return $560639d49e3c9a19$var$caseSensitiveTransform_1(attributes, property.toLowerCase());
}
var $560639d49e3c9a19$var$xmlns = $560639d49e3c9a19$var$create_1({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: $560639d49e3c9a19$var$caseInsensitiveTransform_1,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
});
var $560639d49e3c9a19$var$booleanish$1 = $560639d49e3c9a19$var$types.booleanish;
var $560639d49e3c9a19$var$number$2 = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated$2 = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$aria = $560639d49e3c9a19$var$create_1({
    transform: $560639d49e3c9a19$var$ariaTransform,
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: $560639d49e3c9a19$var$booleanish$1,
        ariaAutoComplete: null,
        ariaBusy: $560639d49e3c9a19$var$booleanish$1,
        ariaChecked: $560639d49e3c9a19$var$booleanish$1,
        ariaColCount: $560639d49e3c9a19$var$number$2,
        ariaColIndex: $560639d49e3c9a19$var$number$2,
        ariaColSpan: $560639d49e3c9a19$var$number$2,
        ariaControls: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaCurrent: null,
        ariaDescribedBy: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaDetails: null,
        ariaDisabled: $560639d49e3c9a19$var$booleanish$1,
        ariaDropEffect: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaErrorMessage: null,
        ariaExpanded: $560639d49e3c9a19$var$booleanish$1,
        ariaFlowTo: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaGrabbed: $560639d49e3c9a19$var$booleanish$1,
        ariaHasPopup: null,
        ariaHidden: $560639d49e3c9a19$var$booleanish$1,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaLevel: $560639d49e3c9a19$var$number$2,
        ariaLive: null,
        ariaModal: $560639d49e3c9a19$var$booleanish$1,
        ariaMultiLine: $560639d49e3c9a19$var$booleanish$1,
        ariaMultiSelectable: $560639d49e3c9a19$var$booleanish$1,
        ariaOrientation: null,
        ariaOwns: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaPlaceholder: null,
        ariaPosInSet: $560639d49e3c9a19$var$number$2,
        ariaPressed: $560639d49e3c9a19$var$booleanish$1,
        ariaReadOnly: $560639d49e3c9a19$var$booleanish$1,
        ariaRelevant: null,
        ariaRequired: $560639d49e3c9a19$var$booleanish$1,
        ariaRoleDescription: $560639d49e3c9a19$var$spaceSeparated$2,
        ariaRowCount: $560639d49e3c9a19$var$number$2,
        ariaRowIndex: $560639d49e3c9a19$var$number$2,
        ariaRowSpan: $560639d49e3c9a19$var$number$2,
        ariaSelected: $560639d49e3c9a19$var$booleanish$1,
        ariaSetSize: $560639d49e3c9a19$var$number$2,
        ariaSort: null,
        ariaValueMax: $560639d49e3c9a19$var$number$2,
        ariaValueMin: $560639d49e3c9a19$var$number$2,
        ariaValueNow: $560639d49e3c9a19$var$number$2,
        ariaValueText: null,
        role: null
    }
});
function $560639d49e3c9a19$var$ariaTransform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
}
var $560639d49e3c9a19$var$boolean$1 = $560639d49e3c9a19$var$types.boolean;
var $560639d49e3c9a19$var$overloadedBoolean = $560639d49e3c9a19$var$types.overloadedBoolean;
var $560639d49e3c9a19$var$booleanish = $560639d49e3c9a19$var$types.booleanish;
var $560639d49e3c9a19$var$number$1 = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated$1 = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$commaSeparated$1 = $560639d49e3c9a19$var$types.commaSeparated;
var $560639d49e3c9a19$var$html$2 = $560639d49e3c9a19$var$create_1({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: $560639d49e3c9a19$var$caseInsensitiveTransform_1,
    mustUseProperty: [
        "checked",
        "multiple",
        "muted",
        "selected"
    ],
    properties: {
        // Standard Properties.
        abbr: null,
        accept: $560639d49e3c9a19$var$commaSeparated$1,
        acceptCharset: $560639d49e3c9a19$var$spaceSeparated$1,
        accessKey: $560639d49e3c9a19$var$spaceSeparated$1,
        action: null,
        allow: null,
        allowFullScreen: $560639d49e3c9a19$var$boolean$1,
        allowPaymentRequest: $560639d49e3c9a19$var$boolean$1,
        allowUserMedia: $560639d49e3c9a19$var$boolean$1,
        alt: null,
        as: null,
        async: $560639d49e3c9a19$var$boolean$1,
        autoCapitalize: null,
        autoComplete: $560639d49e3c9a19$var$spaceSeparated$1,
        autoFocus: $560639d49e3c9a19$var$boolean$1,
        autoPlay: $560639d49e3c9a19$var$boolean$1,
        capture: $560639d49e3c9a19$var$boolean$1,
        charSet: null,
        checked: $560639d49e3c9a19$var$boolean$1,
        cite: null,
        className: $560639d49e3c9a19$var$spaceSeparated$1,
        cols: $560639d49e3c9a19$var$number$1,
        colSpan: null,
        content: null,
        contentEditable: $560639d49e3c9a19$var$booleanish,
        controls: $560639d49e3c9a19$var$boolean$1,
        controlsList: $560639d49e3c9a19$var$spaceSeparated$1,
        coords: $560639d49e3c9a19$var$number$1 | $560639d49e3c9a19$var$commaSeparated$1,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: $560639d49e3c9a19$var$boolean$1,
        defer: $560639d49e3c9a19$var$boolean$1,
        dir: null,
        dirName: null,
        disabled: $560639d49e3c9a19$var$boolean$1,
        download: $560639d49e3c9a19$var$overloadedBoolean,
        draggable: $560639d49e3c9a19$var$booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: $560639d49e3c9a19$var$boolean$1,
        formTarget: null,
        headers: $560639d49e3c9a19$var$spaceSeparated$1,
        height: $560639d49e3c9a19$var$number$1,
        hidden: $560639d49e3c9a19$var$boolean$1,
        high: $560639d49e3c9a19$var$number$1,
        href: null,
        hrefLang: null,
        htmlFor: $560639d49e3c9a19$var$spaceSeparated$1,
        httpEquiv: $560639d49e3c9a19$var$spaceSeparated$1,
        id: null,
        imageSizes: null,
        imageSrcSet: $560639d49e3c9a19$var$commaSeparated$1,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: $560639d49e3c9a19$var$boolean$1,
        itemId: null,
        itemProp: $560639d49e3c9a19$var$spaceSeparated$1,
        itemRef: $560639d49e3c9a19$var$spaceSeparated$1,
        itemScope: $560639d49e3c9a19$var$boolean$1,
        itemType: $560639d49e3c9a19$var$spaceSeparated$1,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loop: $560639d49e3c9a19$var$boolean$1,
        low: $560639d49e3c9a19$var$number$1,
        manifest: null,
        max: null,
        maxLength: $560639d49e3c9a19$var$number$1,
        media: null,
        method: null,
        min: null,
        minLength: $560639d49e3c9a19$var$number$1,
        multiple: $560639d49e3c9a19$var$boolean$1,
        muted: $560639d49e3c9a19$var$boolean$1,
        name: null,
        nonce: null,
        noModule: $560639d49e3c9a19$var$boolean$1,
        noValidate: $560639d49e3c9a19$var$boolean$1,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: $560639d49e3c9a19$var$boolean$1,
        optimum: $560639d49e3c9a19$var$number$1,
        pattern: null,
        ping: $560639d49e3c9a19$var$spaceSeparated$1,
        placeholder: null,
        playsInline: $560639d49e3c9a19$var$boolean$1,
        poster: null,
        preload: null,
        readOnly: $560639d49e3c9a19$var$boolean$1,
        referrerPolicy: null,
        rel: $560639d49e3c9a19$var$spaceSeparated$1,
        required: $560639d49e3c9a19$var$boolean$1,
        reversed: $560639d49e3c9a19$var$boolean$1,
        rows: $560639d49e3c9a19$var$number$1,
        rowSpan: $560639d49e3c9a19$var$number$1,
        sandbox: $560639d49e3c9a19$var$spaceSeparated$1,
        scope: null,
        scoped: $560639d49e3c9a19$var$boolean$1,
        seamless: $560639d49e3c9a19$var$boolean$1,
        selected: $560639d49e3c9a19$var$boolean$1,
        shape: null,
        size: $560639d49e3c9a19$var$number$1,
        sizes: null,
        slot: null,
        span: $560639d49e3c9a19$var$number$1,
        spellCheck: $560639d49e3c9a19$var$booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: $560639d49e3c9a19$var$commaSeparated$1,
        start: $560639d49e3c9a19$var$number$1,
        step: null,
        style: null,
        tabIndex: $560639d49e3c9a19$var$number$1,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: $560639d49e3c9a19$var$boolean$1,
        useMap: null,
        value: $560639d49e3c9a19$var$booleanish,
        width: $560639d49e3c9a19$var$number$1,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        aLink: null,
        archive: $560639d49e3c9a19$var$spaceSeparated$1,
        axis: null,
        background: null,
        bgColor: null,
        border: $560639d49e3c9a19$var$number$1,
        borderColor: null,
        bottomMargin: $560639d49e3c9a19$var$number$1,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: $560639d49e3c9a19$var$boolean$1,
        declare: $560639d49e3c9a19$var$boolean$1,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: $560639d49e3c9a19$var$number$1,
        leftMargin: $560639d49e3c9a19$var$number$1,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: $560639d49e3c9a19$var$number$1,
        marginWidth: $560639d49e3c9a19$var$number$1,
        noResize: $560639d49e3c9a19$var$boolean$1,
        noHref: $560639d49e3c9a19$var$boolean$1,
        noShade: $560639d49e3c9a19$var$boolean$1,
        noWrap: $560639d49e3c9a19$var$boolean$1,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: $560639d49e3c9a19$var$number$1,
        rules: null,
        scheme: null,
        scrolling: $560639d49e3c9a19$var$booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: $560639d49e3c9a19$var$number$1,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: $560639d49e3c9a19$var$number$1,
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: $560639d49e3c9a19$var$boolean$1,
        disableRemotePlayback: $560639d49e3c9a19$var$boolean$1,
        prefix: null,
        property: null,
        results: $560639d49e3c9a19$var$number$1,
        security: null,
        unselectable: null
    }
});
var $560639d49e3c9a19$var$html_1 = $560639d49e3c9a19$var$merge_1([
    $560639d49e3c9a19$var$xml,
    $560639d49e3c9a19$var$xlink,
    $560639d49e3c9a19$var$xmlns,
    $560639d49e3c9a19$var$aria,
    $560639d49e3c9a19$var$html$2
]);
var $560639d49e3c9a19$var$boolean = $560639d49e3c9a19$var$types.boolean;
var $560639d49e3c9a19$var$number = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$commaSeparated = $560639d49e3c9a19$var$types.commaSeparated;
var $560639d49e3c9a19$var$commaOrSpaceSeparated = $560639d49e3c9a19$var$types.commaOrSpaceSeparated;
var $560639d49e3c9a19$var$svg = $560639d49e3c9a19$var$create_1({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: $560639d49e3c9a19$var$caseSensitiveTransform_1,
    properties: {
        about: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        accentHeight: $560639d49e3c9a19$var$number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: $560639d49e3c9a19$var$number,
        amplitude: $560639d49e3c9a19$var$number,
        arabicForm: null,
        ascent: $560639d49e3c9a19$var$number,
        attributeName: null,
        attributeType: null,
        azimuth: $560639d49e3c9a19$var$number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: $560639d49e3c9a19$var$number,
        by: null,
        calcMode: null,
        capHeight: $560639d49e3c9a19$var$number,
        className: $560639d49e3c9a19$var$spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: $560639d49e3c9a19$var$number,
        diffuseConstant: $560639d49e3c9a19$var$number,
        direction: null,
        display: null,
        dur: null,
        divisor: $560639d49e3c9a19$var$number,
        dominantBaseline: null,
        download: $560639d49e3c9a19$var$boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: $560639d49e3c9a19$var$number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: $560639d49e3c9a19$var$number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: $560639d49e3c9a19$var$number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: $560639d49e3c9a19$var$commaSeparated,
        g2: $560639d49e3c9a19$var$commaSeparated,
        glyphName: $560639d49e3c9a19$var$commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: $560639d49e3c9a19$var$number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: $560639d49e3c9a19$var$number,
        horizOriginX: $560639d49e3c9a19$var$number,
        horizOriginY: $560639d49e3c9a19$var$number,
        id: null,
        ideographic: $560639d49e3c9a19$var$number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: $560639d49e3c9a19$var$number,
        k: $560639d49e3c9a19$var$number,
        k1: $560639d49e3c9a19$var$number,
        k2: $560639d49e3c9a19$var$number,
        k3: $560639d49e3c9a19$var$number,
        k4: $560639d49e3c9a19$var$number,
        kernelMatrix: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: $560639d49e3c9a19$var$number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: $560639d49e3c9a19$var$number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: $560639d49e3c9a19$var$number,
        overlineThickness: $560639d49e3c9a19$var$number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: $560639d49e3c9a19$var$number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: $560639d49e3c9a19$var$spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: $560639d49e3c9a19$var$number,
        pointsAtY: $560639d49e3c9a19$var$number,
        pointsAtZ: $560639d49e3c9a19$var$number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        rev: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        requiredFeatures: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        requiredFonts: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        requiredFormats: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: $560639d49e3c9a19$var$number,
        specularExponent: $560639d49e3c9a19$var$number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: $560639d49e3c9a19$var$number,
        strikethroughThickness: $560639d49e3c9a19$var$number,
        string: null,
        stroke: null,
        strokeDashArray: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: $560639d49e3c9a19$var$number,
        strokeOpacity: $560639d49e3c9a19$var$number,
        strokeWidth: null,
        style: null,
        surfaceScale: $560639d49e3c9a19$var$number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        tabIndex: $560639d49e3c9a19$var$number,
        tableValues: null,
        target: null,
        targetX: $560639d49e3c9a19$var$number,
        targetY: $560639d49e3c9a19$var$number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: $560639d49e3c9a19$var$commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: $560639d49e3c9a19$var$number,
        underlineThickness: $560639d49e3c9a19$var$number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: $560639d49e3c9a19$var$number,
        values: null,
        vAlphabetic: $560639d49e3c9a19$var$number,
        vMathematical: $560639d49e3c9a19$var$number,
        vectorEffect: null,
        vHanging: $560639d49e3c9a19$var$number,
        vIdeographic: $560639d49e3c9a19$var$number,
        version: null,
        vertAdvY: $560639d49e3c9a19$var$number,
        vertOriginX: $560639d49e3c9a19$var$number,
        vertOriginY: $560639d49e3c9a19$var$number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: $560639d49e3c9a19$var$number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
});
var $560639d49e3c9a19$var$svg_1 = $560639d49e3c9a19$var$merge_1([
    $560639d49e3c9a19$var$xml,
    $560639d49e3c9a19$var$xlink,
    $560639d49e3c9a19$var$xmlns,
    $560639d49e3c9a19$var$aria,
    $560639d49e3c9a19$var$svg
]);
var $560639d49e3c9a19$var$index$2 = [
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
];
var $560639d49e3c9a19$var$htmlVoidElements = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $560639d49e3c9a19$var$index$2
});
var $560639d49e3c9a19$var$unistUtilIs = $560639d49e3c9a19$var$is;
// Assert if `test` passes for `node`.   When a `parent` node is known the
// `index` of node.
// eslint-disable-next-line max-params
function $560639d49e3c9a19$var$is(test, node, index, parent, context) {
    var hasParent = parent !== null && parent !== undefined;
    var hasIndex = index !== null && index !== undefined;
    var check = $560639d49e3c9a19$var$convert(test);
    if (hasIndex && (typeof index !== "number" || index < 0 || index === Infinity)) throw new Error("Expected positive finite index or child node");
    if (hasParent && (!$560639d49e3c9a19$var$is(null, parent) || !parent.children)) throw new Error("Expected parent node");
    if (!node || !node.type || typeof node.type !== "string") return false;
    if (hasParent !== hasIndex) throw new Error("Expected both parent and index");
    return Boolean(check.call(context, node, index, parent));
}
function $560639d49e3c9a19$var$convert(test) {
    if (typeof test === "string") return $560639d49e3c9a19$var$typeFactory(test);
    if (test === null || test === undefined) return $560639d49e3c9a19$var$ok;
    if (typeof test === "object") return ("length" in test ? $560639d49e3c9a19$var$anyFactory : $560639d49e3c9a19$var$matchesFactory)(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
function $560639d49e3c9a19$var$convertAll(tests) {
    var results = [];
    var length = tests.length;
    var index = -1;
    while(++index < length)results[index] = $560639d49e3c9a19$var$convert(tests[index]);
    return results;
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $560639d49e3c9a19$var$matchesFactory(test) {
    return matches;
    function matches(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $560639d49e3c9a19$var$anyFactory(tests) {
    var checks = $560639d49e3c9a19$var$convertAll(tests);
    var length = checks.length;
    return matches;
    function matches() {
        var index = -1;
        while(++index < length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $560639d49e3c9a19$var$typeFactory(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $560639d49e3c9a19$var$ok() {
    return true;
}
var $560639d49e3c9a19$var$hastUtilIsElement = $560639d49e3c9a19$var$isElement;
// Check if if `node` is an `element` and, if `tagNames` is given, `node`
// matches them `tagNames`.
function $560639d49e3c9a19$var$isElement(node, tagNames) {
    var name;
    if (!(tagNames === null || tagNames === undefined || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) throw new Error("Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`");
    if (!node || typeof node !== "object" || node.type !== "element" || typeof node.tagName !== "string") return false;
    if (tagNames === null || tagNames === undefined) return true;
    name = node.tagName;
    if (typeof tagNames === "string") return name === tagNames;
    return tagNames.indexOf(name) !== -1;
}
var $560639d49e3c9a19$var$hastUtilWhitespace = $560639d49e3c9a19$var$interElementWhiteSpace;
// HTML white-space expression.
// See <https://html.spec.whatwg.org/#space-character>.
var $560639d49e3c9a19$var$re = /[ \t\n\f\r]/g;
function $560639d49e3c9a19$var$interElementWhiteSpace(node) {
    var value;
    if (node && typeof node === "object" && node.type === "text") value = node.value || "";
    else if (typeof node === "string") value = node;
    else return false;
    return value.replace($560639d49e3c9a19$var$re, "") === "";
}
var $560639d49e3c9a19$var$before$1 = $560639d49e3c9a19$var$siblings(-1);
var $560639d49e3c9a19$var$after$2 = $560639d49e3c9a19$var$siblings(1);
/* Factory to check siblings in a direction. */ function $560639d49e3c9a19$var$siblings(increment) {
    return sibling;
    /* Find applicable siblings in a direction.   */ function sibling(parent, index, includeWhiteSpace) {
        var siblings = parent && parent.children;
        var next;
        index += increment;
        next = siblings && siblings[index];
        if (!includeWhiteSpace) while(next && $560639d49e3c9a19$var$hastUtilWhitespace(next)){
            index += increment;
            next = siblings[index];
        }
        return next;
    }
}
var $560639d49e3c9a19$var$siblings_1 = {
    before: $560639d49e3c9a19$var$before$1,
    after: $560639d49e3c9a19$var$after$2
};
var $560639d49e3c9a19$var$after$1 = $560639d49e3c9a19$var$siblings_1.after;
var $560639d49e3c9a19$var$first_1 = $560639d49e3c9a19$var$first;
/* Get the first child in `parent`. */ function $560639d49e3c9a19$var$first(parent, includeWhiteSpace) {
    return $560639d49e3c9a19$var$after$1(parent, -1, includeWhiteSpace);
}
var $560639d49e3c9a19$var$place_1 = $560639d49e3c9a19$var$place;
/* Get the position of `node` in `parent`. */ function $560639d49e3c9a19$var$place(parent, child) {
    return parent && parent.children && parent.children.indexOf(child);
}
var $560639d49e3c9a19$var$whiteSpaceLeft_1 = $560639d49e3c9a19$var$whiteSpaceLeft;
/* Check if `node` starts with white-space. */ function $560639d49e3c9a19$var$whiteSpaceLeft(node) {
    return $560639d49e3c9a19$var$unistUtilIs("text", node) && $560639d49e3c9a19$var$hastUtilWhitespace(node.value.charAt(0));
}
var $560639d49e3c9a19$var$omission_1 = $560639d49e3c9a19$var$omission$1;
var $560639d49e3c9a19$var$own$5 = {}.hasOwnProperty;
/* Factory to check if a given node can have a tag omitted. */ function $560639d49e3c9a19$var$omission$1(handlers) {
    return omit;
    /* Check if a given node can have a tag omitted.   */ function omit(node, index, parent) {
        var name = node.tagName;
        var fn = $560639d49e3c9a19$var$own$5.call(handlers, name) ? handlers[name] : false;
        return fn ? fn(node, index, parent) : false;
    }
}
var $560639d49e3c9a19$var$after = $560639d49e3c9a19$var$siblings_1.after;
var $560639d49e3c9a19$var$optionGroup = "optgroup";
var $560639d49e3c9a19$var$options = [
    "option"
].concat($560639d49e3c9a19$var$optionGroup);
var $560639d49e3c9a19$var$dataListItem = [
    "dt",
    "dd"
];
var $560639d49e3c9a19$var$listItem = "li";
var $560639d49e3c9a19$var$menuContent = [
    "menuitem",
    "hr",
    "menu"
];
var $560639d49e3c9a19$var$ruby = [
    "rp",
    "rt"
];
var $560639d49e3c9a19$var$tableContainer = [
    "tbody",
    "tfoot"
];
var $560639d49e3c9a19$var$tableRow$1 = "tr";
var $560639d49e3c9a19$var$tableCell = [
    "td",
    "th"
];
var $560639d49e3c9a19$var$confusingParagraphParent = [
    "a",
    "audio",
    "del",
    "ins",
    "map",
    "noscript",
    "video"
];
var $560639d49e3c9a19$var$clearParagraphSibling = [
    "address",
    "article",
    "aside",
    "blockquote",
    "details",
    "div",
    "dl",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "main",
    "menu",
    "nav",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
];
var $560639d49e3c9a19$var$closing$1 = $560639d49e3c9a19$var$omission_1({
    html: $560639d49e3c9a19$var$html$1,
    head: $560639d49e3c9a19$var$headOrColgroupOrCaption,
    body: $560639d49e3c9a19$var$body$1,
    p: $560639d49e3c9a19$var$p,
    li: $560639d49e3c9a19$var$li,
    dt: $560639d49e3c9a19$var$dt,
    dd: $560639d49e3c9a19$var$dd,
    rt: $560639d49e3c9a19$var$rubyElement,
    rp: $560639d49e3c9a19$var$rubyElement,
    optgroup: $560639d49e3c9a19$var$optgroup,
    option: $560639d49e3c9a19$var$option,
    menuitem: $560639d49e3c9a19$var$menuitem,
    colgroup: $560639d49e3c9a19$var$headOrColgroupOrCaption,
    caption: $560639d49e3c9a19$var$headOrColgroupOrCaption,
    thead: $560639d49e3c9a19$var$thead,
    tbody: $560639d49e3c9a19$var$tbody$1,
    tfoot: $560639d49e3c9a19$var$tfoot,
    tr: $560639d49e3c9a19$var$tr,
    td: $560639d49e3c9a19$var$cells,
    th: $560639d49e3c9a19$var$cells
});
/* Macro for `</head>`, `</colgroup>`, and `</caption>`. */ function $560639d49e3c9a19$var$headOrColgroupOrCaption(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index, true);
    return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next) && !$560639d49e3c9a19$var$whiteSpaceLeft_1(next);
}
/* Whether to omit `</html>`. */ function $560639d49e3c9a19$var$html$1(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next);
}
/* Whether to omit `</body>`. */ function $560639d49e3c9a19$var$body$1(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next);
}
/* Whether to omit `</p>`. */ function $560639d49e3c9a19$var$p(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return next ? $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$clearParagraphSibling) : !parent || !$560639d49e3c9a19$var$hastUtilIsElement(parent, $560639d49e3c9a19$var$confusingParagraphParent);
}
/* Whether to omit `</li>`. */ function $560639d49e3c9a19$var$li(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$listItem);
}
/* Whether to omit `</dt>`. */ function $560639d49e3c9a19$var$dt(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return next && $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$dataListItem);
}
/* Whether to omit `</dd>`. */ function $560639d49e3c9a19$var$dd(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$dataListItem);
}
/* Whether to omit `</rt>` or `</rp>`. */ function $560639d49e3c9a19$var$rubyElement(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$ruby);
}
/* Whether to omit `</optgroup>`. */ function $560639d49e3c9a19$var$optgroup(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$optionGroup);
}
/* Whether to omit `</option>`. */ function $560639d49e3c9a19$var$option(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$options);
}
/* Whether to omit `</menuitem>`. */ function $560639d49e3c9a19$var$menuitem(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$menuContent);
}
/* Whether to omit `</thead>`. */ function $560639d49e3c9a19$var$thead(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return next && $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableContainer);
}
/* Whether to omit `</tbody>`. */ function $560639d49e3c9a19$var$tbody$1(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableContainer);
}
/* Whether to omit `</tfoot>`. */ function $560639d49e3c9a19$var$tfoot(node, index, parent) {
    return !$560639d49e3c9a19$var$after(parent, index);
}
/* Whether to omit `</tr>`. */ function $560639d49e3c9a19$var$tr(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableRow$1);
}
/* Whether to omit `</td>` or `</th>`. */ function $560639d49e3c9a19$var$cells(node, index, parent) {
    var next = $560639d49e3c9a19$var$after(parent, index);
    return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableCell);
}
var $560639d49e3c9a19$var$before = $560639d49e3c9a19$var$siblings_1.before;
var $560639d49e3c9a19$var$own$4 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$uniqueHeadMetadata = [
    "title",
    "base"
];
var $560639d49e3c9a19$var$meta = [
    "meta",
    "link",
    "script",
    "style",
    "template"
];
var $560639d49e3c9a19$var$tableContainers = [
    "thead",
    "tbody"
];
var $560639d49e3c9a19$var$tableRow = "tr";
var $560639d49e3c9a19$var$opening$1 = $560639d49e3c9a19$var$omission_1({
    html: $560639d49e3c9a19$var$html,
    head: $560639d49e3c9a19$var$head,
    body: $560639d49e3c9a19$var$body,
    colgroup: $560639d49e3c9a19$var$colgroup,
    tbody: $560639d49e3c9a19$var$tbody
});
/* Whether to omit `<html>`. */ function $560639d49e3c9a19$var$html(node) {
    var head = $560639d49e3c9a19$var$first_1(node);
    return !head || !$560639d49e3c9a19$var$unistUtilIs("comment", head);
}
/* Whether to omit `<head>`. */ function $560639d49e3c9a19$var$head(node) {
    var children = node.children;
    var length = children.length;
    var map = {};
    var index = -1;
    var child;
    var name;
    while(++index < length){
        child = children[index];
        name = child.tagName;
        if ($560639d49e3c9a19$var$hastUtilIsElement(child, $560639d49e3c9a19$var$uniqueHeadMetadata)) {
            if ($560639d49e3c9a19$var$own$4.call(map, name)) return false;
            map[name] = true;
        }
    }
    return Boolean(length);
}
/* Whether to omit `<body>`. */ function $560639d49e3c9a19$var$body(node) {
    var head = $560639d49e3c9a19$var$first_1(node, true);
    return !head || !$560639d49e3c9a19$var$unistUtilIs("comment", head) && !$560639d49e3c9a19$var$whiteSpaceLeft_1(head) && !$560639d49e3c9a19$var$hastUtilIsElement(head, $560639d49e3c9a19$var$meta);
}
/* Whether to omit `<colgroup>`.
 * The spec describes some logic for the opening tag,
 * but it’s easier to implement in the closing tag, to
 * the same effect, so we handle it there instead. */ function $560639d49e3c9a19$var$colgroup(node, index, parent) {
    var prev = $560639d49e3c9a19$var$before(parent, index);
    var head = $560639d49e3c9a19$var$first_1(node, true);
    /* Previous colgroup was already omitted. */ if ($560639d49e3c9a19$var$hastUtilIsElement(prev, "colgroup") && $560639d49e3c9a19$var$closing$1(prev, $560639d49e3c9a19$var$place_1(parent, prev), parent)) return false;
    return head && $560639d49e3c9a19$var$hastUtilIsElement(head, "col");
}
/* Whether to omit `<tbody>`. */ function $560639d49e3c9a19$var$tbody(node, index, parent) {
    var prev = $560639d49e3c9a19$var$before(parent, index);
    var head = $560639d49e3c9a19$var$first_1(node);
    /* Previous table section was already omitted. */ if ($560639d49e3c9a19$var$hastUtilIsElement(prev, $560639d49e3c9a19$var$tableContainers) && $560639d49e3c9a19$var$closing$1(prev, $560639d49e3c9a19$var$place_1(parent, prev), parent)) return false;
    return head && $560639d49e3c9a19$var$hastUtilIsElement(head, $560639d49e3c9a19$var$tableRow);
}
var $560639d49e3c9a19$var$opening = $560639d49e3c9a19$var$opening$1;
var $560639d49e3c9a19$var$closing = $560639d49e3c9a19$var$closing$1;
var $560639d49e3c9a19$var$omission = {
    opening: $560639d49e3c9a19$var$opening,
    closing: $560639d49e3c9a19$var$closing
};
var $560639d49e3c9a19$var$index$1 = [
    "script",
    "style",
    "pre",
    "textarea"
];
var $560639d49e3c9a19$var$htmlWhitespaceSensitiveTagNames = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $560639d49e3c9a19$var$index$1
});
var $560639d49e3c9a19$var$sensitive = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$htmlWhitespaceSensitiveTagNames);
var $560639d49e3c9a19$var$all_1 = $560639d49e3c9a19$var$all$1;
/* Stringify all children of `parent`. */ function $560639d49e3c9a19$var$all$1(ctx, parent) {
    var children = parent && parent.children;
    var length = children && children.length;
    var index = -1;
    var results = [];
    let printWidthOffset = 0;
    let innerTextLength = 0;
    while(++index < length){
        innerTextLength = $560639d49e3c9a19$var$getInnerTextLength(children[index]);
        results[index] = $560639d49e3c9a19$var$one_1(ctx, children[index], index, parent, printWidthOffset, innerTextLength);
        printWidthOffset = results[index].replace(/\n+/g, "").length;
    }
    return results.join("");
}
/**
 * Returns the text lenght of the first line of the first child.
 * Whitespace sensitive elements are ignored.
 * @param {*} node
 */ function $560639d49e3c9a19$var$getInnerTextLength(node) {
    // ignore style, script, pre, textarea elements
    if ($560639d49e3c9a19$var$sensitive.indexOf(node.tagName) !== -1) return 0;
    if (!node.children || !node.children.length) return 0;
    var child = node.children[0];
    if (child.type === "text" || child.type === "comment") return child.value.split("\n")[0].length;
    return 0;
}
var $560639d49e3c9a19$var$text_1 = $560639d49e3c9a19$var$text;
/* Stringify `text`. */ function $560639d49e3c9a19$var$text(ctx, node, index, parent) {
    var value = node.value;
    return value;
}
var $560639d49e3c9a19$var$data = "data";
var $560639d49e3c9a19$var$find_1 = $560639d49e3c9a19$var$find;
var $560639d49e3c9a19$var$valid = /^data[-\w.:]+$/i;
var $560639d49e3c9a19$var$dash = /-[a-z]/g;
var $560639d49e3c9a19$var$cap$1 = /[A-Z]/g;
function $560639d49e3c9a19$var$find(schema, value) {
    var normal = $560639d49e3c9a19$var$normalize_1(value);
    var prop = value;
    var Type = $560639d49e3c9a19$var$info;
    if (normal in schema.normal) return schema.property[schema.normal[normal]];
    if (normal.length > 4 && normal.slice(0, 4) === $560639d49e3c9a19$var$data && $560639d49e3c9a19$var$valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === "-") prop = $560639d49e3c9a19$var$datasetToProperty(value);
        else value = $560639d49e3c9a19$var$datasetToAttribute(value);
        Type = $560639d49e3c9a19$var$definedInfo;
    }
    return new Type(prop, value);
}
function $560639d49e3c9a19$var$datasetToProperty(attribute) {
    var value = attribute.slice(5).replace($560639d49e3c9a19$var$dash, $560639d49e3c9a19$var$camelcase);
    return $560639d49e3c9a19$var$data + value.charAt(0).toUpperCase() + value.slice(1);
}
function $560639d49e3c9a19$var$datasetToAttribute(property) {
    var value = property.slice(4);
    if ($560639d49e3c9a19$var$dash.test(value)) return property;
    value = value.replace($560639d49e3c9a19$var$cap$1, $560639d49e3c9a19$var$kebab);
    if (value.charAt(0) !== "-") value = "-" + value;
    return $560639d49e3c9a19$var$data + value;
}
function $560639d49e3c9a19$var$kebab($0) {
    return "-" + $0.toLowerCase();
}
function $560639d49e3c9a19$var$camelcase($0) {
    return $0.charAt(1).toUpperCase();
}
var $560639d49e3c9a19$var$parse_1 = $560639d49e3c9a19$var$parse$2;
var $560639d49e3c9a19$var$stringify_1 = $560639d49e3c9a19$var$stringify$2;
var $560639d49e3c9a19$var$comma = ",";
var $560639d49e3c9a19$var$space$2 = " ";
var $560639d49e3c9a19$var$empty$1 = "";
// Parse comma-separated tokens to an array.
function $560639d49e3c9a19$var$parse$2(value) {
    var values = [];
    var input = String(value || $560639d49e3c9a19$var$empty$1);
    var index = input.indexOf($560639d49e3c9a19$var$comma);
    var lastIndex = 0;
    var end = false;
    var val;
    while(!end){
        if (index === -1) {
            index = input.length;
            end = true;
        }
        val = input.slice(lastIndex, index).trim();
        if (val || !end) values.push(val);
        lastIndex = index + 1;
        index = input.indexOf($560639d49e3c9a19$var$comma, lastIndex);
    }
    return values;
}
// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function $560639d49e3c9a19$var$stringify$2(values, options) {
    var settings = options || {};
    var left = settings.padLeft === false ? $560639d49e3c9a19$var$empty$1 : $560639d49e3c9a19$var$space$2;
    var right = settings.padRight ? $560639d49e3c9a19$var$space$2 : $560639d49e3c9a19$var$empty$1;
    // Ensure the last empty entry is seen.
    if (values[values.length - 1] === $560639d49e3c9a19$var$empty$1) values = values.concat($560639d49e3c9a19$var$empty$1);
    return values.join(right + $560639d49e3c9a19$var$comma + left).trim();
}
var $560639d49e3c9a19$var$commaSeparatedTokens = {
    parse: $560639d49e3c9a19$var$parse_1,
    stringify: $560639d49e3c9a19$var$stringify_1
};
var $560639d49e3c9a19$var$nbsp = "\xa0";
var $560639d49e3c9a19$var$iexcl = "\xa1";
var $560639d49e3c9a19$var$cent = "\xa2";
var $560639d49e3c9a19$var$pound = "\xa3";
var $560639d49e3c9a19$var$curren = "\xa4";
var $560639d49e3c9a19$var$yen = "\xa5";
var $560639d49e3c9a19$var$brvbar = "\xa6";
var $560639d49e3c9a19$var$sect = "\xa7";
var $560639d49e3c9a19$var$uml = "\xa8";
var $560639d49e3c9a19$var$copy = "\xa9";
var $560639d49e3c9a19$var$ordf = "\xaa";
var $560639d49e3c9a19$var$laquo = "\xab";
var $560639d49e3c9a19$var$not = "\xac";
var $560639d49e3c9a19$var$shy = "\xad";
var $560639d49e3c9a19$var$reg = "\xae";
var $560639d49e3c9a19$var$macr = "\xaf";
var $560639d49e3c9a19$var$deg = "\xb0";
var $560639d49e3c9a19$var$plusmn = "\xb1";
var $560639d49e3c9a19$var$sup2 = "\xb2";
var $560639d49e3c9a19$var$sup3 = "\xb3";
var $560639d49e3c9a19$var$acute = "\xb4";
var $560639d49e3c9a19$var$micro = "\xb5";
var $560639d49e3c9a19$var$para = "\xb6";
var $560639d49e3c9a19$var$middot = "\xb7";
var $560639d49e3c9a19$var$cedil = "\xb8";
var $560639d49e3c9a19$var$sup1 = "\xb9";
var $560639d49e3c9a19$var$ordm = "\xba";
var $560639d49e3c9a19$var$raquo = "\xbb";
var $560639d49e3c9a19$var$frac14 = "\xbc";
var $560639d49e3c9a19$var$frac12 = "\xbd";
var $560639d49e3c9a19$var$frac34 = "\xbe";
var $560639d49e3c9a19$var$iquest = "\xbf";
var $560639d49e3c9a19$var$Agrave = "\xc0";
var $560639d49e3c9a19$var$Aacute = "\xc1";
var $560639d49e3c9a19$var$Acirc = "\xc2";
var $560639d49e3c9a19$var$Atilde = "\xc3";
var $560639d49e3c9a19$var$Auml = "\xc4";
var $560639d49e3c9a19$var$Aring = "\xc5";
var $560639d49e3c9a19$var$AElig = "\xc6";
var $560639d49e3c9a19$var$Ccedil = "\xc7";
var $560639d49e3c9a19$var$Egrave = "\xc8";
var $560639d49e3c9a19$var$Eacute = "\xc9";
var $560639d49e3c9a19$var$Ecirc = "\xca";
var $560639d49e3c9a19$var$Euml = "\xcb";
var $560639d49e3c9a19$var$Igrave = "\xcc";
var $560639d49e3c9a19$var$Iacute = "\xcd";
var $560639d49e3c9a19$var$Icirc = "\xce";
var $560639d49e3c9a19$var$Iuml = "\xcf";
var $560639d49e3c9a19$var$ETH = "\xd0";
var $560639d49e3c9a19$var$Ntilde = "\xd1";
var $560639d49e3c9a19$var$Ograve = "\xd2";
var $560639d49e3c9a19$var$Oacute = "\xd3";
var $560639d49e3c9a19$var$Ocirc = "\xd4";
var $560639d49e3c9a19$var$Otilde = "\xd5";
var $560639d49e3c9a19$var$Ouml = "\xd6";
var $560639d49e3c9a19$var$times = "\xd7";
var $560639d49e3c9a19$var$Oslash = "\xd8";
var $560639d49e3c9a19$var$Ugrave = "\xd9";
var $560639d49e3c9a19$var$Uacute = "\xda";
var $560639d49e3c9a19$var$Ucirc = "\xdb";
var $560639d49e3c9a19$var$Uuml = "\xdc";
var $560639d49e3c9a19$var$Yacute = "\xdd";
var $560639d49e3c9a19$var$THORN = "\xde";
var $560639d49e3c9a19$var$szlig = "\xdf";
var $560639d49e3c9a19$var$agrave = "\xe0";
var $560639d49e3c9a19$var$aacute = "\xe1";
var $560639d49e3c9a19$var$acirc = "\xe2";
var $560639d49e3c9a19$var$atilde = "\xe3";
var $560639d49e3c9a19$var$auml = "\xe4";
var $560639d49e3c9a19$var$aring = "\xe5";
var $560639d49e3c9a19$var$aelig = "\xe6";
var $560639d49e3c9a19$var$ccedil = "\xe7";
var $560639d49e3c9a19$var$egrave = "\xe8";
var $560639d49e3c9a19$var$eacute = "\xe9";
var $560639d49e3c9a19$var$ecirc = "\xea";
var $560639d49e3c9a19$var$euml = "\xeb";
var $560639d49e3c9a19$var$igrave = "\xec";
var $560639d49e3c9a19$var$iacute = "\xed";
var $560639d49e3c9a19$var$icirc = "\xee";
var $560639d49e3c9a19$var$iuml = "\xef";
var $560639d49e3c9a19$var$eth = "\xf0";
var $560639d49e3c9a19$var$ntilde = "\xf1";
var $560639d49e3c9a19$var$ograve = "\xf2";
var $560639d49e3c9a19$var$oacute = "\xf3";
var $560639d49e3c9a19$var$ocirc = "\xf4";
var $560639d49e3c9a19$var$otilde = "\xf5";
var $560639d49e3c9a19$var$ouml = "\xf6";
var $560639d49e3c9a19$var$divide = "\xf7";
var $560639d49e3c9a19$var$oslash = "\xf8";
var $560639d49e3c9a19$var$ugrave = "\xf9";
var $560639d49e3c9a19$var$uacute = "\xfa";
var $560639d49e3c9a19$var$ucirc = "\xfb";
var $560639d49e3c9a19$var$uuml = "\xfc";
var $560639d49e3c9a19$var$yacute = "\xfd";
var $560639d49e3c9a19$var$thorn = "\xfe";
var $560639d49e3c9a19$var$yuml = "\xff";
var $560639d49e3c9a19$var$fnof = "\u0192";
var $560639d49e3c9a19$var$Alpha = "\u0391";
var $560639d49e3c9a19$var$Beta = "\u0392";
var $560639d49e3c9a19$var$Gamma = "\u0393";
var $560639d49e3c9a19$var$Delta = "\u0394";
var $560639d49e3c9a19$var$Epsilon = "\u0395";
var $560639d49e3c9a19$var$Zeta = "\u0396";
var $560639d49e3c9a19$var$Eta = "\u0397";
var $560639d49e3c9a19$var$Theta = "\u0398";
var $560639d49e3c9a19$var$Iota = "\u0399";
var $560639d49e3c9a19$var$Kappa = "\u039A";
var $560639d49e3c9a19$var$Lambda = "\u039B";
var $560639d49e3c9a19$var$Mu = "\u039C";
var $560639d49e3c9a19$var$Nu = "\u039D";
var $560639d49e3c9a19$var$Xi = "\u039E";
var $560639d49e3c9a19$var$Omicron = "\u039F";
var $560639d49e3c9a19$var$Pi = "\u03A0";
var $560639d49e3c9a19$var$Rho = "\u03A1";
var $560639d49e3c9a19$var$Sigma = "\u03A3";
var $560639d49e3c9a19$var$Tau = "\u03A4";
var $560639d49e3c9a19$var$Upsilon = "\u03A5";
var $560639d49e3c9a19$var$Phi = "\u03A6";
var $560639d49e3c9a19$var$Chi = "\u03A7";
var $560639d49e3c9a19$var$Psi = "\u03A8";
var $560639d49e3c9a19$var$Omega = "\u03A9";
var $560639d49e3c9a19$var$alpha = "\u03B1";
var $560639d49e3c9a19$var$beta = "\u03B2";
var $560639d49e3c9a19$var$gamma = "\u03B3";
var $560639d49e3c9a19$var$delta = "\u03B4";
var $560639d49e3c9a19$var$epsilon = "\u03B5";
var $560639d49e3c9a19$var$zeta = "\u03B6";
var $560639d49e3c9a19$var$eta = "\u03B7";
var $560639d49e3c9a19$var$theta = "\u03B8";
var $560639d49e3c9a19$var$iota = "\u03B9";
var $560639d49e3c9a19$var$kappa = "\u03BA";
var $560639d49e3c9a19$var$lambda = "\u03BB";
var $560639d49e3c9a19$var$mu = "\u03BC";
var $560639d49e3c9a19$var$nu = "\u03BD";
var $560639d49e3c9a19$var$xi = "\u03BE";
var $560639d49e3c9a19$var$omicron = "\u03BF";
var $560639d49e3c9a19$var$pi = "\u03C0";
var $560639d49e3c9a19$var$rho = "\u03C1";
var $560639d49e3c9a19$var$sigmaf = "\u03C2";
var $560639d49e3c9a19$var$sigma = "\u03C3";
var $560639d49e3c9a19$var$tau = "\u03C4";
var $560639d49e3c9a19$var$upsilon = "\u03C5";
var $560639d49e3c9a19$var$phi = "\u03C6";
var $560639d49e3c9a19$var$chi = "\u03C7";
var $560639d49e3c9a19$var$psi = "\u03C8";
var $560639d49e3c9a19$var$omega = "\u03C9";
var $560639d49e3c9a19$var$thetasym = "\u03D1";
var $560639d49e3c9a19$var$upsih = "\u03D2";
var $560639d49e3c9a19$var$piv = "\u03D6";
var $560639d49e3c9a19$var$bull = "\u2022";
var $560639d49e3c9a19$var$hellip = "\u2026";
var $560639d49e3c9a19$var$prime = "\u2032";
var $560639d49e3c9a19$var$Prime = "\u2033";
var $560639d49e3c9a19$var$oline = "\u203E";
var $560639d49e3c9a19$var$frasl = "\u2044";
var $560639d49e3c9a19$var$weierp = "\u2118";
var $560639d49e3c9a19$var$image = "\u2111";
var $560639d49e3c9a19$var$real = "\u211C";
var $560639d49e3c9a19$var$trade = "\u2122";
var $560639d49e3c9a19$var$alefsym = "\u2135";
var $560639d49e3c9a19$var$larr = "\u2190";
var $560639d49e3c9a19$var$uarr = "\u2191";
var $560639d49e3c9a19$var$rarr = "\u2192";
var $560639d49e3c9a19$var$darr = "\u2193";
var $560639d49e3c9a19$var$harr = "\u2194";
var $560639d49e3c9a19$var$crarr = "\u21B5";
var $560639d49e3c9a19$var$lArr = "\u21D0";
var $560639d49e3c9a19$var$uArr = "\u21D1";
var $560639d49e3c9a19$var$rArr = "\u21D2";
var $560639d49e3c9a19$var$dArr = "\u21D3";
var $560639d49e3c9a19$var$hArr = "\u21D4";
var $560639d49e3c9a19$var$forall = "\u2200";
var $560639d49e3c9a19$var$part = "\u2202";
var $560639d49e3c9a19$var$exist = "\u2203";
var $560639d49e3c9a19$var$empty = "\u2205";
var $560639d49e3c9a19$var$nabla = "\u2207";
var $560639d49e3c9a19$var$isin = "\u2208";
var $560639d49e3c9a19$var$notin = "\u2209";
var $560639d49e3c9a19$var$ni = "\u220B";
var $560639d49e3c9a19$var$prod = "\u220F";
var $560639d49e3c9a19$var$sum = "\u2211";
var $560639d49e3c9a19$var$minus = "\u2212";
var $560639d49e3c9a19$var$lowast = "\u2217";
var $560639d49e3c9a19$var$radic = "\u221A";
var $560639d49e3c9a19$var$prop = "\u221D";
var $560639d49e3c9a19$var$infin = "\u221E";
var $560639d49e3c9a19$var$ang = "\u2220";
var $560639d49e3c9a19$var$and = "\u2227";
var $560639d49e3c9a19$var$or = "\u2228";
var $560639d49e3c9a19$var$cap = "\u2229";
var $560639d49e3c9a19$var$cup = "\u222A";
var $560639d49e3c9a19$var$int = "\u222B";
var $560639d49e3c9a19$var$there4 = "\u2234";
var $560639d49e3c9a19$var$sim = "\u223C";
var $560639d49e3c9a19$var$cong = "\u2245";
var $560639d49e3c9a19$var$asymp = "\u2248";
var $560639d49e3c9a19$var$ne = "\u2260";
var $560639d49e3c9a19$var$equiv = "\u2261";
var $560639d49e3c9a19$var$le = "\u2264";
var $560639d49e3c9a19$var$ge = "\u2265";
var $560639d49e3c9a19$var$sub = "\u2282";
var $560639d49e3c9a19$var$sup = "\u2283";
var $560639d49e3c9a19$var$nsub = "\u2284";
var $560639d49e3c9a19$var$sube = "\u2286";
var $560639d49e3c9a19$var$supe = "\u2287";
var $560639d49e3c9a19$var$oplus = "\u2295";
var $560639d49e3c9a19$var$otimes = "\u2297";
var $560639d49e3c9a19$var$perp = "\u22A5";
var $560639d49e3c9a19$var$sdot = "\u22C5";
var $560639d49e3c9a19$var$lceil = "\u2308";
var $560639d49e3c9a19$var$rceil = "\u2309";
var $560639d49e3c9a19$var$lfloor = "\u230A";
var $560639d49e3c9a19$var$rfloor = "\u230B";
var $560639d49e3c9a19$var$lang = "\u2329";
var $560639d49e3c9a19$var$rang = "\u232A";
var $560639d49e3c9a19$var$loz = "\u25CA";
var $560639d49e3c9a19$var$spades = "\u2660";
var $560639d49e3c9a19$var$clubs = "\u2663";
var $560639d49e3c9a19$var$hearts = "\u2665";
var $560639d49e3c9a19$var$diams = "\u2666";
var $560639d49e3c9a19$var$quot = '"';
var $560639d49e3c9a19$var$amp = "&";
var $560639d49e3c9a19$var$lt = "<";
var $560639d49e3c9a19$var$gt = ">";
var $560639d49e3c9a19$var$OElig = "\u0152";
var $560639d49e3c9a19$var$oelig = "\u0153";
var $560639d49e3c9a19$var$Scaron = "\u0160";
var $560639d49e3c9a19$var$scaron = "\u0161";
var $560639d49e3c9a19$var$Yuml = "\u0178";
var $560639d49e3c9a19$var$circ = "\u02C6";
var $560639d49e3c9a19$var$tilde = "\u02DC";
var $560639d49e3c9a19$var$ensp = "\u2002";
var $560639d49e3c9a19$var$emsp = "\u2003";
var $560639d49e3c9a19$var$thinsp = "\u2009";
var $560639d49e3c9a19$var$zwnj = "\u200C";
var $560639d49e3c9a19$var$zwj = "\u200D";
var $560639d49e3c9a19$var$lrm = "\u200E";
var $560639d49e3c9a19$var$rlm = "\u200F";
var $560639d49e3c9a19$var$ndash = "\u2013";
var $560639d49e3c9a19$var$mdash = "\u2014";
var $560639d49e3c9a19$var$lsquo = "\u2018";
var $560639d49e3c9a19$var$rsquo = "\u2019";
var $560639d49e3c9a19$var$sbquo = "\u201A";
var $560639d49e3c9a19$var$ldquo = "\u201C";
var $560639d49e3c9a19$var$rdquo = "\u201D";
var $560639d49e3c9a19$var$bdquo = "\u201E";
var $560639d49e3c9a19$var$dagger = "\u2020";
var $560639d49e3c9a19$var$Dagger = "\u2021";
var $560639d49e3c9a19$var$permil = "\u2030";
var $560639d49e3c9a19$var$lsaquo = "\u2039";
var $560639d49e3c9a19$var$rsaquo = "\u203A";
var $560639d49e3c9a19$var$euro = "\u20AC";
var $560639d49e3c9a19$var$index = {
    nbsp: $560639d49e3c9a19$var$nbsp,
    iexcl: $560639d49e3c9a19$var$iexcl,
    cent: $560639d49e3c9a19$var$cent,
    pound: $560639d49e3c9a19$var$pound,
    curren: $560639d49e3c9a19$var$curren,
    yen: $560639d49e3c9a19$var$yen,
    brvbar: $560639d49e3c9a19$var$brvbar,
    sect: $560639d49e3c9a19$var$sect,
    uml: $560639d49e3c9a19$var$uml,
    copy: $560639d49e3c9a19$var$copy,
    ordf: $560639d49e3c9a19$var$ordf,
    laquo: $560639d49e3c9a19$var$laquo,
    not: $560639d49e3c9a19$var$not,
    shy: $560639d49e3c9a19$var$shy,
    reg: $560639d49e3c9a19$var$reg,
    macr: $560639d49e3c9a19$var$macr,
    deg: $560639d49e3c9a19$var$deg,
    plusmn: $560639d49e3c9a19$var$plusmn,
    sup2: $560639d49e3c9a19$var$sup2,
    sup3: $560639d49e3c9a19$var$sup3,
    acute: $560639d49e3c9a19$var$acute,
    micro: $560639d49e3c9a19$var$micro,
    para: $560639d49e3c9a19$var$para,
    middot: $560639d49e3c9a19$var$middot,
    cedil: $560639d49e3c9a19$var$cedil,
    sup1: $560639d49e3c9a19$var$sup1,
    ordm: $560639d49e3c9a19$var$ordm,
    raquo: $560639d49e3c9a19$var$raquo,
    frac14: $560639d49e3c9a19$var$frac14,
    frac12: $560639d49e3c9a19$var$frac12,
    frac34: $560639d49e3c9a19$var$frac34,
    iquest: $560639d49e3c9a19$var$iquest,
    Agrave: $560639d49e3c9a19$var$Agrave,
    Aacute: $560639d49e3c9a19$var$Aacute,
    Acirc: $560639d49e3c9a19$var$Acirc,
    Atilde: $560639d49e3c9a19$var$Atilde,
    Auml: $560639d49e3c9a19$var$Auml,
    Aring: $560639d49e3c9a19$var$Aring,
    AElig: $560639d49e3c9a19$var$AElig,
    Ccedil: $560639d49e3c9a19$var$Ccedil,
    Egrave: $560639d49e3c9a19$var$Egrave,
    Eacute: $560639d49e3c9a19$var$Eacute,
    Ecirc: $560639d49e3c9a19$var$Ecirc,
    Euml: $560639d49e3c9a19$var$Euml,
    Igrave: $560639d49e3c9a19$var$Igrave,
    Iacute: $560639d49e3c9a19$var$Iacute,
    Icirc: $560639d49e3c9a19$var$Icirc,
    Iuml: $560639d49e3c9a19$var$Iuml,
    ETH: $560639d49e3c9a19$var$ETH,
    Ntilde: $560639d49e3c9a19$var$Ntilde,
    Ograve: $560639d49e3c9a19$var$Ograve,
    Oacute: $560639d49e3c9a19$var$Oacute,
    Ocirc: $560639d49e3c9a19$var$Ocirc,
    Otilde: $560639d49e3c9a19$var$Otilde,
    Ouml: $560639d49e3c9a19$var$Ouml,
    times: $560639d49e3c9a19$var$times,
    Oslash: $560639d49e3c9a19$var$Oslash,
    Ugrave: $560639d49e3c9a19$var$Ugrave,
    Uacute: $560639d49e3c9a19$var$Uacute,
    Ucirc: $560639d49e3c9a19$var$Ucirc,
    Uuml: $560639d49e3c9a19$var$Uuml,
    Yacute: $560639d49e3c9a19$var$Yacute,
    THORN: $560639d49e3c9a19$var$THORN,
    szlig: $560639d49e3c9a19$var$szlig,
    agrave: $560639d49e3c9a19$var$agrave,
    aacute: $560639d49e3c9a19$var$aacute,
    acirc: $560639d49e3c9a19$var$acirc,
    atilde: $560639d49e3c9a19$var$atilde,
    auml: $560639d49e3c9a19$var$auml,
    aring: $560639d49e3c9a19$var$aring,
    aelig: $560639d49e3c9a19$var$aelig,
    ccedil: $560639d49e3c9a19$var$ccedil,
    egrave: $560639d49e3c9a19$var$egrave,
    eacute: $560639d49e3c9a19$var$eacute,
    ecirc: $560639d49e3c9a19$var$ecirc,
    euml: $560639d49e3c9a19$var$euml,
    igrave: $560639d49e3c9a19$var$igrave,
    iacute: $560639d49e3c9a19$var$iacute,
    icirc: $560639d49e3c9a19$var$icirc,
    iuml: $560639d49e3c9a19$var$iuml,
    eth: $560639d49e3c9a19$var$eth,
    ntilde: $560639d49e3c9a19$var$ntilde,
    ograve: $560639d49e3c9a19$var$ograve,
    oacute: $560639d49e3c9a19$var$oacute,
    ocirc: $560639d49e3c9a19$var$ocirc,
    otilde: $560639d49e3c9a19$var$otilde,
    ouml: $560639d49e3c9a19$var$ouml,
    divide: $560639d49e3c9a19$var$divide,
    oslash: $560639d49e3c9a19$var$oslash,
    ugrave: $560639d49e3c9a19$var$ugrave,
    uacute: $560639d49e3c9a19$var$uacute,
    ucirc: $560639d49e3c9a19$var$ucirc,
    uuml: $560639d49e3c9a19$var$uuml,
    yacute: $560639d49e3c9a19$var$yacute,
    thorn: $560639d49e3c9a19$var$thorn,
    yuml: $560639d49e3c9a19$var$yuml,
    fnof: $560639d49e3c9a19$var$fnof,
    Alpha: $560639d49e3c9a19$var$Alpha,
    Beta: $560639d49e3c9a19$var$Beta,
    Gamma: $560639d49e3c9a19$var$Gamma,
    Delta: $560639d49e3c9a19$var$Delta,
    Epsilon: $560639d49e3c9a19$var$Epsilon,
    Zeta: $560639d49e3c9a19$var$Zeta,
    Eta: $560639d49e3c9a19$var$Eta,
    Theta: $560639d49e3c9a19$var$Theta,
    Iota: $560639d49e3c9a19$var$Iota,
    Kappa: $560639d49e3c9a19$var$Kappa,
    Lambda: $560639d49e3c9a19$var$Lambda,
    Mu: $560639d49e3c9a19$var$Mu,
    Nu: $560639d49e3c9a19$var$Nu,
    Xi: $560639d49e3c9a19$var$Xi,
    Omicron: $560639d49e3c9a19$var$Omicron,
    Pi: $560639d49e3c9a19$var$Pi,
    Rho: $560639d49e3c9a19$var$Rho,
    Sigma: $560639d49e3c9a19$var$Sigma,
    Tau: $560639d49e3c9a19$var$Tau,
    Upsilon: $560639d49e3c9a19$var$Upsilon,
    Phi: $560639d49e3c9a19$var$Phi,
    Chi: $560639d49e3c9a19$var$Chi,
    Psi: $560639d49e3c9a19$var$Psi,
    Omega: $560639d49e3c9a19$var$Omega,
    alpha: $560639d49e3c9a19$var$alpha,
    beta: $560639d49e3c9a19$var$beta,
    gamma: $560639d49e3c9a19$var$gamma,
    delta: $560639d49e3c9a19$var$delta,
    epsilon: $560639d49e3c9a19$var$epsilon,
    zeta: $560639d49e3c9a19$var$zeta,
    eta: $560639d49e3c9a19$var$eta,
    theta: $560639d49e3c9a19$var$theta,
    iota: $560639d49e3c9a19$var$iota,
    kappa: $560639d49e3c9a19$var$kappa,
    lambda: $560639d49e3c9a19$var$lambda,
    mu: $560639d49e3c9a19$var$mu,
    nu: $560639d49e3c9a19$var$nu,
    xi: $560639d49e3c9a19$var$xi,
    omicron: $560639d49e3c9a19$var$omicron,
    pi: $560639d49e3c9a19$var$pi,
    rho: $560639d49e3c9a19$var$rho,
    sigmaf: $560639d49e3c9a19$var$sigmaf,
    sigma: $560639d49e3c9a19$var$sigma,
    tau: $560639d49e3c9a19$var$tau,
    upsilon: $560639d49e3c9a19$var$upsilon,
    phi: $560639d49e3c9a19$var$phi,
    chi: $560639d49e3c9a19$var$chi,
    psi: $560639d49e3c9a19$var$psi,
    omega: $560639d49e3c9a19$var$omega,
    thetasym: $560639d49e3c9a19$var$thetasym,
    upsih: $560639d49e3c9a19$var$upsih,
    piv: $560639d49e3c9a19$var$piv,
    bull: $560639d49e3c9a19$var$bull,
    hellip: $560639d49e3c9a19$var$hellip,
    prime: $560639d49e3c9a19$var$prime,
    Prime: $560639d49e3c9a19$var$Prime,
    oline: $560639d49e3c9a19$var$oline,
    frasl: $560639d49e3c9a19$var$frasl,
    weierp: $560639d49e3c9a19$var$weierp,
    image: $560639d49e3c9a19$var$image,
    real: $560639d49e3c9a19$var$real,
    trade: $560639d49e3c9a19$var$trade,
    alefsym: $560639d49e3c9a19$var$alefsym,
    larr: $560639d49e3c9a19$var$larr,
    uarr: $560639d49e3c9a19$var$uarr,
    rarr: $560639d49e3c9a19$var$rarr,
    darr: $560639d49e3c9a19$var$darr,
    harr: $560639d49e3c9a19$var$harr,
    crarr: $560639d49e3c9a19$var$crarr,
    lArr: $560639d49e3c9a19$var$lArr,
    uArr: $560639d49e3c9a19$var$uArr,
    rArr: $560639d49e3c9a19$var$rArr,
    dArr: $560639d49e3c9a19$var$dArr,
    hArr: $560639d49e3c9a19$var$hArr,
    forall: $560639d49e3c9a19$var$forall,
    part: $560639d49e3c9a19$var$part,
    exist: $560639d49e3c9a19$var$exist,
    empty: $560639d49e3c9a19$var$empty,
    nabla: $560639d49e3c9a19$var$nabla,
    isin: $560639d49e3c9a19$var$isin,
    notin: $560639d49e3c9a19$var$notin,
    ni: $560639d49e3c9a19$var$ni,
    prod: $560639d49e3c9a19$var$prod,
    sum: $560639d49e3c9a19$var$sum,
    minus: $560639d49e3c9a19$var$minus,
    lowast: $560639d49e3c9a19$var$lowast,
    radic: $560639d49e3c9a19$var$radic,
    prop: $560639d49e3c9a19$var$prop,
    infin: $560639d49e3c9a19$var$infin,
    ang: $560639d49e3c9a19$var$ang,
    and: $560639d49e3c9a19$var$and,
    or: $560639d49e3c9a19$var$or,
    cap: $560639d49e3c9a19$var$cap,
    cup: $560639d49e3c9a19$var$cup,
    int: $560639d49e3c9a19$var$int,
    there4: $560639d49e3c9a19$var$there4,
    sim: $560639d49e3c9a19$var$sim,
    cong: $560639d49e3c9a19$var$cong,
    asymp: $560639d49e3c9a19$var$asymp,
    ne: $560639d49e3c9a19$var$ne,
    equiv: $560639d49e3c9a19$var$equiv,
    le: $560639d49e3c9a19$var$le,
    ge: $560639d49e3c9a19$var$ge,
    sub: $560639d49e3c9a19$var$sub,
    sup: $560639d49e3c9a19$var$sup,
    nsub: $560639d49e3c9a19$var$nsub,
    sube: $560639d49e3c9a19$var$sube,
    supe: $560639d49e3c9a19$var$supe,
    oplus: $560639d49e3c9a19$var$oplus,
    otimes: $560639d49e3c9a19$var$otimes,
    perp: $560639d49e3c9a19$var$perp,
    sdot: $560639d49e3c9a19$var$sdot,
    lceil: $560639d49e3c9a19$var$lceil,
    rceil: $560639d49e3c9a19$var$rceil,
    lfloor: $560639d49e3c9a19$var$lfloor,
    rfloor: $560639d49e3c9a19$var$rfloor,
    lang: $560639d49e3c9a19$var$lang,
    rang: $560639d49e3c9a19$var$rang,
    loz: $560639d49e3c9a19$var$loz,
    spades: $560639d49e3c9a19$var$spades,
    clubs: $560639d49e3c9a19$var$clubs,
    hearts: $560639d49e3c9a19$var$hearts,
    diams: $560639d49e3c9a19$var$diams,
    quot: $560639d49e3c9a19$var$quot,
    amp: $560639d49e3c9a19$var$amp,
    lt: $560639d49e3c9a19$var$lt,
    gt: $560639d49e3c9a19$var$gt,
    OElig: $560639d49e3c9a19$var$OElig,
    oelig: $560639d49e3c9a19$var$oelig,
    Scaron: $560639d49e3c9a19$var$Scaron,
    scaron: $560639d49e3c9a19$var$scaron,
    Yuml: $560639d49e3c9a19$var$Yuml,
    circ: $560639d49e3c9a19$var$circ,
    tilde: $560639d49e3c9a19$var$tilde,
    ensp: $560639d49e3c9a19$var$ensp,
    emsp: $560639d49e3c9a19$var$emsp,
    thinsp: $560639d49e3c9a19$var$thinsp,
    zwnj: $560639d49e3c9a19$var$zwnj,
    zwj: $560639d49e3c9a19$var$zwj,
    lrm: $560639d49e3c9a19$var$lrm,
    rlm: $560639d49e3c9a19$var$rlm,
    ndash: $560639d49e3c9a19$var$ndash,
    mdash: $560639d49e3c9a19$var$mdash,
    lsquo: $560639d49e3c9a19$var$lsquo,
    rsquo: $560639d49e3c9a19$var$rsquo,
    sbquo: $560639d49e3c9a19$var$sbquo,
    ldquo: $560639d49e3c9a19$var$ldquo,
    rdquo: $560639d49e3c9a19$var$rdquo,
    bdquo: $560639d49e3c9a19$var$bdquo,
    dagger: $560639d49e3c9a19$var$dagger,
    Dagger: $560639d49e3c9a19$var$Dagger,
    permil: $560639d49e3c9a19$var$permil,
    lsaquo: $560639d49e3c9a19$var$lsaquo,
    rsaquo: $560639d49e3c9a19$var$rsaquo,
    euro: $560639d49e3c9a19$var$euro
};
var $560639d49e3c9a19$var$characterEntitiesHtml4 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    nbsp: $560639d49e3c9a19$var$nbsp,
    iexcl: $560639d49e3c9a19$var$iexcl,
    cent: $560639d49e3c9a19$var$cent,
    pound: $560639d49e3c9a19$var$pound,
    curren: $560639d49e3c9a19$var$curren,
    yen: $560639d49e3c9a19$var$yen,
    brvbar: $560639d49e3c9a19$var$brvbar,
    sect: $560639d49e3c9a19$var$sect,
    uml: $560639d49e3c9a19$var$uml,
    copy: $560639d49e3c9a19$var$copy,
    ordf: $560639d49e3c9a19$var$ordf,
    laquo: $560639d49e3c9a19$var$laquo,
    not: $560639d49e3c9a19$var$not,
    shy: $560639d49e3c9a19$var$shy,
    reg: $560639d49e3c9a19$var$reg,
    macr: $560639d49e3c9a19$var$macr,
    deg: $560639d49e3c9a19$var$deg,
    plusmn: $560639d49e3c9a19$var$plusmn,
    sup2: $560639d49e3c9a19$var$sup2,
    sup3: $560639d49e3c9a19$var$sup3,
    acute: $560639d49e3c9a19$var$acute,
    micro: $560639d49e3c9a19$var$micro,
    para: $560639d49e3c9a19$var$para,
    middot: $560639d49e3c9a19$var$middot,
    cedil: $560639d49e3c9a19$var$cedil,
    sup1: $560639d49e3c9a19$var$sup1,
    ordm: $560639d49e3c9a19$var$ordm,
    raquo: $560639d49e3c9a19$var$raquo,
    frac14: $560639d49e3c9a19$var$frac14,
    frac12: $560639d49e3c9a19$var$frac12,
    frac34: $560639d49e3c9a19$var$frac34,
    iquest: $560639d49e3c9a19$var$iquest,
    Agrave: $560639d49e3c9a19$var$Agrave,
    Aacute: $560639d49e3c9a19$var$Aacute,
    Acirc: $560639d49e3c9a19$var$Acirc,
    Atilde: $560639d49e3c9a19$var$Atilde,
    Auml: $560639d49e3c9a19$var$Auml,
    Aring: $560639d49e3c9a19$var$Aring,
    AElig: $560639d49e3c9a19$var$AElig,
    Ccedil: $560639d49e3c9a19$var$Ccedil,
    Egrave: $560639d49e3c9a19$var$Egrave,
    Eacute: $560639d49e3c9a19$var$Eacute,
    Ecirc: $560639d49e3c9a19$var$Ecirc,
    Euml: $560639d49e3c9a19$var$Euml,
    Igrave: $560639d49e3c9a19$var$Igrave,
    Iacute: $560639d49e3c9a19$var$Iacute,
    Icirc: $560639d49e3c9a19$var$Icirc,
    Iuml: $560639d49e3c9a19$var$Iuml,
    ETH: $560639d49e3c9a19$var$ETH,
    Ntilde: $560639d49e3c9a19$var$Ntilde,
    Ograve: $560639d49e3c9a19$var$Ograve,
    Oacute: $560639d49e3c9a19$var$Oacute,
    Ocirc: $560639d49e3c9a19$var$Ocirc,
    Otilde: $560639d49e3c9a19$var$Otilde,
    Ouml: $560639d49e3c9a19$var$Ouml,
    times: $560639d49e3c9a19$var$times,
    Oslash: $560639d49e3c9a19$var$Oslash,
    Ugrave: $560639d49e3c9a19$var$Ugrave,
    Uacute: $560639d49e3c9a19$var$Uacute,
    Ucirc: $560639d49e3c9a19$var$Ucirc,
    Uuml: $560639d49e3c9a19$var$Uuml,
    Yacute: $560639d49e3c9a19$var$Yacute,
    THORN: $560639d49e3c9a19$var$THORN,
    szlig: $560639d49e3c9a19$var$szlig,
    agrave: $560639d49e3c9a19$var$agrave,
    aacute: $560639d49e3c9a19$var$aacute,
    acirc: $560639d49e3c9a19$var$acirc,
    atilde: $560639d49e3c9a19$var$atilde,
    auml: $560639d49e3c9a19$var$auml,
    aring: $560639d49e3c9a19$var$aring,
    aelig: $560639d49e3c9a19$var$aelig,
    ccedil: $560639d49e3c9a19$var$ccedil,
    egrave: $560639d49e3c9a19$var$egrave,
    eacute: $560639d49e3c9a19$var$eacute,
    ecirc: $560639d49e3c9a19$var$ecirc,
    euml: $560639d49e3c9a19$var$euml,
    igrave: $560639d49e3c9a19$var$igrave,
    iacute: $560639d49e3c9a19$var$iacute,
    icirc: $560639d49e3c9a19$var$icirc,
    iuml: $560639d49e3c9a19$var$iuml,
    eth: $560639d49e3c9a19$var$eth,
    ntilde: $560639d49e3c9a19$var$ntilde,
    ograve: $560639d49e3c9a19$var$ograve,
    oacute: $560639d49e3c9a19$var$oacute,
    ocirc: $560639d49e3c9a19$var$ocirc,
    otilde: $560639d49e3c9a19$var$otilde,
    ouml: $560639d49e3c9a19$var$ouml,
    divide: $560639d49e3c9a19$var$divide,
    oslash: $560639d49e3c9a19$var$oslash,
    ugrave: $560639d49e3c9a19$var$ugrave,
    uacute: $560639d49e3c9a19$var$uacute,
    ucirc: $560639d49e3c9a19$var$ucirc,
    uuml: $560639d49e3c9a19$var$uuml,
    yacute: $560639d49e3c9a19$var$yacute,
    thorn: $560639d49e3c9a19$var$thorn,
    yuml: $560639d49e3c9a19$var$yuml,
    fnof: $560639d49e3c9a19$var$fnof,
    Alpha: $560639d49e3c9a19$var$Alpha,
    Beta: $560639d49e3c9a19$var$Beta,
    Gamma: $560639d49e3c9a19$var$Gamma,
    Delta: $560639d49e3c9a19$var$Delta,
    Epsilon: $560639d49e3c9a19$var$Epsilon,
    Zeta: $560639d49e3c9a19$var$Zeta,
    Eta: $560639d49e3c9a19$var$Eta,
    Theta: $560639d49e3c9a19$var$Theta,
    Iota: $560639d49e3c9a19$var$Iota,
    Kappa: $560639d49e3c9a19$var$Kappa,
    Lambda: $560639d49e3c9a19$var$Lambda,
    Mu: $560639d49e3c9a19$var$Mu,
    Nu: $560639d49e3c9a19$var$Nu,
    Xi: $560639d49e3c9a19$var$Xi,
    Omicron: $560639d49e3c9a19$var$Omicron,
    Pi: $560639d49e3c9a19$var$Pi,
    Rho: $560639d49e3c9a19$var$Rho,
    Sigma: $560639d49e3c9a19$var$Sigma,
    Tau: $560639d49e3c9a19$var$Tau,
    Upsilon: $560639d49e3c9a19$var$Upsilon,
    Phi: $560639d49e3c9a19$var$Phi,
    Chi: $560639d49e3c9a19$var$Chi,
    Psi: $560639d49e3c9a19$var$Psi,
    Omega: $560639d49e3c9a19$var$Omega,
    alpha: $560639d49e3c9a19$var$alpha,
    beta: $560639d49e3c9a19$var$beta,
    gamma: $560639d49e3c9a19$var$gamma,
    delta: $560639d49e3c9a19$var$delta,
    epsilon: $560639d49e3c9a19$var$epsilon,
    zeta: $560639d49e3c9a19$var$zeta,
    eta: $560639d49e3c9a19$var$eta,
    theta: $560639d49e3c9a19$var$theta,
    iota: $560639d49e3c9a19$var$iota,
    kappa: $560639d49e3c9a19$var$kappa,
    lambda: $560639d49e3c9a19$var$lambda,
    mu: $560639d49e3c9a19$var$mu,
    nu: $560639d49e3c9a19$var$nu,
    xi: $560639d49e3c9a19$var$xi,
    omicron: $560639d49e3c9a19$var$omicron,
    pi: $560639d49e3c9a19$var$pi,
    rho: $560639d49e3c9a19$var$rho,
    sigmaf: $560639d49e3c9a19$var$sigmaf,
    sigma: $560639d49e3c9a19$var$sigma,
    tau: $560639d49e3c9a19$var$tau,
    upsilon: $560639d49e3c9a19$var$upsilon,
    phi: $560639d49e3c9a19$var$phi,
    chi: $560639d49e3c9a19$var$chi,
    psi: $560639d49e3c9a19$var$psi,
    omega: $560639d49e3c9a19$var$omega,
    thetasym: $560639d49e3c9a19$var$thetasym,
    upsih: $560639d49e3c9a19$var$upsih,
    piv: $560639d49e3c9a19$var$piv,
    bull: $560639d49e3c9a19$var$bull,
    hellip: $560639d49e3c9a19$var$hellip,
    prime: $560639d49e3c9a19$var$prime,
    Prime: $560639d49e3c9a19$var$Prime,
    oline: $560639d49e3c9a19$var$oline,
    frasl: $560639d49e3c9a19$var$frasl,
    weierp: $560639d49e3c9a19$var$weierp,
    image: $560639d49e3c9a19$var$image,
    real: $560639d49e3c9a19$var$real,
    trade: $560639d49e3c9a19$var$trade,
    alefsym: $560639d49e3c9a19$var$alefsym,
    larr: $560639d49e3c9a19$var$larr,
    uarr: $560639d49e3c9a19$var$uarr,
    rarr: $560639d49e3c9a19$var$rarr,
    darr: $560639d49e3c9a19$var$darr,
    harr: $560639d49e3c9a19$var$harr,
    crarr: $560639d49e3c9a19$var$crarr,
    lArr: $560639d49e3c9a19$var$lArr,
    uArr: $560639d49e3c9a19$var$uArr,
    rArr: $560639d49e3c9a19$var$rArr,
    dArr: $560639d49e3c9a19$var$dArr,
    hArr: $560639d49e3c9a19$var$hArr,
    forall: $560639d49e3c9a19$var$forall,
    part: $560639d49e3c9a19$var$part,
    exist: $560639d49e3c9a19$var$exist,
    empty: $560639d49e3c9a19$var$empty,
    nabla: $560639d49e3c9a19$var$nabla,
    isin: $560639d49e3c9a19$var$isin,
    notin: $560639d49e3c9a19$var$notin,
    ni: $560639d49e3c9a19$var$ni,
    prod: $560639d49e3c9a19$var$prod,
    sum: $560639d49e3c9a19$var$sum,
    minus: $560639d49e3c9a19$var$minus,
    lowast: $560639d49e3c9a19$var$lowast,
    radic: $560639d49e3c9a19$var$radic,
    prop: $560639d49e3c9a19$var$prop,
    infin: $560639d49e3c9a19$var$infin,
    ang: $560639d49e3c9a19$var$ang,
    and: $560639d49e3c9a19$var$and,
    or: $560639d49e3c9a19$var$or,
    cap: $560639d49e3c9a19$var$cap,
    cup: $560639d49e3c9a19$var$cup,
    int: $560639d49e3c9a19$var$int,
    there4: $560639d49e3c9a19$var$there4,
    sim: $560639d49e3c9a19$var$sim,
    cong: $560639d49e3c9a19$var$cong,
    asymp: $560639d49e3c9a19$var$asymp,
    ne: $560639d49e3c9a19$var$ne,
    equiv: $560639d49e3c9a19$var$equiv,
    le: $560639d49e3c9a19$var$le,
    ge: $560639d49e3c9a19$var$ge,
    sub: $560639d49e3c9a19$var$sub,
    sup: $560639d49e3c9a19$var$sup,
    nsub: $560639d49e3c9a19$var$nsub,
    sube: $560639d49e3c9a19$var$sube,
    supe: $560639d49e3c9a19$var$supe,
    oplus: $560639d49e3c9a19$var$oplus,
    otimes: $560639d49e3c9a19$var$otimes,
    perp: $560639d49e3c9a19$var$perp,
    sdot: $560639d49e3c9a19$var$sdot,
    lceil: $560639d49e3c9a19$var$lceil,
    rceil: $560639d49e3c9a19$var$rceil,
    lfloor: $560639d49e3c9a19$var$lfloor,
    rfloor: $560639d49e3c9a19$var$rfloor,
    lang: $560639d49e3c9a19$var$lang,
    rang: $560639d49e3c9a19$var$rang,
    loz: $560639d49e3c9a19$var$loz,
    spades: $560639d49e3c9a19$var$spades,
    clubs: $560639d49e3c9a19$var$clubs,
    hearts: $560639d49e3c9a19$var$hearts,
    diams: $560639d49e3c9a19$var$diams,
    quot: $560639d49e3c9a19$var$quot,
    amp: $560639d49e3c9a19$var$amp,
    lt: $560639d49e3c9a19$var$lt,
    gt: $560639d49e3c9a19$var$gt,
    OElig: $560639d49e3c9a19$var$OElig,
    oelig: $560639d49e3c9a19$var$oelig,
    Scaron: $560639d49e3c9a19$var$Scaron,
    scaron: $560639d49e3c9a19$var$scaron,
    Yuml: $560639d49e3c9a19$var$Yuml,
    circ: $560639d49e3c9a19$var$circ,
    tilde: $560639d49e3c9a19$var$tilde,
    ensp: $560639d49e3c9a19$var$ensp,
    emsp: $560639d49e3c9a19$var$emsp,
    thinsp: $560639d49e3c9a19$var$thinsp,
    zwnj: $560639d49e3c9a19$var$zwnj,
    zwj: $560639d49e3c9a19$var$zwj,
    lrm: $560639d49e3c9a19$var$lrm,
    rlm: $560639d49e3c9a19$var$rlm,
    ndash: $560639d49e3c9a19$var$ndash,
    mdash: $560639d49e3c9a19$var$mdash,
    lsquo: $560639d49e3c9a19$var$lsquo,
    rsquo: $560639d49e3c9a19$var$rsquo,
    sbquo: $560639d49e3c9a19$var$sbquo,
    ldquo: $560639d49e3c9a19$var$ldquo,
    rdquo: $560639d49e3c9a19$var$rdquo,
    bdquo: $560639d49e3c9a19$var$bdquo,
    dagger: $560639d49e3c9a19$var$dagger,
    Dagger: $560639d49e3c9a19$var$Dagger,
    permil: $560639d49e3c9a19$var$permil,
    lsaquo: $560639d49e3c9a19$var$lsaquo,
    rsaquo: $560639d49e3c9a19$var$rsaquo,
    euro: $560639d49e3c9a19$var$euro,
    "default": $560639d49e3c9a19$var$index
});
var $560639d49e3c9a19$var$dangerous$1 = [
    "cent",
    "copy",
    "divide",
    "gt",
    "lt",
    "not",
    "para",
    "times"
];
var $560639d49e3c9a19$var$dangerous$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $560639d49e3c9a19$var$dangerous$1
});
var $560639d49e3c9a19$var$entities = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntitiesHtml4);
var $560639d49e3c9a19$var$dangerous = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$dangerous$2);
var $560639d49e3c9a19$var$decimal = $560639d49e3c9a19$var$isDecimal;
var $560639d49e3c9a19$var$stringifyEntities = $560639d49e3c9a19$var$encode;
$560639d49e3c9a19$var$encode.escape = $560639d49e3c9a19$var$escape;
var $560639d49e3c9a19$var$own$3 = {}.hasOwnProperty;
// List of enforced escapes.
var $560639d49e3c9a19$var$escapes = [
    '"',
    "'",
    "<",
    ">",
    "&",
    "`"
];
// Map of characters to names.
var $560639d49e3c9a19$var$characters = $560639d49e3c9a19$var$construct();
// Default escapes.
var $560639d49e3c9a19$var$defaultEscapes = $560639d49e3c9a19$var$toExpression($560639d49e3c9a19$var$escapes);
// Surrogate pairs.
var $560639d49e3c9a19$var$surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
// Non-ASCII characters.
// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
var $560639d49e3c9a19$var$bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
// Encode special characters in `value`.
function $560639d49e3c9a19$var$encode(value, options) {
    var settings = options || {};
    var subset = settings.subset;
    var set = subset ? $560639d49e3c9a19$var$toExpression(subset) : $560639d49e3c9a19$var$defaultEscapes;
    var escapeOnly = settings.escapeOnly;
    var omit = settings.omitOptionalSemicolons;
    value = value.replace(set, replace);
    if (subset || escapeOnly) return value;
    return value.replace($560639d49e3c9a19$var$surrogatePair, replaceSurrogatePair).replace($560639d49e3c9a19$var$bmp, replace);
    function replaceSurrogatePair(pair, pos, val) {
        return $560639d49e3c9a19$var$toHexReference((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, val.charAt(pos + 2), omit);
    }
    function replace(char, pos, val) {
        return $560639d49e3c9a19$var$one$1(char, val.charAt(pos + 1), settings);
    }
}
// Shortcut to escape special characters in HTML.
function $560639d49e3c9a19$var$escape(value) {
    return $560639d49e3c9a19$var$encode(value, {
        escapeOnly: true,
        useNamedReferences: true
    });
}
// Encode `char` according to `options`.
function $560639d49e3c9a19$var$one$1(char, next, options) {
    var shortest = options.useShortestReferences;
    var omit = options.omitOptionalSemicolons;
    var named;
    var code;
    var numeric;
    var decimal;
    if ((shortest || options.useNamedReferences) && $560639d49e3c9a19$var$own$3.call($560639d49e3c9a19$var$characters, char)) named = $560639d49e3c9a19$var$toNamed($560639d49e3c9a19$var$characters[char], next, omit, options.attribute);
    if (shortest || !named) {
        code = char.charCodeAt(0);
        numeric = $560639d49e3c9a19$var$toHexReference(code, next, omit);
        // Use the shortest numeric reference when requested.
        // A simple algorithm would use decimal for all code points under 100, as
        // those are shorter than hexadecimal:
        //
        // * `&#99;` vs `&#x63;` (decimal shorter)
        // * `&#100;` vs `&#x64;` (equal)
        //
        // However, because we take `next` into consideration when `omit` is used,
        // And it would be possible that decimals are shorter on bigger values as
        // well if `next` is hexadecimal but not decimal, we instead compare both.
        if (shortest) {
            decimal = $560639d49e3c9a19$var$toDecimalReference(code, next, omit);
            if (decimal.length < numeric.length) numeric = decimal;
        }
    }
    if (named && (!shortest || named.length < numeric.length)) return named;
    return numeric;
}
// Transform `code` into an entity.
function $560639d49e3c9a19$var$toNamed(name, next, omit, attribute) {
    var value = "&" + name;
    if (omit && $560639d49e3c9a19$var$own$3.call($560639d49e3c9a19$var$legacy, name) && $560639d49e3c9a19$var$dangerous.indexOf(name) === -1 && (!attribute || next && next !== "=" && !$560639d49e3c9a19$var$isAlphanumerical(next))) return value;
    return value + ";";
}
// Transform `code` into a hexadecimal character reference.
function $560639d49e3c9a19$var$toHexReference(code, next, omit) {
    var value = "&#x" + code.toString(16).toUpperCase();
    return omit && next && !$560639d49e3c9a19$var$isHexadecimal(next) ? value : value + ";";
}
// Transform `code` into a decimal character reference.
function $560639d49e3c9a19$var$toDecimalReference(code, next, omit) {
    var value = "&#" + String(code);
    return omit && next && !$560639d49e3c9a19$var$decimal(next) ? value : value + ";";
}
// Create an expression for `characters`.
function $560639d49e3c9a19$var$toExpression(characters) {
    return new RegExp("[" + characters.join("") + "]", "g");
}
// Construct the map.
function $560639d49e3c9a19$var$construct() {
    var chars = {};
    var name;
    for(name in $560639d49e3c9a19$var$entities)chars[$560639d49e3c9a19$var$entities[name]] = name;
    return chars;
}
// Characters.
var $560639d49e3c9a19$var$NULL = "\0";
var $560639d49e3c9a19$var$AMP = "&";
var $560639d49e3c9a19$var$SP = " ";
var $560639d49e3c9a19$var$TB = "	";
var $560639d49e3c9a19$var$GR = "`";
var $560639d49e3c9a19$var$DQ$1 = '"';
var $560639d49e3c9a19$var$SQ$1 = "'";
var $560639d49e3c9a19$var$EQ = "=";
var $560639d49e3c9a19$var$LT = "<";
var $560639d49e3c9a19$var$GT = ">";
var $560639d49e3c9a19$var$SO = "/";
var $560639d49e3c9a19$var$LF = "\n";
var $560639d49e3c9a19$var$CR = "\r";
var $560639d49e3c9a19$var$FF = "\f";
var $560639d49e3c9a19$var$whitespace = [
    $560639d49e3c9a19$var$SP,
    $560639d49e3c9a19$var$TB,
    $560639d49e3c9a19$var$LF,
    $560639d49e3c9a19$var$CR,
    $560639d49e3c9a19$var$FF
];
// https://html.spec.whatwg.org/#attribute-name-state
var $560639d49e3c9a19$var$name = $560639d49e3c9a19$var$whitespace.concat($560639d49e3c9a19$var$AMP, $560639d49e3c9a19$var$SO, $560639d49e3c9a19$var$GT, $560639d49e3c9a19$var$EQ);
// https://html.spec.whatwg.org/#attribute-value-(unquoted)-state
var $560639d49e3c9a19$var$unquoted$1 = $560639d49e3c9a19$var$whitespace.concat($560639d49e3c9a19$var$AMP, $560639d49e3c9a19$var$GT);
var $560639d49e3c9a19$var$unquotedSafe = $560639d49e3c9a19$var$unquoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT, $560639d49e3c9a19$var$EQ, $560639d49e3c9a19$var$GR);
// https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
var $560639d49e3c9a19$var$singleQuoted$1 = [
    $560639d49e3c9a19$var$AMP,
    $560639d49e3c9a19$var$SQ$1
];
// https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
var $560639d49e3c9a19$var$doubleQuoted$1 = [
    $560639d49e3c9a19$var$AMP,
    $560639d49e3c9a19$var$DQ$1
];
// Maps of subsets. Each value is a matrix of tuples.
// The first value causes parse errors, the second is valid.
// Of both values, the first value is unsafe, and the second is safe.
var $560639d49e3c9a19$var$constants = {
    name: [
        [
            $560639d49e3c9a19$var$name,
            $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
        ],
        [
            $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT),
            $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT, $560639d49e3c9a19$var$GR)
        ]
    ],
    unquoted: [
        [
            $560639d49e3c9a19$var$unquoted$1,
            $560639d49e3c9a19$var$unquotedSafe
        ],
        [
            $560639d49e3c9a19$var$unquotedSafe,
            $560639d49e3c9a19$var$unquotedSafe
        ]
    ],
    single: [
        [
            $560639d49e3c9a19$var$singleQuoted$1,
            $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$GR)
        ],
        [
            $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$NULL),
            $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$GR)
        ]
    ],
    double: [
        [
            $560639d49e3c9a19$var$doubleQuoted$1,
            $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
        ],
        [
            $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$NULL),
            $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
        ]
    ]
};
var $560639d49e3c9a19$var$spaces = $560639d49e3c9a19$var$spaceSeparatedTokens.stringify;
var $560639d49e3c9a19$var$commas = $560639d49e3c9a19$var$commaSeparatedTokens.stringify;
var $560639d49e3c9a19$var$element_1 = $560639d49e3c9a19$var$element;
/* Constants. */ var $560639d49e3c9a19$var$emptyString = "";
/* Characters. */ var $560639d49e3c9a19$var$space$1 = " ";
var $560639d49e3c9a19$var$quotationMark = '"';
var $560639d49e3c9a19$var$apostrophe$1 = "'";
var $560639d49e3c9a19$var$equalsTo = "=";
var $560639d49e3c9a19$var$lessThan$1 = "<";
var $560639d49e3c9a19$var$greaterThan = ">";
var $560639d49e3c9a19$var$slash$1 = "/";
var $560639d49e3c9a19$var$newLine = "\n";
/* Stringify an element `node`. */ function $560639d49e3c9a19$var$element(ctx, node, index, parent, printWidthOffset, innerTextLength) {
    var parentSchema = ctx.schema;
    var name = node.tagName;
    var value = "";
    var selfClosing;
    var close;
    var omit;
    var root = node;
    var content;
    var attrs;
    var indentLevel = $560639d49e3c9a19$var$getNodeData(node, "indentLevel", 0);
    var printContext = {
        offset: printWidthOffset,
        wrapAttributes: false,
        indentLevel: indentLevel
    };
    var isVoid = ctx.voids.indexOf(name) !== -1;
    var ignoreAttrCollapsing = $560639d49e3c9a19$var$getNodeData(node, "ignore", false) || $560639d49e3c9a19$var$getNodeData(node, "preserveAttrWrapping", false);
    if (parentSchema.space === "html" && name === "svg") ctx.schema = $560639d49e3c9a19$var$svg_1;
    if (ctx.schema.space === "svg") {
        omit = false;
        close = true;
        selfClosing = ctx.closeEmpty;
    } else {
        omit = ctx.omit;
        close = ctx.close;
        selfClosing = isVoid;
    }
    // check for 'selfClosing' property set by hast-util-from-webparser package
    // in order to support custom self-closing elements
    if (selfClosing === false) selfClosing = $560639d49e3c9a19$var$getNodeData(node, "selfClosing", false);
    // <
    printContext.offset += $560639d49e3c9a19$var$lessThan$1.length;
    // tagName length
    printContext.offset += node.tagName.length;
    // / closing tag
    if (selfClosing && !isVoid) printContext.offset += $560639d49e3c9a19$var$slash$1.length;
    // >
    printContext.offset += $560639d49e3c9a19$var$greaterThan.length;
    const propertyCount = Object.keys(node.properties).length;
    // force to wrap attributes on multiple lines when the node contains
    // more than one attribute
    if (propertyCount > 1 && ctx.wrapAttributes) printContext.wrapAttributes = true;
    // one space before each attribute
    if (propertyCount) printContext.offset += propertyCount * $560639d49e3c9a19$var$space$1.length;
    // represent the length of the inner text of the node
    printContext.offset += innerTextLength;
    attrs = $560639d49e3c9a19$var$attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);
    const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
    content = $560639d49e3c9a19$var$all_1(ctx, root);
    /* If the node is categorised as void, but it has
   * children, remove the categorisation.  This
   * enables for example `menuitem`s, which are
   * void in W3C HTML but not void in WHATWG HTML, to
   * be stringified properly. */ selfClosing = content ? false : selfClosing;
    if (attrs || !omit || !omit.opening(node, index, parent)) {
        value = $560639d49e3c9a19$var$lessThan$1 + name;
        if (attrs) {
            // add no space after tagName when element is collapsed
            if (shouldCollapse) value += attrs;
            else value += $560639d49e3c9a19$var$space$1 + attrs;
        }
        let selfClosed = false;
        // check if the should close self-closing elements
        if (selfClosing && close) {
            if ((!ctx.tightClose || attrs.charAt(attrs.length - 1) === $560639d49e3c9a19$var$slash$1) && !shouldCollapse) value += $560639d49e3c9a19$var$space$1;
            if (shouldCollapse) value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
            selfClosed = true;
            value += $560639d49e3c9a19$var$slash$1;
        } else if (selfClosing && !isVoid) {
            if (shouldCollapse) value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
            selfClosed = true;
            value += $560639d49e3c9a19$var$slash$1;
        }
        // add newline when element should be wrappend on multiple lines and when
        // it's no self-closing element because in that case the newline was already added before the slash (/)
        if (shouldCollapse && !selfClosed) value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
        value += $560639d49e3c9a19$var$greaterThan;
    }
    value += content;
    if (!selfClosing && (!omit || !omit.closing(node, index, parent))) value += $560639d49e3c9a19$var$lessThan$1 + $560639d49e3c9a19$var$slash$1 + name + $560639d49e3c9a19$var$greaterThan;
    ctx.schema = parentSchema;
    return value;
}
/* Stringify all attributes. */ function $560639d49e3c9a19$var$attributes(ctx, props, printContext, ignoreIndent) {
    var values = [];
    var key;
    var value;
    var result;
    var length;
    var index;
    var last;
    for(key in props){
        value = props[key];
        if (value == null) continue;
        result = $560639d49e3c9a19$var$attribute$1(ctx, key, value);
        printContext.offset += result.length;
        if (ignoreIndent === false && printContext.offset > ctx.printWidth) printContext.wrapAttributes = true;
        if (result) values.push(result);
    }
    length = values.length;
    index = -1;
    while(++index < length){
        result = values[index];
        last = null;
        /* In tight mode, don’t add a space after quoted attributes. */ if (last !== $560639d49e3c9a19$var$quotationMark && last !== $560639d49e3c9a19$var$apostrophe$1) {
            if (printContext.wrapAttributes) values[index] = $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
            else if (index !== length - 1) values[index] = result + $560639d49e3c9a19$var$space$1;
            else values[index] = result;
        }
    }
    return values.join($560639d49e3c9a19$var$emptyString);
}
/* Stringify one attribute. */ function $560639d49e3c9a19$var$attribute$1(ctx, key, value) {
    var schema = ctx.schema;
    var info = $560639d49e3c9a19$var$find_1(schema, key);
    var name = info.attribute;
    if (value == null || typeof value === "number" && isNaN(value) || value === false && info.boolean) return $560639d49e3c9a19$var$emptyString;
    name = $560639d49e3c9a19$var$attributeName$1(ctx, name);
    if (value === true && info.boolean || value === true && info.overloadedBoolean) return name;
    return name + $560639d49e3c9a19$var$attributeValue$1(ctx, key, value, info);
}
/* Stringify the attribute name. */ function $560639d49e3c9a19$var$attributeName$1(ctx, name) {
    // Always encode without parse errors in non-HTML.
    var valid = ctx.schema.space === "html" ? ctx.valid : 1;
    var subset = $560639d49e3c9a19$var$constants.name[valid][ctx.safe];
    return $560639d49e3c9a19$var$stringifyEntities(name, $560639d49e3c9a19$var$immutable(ctx.entities, {
        subset: subset
    }));
}
/* Stringify the attribute value. */ function $560639d49e3c9a19$var$attributeValue$1(ctx, key, value, info) {
    var quote = ctx.quote;
    if (typeof value === "object" && "length" in value) /* `spaces` doesn’t accept a second argument, but it’s
     * given here just to keep the code cleaner. */ value = (info.commaSeparated ? $560639d49e3c9a19$var$commas : $560639d49e3c9a19$var$spaces)(value, {
        padLeft: !ctx.tightLists
    });
    value = String(value);
    // When attr has no value we avoid quoting
    if (value === "") return value;
    else value = $560639d49e3c9a19$var$equalsTo + quote + value + quote;
    return value;
}
function $560639d49e3c9a19$var$getNodeData(node, key, defaultValue) {
    let data = node.data || {};
    return data[key] || defaultValue;
}
var $560639d49e3c9a19$var$doctype_1 = $560639d49e3c9a19$var$doctype;
/* Stringify a doctype `node`. */ function $560639d49e3c9a19$var$doctype(ctx, node) {
    var sep = ctx.tightDoctype ? "" : " ";
    var name = node.name;
    var pub = node.public;
    var sys = node.system;
    var val = [
        "<!doctype"
    ];
    if (name) {
        val.push(sep, name);
        if (pub != null) val.push(" public", sep, $560639d49e3c9a19$var$smart(pub));
        else if (sys != null) val.push(" system");
        if (sys != null) val.push(sep, $560639d49e3c9a19$var$smart(sys));
    }
    return val.join("") + ">";
}
function $560639d49e3c9a19$var$smart(value) {
    var quote = value.indexOf('"') === -1 ? '"' : "'";
    return quote + value + quote;
}
var $560639d49e3c9a19$var$comment_1 = $560639d49e3c9a19$var$comment;
/* Stringify a comment `node`. */ function $560639d49e3c9a19$var$comment(ctx, node) {
    return "<!--" + node.value + "-->";
}
var $560639d49e3c9a19$var$raw_1 = $560639d49e3c9a19$var$raw;
/* Stringify `raw`. */ function $560639d49e3c9a19$var$raw(ctx, node) {
    return node.value;
}
var $560639d49e3c9a19$var$one_1 = $560639d49e3c9a19$var$one;
var $560639d49e3c9a19$var$own$2 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$handlers = {};
$560639d49e3c9a19$var$handlers.root = $560639d49e3c9a19$var$all_1;
$560639d49e3c9a19$var$handlers.text = $560639d49e3c9a19$var$text_1;
$560639d49e3c9a19$var$handlers.element = $560639d49e3c9a19$var$element_1;
$560639d49e3c9a19$var$handlers.doctype = $560639d49e3c9a19$var$doctype_1;
$560639d49e3c9a19$var$handlers.comment = $560639d49e3c9a19$var$comment_1;
$560639d49e3c9a19$var$handlers.raw = $560639d49e3c9a19$var$raw_1;
/* Stringify `node`. */ function $560639d49e3c9a19$var$one(ctx, node, index, parent, printWidthOffset, innerTextLength) {
    var type = node && node.type;
    if (!type) throw new Error("Expected node, not `" + node + "`");
    if (!$560639d49e3c9a19$var$own$2.call($560639d49e3c9a19$var$handlers, type)) throw new Error("Cannot compile unknown node `" + type + "`");
    return $560639d49e3c9a19$var$handlers[type](ctx, node, index, parent, printWidthOffset, innerTextLength);
}
var $560639d49e3c9a19$var$voids = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$htmlVoidElements);
var $560639d49e3c9a19$var$lib$1 = $560639d49e3c9a19$var$toHTML;
/* Characters. */ var $560639d49e3c9a19$var$DQ = '"';
var $560639d49e3c9a19$var$SQ = "'";
/* Stringify the given HAST node. */ function $560639d49e3c9a19$var$toHTML(node, options) {
    var settings = options || {};
    var quote = settings.singleQuote ? $560639d49e3c9a19$var$SQ : $560639d49e3c9a19$var$DQ;
    var printWidth = settings.printWidth === undefined ? 80 : settings.printWidth;
    var useTabs = settings.useTabs;
    var tabWidth = settings.tabWidth || 2;
    var wrapAttributes = settings.wrapAttributes;
    if (useTabs) tabWidth = "	";
    else if (typeof tabWidth === "number") tabWidth = $560639d49e3c9a19$var$repeatString(" ", tabWidth);
    return $560639d49e3c9a19$var$one_1({
        valid: settings.allowParseErrors ? 0 : 1,
        safe: settings.allowDangerousCharacters ? 0 : 1,
        schema: settings.space === "svg" ? $560639d49e3c9a19$var$svg_1 : $560639d49e3c9a19$var$html_1,
        omit: settings.omitOptionalTags && $560639d49e3c9a19$var$omission,
        quote: quote,
        printWidth: printWidth,
        tabWidth: tabWidth,
        wrapAttributes: wrapAttributes,
        tightDoctype: Boolean(settings.tightDoctype),
        tightLists: settings.tightCommaSeparatedLists,
        voids: settings.voids || $560639d49e3c9a19$var$voids.concat(),
        entities: settings.entities || {},
        close: settings.closeSelfClosing,
        tightClose: settings.tightSelfClosing,
        closeEmpty: settings.closeEmptyElements
    }, node);
}
var $560639d49e3c9a19$var$prettyhtmlHastToHtml = $560639d49e3c9a19$var$lib$1;
const $560639d49e3c9a19$var$void_els = [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
];
// these regex don't check if it is a valid svelte tag name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser
const $560639d49e3c9a19$var$RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
const $560639d49e3c9a19$var$RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function $560639d49e3c9a19$var$parse_svelte_tag(eat, value, silent) {
    const is_svelte_tag = $560639d49e3c9a19$var$RE_SVELTE_TAG_START.exec(value);
    if (is_svelte_tag) {
        if (silent) return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        let current_tag = "";
        let in_tag_name = false;
        while(cbPos > -1){
            if (!trimmed_value[pos]) break;
            if (trimmed_value[pos].match(/</)) {
                cbPos++;
                current_tag = "";
                in_tag_name = true;
            }
            if (in_tag_name && trimmed_value[pos].match(/\s/)) in_tag_name = false;
            if (in_tag_name && !trimmed_value[pos].match(/</)) current_tag += trimmed_value[pos];
            const is_void = $560639d49e3c9a19$var$void_els.includes(current_tag);
            if (is_void && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) cbPos--;
            if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
                let inner_indent = 0;
                while(inner_indent > -1)if (trimmed_value[pos].match(/>/)) {
                    pos++;
                    inner_indent -= 1;
                    cbPos -= 2;
                } else pos++;
            }
            pos++;
        }
        const match = $560639d49e3c9a19$var$RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
        if (!match) return;
        return eat(is_svelte_tag[1] + match[0])({
            type: "svelteTag",
            value: match[0],
            name: match[1]
        });
    }
}
// these regex don't check if it is a valid block name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser
// 'else if' is a special case due to the annoying whitespace
const $560639d49e3c9a19$var$RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
const $560639d49e3c9a19$var$RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function $560639d49e3c9a19$var$parse_svelte_block(eat, value, silent) {
    const is_svelte_block = $560639d49e3c9a19$var$RE_SVELTE_BLOCK_START.exec(value);
    if (is_svelte_block) {
        if (silent) return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        while(cbPos > -1){
            if (trimmed_value[pos].match(/{/)) cbPos++;
            if (trimmed_value[pos].match(/}/)) cbPos--;
            pos++;
        }
        const match = $560639d49e3c9a19$var$RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
        if (!match) return;
        return eat(is_svelte_block[1] + match[0])({
            type: "svelteBlock",
            value: `${is_svelte_block[1]}${match[0]}`,
            name: match[1]
        });
    }
}
const $560639d49e3c9a19$var$dotAllPolyfill = "[\0-\uFFFF]";
const $560639d49e3c9a19$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const $560639d49e3c9a19$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
const $560639d49e3c9a19$var$singleQuoted = "'[^']*'";
const $560639d49e3c9a19$var$doubleQuoted = '"[^"]*"';
const $560639d49e3c9a19$var$jsProps = "{.*}".replace(".", $560639d49e3c9a19$var$dotAllPolyfill);
const $560639d49e3c9a19$var$attributeValue = "(?:" + $560639d49e3c9a19$var$unquoted + "|" + $560639d49e3c9a19$var$singleQuoted + "|" + $560639d49e3c9a19$var$doubleQuoted + "|" + $560639d49e3c9a19$var$jsProps + ")";
const $560639d49e3c9a19$var$attribute = "(?:\\s+" + $560639d49e3c9a19$var$attributeName + "(?:\\s*=\\s*" + $560639d49e3c9a19$var$attributeValue + ")?)";
const $560639d49e3c9a19$var$openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + $560639d49e3c9a19$var$attribute + "*\\s*\\/?>";
const $560639d49e3c9a19$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
"<[?].*?[?]>".replace(".", $560639d49e3c9a19$var$dotAllPolyfill);
const $560639d49e3c9a19$var$openCloseTag = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag + "|" + $560639d49e3c9a19$var$closeTag + ")");
const $560639d49e3c9a19$var$tab = "	";
const $560639d49e3c9a19$var$space = " ";
const $560639d49e3c9a19$var$lineFeed = "\n";
const $560639d49e3c9a19$var$lessThan = "<";
const $560639d49e3c9a19$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
const $560639d49e3c9a19$var$rawCloseExpression = /<\/(script|pre|style)>/i;
const $560639d49e3c9a19$var$commentOpenExpression = /^<!--/;
const $560639d49e3c9a19$var$commentCloseExpression = /-->/;
const $560639d49e3c9a19$var$instructionOpenExpression = /^<\?/;
const $560639d49e3c9a19$var$instructionCloseExpression = /\?>/;
const $560639d49e3c9a19$var$directiveOpenExpression = /^<![A-Za-z]/;
const $560639d49e3c9a19$var$directiveCloseExpression = />/;
const $560639d49e3c9a19$var$cdataOpenExpression = /^<!\[CDATA\[/;
const $560639d49e3c9a19$var$cdataCloseExpression = /\]\]>/;
const $560639d49e3c9a19$var$elementCloseExpression = /^$/;
const $560639d49e3c9a19$var$otherElementOpenExpression = new RegExp($560639d49e3c9a19$var$openCloseTag.source + "\\s*$");
const $560639d49e3c9a19$var$fragmentOpenExpression = /^<>/;
//@ts-ignore
function $560639d49e3c9a19$var$blockHtml(eat, value, silent) {
    const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
    const elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    const length = value.length;
    let index = 0;
    let next;
    let line;
    let offset;
    let character;
    let sequence;
    const sequences = [
        [
            $560639d49e3c9a19$var$rawOpenExpression,
            $560639d49e3c9a19$var$rawCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$commentOpenExpression,
            $560639d49e3c9a19$var$commentCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$instructionOpenExpression,
            $560639d49e3c9a19$var$instructionCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$directiveOpenExpression,
            $560639d49e3c9a19$var$directiveCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$cdataOpenExpression,
            $560639d49e3c9a19$var$cdataCloseExpression,
            true
        ],
        [
            elementOpenExpression,
            $560639d49e3c9a19$var$elementCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$fragmentOpenExpression,
            $560639d49e3c9a19$var$elementCloseExpression,
            true
        ],
        [
            $560639d49e3c9a19$var$otherElementOpenExpression,
            $560639d49e3c9a19$var$elementCloseExpression,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $560639d49e3c9a19$var$tab && character !== $560639d49e3c9a19$var$space) break;
        index++;
    }
    if (value.charAt(index) !== $560639d49e3c9a19$var$lessThan) return;
    next = value.indexOf($560639d49e3c9a19$var$lineFeed, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    const count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($560639d49e3c9a19$var$lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    const subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
function $560639d49e3c9a19$var$mdsvex_parser() {
    const Parser = this.Parser;
    const block_tokenizers = Parser.prototype.blockTokenizers;
    const methods = Parser.prototype.blockMethods;
    block_tokenizers.svelteBlock = $560639d49e3c9a19$var$parse_svelte_block;
    block_tokenizers.svelteTag = $560639d49e3c9a19$var$parse_svelte_tag;
    block_tokenizers.html = $560639d49e3c9a19$var$blockHtml;
    block_tokenizers.indentedCode = $560639d49e3c9a19$var$indentedCode;
    methods.splice(methods.indexOf("html"), 0, "svelteBlock");
    methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function $560639d49e3c9a19$var$indentedCode() {
    return true;
}
// Expose a frozen processor.
var $560639d49e3c9a19$var$unified_1 = $560639d49e3c9a19$var$unified().freeze();
var $560639d49e3c9a19$var$slice = [].slice;
var $560639d49e3c9a19$var$own$1 = {}.hasOwnProperty;
// Process pipeline.
var $560639d49e3c9a19$var$pipeline = $560639d49e3c9a19$var$trough_1().use($560639d49e3c9a19$var$pipelineParse).use($560639d49e3c9a19$var$pipelineRun).use($560639d49e3c9a19$var$pipelineStringify);
function $560639d49e3c9a19$var$pipelineParse(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $560639d49e3c9a19$var$pipelineRun(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $560639d49e3c9a19$var$pipelineStringify(p, ctx) {
    ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}
// Function to create the first processor.
function $560639d49e3c9a19$var$unified() {
    var attachers = [];
    var transformers = $560639d49e3c9a19$var$trough_1();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process1;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $560639d49e3c9a19$var$unified();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($560639d49e3c9a19$var$extend$2(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $560639d49e3c9a19$var$assertUnfrozen("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $560639d49e3c9a19$var$own$1.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $560639d49e3c9a19$var$assertUnfrozen("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $560639d49e3c9a19$var$assertUnfrozen("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $560639d49e3c9a19$var$extend$2(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $560639d49e3c9a19$var$extend$2(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($560639d49e3c9a19$var$isPlainObj(entry[1]) && $560639d49e3c9a19$var$isPlainObj(value)) value = $560639d49e3c9a19$var$extend$2(entry[1], value);
                entry[1] = value;
            } else attachers.push($560639d49e3c9a19$var$slice.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $560639d49e3c9a19$var$vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $560639d49e3c9a19$var$assertParser("parse", Parser);
        if ($560639d49e3c9a19$var$newable(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $560639d49e3c9a19$var$assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $560639d49e3c9a19$var$vfile(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $560639d49e3c9a19$var$assertDone("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $560639d49e3c9a19$var$bail_1(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $560639d49e3c9a19$var$vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $560639d49e3c9a19$var$assertCompiler("stringify", Compiler);
        $560639d49e3c9a19$var$assertNode(node);
        if ($560639d49e3c9a19$var$newable(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process1(doc, cb) {
        freeze();
        $560639d49e3c9a19$var$assertParser("process", processor.Parser);
        $560639d49e3c9a19$var$assertCompiler("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $560639d49e3c9a19$var$vfile(doc);
            $560639d49e3c9a19$var$pipeline.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $560639d49e3c9a19$var$assertParser("processSync", processor.Parser);
        $560639d49e3c9a19$var$assertCompiler("processSync", processor.Compiler);
        file = $560639d49e3c9a19$var$vfile(doc);
        process1(file, done);
        $560639d49e3c9a19$var$assertDone("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $560639d49e3c9a19$var$bail_1(err);
        }
    }
}
// Check if `value` is a constructor.
function $560639d49e3c9a19$var$newable(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($560639d49e3c9a19$var$keys(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $560639d49e3c9a19$var$keys(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $560639d49e3c9a19$var$assertParser(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $560639d49e3c9a19$var$assertCompiler(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $560639d49e3c9a19$var$assertUnfrozen(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $560639d49e3c9a19$var$assertNode(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $560639d49e3c9a19$var$assertDone(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $560639d49e3c9a19$var$nlcstToString_1 = $560639d49e3c9a19$var$nlcstToString;
// Stringify one nlcst node or list of nodes.
function $560639d49e3c9a19$var$nlcstToString(node, separator) {
    var sep = separator || "";
    var values;
    var length;
    var children;
    if (!node || !("length" in node) && !node.type) throw new Error("Expected node, not `" + node + "`");
    if (typeof node.value === "string") return node.value;
    children = "length" in node ? node : node.children;
    length = children.length;
    // Shortcut: This is pretty common, and a small performance win.
    if (length === 1 && "value" in children[0]) return children[0].value;
    values = [];
    while(length--)values[length] = $560639d49e3c9a19$var$nlcstToString(children[length], sep);
    return values.join(sep);
}
var $560639d49e3c9a19$var$tokenizer = $560639d49e3c9a19$var$tokenizerFactory;
// Factory to create a tokenizer based on a given `expression`.
function $560639d49e3c9a19$var$tokenizerFactory(childType, expression) {
    return tokenizer;
    // A function that splits.
    function tokenizer(node) {
        var children = [];
        var tokens = node.children;
        var type = node.type;
        var length = tokens.length;
        var index = -1;
        var lastIndex = length - 1;
        var start = 0;
        var first;
        var last;
        var parent;
        while(++index < length)if (index === lastIndex || tokens[index].type === childType && expression.test($560639d49e3c9a19$var$nlcstToString_1(tokens[index]))) {
            first = tokens[start];
            last = tokens[index];
            parent = {
                type: type,
                children: tokens.slice(start, index + 1)
            };
            if (first.position && last.position) parent.position = {
                start: first.position.start,
                end: last.position.end
            };
            children.push(parent);
            start = index + 1;
        }
        return children;
    }
}
var $560639d49e3c9a19$var$parser = $560639d49e3c9a19$var$parserFactory;
// Construct a parser based on `options`.
function $560639d49e3c9a19$var$parserFactory(options) {
    var type = options.type;
    var tokenizerProperty = options.tokenizer;
    var delimiter = options.delimiter;
    var tokenize = delimiter && $560639d49e3c9a19$var$tokenizer(options.delimiterType, delimiter);
    return parser;
    function parser(value) {
        var children = this[tokenizerProperty](value);
        return {
            type: type,
            children: tokenize ? tokenize(children) : children
        };
    }
}
// This module is generated by `script/build-expressions.js`.
var $560639d49e3c9a19$var$expressions = {
    affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
    newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
    newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
    terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
    wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
    numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
    digitStart: /^\d/,
    lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
    surrogates: /[\uD800-\uDFFF]/,
    punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
    word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
    whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var $560639d49e3c9a19$var$arrayIterate = $560639d49e3c9a19$var$iterate;
var $560639d49e3c9a19$var$own = {}.hasOwnProperty;
function $560639d49e3c9a19$var$iterate(values, callback, context) {
    var index = -1;
    var result;
    if (!values) throw new Error("Iterate requires that |this| not be " + values);
    if (!$560639d49e3c9a19$var$own.call(values, "length")) throw new Error("Iterate requires that |this| has a `length`");
    if (typeof callback !== "function") throw new Error("`callback` must be a function");
    // The length might change, so we do not cache it.
    while(++index < values.length){
        // Skip missing values.
        if (!(index in values)) continue;
        result = callback.call(context, values[index], index, values);
        // If `callback` returns a `number`, move `index` over to `number`.
        if (typeof result === "number") {
            // Make sure that negative numbers do not break the loop.
            if (result < 0) index = 0;
            index = result - 1;
        }
    }
}
var $560639d49e3c9a19$var$unistUtilModifyChildren = $560639d49e3c9a19$var$modifierFactory;
// Turn `callback` into a child-modifier accepting a parent.  See
// `array-iterate` for more info.
function $560639d49e3c9a19$var$modifierFactory(callback) {
    return $560639d49e3c9a19$var$iteratorFactory($560639d49e3c9a19$var$wrapperFactory(callback));
}
// Turn `callback` into a `iterator' accepting a parent.
function $560639d49e3c9a19$var$iteratorFactory(callback) {
    return iterator;
    function iterator(parent) {
        var children = parent && parent.children;
        if (!children) throw new Error("Missing children in `parent` for `modifier`");
        return $560639d49e3c9a19$var$arrayIterate(children, callback, parent);
    }
}
// Pass the context as the third argument to `callback`.
function $560639d49e3c9a19$var$wrapperFactory(callback) {
    return wrapper;
    function wrapper(value, index) {
        return callback(value, index, this);
    }
}
var $560639d49e3c9a19$var$mergeInitialWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialWordSymbol);
// Merge certain punctuation marks into their following words.
function $560639d49e3c9a19$var$mergeInitialWordSymbol(child, index, parent) {
    var children;
    var next;
    if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || $560639d49e3c9a19$var$nlcstToString_1(child) !== "&") return;
    children = parent.children;
    next = children[index + 1];
    // If either a previous word, or no following word, exists, exit early.
    if (index !== 0 && children[index - 1].type === "WordNode" || !(next && next.type === "WordNode")) return;
    // Remove `child` from parent.
    children.splice(index, 1);
    // Add the punctuation mark at the start of the next node.
    next.children.unshift(child);
    // Update position.
    if (next.position && child.position) next.position.start = child.position.start;
    // Next, iterate over the node at the previous position, as it's now adjacent
    // to a following word.
    return index - 1;
}
var $560639d49e3c9a19$var$mergeFinalWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeFinalWordSymbol$1);
// Merge certain punctuation marks into their preceding words.
function $560639d49e3c9a19$var$mergeFinalWordSymbol$1(child, index, parent) {
    var children;
    var prev;
    var next;
    if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $560639d49e3c9a19$var$nlcstToString_1(child) === "-") {
        children = parent.children;
        prev = children[index - 1];
        next = children[index + 1];
        if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
            // Remove `child` from parent.
            children.splice(index, 1);
            // Add the punctuation mark at the end of the previous node.
            prev.children.push(child);
            // Update position.
            if (prev.position && child.position) prev.position.end = child.position.end;
            // Next, iterate over the node *now* at the current position (which was
            // the next node).
            return index;
        }
    }
}
var $560639d49e3c9a19$var$mergeInnerWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInnerWordSymbol);
// Symbols part of surrounding words.
var $560639d49e3c9a19$var$wordSymbolInner = $560639d49e3c9a19$var$expressions.wordSymbolInner;
// Merge words joined by certain punctuation marks.
function $560639d49e3c9a19$var$mergeInnerWordSymbol(child, index, parent) {
    var siblings;
    var sibling;
    var prev;
    var last;
    var position;
    var tokens;
    var queue;
    if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
        siblings = parent.children;
        prev = siblings[index - 1];
        if (prev && prev.type === "WordNode") {
            position = index - 1;
            tokens = [];
            queue = [];
            // -   If a token which is neither word nor inner word symbol is found,
            //     the loop is broken
            // -   If an inner word symbol is found,  it’s queued
            // -   If a word is found, it’s queued (and the queue stored and emptied)
            while(siblings[++position]){
                sibling = siblings[position];
                if (sibling.type === "WordNode") {
                    tokens = tokens.concat(queue, sibling.children);
                    queue = [];
                } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && $560639d49e3c9a19$var$wordSymbolInner.test($560639d49e3c9a19$var$nlcstToString_1(sibling))) queue.push(sibling);
                else break;
            }
            if (tokens.length !== 0) {
                // If there is a queue, remove its length from `position`.
                if (queue.length !== 0) position -= queue.length;
                // Remove every (one or more) inner-word punctuation marks and children
                // of words.
                siblings.splice(index, position - index);
                // Add all found tokens to `prev`s children.
                prev.children = prev.children.concat(tokens);
                last = tokens[tokens.length - 1];
                // Update position.
                if (prev.position && last.position) prev.position.end = last.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
        }
    }
}
var $560639d49e3c9a19$var$mergeInnerWordSlash_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInnerWordSlash);
var $560639d49e3c9a19$var$slash = "/";
// Merge words joined by certain punctuation marks.
function $560639d49e3c9a19$var$mergeInnerWordSlash(child, index, parent) {
    var siblings = parent.children;
    var prev;
    var next;
    var prevValue;
    var nextValue;
    var queue;
    var tail;
    var count;
    prev = siblings[index - 1];
    next = siblings[index + 1];
    if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $560639d49e3c9a19$var$nlcstToString_1(child) === $560639d49e3c9a19$var$slash) {
        prevValue = $560639d49e3c9a19$var$nlcstToString_1(prev);
        tail = child;
        queue = [
            child
        ];
        count = 1;
        if (next && next.type === "WordNode") {
            nextValue = $560639d49e3c9a19$var$nlcstToString_1(next);
            tail = next;
            queue = queue.concat(next.children);
            count++;
        }
        if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
            // Add all found tokens to `prev`s children.
            prev.children = prev.children.concat(queue);
            siblings.splice(index, count);
            // Update position.
            if (prev.position && tail.position) prev.position.end = tail.position.end;
            // Next, iterate over the node *now* at the current position.
            return index;
        }
    }
}
var $560639d49e3c9a19$var$mergeInitialisms_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialisms);
var $560639d49e3c9a19$var$numerical = $560639d49e3c9a19$var$expressions.numerical;
// Merge initialisms.
function $560639d49e3c9a19$var$mergeInitialisms(child, index, parent) {
    var siblings;
    var prev;
    var children;
    var length;
    var position;
    var otherChild;
    var isAllDigits;
    var value;
    if (index !== 0 && $560639d49e3c9a19$var$nlcstToString_1(child) === ".") {
        siblings = parent.children;
        prev = siblings[index - 1];
        children = prev.children;
        length = children && children.length;
        if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
            position = length;
            isAllDigits = true;
            while(children[--position]){
                otherChild = children[position];
                value = $560639d49e3c9a19$var$nlcstToString_1(otherChild);
                if (position % 2 === 0) {
                    // Initialisms consist of one character values.
                    if (value.length > 1) return;
                    if (!$560639d49e3c9a19$var$numerical.test(value)) isAllDigits = false;
                } else if (value !== ".") {
                    if (position < length - 2) break;
                    else return;
                }
            }
            if (!isAllDigits) {
                // Remove `child` from parent.
                siblings.splice(index, 1);
                // Add child to the previous children.
                children.push(child);
                // Update position.
                if (prev.position && child.position) prev.position.end = child.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
        }
    }
}
var $560639d49e3c9a19$var$mergeWords = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeFinalWordSymbol);
// Merge multiple words. This merges the children of adjacent words, something
// which should not occur naturally by parse-latin, but might happen when custom
// tokens were passed in.
function $560639d49e3c9a19$var$mergeFinalWordSymbol(child, index, parent) {
    var siblings = parent.children;
    var next;
    if (child.type === "WordNode") {
        next = siblings[index + 1];
        if (next && next.type === "WordNode") {
            // Remove `next` from parent.
            siblings.splice(index + 1, 1);
            // Add the punctuation mark at the end of the previous node.
            child.children = child.children.concat(next.children);
            // Update position.
            if (next.position && child.position) child.position.end = next.position.end;
            // Next, re-iterate the current node.
            return index;
        }
    }
}
var $560639d49e3c9a19$var$unistUtilVisitChildren = $560639d49e3c9a19$var$visitChildren;
function $560639d49e3c9a19$var$visitChildren(callback) {
    return visitor;
    // Visit `parent`, invoking `callback` for each child.
    function visitor(parent) {
        var index = -1;
        var children = parent && parent.children;
        if (!children) throw new Error("Missing children in `parent` for `visitor`");
        while(++index in children)callback(children[index], index, parent);
    }
}
var $560639d49e3c9a19$var$patchPosition_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$patchPosition);
// Patch the position on a parent node based on its first and last child.
function $560639d49e3c9a19$var$patchPosition(child, index, node) {
    var siblings = node.children;
    if (!child.position) return;
    if (index === 0 && (!node.position || /* istanbul ignore next */ !node.position.start)) {
        $560639d49e3c9a19$var$patch(node);
        node.position.start = child.position.start;
    }
    if (index === siblings.length - 1 && (!node.position || !node.position.end)) {
        $560639d49e3c9a19$var$patch(node);
        node.position.end = child.position.end;
    }
}
// Add a `position` object when it does not yet exist on `node`.
function $560639d49e3c9a19$var$patch(node) {
    if (!node.position) node.position = {};
}
var $560639d49e3c9a19$var$mergeNonWordSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeNonWordSentences);
// Merge a sentence into the following sentence, when the sentence does not
// contain word tokens.
function $560639d49e3c9a19$var$mergeNonWordSentences(child, index, parent) {
    var children = child.children;
    var position = -1;
    var prev;
    var next;
    while(children[++position]){
        if (children[position].type === "WordNode") return;
    }
    prev = parent.children[index - 1];
    if (prev) {
        prev.children = prev.children.concat(children);
        // Remove the child.
        parent.children.splice(index, 1);
        // Patch position.
        if (prev.position && child.position) prev.position.end = child.position.end;
        // Next, iterate over the node *now* at the current position (which was the
        // next node).
        return index;
    }
    next = parent.children[index + 1];
    if (next) {
        next.children = children.concat(next.children);
        // Patch position.
        if (next.position && child.position) next.position.start = child.position.start;
        // Remove the child.
        parent.children.splice(index, 1);
    }
}
var $560639d49e3c9a19$var$mergeAffixSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeAffixSymbol);
// Closing or final punctuation, or terminal markers that should still be
// included in the previous sentence, even though they follow the sentence’s
// terminal marker.
var $560639d49e3c9a19$var$affixSymbol = $560639d49e3c9a19$var$expressions.affixSymbol;
// Move certain punctuation following a terminal marker (thus in the next
// sentence) to the previous sentence.
function $560639d49e3c9a19$var$mergeAffixSymbol(child, index, parent) {
    var children = child.children;
    var first;
    var second;
    var prev;
    if (children && children.length !== 0 && index !== 0) {
        first = children[0];
        second = children[1];
        prev = parent.children[index - 1];
        if ((first.type === "SymbolNode" || first.type === "PunctuationNode") && $560639d49e3c9a19$var$affixSymbol.test($560639d49e3c9a19$var$nlcstToString_1(first))) {
            prev.children.push(children.shift());
            // Update position.
            if (first.position && prev.position) prev.position.end = first.position.end;
            if (second && second.position && child.position) child.position.start = second.position.start;
            // Next, iterate over the previous node again.
            return index - 1;
        }
    }
}
var $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences);
// Initial lowercase letter.
var $560639d49e3c9a19$var$lowerInitial = $560639d49e3c9a19$var$expressions.lowerInitial;
// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences(child, index, parent) {
    var children = child.children;
    var position;
    var node;
    var siblings;
    var prev;
    if (children && children.length !== 0 && index !== 0) {
        position = -1;
        while(children[++position]){
            node = children[position];
            if (node.type === "WordNode") {
                if (!$560639d49e3c9a19$var$lowerInitial.test($560639d49e3c9a19$var$nlcstToString_1(node))) return;
                siblings = parent.children;
                prev = siblings[index - 1];
                prev.children = prev.children.concat(children);
                siblings.splice(index, 1);
                // Update position.
                if (prev.position && child.position) prev.position.end = child.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
            if (node.type === "SymbolNode" || node.type === "PunctuationNode") return;
        }
    }
}
var $560639d49e3c9a19$var$mergeInitialDigitSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialDigitSentences);
// Initial lowercase letter.
var $560639d49e3c9a19$var$digit = $560639d49e3c9a19$var$expressions.digitStart;
// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function $560639d49e3c9a19$var$mergeInitialDigitSentences(child, index, parent) {
    var children = child.children;
    var siblings = parent.children;
    var prev = siblings[index - 1];
    var head = children[0];
    if (prev && head && head.type === "WordNode" && $560639d49e3c9a19$var$digit.test($560639d49e3c9a19$var$nlcstToString_1(head))) {
        prev.children = prev.children.concat(children);
        siblings.splice(index, 1);
        // Update position.
        if (prev.position && child.position) prev.position.end = child.position.end;
        // Next, iterate over the node *now* at the current position.
        return index;
    }
}
var $560639d49e3c9a19$var$mergePrefixExceptions_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergePrefixExceptions);
// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var $560639d49e3c9a19$var$abbreviationPrefix = new RegExp("^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$");
// Merge a sentence into its next sentence, when the sentence ends with a
// certain word.
function $560639d49e3c9a19$var$mergePrefixExceptions(child, index, parent) {
    var children = child.children;
    var period;
    var node;
    var next;
    if (children && children.length > 1) {
        period = children[children.length - 1];
        if (period && $560639d49e3c9a19$var$nlcstToString_1(period) === ".") {
            node = children[children.length - 2];
            if (node && node.type === "WordNode" && $560639d49e3c9a19$var$abbreviationPrefix.test($560639d49e3c9a19$var$nlcstToString_1(node).toLowerCase())) {
                // Merge period into abbreviation.
                node.children.push(period);
                children.pop();
                // Update position.
                if (period.position && node.position) node.position.end = period.position.end;
                // Merge sentences.
                next = parent.children[index + 1];
                if (next) {
                    child.children = children.concat(next.children);
                    parent.children.splice(index + 1, 1);
                    // Update position.
                    if (next.position && child.position) child.position.end = next.position.end;
                    // Next, iterate over the current node again.
                    return index - 1;
                }
            }
        }
    }
}
var $560639d49e3c9a19$var$mergeAffixExceptions_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeAffixExceptions);
// Merge a sentence into its previous sentence, when the sentence starts with a
// comma.
function $560639d49e3c9a19$var$mergeAffixExceptions(child, index, parent) {
    var children = child.children;
    var node;
    var position;
    var value;
    var previousChild;
    if (!children || children.length === 0 || index === 0) return;
    position = -1;
    while(children[++position]){
        node = children[position];
        if (node.type === "WordNode") return;
        if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
            value = $560639d49e3c9a19$var$nlcstToString_1(node);
            if (value !== "," && value !== ";") return;
            previousChild = parent.children[index - 1];
            previousChild.children = previousChild.children.concat(children);
            // Update position.
            if (previousChild.position && child.position) previousChild.position.end = child.position.end;
            parent.children.splice(index, 1);
            // Next, iterate over the node *now* at the current position.
            return index;
        }
    }
}
var $560639d49e3c9a19$var$mergeRemainingFullStops_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$mergeRemainingFullStops);
// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var $560639d49e3c9a19$var$terminalMarker = $560639d49e3c9a19$var$expressions.terminalMarker;
// Merge non-terminal-marker full stops into the previous word (if available),
// or the next word (if available).
function $560639d49e3c9a19$var$mergeRemainingFullStops(child) {
    var children = child.children;
    var position = children.length;
    var hasFoundDelimiter = false;
    var grandchild;
    var prev;
    var next;
    var nextNext;
    while(children[--position]){
        grandchild = children[position];
        if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
            // This is a sentence without terminal marker, so we 'fool' the code to
            // make it think we have found one.
            if (grandchild.type === "WordNode") hasFoundDelimiter = true;
            continue;
        }
        // Exit when this token is not a terminal marker.
        if (!$560639d49e3c9a19$var$terminalMarker.test($560639d49e3c9a19$var$nlcstToString_1(grandchild))) continue;
        // Ignore the first terminal marker found (starting at the end), as it
        // should not be merged.
        if (!hasFoundDelimiter) {
            hasFoundDelimiter = true;
            continue;
        }
        // Only merge a single full stop.
        if ($560639d49e3c9a19$var$nlcstToString_1(grandchild) !== ".") continue;
        prev = children[position - 1];
        next = children[position + 1];
        if (prev && prev.type === "WordNode") {
            nextNext = children[position + 2];
            // Continue when the full stop is followed by a space and another full
            // stop, such as: `{.} .`
            if (next && nextNext && next.type === "WhiteSpaceNode" && $560639d49e3c9a19$var$nlcstToString_1(nextNext) === ".") continue;
            // Remove `child` from parent.
            children.splice(position, 1);
            // Add the punctuation mark at the end of the previous node.
            prev.children.push(grandchild);
            // Update position.
            if (grandchild.position && prev.position) prev.position.end = grandchild.position.end;
            position--;
        } else if (next && next.type === "WordNode") {
            // Remove `child` from parent.
            children.splice(position, 1);
            // Add the punctuation mark at the start of the next node.
            next.children.unshift(grandchild);
            if (grandchild.position && next.position) next.position.start = grandchild.position.start;
        }
    }
}
var $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings);
// Move white space starting a sentence up, so they are the siblings of
// sentences.
function $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings(child, index, parent) {
    var children = child.children;
    var next;
    if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
        parent.children.splice(index, 0, children.shift());
        next = children[0];
        if (next && next.position && child.position) child.position.start = next.position.start;
    }
}
var $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings);
// Move white space ending a paragraph up, so they are the siblings of
// paragraphs.
function $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings(child, index, parent) {
    var children = child.children;
    var prev;
    if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
        parent.children.splice(index + 1, 0, child.children.pop());
        prev = children[children.length - 1];
        if (prev && prev.position && child.position) child.position.end = prev.position.end;
        // Next, iterate over the current node again.
        return index;
    }
}
var $560639d49e3c9a19$var$breakImplicitSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$breakImplicitSentences);
// Two or more new line characters.
var $560639d49e3c9a19$var$multiNewLine = $560639d49e3c9a19$var$expressions.newLineMulti;
// Break a sentence if a white space with more than one new-line is found.
function $560639d49e3c9a19$var$breakImplicitSentences(child, index, parent) {
    var children;
    var position;
    var length;
    var tail;
    var head;
    var end;
    var insertion;
    var node;
    if (child.type !== "SentenceNode") return;
    children = child.children;
    // Ignore first and last child.
    length = children.length - 1;
    position = 0;
    while(++position < length){
        node = children[position];
        if (node.type !== "WhiteSpaceNode" || !$560639d49e3c9a19$var$multiNewLine.test($560639d49e3c9a19$var$nlcstToString_1(node))) continue;
        child.children = children.slice(0, position);
        insertion = {
            type: "SentenceNode",
            children: children.slice(position + 1)
        };
        tail = children[position - 1];
        head = children[position + 1];
        parent.children.splice(index + 1, 0, node, insertion);
        if (child.position && tail.position && head.position) {
            end = child.position.end;
            child.position.end = tail.position.end;
            insertion.position = {
                start: head.position.start,
                end: end
            };
        }
        return index + 1;
    }
}
var $560639d49e3c9a19$var$removeEmptyNodes_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$removeEmptyNodes);
// Remove empty children.
function $560639d49e3c9a19$var$removeEmptyNodes(child, index, parent) {
    if ("children" in child && child.children.length === 0) {
        parent.children.splice(index, 1);
        // Next, iterate over the node *now* at the current position (which was the
        // next node).
        return index;
    }
}
var $560639d49e3c9a19$var$lib = $560639d49e3c9a19$var$ParseLatin;
// PARSE LATIN
// Transform Latin-script natural language into an NLCST-tree.
function $560639d49e3c9a19$var$ParseLatin(doc, file) {
    var value = file || doc;
    if (!(this instanceof $560639d49e3c9a19$var$ParseLatin)) return new $560639d49e3c9a19$var$ParseLatin(doc, file);
    this.doc = value ? String(value) : null;
}
// Quick access to the prototype.
var $560639d49e3c9a19$var$proto = $560639d49e3c9a19$var$ParseLatin.prototype;
// Default position.
$560639d49e3c9a19$var$proto.position = true;
// Create text nodes.
$560639d49e3c9a19$var$proto.tokenizeSymbol = $560639d49e3c9a19$var$createTextFactory("Symbol");
$560639d49e3c9a19$var$proto.tokenizeWhiteSpace = $560639d49e3c9a19$var$createTextFactory("WhiteSpace");
$560639d49e3c9a19$var$proto.tokenizePunctuation = $560639d49e3c9a19$var$createTextFactory("Punctuation");
$560639d49e3c9a19$var$proto.tokenizeSource = $560639d49e3c9a19$var$createTextFactory("Source");
$560639d49e3c9a19$var$proto.tokenizeText = $560639d49e3c9a19$var$createTextFactory("Text");
// Expose `run`.
$560639d49e3c9a19$var$proto.run = $560639d49e3c9a19$var$run;
// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context.
$560639d49e3c9a19$var$proto.use = $560639d49e3c9a19$var$useFactory(function(context, key, plugins) {
    context[key] = context[key].concat(plugins);
});
// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context, before any other.
$560639d49e3c9a19$var$proto.useFirst = $560639d49e3c9a19$var$useFactory(function(context, key, plugins) {
    context[key] = plugins.concat(context[key]);
});
// Easy access to the document parser. This additionally supports retext-style
// invocation: where an instance is created for each file, and the file is given
// on construction.
$560639d49e3c9a19$var$proto.parse = function(value) {
    return this.tokenizeRoot(value || this.doc);
};
// Transform a `value` into a list of `NLCSTNode`s.
$560639d49e3c9a19$var$proto.tokenize = function(value) {
    return $560639d49e3c9a19$var$tokenize(this, value);
};
// PARENT NODES
//
// All these nodes are `pluggable`: they come with a `use` method which accepts
// a plugin (`function(NLCSTNode)`).
// Every time one of these methods are called, the plugin is invoked with the
// node, allowing for easy modification.
//
// In fact, the internal transformation from `tokenize` (a list of words, white
// space, punctuation, and symbols) to `tokenizeRoot` (an NLCST tree), is also
// implemented through this mechanism.
// Create a `WordNode` with its children set to a single `TextNode`, its value
// set to the given `value`.
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeWord", function(value, eat) {
    var add = (eat || $560639d49e3c9a19$var$noopEat)("");
    var parent = {
        type: "WordNode",
        children: []
    };
    this.tokenizeText(value, eat, parent);
    return add(parent);
});
// Create a `SentenceNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the sentence is populated by `WordNode`s,
// `SymbolNode`s, `PunctuationNode`s, and `WhiteSpaceNode`s.
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeSentence", $560639d49e3c9a19$var$parser({
    type: "SentenceNode",
    tokenizer: "tokenize"
}));
// Create a `ParagraphNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the paragraph is populated by `SentenceNode`s
// and `WhiteSpaceNode`s.
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeParagraph", $560639d49e3c9a19$var$parser({
    type: "ParagraphNode",
    delimiter: $560639d49e3c9a19$var$expressions.terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
}));
// Create a `RootNode` with its children set to `Node`s, their values set to the
// tokenized given `value`.
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeRoot", $560639d49e3c9a19$var$parser({
    type: "RootNode",
    delimiter: $560639d49e3c9a19$var$expressions.newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
}));
// PLUGINS
$560639d49e3c9a19$var$proto.use("tokenizeSentence", [
    $560639d49e3c9a19$var$mergeInitialWordSymbol_1,
    $560639d49e3c9a19$var$mergeFinalWordSymbol_1,
    $560639d49e3c9a19$var$mergeInnerWordSymbol_1,
    $560639d49e3c9a19$var$mergeInnerWordSlash_1,
    $560639d49e3c9a19$var$mergeInitialisms_1,
    $560639d49e3c9a19$var$mergeWords,
    $560639d49e3c9a19$var$patchPosition_1
]);
$560639d49e3c9a19$var$proto.use("tokenizeParagraph", [
    $560639d49e3c9a19$var$mergeNonWordSentences_1,
    $560639d49e3c9a19$var$mergeAffixSymbol_1,
    $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences_1,
    $560639d49e3c9a19$var$mergeInitialDigitSentences_1,
    $560639d49e3c9a19$var$mergePrefixExceptions_1,
    $560639d49e3c9a19$var$mergeAffixExceptions_1,
    $560639d49e3c9a19$var$mergeRemainingFullStops_1,
    $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1,
    $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1,
    $560639d49e3c9a19$var$breakImplicitSentences_1,
    $560639d49e3c9a19$var$removeEmptyNodes_1,
    $560639d49e3c9a19$var$patchPosition_1
]);
$560639d49e3c9a19$var$proto.use("tokenizeRoot", [
    $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1,
    $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1,
    $560639d49e3c9a19$var$removeEmptyNodes_1,
    $560639d49e3c9a19$var$patchPosition_1
]);
// TEXT NODES
// Factory to create a `Text`.
function $560639d49e3c9a19$var$createTextFactory(type) {
    type += "Node";
    return createText;
    // Construct a `Text` from a bound `type`
    function createText(value, eat, parent) {
        if (value === null || value === undefined) value = "";
        return (eat || $560639d49e3c9a19$var$noopEat)(value)({
            type: type,
            value: String(value)
        }, parent);
    }
}
// Run transform plug-ins for `key` on `nodes`.
function $560639d49e3c9a19$var$run(key, nodes) {
    var wareKey = key + "Plugins";
    var plugins = this[wareKey];
    var index = -1;
    if (plugins) while(plugins[++index])plugins[index](nodes);
    return nodes;
}
// Make a method “pluggable”.
function $560639d49e3c9a19$var$pluggable(Constructor, key, callback) {
    // Set a pluggable version of `callback` on `Constructor`.
    Constructor.prototype[key] = function() {
        return this.run(key, callback.apply(this, arguments));
    };
}
// Factory to inject `plugins`. Takes `callback` for the actual inserting.
function $560639d49e3c9a19$var$useFactory(callback) {
    return use;
    // Validate if `plugins` can be inserted.
    // Invokes the bound `callback` to do the actual inserting.
    function use(key, plugins) {
        var self = this;
        var wareKey;
        // Throw if the method is not pluggable.
        if (!(key in self)) throw new Error("Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function");
        // Fail silently when no plugins are given.
        if (!plugins) return;
        wareKey = key + "Plugins";
        // Make sure `plugins` is a list.
        if (typeof plugins === "function") plugins = [
            plugins
        ];
        else plugins = plugins.concat();
        // Make sure `wareKey` exists.
        if (!self[wareKey]) self[wareKey] = [];
        // Invoke callback with the ware key and plugins.
        callback(self, wareKey, plugins);
    }
}
// CLASSIFY
// Match a word character.
var $560639d49e3c9a19$var$wordRe = $560639d49e3c9a19$var$expressions.word;
// Match a surrogate character.
var $560639d49e3c9a19$var$surrogatesRe = $560639d49e3c9a19$var$expressions.surrogates;
// Match a punctuation character.
var $560639d49e3c9a19$var$punctuationRe = $560639d49e3c9a19$var$expressions.punctuation;
// Match a white space character.
var $560639d49e3c9a19$var$whiteSpaceRe = $560639d49e3c9a19$var$expressions.whiteSpace;
// Transform a `value` into a list of `NLCSTNode`s.
function $560639d49e3c9a19$var$tokenize(parser, value) {
    var tokens;
    var offset;
    var line;
    var column;
    var index;
    var length;
    var character;
    var queue;
    var prev;
    var left;
    var right;
    var eater;
    if (value === null || value === undefined) value = "";
    else if (value instanceof String) value = value.toString();
    if (typeof value !== "string") {
        // Return the given nodes if this is either an empty array, or an array with
        // a node as a first child.
        if ("length" in value && (!value[0] || value[0].type)) return value;
        throw new Error("Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'");
    }
    tokens = [];
    if (!value) return tokens;
    index = 0;
    offset = 0;
    line = 1;
    column = 1;
    // Eat mechanism to use.
    eater = parser.position ? eat : noPositionEat;
    length = value.length;
    prev = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if ($560639d49e3c9a19$var$whiteSpaceRe.test(character)) right = "WhiteSpace";
        else if ($560639d49e3c9a19$var$punctuationRe.test(character)) right = "Punctuation";
        else if ($560639d49e3c9a19$var$wordRe.test(character)) right = "Word";
        else right = "Symbol";
        tick();
        prev = character;
        character = "";
        left = right;
        right = null;
        index++;
    }
    tick();
    return tokens;
    // Check one character.
    function tick() {
        if (left === right && (left === "Word" || left === "WhiteSpace" || character === prev || $560639d49e3c9a19$var$surrogatesRe.test(character))) queue += character;
        else {
            // Flush the previous queue.
            if (queue) parser["tokenize" + left](queue, eater);
            queue = character;
        }
    }
    // Remove `subvalue` from `value`.
    // Expects `subvalue` to be at the start from `value`, and applies no
    // validation.
    function eat(subvalue) {
        var pos = position();
        update(subvalue);
        return apply;
        // Add the given arguments, add `position` to the returned node, and return
        // the node.
        function apply() {
            return pos(add.apply(null, arguments));
        }
    }
    // Remove `subvalue` from `value`.
    // Does not patch positional information.
    function noPositionEat() {
        return apply;
        // Add the given arguments and return the node.
        function apply() {
            return add.apply(null, arguments);
        }
    }
    // Add mechanism.
    function add(node, parent) {
        if (parent) parent.children.push(node);
        else tokens.push(node);
        return node;
    }
    // Mark position and patch `node.position`.
    function position() {
        var before = now();
        // Add the position to a node.
        function patch(node) {
            node.position = new Position(before);
            return node;
        }
        return patch;
    }
    // Update line and column based on `value`.
    function update(subvalue) {
        var subvalueLength = subvalue.length;
        var character = -1;
        var lastIndex = -1;
        offset += subvalueLength;
        while(++character < subvalueLength)if (subvalue.charAt(character) === "\n") {
            lastIndex = character;
            line++;
        }
        if (lastIndex === -1) column += subvalueLength;
        else column = subvalueLength - lastIndex;
    }
    // Store position information for a node.
    function Position(start) {
        this.start = start;
        this.end = now();
    }
    // Get the current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: offset
        };
    }
}
// Add mechanism used when text-tokenisers are called directly outside of the
// `tokenize` function.
function $560639d49e3c9a19$var$noopAdd(node, parent) {
    if (parent) parent.children.push(node);
    return node;
}
// Eat and add mechanism without adding positional information, used when
// text-tokenisers are called directly outside of the `tokenize` function.
function $560639d49e3c9a19$var$noopEat() {
    return $560639d49e3c9a19$var$noopAdd;
}
var $560639d49e3c9a19$var$parseLatin = $560639d49e3c9a19$var$lib;
var $560639d49e3c9a19$var$retextLatin = $560639d49e3c9a19$var$parse$1;
$560639d49e3c9a19$var$parse$1.Parser = $560639d49e3c9a19$var$parseLatin;
function $560639d49e3c9a19$var$parse$1() {
    this.Parser = $560639d49e3c9a19$var$unherit_1($560639d49e3c9a19$var$parseLatin);
}
var $560639d49e3c9a19$var$retextStringify = $560639d49e3c9a19$var$stringify$1;
function $560639d49e3c9a19$var$stringify$1() {
    this.Compiler = $560639d49e3c9a19$var$compiler;
}
function $560639d49e3c9a19$var$compiler(tree) {
    return $560639d49e3c9a19$var$nlcstToString_1(tree);
}
var $560639d49e3c9a19$var$retext = $560639d49e3c9a19$var$unified_1().use($560639d49e3c9a19$var$retextLatin).use($560639d49e3c9a19$var$retextStringify).freeze();
var $560639d49e3c9a19$var$retextSmartypants = $560639d49e3c9a19$var$smartypants;
var $560639d49e3c9a19$var$punctuation = "PunctuationNode";
var $560639d49e3c9a19$var$symbol = "SymbolNode";
var $560639d49e3c9a19$var$word = "WordNode";
var $560639d49e3c9a19$var$whiteSpace = "WhiteSpaceNode";
var $560639d49e3c9a19$var$decadeExpression = /^\d\ds$/;
var $560639d49e3c9a19$var$threeFullStopsExpression = /^\.{3,}$/;
var $560639d49e3c9a19$var$fullStopsExpression = /^\.+$/;
var $560639d49e3c9a19$var$threeDashes = "---";
var $560639d49e3c9a19$var$twoDashes = "--";
var $560639d49e3c9a19$var$emDash = "\u2014";
var $560639d49e3c9a19$var$enDash = "\u2013";
var $560639d49e3c9a19$var$ellipsis = "\u2026";
var $560639d49e3c9a19$var$twoBackticks = "``";
var $560639d49e3c9a19$var$backtick = "`";
var $560639d49e3c9a19$var$twoSingleQuotes = "''";
var $560639d49e3c9a19$var$singleQuote = "'";
var $560639d49e3c9a19$var$apostrophe = "\u2019";
var $560639d49e3c9a19$var$doubleQuote = '"';
var $560639d49e3c9a19$var$openingDoubleQuote = "\u201C";
var $560639d49e3c9a19$var$closingDoubleQuote = "\u201D";
var $560639d49e3c9a19$var$openingSingleQuote = "\u2018";
var $560639d49e3c9a19$var$closingSingleQuote = "\u2019";
var $560639d49e3c9a19$var$closingQuotes = {};
var $560639d49e3c9a19$var$openingQuotes = {};
$560639d49e3c9a19$var$openingQuotes[$560639d49e3c9a19$var$doubleQuote] = $560639d49e3c9a19$var$openingDoubleQuote;
$560639d49e3c9a19$var$closingQuotes[$560639d49e3c9a19$var$doubleQuote] = $560639d49e3c9a19$var$closingDoubleQuote;
$560639d49e3c9a19$var$openingQuotes[$560639d49e3c9a19$var$singleQuote] = $560639d49e3c9a19$var$openingSingleQuote;
$560639d49e3c9a19$var$closingQuotes[$560639d49e3c9a19$var$singleQuote] = $560639d49e3c9a19$var$closingSingleQuote;
var $560639d49e3c9a19$var$educators = {};
// Expose educators.
$560639d49e3c9a19$var$educators.dashes = {
    true: $560639d49e3c9a19$var$dashes,
    oldschool: $560639d49e3c9a19$var$oldschool,
    inverted: $560639d49e3c9a19$var$inverted
};
$560639d49e3c9a19$var$educators.backticks = {
    true: $560639d49e3c9a19$var$backticks,
    all: $560639d49e3c9a19$var$all
};
$560639d49e3c9a19$var$educators.ellipses = {
    true: $560639d49e3c9a19$var$ellipses
};
$560639d49e3c9a19$var$educators.quotes = {
    true: $560639d49e3c9a19$var$quotes
};
// Attacher.
function $560639d49e3c9a19$var$smartypants(options) {
    var methods = [];
    var quotes;
    var ellipses;
    var backticks;
    var dashes;
    if (!options) options = {};
    if ("quotes" in options) {
        quotes = options.quotes;
        if (quotes !== Boolean(quotes)) throw new TypeError("Illegal invocation: `" + quotes + "` " + "is not a valid value for `quotes` in " + "`smartypants`");
    } else quotes = true;
    if ("ellipses" in options) {
        ellipses = options.ellipses;
        if (ellipses !== Boolean(ellipses)) throw new TypeError("Illegal invocation: `" + ellipses + "` " + "is not a valid value for `ellipses` in " + "`smartypants`");
    } else ellipses = true;
    if ("backticks" in options) {
        backticks = options.backticks;
        if (backticks !== Boolean(backticks) && backticks !== "all") throw new TypeError("Illegal invocation: `" + backticks + "` " + "is not a valid value for `backticks` in " + "`smartypants`");
        if (backticks === "all" && quotes === true) throw new TypeError("Illegal invocation: `backticks: " + backticks + "` is not a valid value " + "when `quotes: " + quotes + "` in " + "`smartypants`");
    } else backticks = true;
    if ("dashes" in options) {
        dashes = options.dashes;
        if (dashes !== Boolean(dashes) && dashes !== "oldschool" && dashes !== "inverted") throw new TypeError("Illegal invocation: `" + dashes + "` " + "is not a valid value for `dahes` in " + "`smartypants`");
    } else dashes = true;
    if (quotes !== false) methods.push($560639d49e3c9a19$var$educators.quotes[quotes]);
    if (ellipses !== false) methods.push($560639d49e3c9a19$var$educators.ellipses[ellipses]);
    if (backticks !== false) methods.push($560639d49e3c9a19$var$educators.backticks[backticks]);
    if (dashes !== false) methods.push($560639d49e3c9a19$var$educators.dashes[dashes]);
    return $560639d49e3c9a19$var$transformFactory(methods);
}
// Create a transformer for the bound methods.
function $560639d49e3c9a19$var$transformFactory(methods) {
    var length = methods.length;
    return transformer;
    // Transformer.
    function transformer(tree) {
        $560639d49e3c9a19$var$unistUtilVisit(tree, visitor);
    }
    function visitor(node, position, parent) {
        var index = -1;
        if (node.type === $560639d49e3c9a19$var$punctuation || node.type === $560639d49e3c9a19$var$symbol) while(++index < length)methods[index](node, position, parent);
    }
}
// Transform three dahes into an em-dash, and two into an en-dash.
function $560639d49e3c9a19$var$oldschool(node) {
    if (node.value === $560639d49e3c9a19$var$threeDashes) node.value = $560639d49e3c9a19$var$emDash;
    else if (node.value === $560639d49e3c9a19$var$twoDashes) node.value = $560639d49e3c9a19$var$enDash;
}
// Transform two dahes into an em-dash.
function $560639d49e3c9a19$var$dashes(node) {
    if (node.value === $560639d49e3c9a19$var$twoDashes) node.value = $560639d49e3c9a19$var$emDash;
}
// Transform three dahes into an en-dash, and two into an em-dash.
function $560639d49e3c9a19$var$inverted(node) {
    if (node.value === $560639d49e3c9a19$var$threeDashes) node.value = $560639d49e3c9a19$var$enDash;
    else if (node.value === $560639d49e3c9a19$var$twoDashes) node.value = $560639d49e3c9a19$var$emDash;
}
// Transform double backticks and single quotes into smart quotes.
function $560639d49e3c9a19$var$backticks(node) {
    if (node.value === $560639d49e3c9a19$var$twoBackticks) node.value = $560639d49e3c9a19$var$openingDoubleQuote;
    else if (node.value === $560639d49e3c9a19$var$twoSingleQuotes) node.value = $560639d49e3c9a19$var$closingDoubleQuote;
}
// Transform single and double backticks and single quotes into smart quotes.
function $560639d49e3c9a19$var$all(node) {
    $560639d49e3c9a19$var$backticks(node);
    if (node.value === $560639d49e3c9a19$var$backtick) node.value = $560639d49e3c9a19$var$openingSingleQuote;
    else if (node.value === $560639d49e3c9a19$var$singleQuote) node.value = $560639d49e3c9a19$var$closingSingleQuote;
}
// Transform multiple dots into unicode ellipses.
function $560639d49e3c9a19$var$ellipses(node, index, parent) {
    var value = node.value;
    var siblings = parent.children;
    var position;
    var nodes;
    var sibling;
    var type;
    var count;
    var queue;
    // Simple node with three dots and without white-space.
    if ($560639d49e3c9a19$var$threeFullStopsExpression.test(node.value)) {
        node.value = $560639d49e3c9a19$var$ellipsis;
        return;
    }
    if (!$560639d49e3c9a19$var$fullStopsExpression.test(value)) return;
    // Search for dot-nodes with white-space between.
    nodes = [];
    position = index;
    count = 1;
    // It’s possible that the node is merged with an adjacent word-node.  In that
    // code, we cannot transform it because there’s no reference to the
    // grandparent.
    while(--position > 0){
        sibling = siblings[position];
        if (sibling.type !== $560639d49e3c9a19$var$whiteSpace) break;
        queue = sibling;
        sibling = siblings[--position];
        type = sibling && sibling.type;
        if (sibling && (type === $560639d49e3c9a19$var$punctuation || type === $560639d49e3c9a19$var$symbol) && $560639d49e3c9a19$var$fullStopsExpression.test(sibling.value)) {
            nodes.push(queue, sibling);
            count++;
            continue;
        }
        break;
    }
    if (count < 3) return;
    siblings.splice(index - nodes.length, nodes.length);
    node.value = $560639d49e3c9a19$var$ellipsis;
}
// Transform straight single- and double quotes into smart quotes.
// eslint-disable-next-line complexity
function $560639d49e3c9a19$var$quotes(node, index, parent) {
    var siblings = parent.children;
    var value = node.value;
    var next;
    var nextNext;
    var prev;
    var nextValue;
    if (value !== $560639d49e3c9a19$var$doubleQuote && value !== $560639d49e3c9a19$var$singleQuote) return;
    prev = siblings[index - 1];
    next = siblings[index + 1];
    nextNext = siblings[index + 2];
    nextValue = next && $560639d49e3c9a19$var$nlcstToString_1(next);
    if (next && nextNext && (next.type === $560639d49e3c9a19$var$punctuation || next.type === $560639d49e3c9a19$var$symbol) && nextNext.type !== $560639d49e3c9a19$var$word) // Special case if the very first character is a quote followed by
    // punctuation at a non-word-break. Close the quotes by brute force.
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
    else if (nextNext && (nextValue === $560639d49e3c9a19$var$doubleQuote || nextValue === $560639d49e3c9a19$var$singleQuote) && nextNext.type === $560639d49e3c9a19$var$word) {
        // Special case for double sets of quotes:
        // `He said, "'Quoted' words in a larger quote."`
        node.value = $560639d49e3c9a19$var$openingQuotes[value];
        next.value = $560639d49e3c9a19$var$openingQuotes[nextValue];
    } else if (next && $560639d49e3c9a19$var$decadeExpression.test(nextValue)) // Special case for decade abbreviations: `the '80s`
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
    else if (prev && next && (prev.type === $560639d49e3c9a19$var$whiteSpace || prev.type === $560639d49e3c9a19$var$punctuation || prev.type === $560639d49e3c9a19$var$symbol) && next.type === $560639d49e3c9a19$var$word) // Get most opening single quotes.
    node.value = $560639d49e3c9a19$var$openingQuotes[value];
    else if (prev && prev.type !== $560639d49e3c9a19$var$whiteSpace && prev.type !== $560639d49e3c9a19$var$symbol && prev.type !== $560639d49e3c9a19$var$punctuation) // Closing quotes.
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
    else if (!next || next.type === $560639d49e3c9a19$var$whiteSpace || (value === $560639d49e3c9a19$var$singleQuote || value === $560639d49e3c9a19$var$apostrophe) && nextValue === "s") node.value = $560639d49e3c9a19$var$closingQuotes[value];
    else node.value = $560639d49e3c9a19$var$openingQuotes[value];
}
function $560639d49e3c9a19$var$isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
}
function $560639d49e3c9a19$var$isObject(subject) {
    return typeof subject === "object" && subject !== null;
}
function $560639d49e3c9a19$var$toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if ($560639d49e3c9a19$var$isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function $560639d49e3c9a19$var$extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function $560639d49e3c9a19$var$repeat(string, count) {
    var result = "", cycle;
    for(cycle = 0; cycle < count; cycle += 1)result += string;
    return result;
}
function $560639d49e3c9a19$var$isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var $560639d49e3c9a19$var$isNothing_1 = $560639d49e3c9a19$var$isNothing;
var $560639d49e3c9a19$var$isObject_1 = $560639d49e3c9a19$var$isObject;
var $560639d49e3c9a19$var$toArray_1 = $560639d49e3c9a19$var$toArray;
var $560639d49e3c9a19$var$repeat_1 = $560639d49e3c9a19$var$repeat;
var $560639d49e3c9a19$var$isNegativeZero_1 = $560639d49e3c9a19$var$isNegativeZero;
var $560639d49e3c9a19$var$extend_1 = $560639d49e3c9a19$var$extend;
var $560639d49e3c9a19$var$common = {
    isNothing: $560639d49e3c9a19$var$isNothing_1,
    isObject: $560639d49e3c9a19$var$isObject_1,
    toArray: $560639d49e3c9a19$var$toArray_1,
    repeat: $560639d49e3c9a19$var$repeat_1,
    isNegativeZero: $560639d49e3c9a19$var$isNegativeZero_1,
    extend: $560639d49e3c9a19$var$extend_1
};
// YAML error class. http://stackoverflow.com/questions/8458984
function $560639d49e3c9a19$var$YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    // Include stack trace in error object
    if (Error.captureStackTrace) // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
    else // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || "";
}
// Inherit from Error
$560639d49e3c9a19$var$YAMLException$1.prototype = Object.create(Error.prototype);
$560639d49e3c9a19$var$YAMLException$1.prototype.constructor = $560639d49e3c9a19$var$YAMLException$1;
$560639d49e3c9a19$var$YAMLException$1.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) result += " " + this.mark.toString();
    return result;
};
var $560639d49e3c9a19$var$exception = $560639d49e3c9a19$var$YAMLException$1;
function $560639d49e3c9a19$var$Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
}
$560639d49e3c9a19$var$Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer) return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while(start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1){
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
        }
    }
    tail = "";
    end = this.position;
    while(end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1){
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
        }
    }
    snippet = this.buffer.slice(start, end);
    return $560639d49e3c9a19$var$common.repeat(" ", indent) + head + snippet + tail + "\n" + $560639d49e3c9a19$var$common.repeat(" ", indent + this.position - start + head.length) + "^";
};
$560639d49e3c9a19$var$Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) where += 'in "' + this.name + '" ';
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
        snippet = this.getSnippet();
        if (snippet) where += ":\n" + snippet;
    }
    return where;
};
var $560639d49e3c9a19$var$mark = $560639d49e3c9a19$var$Mark;
var $560639d49e3c9a19$var$TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
];
var $560639d49e3c9a19$var$YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
];
function $560639d49e3c9a19$var$compileStyleAliases(map) {
    var result = {};
    if (map !== null) Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
            result[String(alias)] = style;
        });
    });
    return result;
}
function $560639d49e3c9a19$var$Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if ($560639d49e3c9a19$var$TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) throw new $560639d49e3c9a19$var$exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    });
    // TODO: Add tag format check.
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
        return true;
    };
    this.construct = options["construct"] || function(data) {
        return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = $560639d49e3c9a19$var$compileStyleAliases(options["styleAliases"] || null);
    if ($560639d49e3c9a19$var$YAML_NODE_KINDS.indexOf(this.kind) === -1) throw new $560639d49e3c9a19$var$exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var $560639d49e3c9a19$var$type = $560639d49e3c9a19$var$Type$1;
/*eslint-disable max-len*/ function $560639d49e3c9a19$var$compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
        result = $560639d49e3c9a19$var$compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) exclude.push(previousIndex);
        });
        result.push(currentType);
    });
    return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
    });
}
function $560639d49e3c9a19$var$compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
    }, index, length;
    function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for(index = 0, length = arguments.length; index < length; index += 1)arguments[index].forEach(collectType);
    return result;
}
function $560639d49e3c9a19$var$Schema$1(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") throw new $560639d49e3c9a19$var$exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    });
    this.compiledImplicit = $560639d49e3c9a19$var$compileList(this, "implicit", []);
    this.compiledExplicit = $560639d49e3c9a19$var$compileList(this, "explicit", []);
    this.compiledTypeMap = $560639d49e3c9a19$var$compileMap(this.compiledImplicit, this.compiledExplicit);
}
$560639d49e3c9a19$var$Schema$1.DEFAULT = null;
$560639d49e3c9a19$var$Schema$1.create = function createSchema() {
    var schemas, types;
    switch(arguments.length){
        case 1:
            schemas = $560639d49e3c9a19$var$Schema$1.DEFAULT;
            types = arguments[0];
            break;
        case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
        default:
            throw new $560639d49e3c9a19$var$exception("Wrong number of arguments for Schema.create function");
    }
    schemas = $560639d49e3c9a19$var$common.toArray(schemas);
    types = $560639d49e3c9a19$var$common.toArray(types);
    if (!schemas.every(function(schema) {
        return schema instanceof $560639d49e3c9a19$var$Schema$1;
    })) throw new $560639d49e3c9a19$var$exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types.every(function(type$1) {
        return type$1 instanceof $560639d49e3c9a19$var$type;
    })) throw new $560639d49e3c9a19$var$exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new $560639d49e3c9a19$var$Schema$1({
        include: schemas,
        explicit: types
    });
};
var $560639d49e3c9a19$var$schema = $560639d49e3c9a19$var$Schema$1;
var $560639d49e3c9a19$var$str = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
        return data !== null ? data : "";
    }
});
var $560639d49e3c9a19$var$seq = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
        return data !== null ? data : [];
    }
});
var $560639d49e3c9a19$var$map = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
        return data !== null ? data : {};
    }
});
var $560639d49e3c9a19$var$failsafe = new $560639d49e3c9a19$var$schema({
    explicit: [
        $560639d49e3c9a19$var$str,
        $560639d49e3c9a19$var$seq,
        $560639d49e3c9a19$var$map
    ]
});
function $560639d49e3c9a19$var$resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function $560639d49e3c9a19$var$constructYamlNull() {
    return null;
}
function $560639d49e3c9a19$var$isNull(object) {
    return object === null;
}
var $560639d49e3c9a19$var$_null = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlNull,
    construct: $560639d49e3c9a19$var$constructYamlNull,
    predicate: $560639d49e3c9a19$var$isNull,
    represent: {
        canonical: function() {
            return "~";
        },
        lowercase: function() {
            return "null";
        },
        uppercase: function() {
            return "NULL";
        },
        camelcase: function() {
            return "Null";
        }
    },
    defaultStyle: "lowercase"
});
function $560639d49e3c9a19$var$resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function $560639d49e3c9a19$var$constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
}
function $560639d49e3c9a19$var$isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
}
var $560639d49e3c9a19$var$bool = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlBoolean,
    construct: $560639d49e3c9a19$var$constructYamlBoolean,
    predicate: $560639d49e3c9a19$var$isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? "true" : "false";
        },
        uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
            return object ? "True" : "False";
        }
    },
    defaultStyle: "lowercase"
});
function $560639d49e3c9a19$var$isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function $560639d49e3c9a19$var$isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function $560639d49e3c9a19$var$isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function $560639d49e3c9a19$var$resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === "-" || ch === "+") ch = data[++index];
    if (ch === "0") {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === "b") {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "x") {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!$560639d49e3c9a19$var$isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        // base 8
        for(; index < max; index++){
            ch = data[index];
            if (ch === "_") continue;
            if (!$560639d49e3c9a19$var$isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
        }
        return hasDigits && ch !== "_";
    }
    // base 10 (except 0) or base 60
    // value should not start with `_`;
    if (ch === "_") return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === "_") continue;
        if (ch === ":") break;
        if (!$560639d49e3c9a19$var$isDecCode(data.charCodeAt(index))) return false;
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === "_") return false;
    // if !base60 - done;
    if (ch !== ":") return true;
    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function $560639d49e3c9a19$var$constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) value = value.replace(/_/g, "");
    ch = value[0];
    if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseInt(value, 10);
}
function $560639d49e3c9a19$var$isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !$560639d49e3c9a19$var$common.isNegativeZero(object);
}
var $560639d49e3c9a19$var$int_1 = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlInteger,
    construct: $560639d49e3c9a19$var$constructYamlInteger,
    predicate: $560639d49e3c9a19$var$isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [
            2,
            "bin"
        ],
        octal: [
            8,
            "oct"
        ],
        decimal: [
            10,
            "dec"
        ],
        hexadecimal: [
            16,
            "hex"
        ]
    }
});
var $560639d49e3c9a19$var$YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
"^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function $560639d49e3c9a19$var$resolveYamlFloat(data) {
    if (data === null) return false;
    if (!$560639d49e3c9a19$var$YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") return false;
    return true;
}
function $560639d49e3c9a19$var$constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) value = value.slice(1);
    if (value === ".inf") return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    else if (value === ".nan") return NaN;
    else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseFloat(value, 10);
}
var $560639d49e3c9a19$var$SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function $560639d49e3c9a19$var$representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) switch(style){
        case "lowercase":
            return ".nan";
        case "uppercase":
            return ".NAN";
        case "camelcase":
            return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === object) switch(style){
        case "lowercase":
            return ".inf";
        case "uppercase":
            return ".INF";
        case "camelcase":
            return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === object) switch(style){
        case "lowercase":
            return "-.inf";
        case "uppercase":
            return "-.INF";
        case "camelcase":
            return "-.Inf";
    }
    else if ($560639d49e3c9a19$var$common.isNegativeZero(object)) return "-0.0";
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return $560639d49e3c9a19$var$SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function $560639d49e3c9a19$var$isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || $560639d49e3c9a19$var$common.isNegativeZero(object));
}
var $560639d49e3c9a19$var$float_1 = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlFloat,
    construct: $560639d49e3c9a19$var$constructYamlFloat,
    predicate: $560639d49e3c9a19$var$isFloat,
    represent: $560639d49e3c9a19$var$representYamlFloat,
    defaultStyle: "lowercase"
});
var $560639d49e3c9a19$var$json = new $560639d49e3c9a19$var$schema({
    include: [
        $560639d49e3c9a19$var$failsafe
    ],
    implicit: [
        $560639d49e3c9a19$var$_null,
        $560639d49e3c9a19$var$bool,
        $560639d49e3c9a19$var$int_1,
        $560639d49e3c9a19$var$float_1
    ]
});
var $560639d49e3c9a19$var$core = new $560639d49e3c9a19$var$schema({
    include: [
        $560639d49e3c9a19$var$json
    ]
});
var $560639d49e3c9a19$var$YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"); // [3] day
var $560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"); // [11] tz_minute
function $560639d49e3c9a19$var$resolveYamlTimestamp(data) {
    if (data === null) return false;
    if ($560639d49e3c9a19$var$YAML_DATE_REGEXP.exec(data) !== null) return true;
    if ($560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function $560639d49e3c9a19$var$constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = $560639d49e3c9a19$var$YAML_DATE_REGEXP.exec(data);
    if (match === null) match = $560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) return new Date(Date.UTC(year, month, day));
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3)fraction += "0";
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function $560639d49e3c9a19$var$representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
var $560639d49e3c9a19$var$timestamp = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlTimestamp,
    construct: $560639d49e3c9a19$var$constructYamlTimestamp,
    instanceOf: Date,
    represent: $560639d49e3c9a19$var$representYamlTimestamp
});
function $560639d49e3c9a19$var$resolveYamlMerge(data) {
    return data === "<<" || data === null;
}
var $560639d49e3c9a19$var$merge = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlMerge
});
/*eslint-disable no-bitwise*/ var $560639d49e3c9a19$var$NodeBuffer;
try {
    // A trick for browserified version, to not include `Buffer` shim
    var $560639d49e3c9a19$var$_require$1 = $560639d49e3c9a19$var$commonjsRequire;
    $560639d49e3c9a19$var$NodeBuffer = $560639d49e3c9a19$var$_require$1("buffer").Buffer;
} catch (__) {}
// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var $560639d49e3c9a19$var$BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function $560639d49e3c9a19$var$resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = $560639d49e3c9a19$var$BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function $560639d49e3c9a19$var$constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = $560639d49e3c9a19$var$BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) result.push(bits >> 4 & 0xFF);
    // Wrap into Buffer for NodeJS and leave Array for browser
    if ($560639d49e3c9a19$var$NodeBuffer) // Support node 6.+ Buffer API when available
    return $560639d49e3c9a19$var$NodeBuffer.from ? $560639d49e3c9a19$var$NodeBuffer.from(result) : new $560639d49e3c9a19$var$NodeBuffer(result);
    return result;
}
function $560639d49e3c9a19$var$representYamlBinary(object /*, style*/ ) {
    var result = "", bits = 0, idx, tail, max = object.length, map = $560639d49e3c9a19$var$BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function $560639d49e3c9a19$var$isBinary(object) {
    return $560639d49e3c9a19$var$NodeBuffer && $560639d49e3c9a19$var$NodeBuffer.isBuffer(object);
}
var $560639d49e3c9a19$var$binary = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveYamlBinary,
    construct: $560639d49e3c9a19$var$constructYamlBinary,
    predicate: $560639d49e3c9a19$var$isBinary,
    represent: $560639d49e3c9a19$var$representYamlBinary
});
var $560639d49e3c9a19$var$_hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$_toString$2 = Object.prototype.toString;
function $560639d49e3c9a19$var$resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if ($560639d49e3c9a19$var$_toString$2.call(pair) !== "[object Object]") return false;
        for(pairKey in pair)if ($560639d49e3c9a19$var$_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function $560639d49e3c9a19$var$constructYamlOmap(data) {
    return data !== null ? data : [];
}
var $560639d49e3c9a19$var$omap = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: $560639d49e3c9a19$var$resolveYamlOmap,
    construct: $560639d49e3c9a19$var$constructYamlOmap
});
var $560639d49e3c9a19$var$_toString$1 = Object.prototype.toString;
function $560639d49e3c9a19$var$resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if ($560639d49e3c9a19$var$_toString$1.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function $560639d49e3c9a19$var$constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
var $560639d49e3c9a19$var$pairs = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: $560639d49e3c9a19$var$resolveYamlPairs,
    construct: $560639d49e3c9a19$var$constructYamlPairs
});
var $560639d49e3c9a19$var$_hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function $560639d49e3c9a19$var$resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object)if ($560639d49e3c9a19$var$_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
    }
    return true;
}
function $560639d49e3c9a19$var$constructYamlSet(data) {
    return data !== null ? data : {};
}
var $560639d49e3c9a19$var$set = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: $560639d49e3c9a19$var$resolveYamlSet,
    construct: $560639d49e3c9a19$var$constructYamlSet
});
var $560639d49e3c9a19$var$default_safe = new $560639d49e3c9a19$var$schema({
    include: [
        $560639d49e3c9a19$var$core
    ],
    implicit: [
        $560639d49e3c9a19$var$timestamp,
        $560639d49e3c9a19$var$merge
    ],
    explicit: [
        $560639d49e3c9a19$var$binary,
        $560639d49e3c9a19$var$omap,
        $560639d49e3c9a19$var$pairs,
        $560639d49e3c9a19$var$set
    ]
});
function $560639d49e3c9a19$var$resolveJavascriptUndefined() {
    return true;
}
function $560639d49e3c9a19$var$constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/ return undefined;
}
function $560639d49e3c9a19$var$representJavascriptUndefined() {
    return "";
}
function $560639d49e3c9a19$var$isUndefined(object) {
    return typeof object === "undefined";
}
var $560639d49e3c9a19$var$_undefined = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveJavascriptUndefined,
    construct: $560639d49e3c9a19$var$constructJavascriptUndefined,
    predicate: $560639d49e3c9a19$var$isUndefined,
    represent: $560639d49e3c9a19$var$representJavascriptUndefined
});
function $560639d49e3c9a19$var$resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
    }
    return true;
}
function $560639d49e3c9a19$var$constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
}
function $560639d49e3c9a19$var$representJavascriptRegExp(object /*, style*/ ) {
    var result = "/" + object.source + "/";
    if (object.global) result += "g";
    if (object.multiline) result += "m";
    if (object.ignoreCase) result += "i";
    return result;
}
function $560639d49e3c9a19$var$isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}
var $560639d49e3c9a19$var$regexp = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveJavascriptRegExp,
    construct: $560639d49e3c9a19$var$constructJavascriptRegExp,
    predicate: $560639d49e3c9a19$var$isRegExp,
    represent: $560639d49e3c9a19$var$representJavascriptRegExp
});
var $560639d49e3c9a19$var$esprima;
// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
    // workaround to exclude package from browserify list.
    var $560639d49e3c9a19$var$_require = $560639d49e3c9a19$var$commonjsRequire;
    $560639d49e3c9a19$var$esprima = $560639d49e3c9a19$var$_require("esprima");
} catch (_) {
    /* eslint-disable no-redeclare */ /* global window */ if (typeof window !== "undefined") $560639d49e3c9a19$var$esprima = window.esprima;
}
function $560639d49e3c9a19$var$resolveJavascriptFunction(data) {
    if (data === null) return false;
    try {
        var source = "(" + data + ")", ast = $560639d49e3c9a19$var$esprima.parse(source, {
            range: true
        });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") return false;
        return true;
    } catch (err) {
        return false;
    }
}
function $560639d49e3c9a19$var$constructJavascriptFunction(data) {
    /*jslint evil:true*/ var source = "(" + data + ")", ast = $560639d49e3c9a19$var$esprima.parse(source, {
        range: true
    }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") throw new Error("Failed to resolve function");
    ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === "BlockStatement") /*eslint-disable no-new-func*/ return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/ return new Function(params, "return " + source.slice(body[0], body[1]));
}
function $560639d49e3c9a19$var$representJavascriptFunction(object /*, style*/ ) {
    return object.toString();
}
function $560639d49e3c9a19$var$isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
}
var $560639d49e3c9a19$var$_function = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: $560639d49e3c9a19$var$resolveJavascriptFunction,
    construct: $560639d49e3c9a19$var$constructJavascriptFunction,
    predicate: $560639d49e3c9a19$var$isFunction,
    represent: $560639d49e3c9a19$var$representJavascriptFunction
});
var $560639d49e3c9a19$var$default_full = $560639d49e3c9a19$var$schema.DEFAULT = new $560639d49e3c9a19$var$schema({
    include: [
        $560639d49e3c9a19$var$default_safe
    ],
    explicit: [
        $560639d49e3c9a19$var$_undefined,
        $560639d49e3c9a19$var$regexp,
        $560639d49e3c9a19$var$_function
    ]
});
/*eslint-disable max-len,no-use-before-define*/ var $560639d49e3c9a19$var$_hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$CONTEXT_FLOW_IN = 1;
var $560639d49e3c9a19$var$CONTEXT_FLOW_OUT = 2;
var $560639d49e3c9a19$var$CONTEXT_BLOCK_IN = 3;
var $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT = 4;
var $560639d49e3c9a19$var$CHOMPING_CLIP = 1;
var $560639d49e3c9a19$var$CHOMPING_STRIP = 2;
var $560639d49e3c9a19$var$CHOMPING_KEEP = 3;
var $560639d49e3c9a19$var$PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var $560639d49e3c9a19$var$PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var $560639d49e3c9a19$var$PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var $560639d49e3c9a19$var$PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var $560639d49e3c9a19$var$PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function $560639d49e3c9a19$var$_class(obj) {
    return Object.prototype.toString.call(obj);
}
function $560639d49e3c9a19$var$is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function $560639d49e3c9a19$var$is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function $560639d49e3c9a19$var$is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function $560639d49e3c9a19$var$is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function $560639d49e3c9a19$var$fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) return lc - 0x61 + 10;
    return -1;
}
function $560639d49e3c9a19$var$escapedHexLen(c) {
    if (c === 0x78 /* x */ ) return 2;
    if (c === 0x75 /* u */ ) return 4;
    if (c === 0x55 /* U */ ) return 8;
    return 0;
}
function $560639d49e3c9a19$var$fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    return -1;
}
function $560639d49e3c9a19$var$simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? "\0" : c === 0x61 /* a */  ? "\x07" : c === 0x62 /* b */  ? "\b" : c === 0x74 /* t */  ? "	" : c === 0x09 /* Tab */  ? "	" : c === 0x6E /* n */  ? "\n" : c === 0x76 /* v */  ? "\v" : c === 0x66 /* f */  ? "\f" : c === 0x72 /* r */  ? "\r" : c === 0x65 /* e */  ? "\x1b" : c === 0x20 /* Space */  ? " " : c === 0x22 /* " */  ? '"' : c === 0x2F /* / */  ? "/" : c === 0x5C /* \ */  ? "\\" : c === 0x4E /* N */  ? "\x85" : c === 0x5F /* _ */  ? "\xa0" : c === 0x4C /* L */  ? "\u2028" : c === 0x50 /* P */  ? "\u2029" : "";
}
function $560639d49e3c9a19$var$charFromCodepoint(c) {
    if (c <= 0xFFFF) return String.fromCharCode(c);
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var $560639d49e3c9a19$var$simpleEscapeCheck = new Array(256); // integer, for fast access
var $560639d49e3c9a19$var$simpleEscapeMap = new Array(256);
for(var $560639d49e3c9a19$var$i = 0; $560639d49e3c9a19$var$i < 256; $560639d49e3c9a19$var$i++){
    $560639d49e3c9a19$var$simpleEscapeCheck[$560639d49e3c9a19$var$i] = $560639d49e3c9a19$var$simpleEscapeSequence($560639d49e3c9a19$var$i) ? 1 : 0;
    $560639d49e3c9a19$var$simpleEscapeMap[$560639d49e3c9a19$var$i] = $560639d49e3c9a19$var$simpleEscapeSequence($560639d49e3c9a19$var$i);
}
function $560639d49e3c9a19$var$State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || $560639d49e3c9a19$var$default_full;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function $560639d49e3c9a19$var$generateError(state, message) {
    return new $560639d49e3c9a19$var$exception(message, new $560639d49e3c9a19$var$mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function $560639d49e3c9a19$var$throwError(state, message) {
    throw $560639d49e3c9a19$var$generateError(state, message);
}
function $560639d49e3c9a19$var$throwWarning(state, message) {
    if (state.onWarning) state.onWarning.call(null, $560639d49e3c9a19$var$generateError(state, message));
}
var $560639d49e3c9a19$var$directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) $560639d49e3c9a19$var$throwError(state, "duplication of %YAML directive");
        if (args.length !== 1) $560639d49e3c9a19$var$throwError(state, "YAML directive accepts exactly one argument");
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) $560639d49e3c9a19$var$throwError(state, "ill-formed argument of the YAML directive");
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) $560639d49e3c9a19$var$throwError(state, "unacceptable YAML version of the document");
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) $560639d49e3c9a19$var$throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) $560639d49e3c9a19$var$throwError(state, "TAG directive accepts exactly two arguments");
        handle = args[0];
        prefix = args[1];
        if (!$560639d49e3c9a19$var$PATTERN_TAG_HANDLE.test(handle)) $560639d49e3c9a19$var$throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.tagMap, handle)) $560639d49e3c9a19$var$throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        if (!$560639d49e3c9a19$var$PATTERN_TAG_URI.test(prefix)) $560639d49e3c9a19$var$throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        state.tagMap[handle] = prefix;
    }
};
function $560639d49e3c9a19$var$captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) for(_position = 0, _length = _result.length; _position < _length; _position += 1){
            _character = _result.charCodeAt(_position);
            if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) $560639d49e3c9a19$var$throwError(state, "expected valid JSON character");
        }
        else if ($560639d49e3c9a19$var$PATTERN_NON_PRINTABLE.test(_result)) $560639d49e3c9a19$var$throwError(state, "the stream contains non-printable characters");
        state.result += _result;
    }
}
function $560639d49e3c9a19$var$mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!$560639d49e3c9a19$var$common.isObject(source)) $560639d49e3c9a19$var$throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!$560639d49e3c9a19$var$_hasOwnProperty$1.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) $560639d49e3c9a19$var$throwError(state, "nested arrays are not supported inside keys");
            if (typeof keyNode === "object" && $560639d49e3c9a19$var$_class(keyNode[index]) === "[object Object]") keyNode[index] = "[object Object]";
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === "object" && $560639d49e3c9a19$var$_class(keyNode) === "[object Object]") keyNode = "[object Object]";
    keyNode = String(keyNode);
    if (_result === null) _result = {};
    if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) for(index = 0, quantity = valueNode.length; index < quantity; index += 1)$560639d49e3c9a19$var$mergeMappings(state, _result, valueNode[index], overridableKeys);
        else $560639d49e3c9a19$var$mergeMappings(state, _result, valueNode, overridableKeys);
    } else {
        if (!state.json && !$560639d49e3c9a19$var$_hasOwnProperty$1.call(overridableKeys, keyNode) && $560639d49e3c9a19$var$_hasOwnProperty$1.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            $560639d49e3c9a19$var$throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
    }
    return _result;
}
function $560639d49e3c9a19$var$readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) state.position++;
    else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) state.position++;
    } else $560639d49e3c9a19$var$throwError(state, "a line break is expected");
    state.line += 1;
    state.lineStart = state.position;
}
function $560639d49e3c9a19$var$skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while($560639d49e3c9a19$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
        if (allowComments && ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);
        if ($560639d49e3c9a19$var$is_EOL(ch)) {
            $560639d49e3c9a19$var$readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else break;
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) $560639d49e3c9a19$var$throwWarning(state, "deficient indentation");
    return lineBreaks;
}
function $560639d49e3c9a19$var$testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || $560639d49e3c9a19$var$is_WS_OR_EOL(ch)) return true;
    }
    return false;
}
function $560639d49e3c9a19$var$writeFoldedLines(state, count) {
    if (count === 1) state.result += " ";
    else if (count > 1) state.result += $560639d49e3c9a19$var$common.repeat("\n", count - 1);
}
function $560639d49e3c9a19$var$readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if ($560639d49e3c9a19$var$is_WS_OR_EOL(ch) || $560639d49e3c9a19$var$is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) return false;
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if ($560639d49e3c9a19$var$is_WS_OR_EOL(following) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(following)) return false;
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if ($560639d49e3c9a19$var$is_WS_OR_EOL(following) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(following)) break;
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if ($560639d49e3c9a19$var$is_WS_OR_EOL(preceding)) break;
        } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(ch)) break;
        else if ($560639d49e3c9a19$var$is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            $560639d49e3c9a19$var$skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, false);
            $560639d49e3c9a19$var$writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!$560639d49e3c9a19$var$is_WHITE_SPACE(ch)) captureEnd = state.position + 1;
        ch = state.input.charCodeAt(++state.position);
    }
    $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, false);
    if (state.result) return true;
    state.kind = _kind;
    state.result = _result;
    return false;
}
function $560639d49e3c9a19$var$readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else return true;
        } else if ($560639d49e3c9a19$var$is_EOL(ch)) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, true);
            $560639d49e3c9a19$var$writeFoldedLines(state, $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state)) $560639d49e3c9a19$var$throwError(state, "unexpected end of the document within a single quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function $560639d49e3c9a19$var$readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if ($560639d49e3c9a19$var$is_EOL(ch)) $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent);
            else if (ch < 256 && $560639d49e3c9a19$var$simpleEscapeCheck[ch]) {
                state.result += $560639d49e3c9a19$var$simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = $560639d49e3c9a19$var$escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = $560639d49e3c9a19$var$fromHexCode(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
                    else $560639d49e3c9a19$var$throwError(state, "expected hexadecimal character");
                }
                state.result += $560639d49e3c9a19$var$charFromCodepoint(hexResult);
                state.position++;
            } else $560639d49e3c9a19$var$throwError(state, "unknown escape sequence");
            captureStart = captureEnd = state.position;
        } else if ($560639d49e3c9a19$var$is_EOL(ch)) {
            $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, true);
            $560639d49e3c9a19$var$writeFoldedLines(state, $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state)) $560639d49e3c9a19$var$throwError(state, "unexpected end of the document within a double quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function $560639d49e3c9a19$var$readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else return false;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
        } else if (!readNext) $560639d49e3c9a19$var$throwError(state, "missed comma between flow collection entries");
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if ($560639d49e3c9a19$var$is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line;
        $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
            $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        else if (isPair) _result.push($560639d49e3c9a19$var$storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        else _result.push(keyNode);
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else readNext = false;
    }
    $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a flow collection");
}
function $560639d49e3c9a19$var$readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = $560639d49e3c9a19$var$CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) folding = false;
    else if (ch === 0x3E /* > */ ) folding = true;
    else return false;
    state.kind = "scalar";
    state.result = "";
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if ($560639d49e3c9a19$var$CHOMPING_CLIP === chomping) chomping = ch === 0x2B /* + */  ? $560639d49e3c9a19$var$CHOMPING_KEEP : $560639d49e3c9a19$var$CHOMPING_STRIP;
            else $560639d49e3c9a19$var$throwError(state, "repeat of a chomping mode identifier");
        } else if ((tmp = $560639d49e3c9a19$var$fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) $560639d49e3c9a19$var$throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else $560639d49e3c9a19$var$throwError(state, "repeat of an indentation width identifier");
        } else break;
    }
    if ($560639d49e3c9a19$var$is_WHITE_SPACE(ch)) {
        do ch = state.input.charCodeAt(++state.position);
        while ($560639d49e3c9a19$var$is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (!$560639d49e3c9a19$var$is_EOL(ch) && ch !== 0);
    }
    while(ch !== 0){
        $560639d49e3c9a19$var$readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) textIndent = state.lineIndent;
        if ($560639d49e3c9a19$var$is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === $560639d49e3c9a19$var$CHOMPING_KEEP) state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            else if (chomping === $560639d49e3c9a19$var$CHOMPING_CLIP) {
                if (didReadContent) state.result += "\n";
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if ($560639d49e3c9a19$var$is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += $560639d49e3c9a19$var$common.repeat("\n", emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) state.result += " ";
            } else state.result += $560639d49e3c9a19$var$common.repeat("\n", emptyLines);
        // Literal style: just add exact number of line breaks between content lines.
        } else // Keep all line breaks except the header line break.
        state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!$560639d49e3c9a19$var$is_EOL(ch) && ch !== 0)ch = state.input.charCodeAt(++state.position);
        $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function $560639d49e3c9a19$var$readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (ch !== 0x2D /* - */ ) break;
        following = state.input.charCodeAt(state.position + 1);
        if (!$560639d49e3c9a19$var$is_WS_OR_EOL(following)) break;
        detected = true;
        state.position++;
        if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) $560639d49e3c9a19$var$throwError(state, "bad indentation of a sequence entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
    }
    return false;
}
function $560639d49e3c9a19$var$readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        _pos = state.position;
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && $560639d49e3c9a19$var$is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else $560639d49e3c9a19$var$throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else if ($560639d49e3c9a19$var$composeNode(state, flowIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while($560639d49e3c9a19$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!$560639d49e3c9a19$var$is_WS_OR_EOL(ch)) $560639d49e3c9a19$var$throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    if (atExplicitKey) {
                        $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) $560639d49e3c9a19$var$throwError(state, "can not read an implicit mapping pair; a colon is missed");
                else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) $560639d49e3c9a19$var$throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        } else break; // Reading is done. Go to the epilogue.
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if ($560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) keyNode = state.result;
                else valueNode = state.result;
            }
            if (!atExplicitKey) {
                $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
            }
            $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) $560639d49e3c9a19$var$throwError(state, "bad indentation of a mapping entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
    }
    return detected;
}
function $560639d49e3c9a19$var$readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) $560639d49e3c9a19$var$throwError(state, "duplication of a tag property");
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
    } else tagHandle = "!";
    _position = state.position;
    if (isVerbatim) {
        do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && ch !== 0x3E /* > */ );
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a verbatim tag");
    } else {
        while(ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!$560639d49e3c9a19$var$PATTERN_TAG_HANDLE.test(tagHandle)) $560639d49e3c9a19$var$throwError(state, "named tag handle cannot contain such characters");
                    isNamed = true;
                    _position = state.position + 1;
                } else $560639d49e3c9a19$var$throwError(state, "tag suffix cannot contain exclamation marks");
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if ($560639d49e3c9a19$var$PATTERN_FLOW_INDICATORS.test(tagName)) $560639d49e3c9a19$var$throwError(state, "tag suffix cannot contain flow indicator characters");
    }
    if (tagName && !$560639d49e3c9a19$var$PATTERN_TAG_URI.test(tagName)) $560639d49e3c9a19$var$throwError(state, "tag name cannot contain such characters: " + tagName);
    if (isVerbatim) state.tag = tagName;
    else if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.tagMap, tagHandle)) state.tag = state.tagMap[tagHandle] + tagName;
    else if (tagHandle === "!") state.tag = "!" + tagName;
    else if (tagHandle === "!!") state.tag = "tag:yaml.org,2002:" + tagName;
    else $560639d49e3c9a19$var$throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    return true;
}
function $560639d49e3c9a19$var$readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) $560639d49e3c9a19$var$throwError(state, "duplication of an anchor property");
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch) && !$560639d49e3c9a19$var$is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) $560639d49e3c9a19$var$throwError(state, "name of an anchor node must contain at least one character");
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function $560639d49e3c9a19$var$readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch) && !$560639d49e3c9a19$var$is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) $560639d49e3c9a19$var$throwError(state, "name of an alias node must contain at least one character");
    alias = state.input.slice(_position, state.position);
    if (!state.anchorMap.hasOwnProperty(alias)) $560639d49e3c9a19$var$throwError(state, 'unidentified alias "' + alias + '"');
    state.result = state.anchorMap[alias];
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    return true;
}
function $560639d49e3c9a19$var$composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) state.listener("open", state);
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT === nodeContext || $560639d49e3c9a19$var$CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        }
    }
    if (indentStatus === 1) {
        while($560639d49e3c9a19$var$readTagProperty(state) || $560639d49e3c9a19$var$readAnchorProperty(state))if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        } else allowBlockCollections = false;
    }
    if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
    if (indentStatus === 1 || $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT === nodeContext) {
        if ($560639d49e3c9a19$var$CONTEXT_FLOW_IN === nodeContext || $560639d49e3c9a19$var$CONTEXT_FLOW_OUT === nodeContext) flowIndent = parentIndent;
        else flowIndent = parentIndent + 1;
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && ($560639d49e3c9a19$var$readBlockSequence(state, blockIndent) || $560639d49e3c9a19$var$readBlockMapping(state, blockIndent, flowIndent)) || $560639d49e3c9a19$var$readFlowCollection(state, flowIndent)) hasContent = true;
            else {
                if (allowBlockScalars && $560639d49e3c9a19$var$readBlockScalar(state, flowIndent) || $560639d49e3c9a19$var$readSingleQuotedScalar(state, flowIndent) || $560639d49e3c9a19$var$readDoubleQuotedScalar(state, flowIndent)) hasContent = true;
                else if ($560639d49e3c9a19$var$readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) $560639d49e3c9a19$var$throwError(state, "alias node should not have any properties");
                } else if ($560639d49e3c9a19$var$readPlainScalar(state, flowIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) state.tag = "?";
                }
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
            }
        } else if (indentStatus === 0) // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && $560639d49e3c9a19$var$readBlockSequence(state, blockIndent);
    }
    if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== "scalar") $560639d49e3c9a19$var$throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
                    break;
                }
            }
        } else if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) $560639d49e3c9a19$var$throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            if (!type.resolve(state.result)) $560639d49e3c9a19$var$throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
            }
        } else $560639d49e3c9a19$var$throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.listener !== null) state.listener("close", state);
    return state.tag !== null || state.anchor !== null || hasContent;
}
function $560639d49e3c9a19$var$readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) break;
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) $560639d49e3c9a19$var$throwError(state, "directive name must not be less than one character in length");
        while(ch !== 0){
            while($560639d49e3c9a19$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
            if (ch === 0x23 /* # */ ) {
                do ch = state.input.charCodeAt(++state.position);
                while (ch !== 0 && !$560639d49e3c9a19$var$is_EOL(ch));
                break;
            }
            if ($560639d49e3c9a19$var$is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) $560639d49e3c9a19$var$readLineBreak(state);
        if ($560639d49e3c9a19$var$_hasOwnProperty$1.call($560639d49e3c9a19$var$directiveHandlers, directiveName)) $560639d49e3c9a19$var$directiveHandlers[directiveName](state, directiveName, directiveArgs);
        else $560639d49e3c9a19$var$throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) $560639d49e3c9a19$var$throwError(state, "directives end mark is expected");
    $560639d49e3c9a19$var$composeNode(state, state.lineIndent - 1, $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT, false, true);
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && $560639d49e3c9a19$var$PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) $560639d49e3c9a19$var$throwWarning(state, "non-ASCII line breaks are interpreted as content");
    state.documents.push(state.result);
    if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) $560639d49e3c9a19$var$throwError(state, "end of the stream or a document separator is expected");
    else return;
}
function $560639d49e3c9a19$var$loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) input += "\n";
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) input = input.slice(1);
    }
    var state = new $560639d49e3c9a19$var$State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
        state.position = nullpos;
        $560639d49e3c9a19$var$throwError(state, "null byte is not allowed in input");
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += "\0";
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1)$560639d49e3c9a19$var$readDocument(state);
    return state.documents;
}
function $560639d49e3c9a19$var$loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    var documents = $560639d49e3c9a19$var$loadDocuments(input, options);
    if (typeof iterator !== "function") return documents;
    for(var index = 0, length = documents.length; index < length; index += 1)iterator(documents[index]);
}
function $560639d49e3c9a19$var$load$1(input, options) {
    var documents = $560639d49e3c9a19$var$loadDocuments(input, options);
    if (documents.length === 0) /*eslint-disable no-undefined*/ return undefined;
    else if (documents.length === 1) return documents[0];
    throw new $560639d49e3c9a19$var$exception("expected a single document in the stream, but found more");
}
function $560639d49e3c9a19$var$safeLoadAll$1(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    return $560639d49e3c9a19$var$loadAll$1(input, iterator, $560639d49e3c9a19$var$common.extend({
        schema: $560639d49e3c9a19$var$default_safe
    }, options));
}
function $560639d49e3c9a19$var$safeLoad$1(input, options) {
    return $560639d49e3c9a19$var$load$1(input, $560639d49e3c9a19$var$common.extend({
        schema: $560639d49e3c9a19$var$default_safe
    }, options));
}
var $560639d49e3c9a19$var$loadAll_1 = $560639d49e3c9a19$var$loadAll$1;
var $560639d49e3c9a19$var$load_1 = $560639d49e3c9a19$var$load$1;
var $560639d49e3c9a19$var$safeLoadAll_1 = $560639d49e3c9a19$var$safeLoadAll$1;
var $560639d49e3c9a19$var$safeLoad_1 = $560639d49e3c9a19$var$safeLoad$1;
var $560639d49e3c9a19$var$loader = {
    loadAll: $560639d49e3c9a19$var$loadAll_1,
    load: $560639d49e3c9a19$var$load_1,
    safeLoadAll: $560639d49e3c9a19$var$safeLoadAll_1,
    safeLoad: $560639d49e3c9a19$var$safeLoad_1
};
/*eslint-disable no-use-before-define*/ var $560639d49e3c9a19$var$_toString = Object.prototype.toString;
var $560639d49e3c9a19$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$CHAR_TAB = 0x09; /* Tab */ 
var $560639d49e3c9a19$var$CHAR_LINE_FEED = 0x0A; /* LF */ 
var $560639d49e3c9a19$var$CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var $560639d49e3c9a19$var$CHAR_SPACE = 0x20; /* Space */ 
var $560639d49e3c9a19$var$CHAR_EXCLAMATION = 0x21; /* ! */ 
var $560639d49e3c9a19$var$CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var $560639d49e3c9a19$var$CHAR_SHARP = 0x23; /* # */ 
var $560639d49e3c9a19$var$CHAR_PERCENT = 0x25; /* % */ 
var $560639d49e3c9a19$var$CHAR_AMPERSAND = 0x26; /* & */ 
var $560639d49e3c9a19$var$CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var $560639d49e3c9a19$var$CHAR_ASTERISK = 0x2A; /* * */ 
var $560639d49e3c9a19$var$CHAR_COMMA = 0x2C; /* , */ 
var $560639d49e3c9a19$var$CHAR_MINUS = 0x2D; /* - */ 
var $560639d49e3c9a19$var$CHAR_COLON = 0x3A; /* : */ 
var $560639d49e3c9a19$var$CHAR_EQUALS = 0x3D; /* = */ 
var $560639d49e3c9a19$var$CHAR_GREATER_THAN = 0x3E; /* > */ 
var $560639d49e3c9a19$var$CHAR_QUESTION = 0x3F; /* ? */ 
var $560639d49e3c9a19$var$CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var $560639d49e3c9a19$var$CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var $560639d49e3c9a19$var$CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var $560639d49e3c9a19$var$ESCAPE_SEQUENCES = {};
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x00] = "\\0";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x07] = "\\a";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x08] = "\\b";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x09] = "\\t";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x0A] = "\\n";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x0B] = "\\v";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x0C] = "\\f";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x0D] = "\\r";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x1B] = "\\e";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x22] = '\\"';
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x5C] = "\\\\";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x85] = "\\N";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0xA0] = "\\_";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x2028] = "\\L";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0x2029] = "\\P";
var $560639d49e3c9a19$var$DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
];
function $560639d49e3c9a19$var$compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") tag = "tag:yaml.org,2002:" + tag.slice(2);
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && $560639d49e3c9a19$var$_hasOwnProperty.call(type.styleAliases, style)) style = type.styleAliases[style];
        result[tag] = style;
    }
    return result;
}
function $560639d49e3c9a19$var$encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = "x";
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = "u";
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = "U";
        length = 8;
    } else throw new $560639d49e3c9a19$var$exception("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + $560639d49e3c9a19$var$common.repeat("0", length - string.length) + string;
}
function $560639d49e3c9a19$var$State(options) {
    this.schema = options["schema"] || $560639d49e3c9a19$var$default_full;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = $560639d49e3c9a19$var$common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = $560639d49e3c9a19$var$compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function $560639d49e3c9a19$var$indentString(string, spaces) {
    var ind = $560639d49e3c9a19$var$common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while(position < length){
        next = string.indexOf("\n", position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
    }
    return result;
}
function $560639d49e3c9a19$var$generateNextLine(state, level) {
    return "\n" + $560639d49e3c9a19$var$common.repeat(" ", state.indent * level);
}
function $560639d49e3c9a19$var$testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) return true;
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function $560639d49e3c9a19$var$isWhitespace(c) {
    return c === $560639d49e3c9a19$var$CHAR_SPACE || c === $560639d49e3c9a19$var$CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function $560639d49e3c9a19$var$isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */  || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function $560639d49e3c9a19$var$isNsChar(c) {
    return $560639d49e3c9a19$var$isPrintable(c) && !$560639d49e3c9a19$var$isWhitespace(c) && c !== 0xFEFF && c !== $560639d49e3c9a19$var$CHAR_CARRIAGE_RETURN && c !== $560639d49e3c9a19$var$CHAR_LINE_FEED;
}
// Simplified test for values allowed after the first character in plain style.
function $560639d49e3c9a19$var$isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return $560639d49e3c9a19$var$isPrintable(c) && c !== 0xFEFF && c !== $560639d49e3c9a19$var$CHAR_COMMA && c !== $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_COLON && (c !== $560639d49e3c9a19$var$CHAR_SHARP || prev && $560639d49e3c9a19$var$isNsChar(prev));
}
// Simplified test for values allowed as the first character in plain style.
function $560639d49e3c9a19$var$isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return $560639d49e3c9a19$var$isPrintable(c) && c !== 0xFEFF && !$560639d49e3c9a19$var$isWhitespace(c) // - s-white
     && c !== $560639d49e3c9a19$var$CHAR_MINUS && c !== $560639d49e3c9a19$var$CHAR_QUESTION && c !== $560639d49e3c9a19$var$CHAR_COLON && c !== $560639d49e3c9a19$var$CHAR_COMMA && c !== $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_SHARP && c !== $560639d49e3c9a19$var$CHAR_AMPERSAND && c !== $560639d49e3c9a19$var$CHAR_ASTERISK && c !== $560639d49e3c9a19$var$CHAR_EXCLAMATION && c !== $560639d49e3c9a19$var$CHAR_VERTICAL_LINE && c !== $560639d49e3c9a19$var$CHAR_EQUALS && c !== $560639d49e3c9a19$var$CHAR_GREATER_THAN && c !== $560639d49e3c9a19$var$CHAR_SINGLE_QUOTE && c !== $560639d49e3c9a19$var$CHAR_DOUBLE_QUOTE && c !== $560639d49e3c9a19$var$CHAR_PERCENT && c !== $560639d49e3c9a19$var$CHAR_COMMERCIAL_AT && c !== $560639d49e3c9a19$var$CHAR_GRAVE_ACCENT;
}
// Determines whether block indentation indicator is required.
function $560639d49e3c9a19$var$needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var $560639d49e3c9a19$var$STYLE_PLAIN = 1, $560639d49e3c9a19$var$STYLE_SINGLE = 2, $560639d49e3c9a19$var$STYLE_LITERAL = 3, $560639d49e3c9a19$var$STYLE_FOLDED = 4, $560639d49e3c9a19$var$STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function $560639d49e3c9a19$var$chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = $560639d49e3c9a19$var$isPlainSafeFirst(string.charCodeAt(0)) && !$560639d49e3c9a19$var$isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for(i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        if (!$560639d49e3c9a19$var$isPrintable(char)) return $560639d49e3c9a19$var$STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && $560639d49e3c9a19$var$isPlainSafe(char, prev_char);
    }
    else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (char === $560639d49e3c9a19$var$CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i;
                }
            } else if (!$560639d49e3c9a19$var$isPrintable(char)) return $560639d49e3c9a19$var$STYLE_DOUBLE;
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && $560639d49e3c9a19$var$isPlainSafe(char, prev_char);
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? $560639d49e3c9a19$var$STYLE_PLAIN : $560639d49e3c9a19$var$STYLE_SINGLE;
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && $560639d49e3c9a19$var$needIndentIndicator(string)) return $560639d49e3c9a19$var$STYLE_DOUBLE;
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? $560639d49e3c9a19$var$STYLE_FOLDED : $560639d49e3c9a19$var$STYLE_LITERAL;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function $560639d49e3c9a19$var$writeScalar(state, string, level, iskey) {
    state.dump = function() {
        if (string.length === 0) return "''";
        if (!state.noCompatMode && $560639d49e3c9a19$var$DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) return "'" + string + "'";
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return $560639d49e3c9a19$var$testImplicitResolving(state, string);
        }
        switch($560639d49e3c9a19$var$chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)){
            case $560639d49e3c9a19$var$STYLE_PLAIN:
                return string;
            case $560639d49e3c9a19$var$STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case $560639d49e3c9a19$var$STYLE_LITERAL:
                return "|" + $560639d49e3c9a19$var$blockHeader(string, state.indent) + $560639d49e3c9a19$var$dropEndingNewline($560639d49e3c9a19$var$indentString(string, indent));
            case $560639d49e3c9a19$var$STYLE_FOLDED:
                return ">" + $560639d49e3c9a19$var$blockHeader(string, state.indent) + $560639d49e3c9a19$var$dropEndingNewline($560639d49e3c9a19$var$indentString($560639d49e3c9a19$var$foldString(string, lineWidth), indent));
            case $560639d49e3c9a19$var$STYLE_DOUBLE:
                return '"' + $560639d49e3c9a19$var$escapeString(string) + '"';
            default:
                throw new $560639d49e3c9a19$var$exception("impossible error: invalid scalar style");
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function $560639d49e3c9a19$var$blockHeader(string, indentPerLevel) {
    var indentIndicator = $560639d49e3c9a19$var$needIndentIndicator(string) ? String(indentPerLevel) : "";
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
}
// (See the note for writeScalar.)
function $560639d49e3c9a19$var$dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function $560639d49e3c9a19$var$foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return $560639d49e3c9a19$var$foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + $560639d49e3c9a19$var$foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function $560639d49e3c9a19$var$foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += "\n" + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += "\n";
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    else result += line.slice(start);
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function $560639d49e3c9a19$var$escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for(var i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
        if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */ ) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */ ) {
                // Combine the surrogate pair and store it escaped.
                result += $560639d49e3c9a19$var$encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
            }
        }
        escapeSeq = $560639d49e3c9a19$var$ESCAPE_SEQUENCES[char];
        result += !escapeSeq && $560639d49e3c9a19$var$isPrintable(char) ? string[i] : escapeSeq || $560639d49e3c9a19$var$encodeHex(char);
    }
    return result;
}
function $560639d49e3c9a19$var$writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1)// Write only valid elements.
    if ($560639d49e3c9a19$var$writeNode(state, level, object[index], false, false)) {
        if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
}
function $560639d49e3c9a19$var$writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1)// Write only valid elements.
    if ($560639d49e3c9a19$var$writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) _result += $560639d49e3c9a19$var$generateNextLine(state, level);
        if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) _result += "-";
        else _result += "- ";
        _result += state.dump;
    }
    state.tag = _tag;
    state.dump = _result || "[]"; // Empty sequence if no valid values.
}
function $560639d49e3c9a19$var$writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (index !== 0) pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!$560639d49e3c9a19$var$writeNode(state, level, objectKey, false, false)) continue; // Skip this pair because of invalid key;
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!$560639d49e3c9a19$var$writeNode(state, level, objectValue, false, false)) continue; // Skip this pair because of invalid value.
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
}
function $560639d49e3c9a19$var$writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) // Default sorting
    objectKeyList.sort();
    else if (typeof state.sortKeys === "function") // Custom sort function
    objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys) // Something is wrong
    throw new $560639d49e3c9a19$var$exception("sortKeys must be a boolean or a function");
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (!compact || index !== 0) pairBuffer += $560639d49e3c9a19$var$generateNextLine(state, level);
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!$560639d49e3c9a19$var$writeNode(state, level + 1, objectKey, true, true, true)) continue; // Skip this pair because of invalid key.
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += "?";
            else pairBuffer += "? ";
        }
        pairBuffer += state.dump;
        if (explicitPair) pairBuffer += $560639d49e3c9a19$var$generateNextLine(state, level);
        if (!$560639d49e3c9a19$var$writeNode(state, level + 1, objectValue, true, explicitPair)) continue; // Skip this pair because of invalid value.
        if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += ":";
        else pairBuffer += ": ";
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}"; // Empty mapping if no valid pairs.
}
function $560639d49e3c9a19$var$detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if ($560639d49e3c9a19$var$_toString.call(type.represent) === "[object Function]") _result = type.represent(object, style);
                else if ($560639d49e3c9a19$var$_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
                else throw new $560639d49e3c9a19$var$exception("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function $560639d49e3c9a19$var$writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!$560639d49e3c9a19$var$detectType(state, object, false)) $560639d49e3c9a19$var$detectType(state, object, true);
    var type = $560639d49e3c9a19$var$_toString.call(state.dump);
    if (block) block = state.flowLevel < 0 || state.flowLevel > level;
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) compact = false;
    if (duplicate && state.usedDuplicates[duplicateIndex]) state.dump = "*ref_" + duplicateIndex;
    else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) state.usedDuplicates[duplicateIndex] = true;
        if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
                $560639d49e3c9a19$var$writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                $560639d49e3c9a19$var$writeFlowMapping(state, level, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block && state.dump.length !== 0) {
                $560639d49e3c9a19$var$writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                $560639d49e3c9a19$var$writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object String]") {
            if (state.tag !== "?") $560639d49e3c9a19$var$writeScalar(state, state.dump, level, iskey);
        } else {
            if (state.skipInvalid) return false;
            throw new $560639d49e3c9a19$var$exception("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") state.dump = "!<" + state.tag + "> " + state.dump;
    }
    return true;
}
function $560639d49e3c9a19$var$getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    $560639d49e3c9a19$var$inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1)state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
}
function $560639d49e3c9a19$var$inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) duplicatesIndexes.push(index);
        } else {
            objects.push(object);
            if (Array.isArray(object)) for(index = 0, length = object.length; index < length; index += 1)$560639d49e3c9a19$var$inspectNode(object[index], objects, duplicatesIndexes);
            else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1)$560639d49e3c9a19$var$inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
        }
    }
}
function $560639d49e3c9a19$var$dump$1(input, options) {
    options = options || {};
    var state = new $560639d49e3c9a19$var$State(options);
    if (!state.noRefs) $560639d49e3c9a19$var$getDuplicateReferences(input, state);
    if ($560639d49e3c9a19$var$writeNode(state, 0, input, true, true)) return state.dump + "\n";
    return "";
}
function $560639d49e3c9a19$var$safeDump$1(input, options) {
    return $560639d49e3c9a19$var$dump$1(input, $560639d49e3c9a19$var$common.extend({
        schema: $560639d49e3c9a19$var$default_safe
    }, options));
}
var $560639d49e3c9a19$var$dump_1 = $560639d49e3c9a19$var$dump$1;
var $560639d49e3c9a19$var$safeDump_1 = $560639d49e3c9a19$var$safeDump$1;
var $560639d49e3c9a19$var$dumper = {
    dump: $560639d49e3c9a19$var$dump_1,
    safeDump: $560639d49e3c9a19$var$safeDump_1
};
function $560639d49e3c9a19$var$deprecated(name) {
    return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
}
var $560639d49e3c9a19$var$Type = $560639d49e3c9a19$var$type;
var $560639d49e3c9a19$var$Schema = $560639d49e3c9a19$var$schema;
var $560639d49e3c9a19$var$FAILSAFE_SCHEMA = $560639d49e3c9a19$var$failsafe;
var $560639d49e3c9a19$var$JSON_SCHEMA = $560639d49e3c9a19$var$json;
var $560639d49e3c9a19$var$CORE_SCHEMA = $560639d49e3c9a19$var$core;
var $560639d49e3c9a19$var$DEFAULT_SAFE_SCHEMA = $560639d49e3c9a19$var$default_safe;
var $560639d49e3c9a19$var$DEFAULT_FULL_SCHEMA = $560639d49e3c9a19$var$default_full;
var $560639d49e3c9a19$var$load = $560639d49e3c9a19$var$loader.load;
var $560639d49e3c9a19$var$loadAll = $560639d49e3c9a19$var$loader.loadAll;
var $560639d49e3c9a19$var$safeLoad = $560639d49e3c9a19$var$loader.safeLoad;
var $560639d49e3c9a19$var$safeLoadAll = $560639d49e3c9a19$var$loader.safeLoadAll;
var $560639d49e3c9a19$var$dump = $560639d49e3c9a19$var$dumper.dump;
var $560639d49e3c9a19$var$safeDump = $560639d49e3c9a19$var$dumper.safeDump;
var $560639d49e3c9a19$var$YAMLException = $560639d49e3c9a19$var$exception;
// Deprecated schema names from JS-YAML 2.0.x
var $560639d49e3c9a19$var$MINIMAL_SCHEMA = $560639d49e3c9a19$var$failsafe;
var $560639d49e3c9a19$var$SAFE_SCHEMA = $560639d49e3c9a19$var$default_safe;
var $560639d49e3c9a19$var$DEFAULT_SCHEMA = $560639d49e3c9a19$var$default_full;
// Deprecated functions from JS-YAML 1.x.x
var $560639d49e3c9a19$var$scan = $560639d49e3c9a19$var$deprecated("scan");
var $560639d49e3c9a19$var$parse = $560639d49e3c9a19$var$deprecated("parse");
var $560639d49e3c9a19$var$compose = $560639d49e3c9a19$var$deprecated("compose");
var $560639d49e3c9a19$var$addConstructor = $560639d49e3c9a19$var$deprecated("addConstructor");
var $560639d49e3c9a19$var$jsYaml$1 = {
    Type: $560639d49e3c9a19$var$Type,
    Schema: $560639d49e3c9a19$var$Schema,
    FAILSAFE_SCHEMA: $560639d49e3c9a19$var$FAILSAFE_SCHEMA,
    JSON_SCHEMA: $560639d49e3c9a19$var$JSON_SCHEMA,
    CORE_SCHEMA: $560639d49e3c9a19$var$CORE_SCHEMA,
    DEFAULT_SAFE_SCHEMA: $560639d49e3c9a19$var$DEFAULT_SAFE_SCHEMA,
    DEFAULT_FULL_SCHEMA: $560639d49e3c9a19$var$DEFAULT_FULL_SCHEMA,
    load: $560639d49e3c9a19$var$load,
    loadAll: $560639d49e3c9a19$var$loadAll,
    safeLoad: $560639d49e3c9a19$var$safeLoad,
    safeLoadAll: $560639d49e3c9a19$var$safeLoadAll,
    dump: $560639d49e3c9a19$var$dump,
    safeDump: $560639d49e3c9a19$var$safeDump,
    YAMLException: $560639d49e3c9a19$var$YAMLException,
    MINIMAL_SCHEMA: $560639d49e3c9a19$var$MINIMAL_SCHEMA,
    SAFE_SCHEMA: $560639d49e3c9a19$var$SAFE_SCHEMA,
    DEFAULT_SCHEMA: $560639d49e3c9a19$var$DEFAULT_SCHEMA,
    scan: $560639d49e3c9a19$var$scan,
    parse: $560639d49e3c9a19$var$parse,
    compose: $560639d49e3c9a19$var$compose,
    addConstructor: $560639d49e3c9a19$var$addConstructor
};
var $560639d49e3c9a19$var$jsYaml = $560639d49e3c9a19$var$jsYaml$1;
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ /**
 * Module variables.
 * @private
 */ var $560639d49e3c9a19$var$matchHtmlRegExp = /["'&<>]/;
/**
 * Module exports.
 * @public
 */ var $560639d49e3c9a19$var$escapeHtml_1 = $560639d49e3c9a19$var$escapeHtml;
/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */ function $560639d49e3c9a19$var$escapeHtml(string) {
    var str = "" + string;
    var match = $560639d49e3c9a19$var$matchHtmlRegExp.exec(str);
    if (!match) return str;
    var escape;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = "&quot;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 39:
                escape = "&#39;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.substring(lastIndex, index);
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
function $560639d49e3c9a19$var$_optionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while(i < ops.length){
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) return undefined;
        if (op === "access" || op === "optionalAccess") {
            lastAccessLHS = value;
            value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
            value = fn((...args)=>value.call(lastAccessLHS, ...args));
            lastAccessLHS = undefined;
        }
    }
    return value;
}
// this needs a big old cleanup
const $560639d49e3c9a19$var$newline = "\n";
// extract the yaml from 'yaml' nodes and put them in the vfil for later use
function $560639d49e3c9a19$var$default_frontmatter(value, messages) {
    try {
        return $560639d49e3c9a19$var$jsYaml.safeLoad(value);
    } catch (e) {
        messages.push(new $560639d49e3c9a19$var$vfileMessage("YAML failed to parse"));
    }
}
function $560639d49e3c9a19$var$parse_frontmatter({ parse: parse, type: type }) {
    const transformer = (tree, vFile)=>{
        $560639d49e3c9a19$var$unistUtilVisit(tree, type, (node)=>{
            const data = parse(node.value, vFile.messages);
            if (data) // @ts-ignore
            vFile.data.fm = data;
        });
    };
    return transformer;
}
// in code nodes replace the character witrh the html entities
// maybe I'll need more of these
const $560639d49e3c9a19$var$entites = [
    [
        /</g,
        "&lt;"
    ],
    [
        />/g,
        "&gt;"
    ],
    [
        /{/g,
        "&#123;"
    ],
    [
        /}/g,
        "&#125;"
    ]
];
function $560639d49e3c9a19$var$escape_code({ blocks: blocks }) {
    return function(tree) {
        if (!blocks) $560639d49e3c9a19$var$unistUtilVisit(tree, "code", escape);
        $560639d49e3c9a19$var$unistUtilVisit(tree, "inlineCode", escape);
        function escape(node) {
            for(let i = 0; i < $560639d49e3c9a19$var$entites.length; i += 1)node.value = node.value.replace($560639d49e3c9a19$var$entites[i][0], $560639d49e3c9a19$var$entites[i][1]);
        }
    };
}
// special case - process nodes with retext and smartypants
// retext plugins can't work generally due to the difficulties in converting between the two trees
function $560639d49e3c9a19$var$smartypants_transformer(options = {}) {
    const processor = $560639d49e3c9a19$var$retext().use($560639d49e3c9a19$var$retextSmartypants, options);
    return function(tree) {
        $560639d49e3c9a19$var$unistUtilVisit(tree, "text", (node)=>{
            node.value = String(processor.processSync(node.value));
        });
    };
}
// regex for scripts and attributes
const $560639d49e3c9a19$var$attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
const $560639d49e3c9a19$var$context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
const $560639d49e3c9a19$var$RE_BLANK = /^\n+$|^\s+$/;
const $560639d49e3c9a19$var$RE_SCRIPT = new RegExp(`^(<script` + $560639d49e3c9a19$var$attrs + `>)`);
const $560639d49e3c9a19$var$RE_MODULE_SCRIPT = new RegExp(`^(<script` + $560639d49e3c9a19$var$attrs + $560639d49e3c9a19$var$context + $560639d49e3c9a19$var$attrs + `>)`);
function $560639d49e3c9a19$var$extract_parts(nodes) {
    // since we are wrapping and replacing we need to keep track of the different component 'parts'
    // many special tags cannot be wrapped nor can style or script tags
    const parts = {
        special: [],
        html: [],
        instance: [],
        module: [],
        css: []
    };
    // iterate through all top level child nodes and assign them to the correct 'part'
    // anything that is a normal HAST node gets stored as HTML untouched
    // everything else gets parsed by the svelte parser
    children: for(let i = 0; i < nodes.length; i += 1){
        const empty_node = nodes[i].type === "text" && $560639d49e3c9a19$var$RE_BLANK.exec(nodes[i].value);
        // i no longer knwo why i did this
        if (empty_node || !nodes[i].value) {
            if (!parts.html.length || !($560639d49e3c9a19$var$RE_BLANK.exec(nodes[i].value) && $560639d49e3c9a19$var$RE_BLANK.exec(parts.html[parts.html.length - 1].value))) parts.html.push(nodes[i]);
            continue children;
        }
        let result;
        try {
            result = (0, $49260c17099cae5e$exports.parse)(nodes[i].value);
        } catch (e) {
            parts.html.push(nodes[i]);
            continue children;
        }
        // svelte special tags that have to be top level
        if (!result.html || !result.html.children) return parts;
        const _parts = result.html.children.map((v)=>{
            if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body") return [
                "special",
                v.start,
                v.end
            ];
            else return [
                "html",
                v.start,
                v.end
            ];
        });
        results: for(const key in result){
            if (key === "html" || !result[key]) continue results;
            _parts.push([
                key,
                result[key].start,
                result[key].end
            ]);
        }
        // sort them to ensure the array is in the order they appear in the source, no gaps
        // this might not be necessary any more, i forget
        const sorted = _parts.sort((a, b)=>a[1] - b[1]);
        // push the nodes into the correct 'part' since they are sorted everything should be in the correct order
        sorted.forEach((next)=>{
            parts[next[0]].push({
                type: "raw",
                value: nodes[i].value.substring(next[1], next[2])
            });
        });
    }
    return parts;
}
function $560639d49e3c9a19$var$map_layout_to_path(filename, layout_map) {
    const match = Object.keys(layout_map).find((l)=>new RegExp(`\\` + `${$4S4dR$sep}${l}` + `\\` + `${$4S4dR$sep}`).test($4S4dR$normalize(filename).replace(process.cwd(), "")));
    if (match) return layout_map[match];
    else return layout_map["_"] ? layout_map["_"] : undefined;
}
function $560639d49e3c9a19$var$generate_layout_import(layout) {
    if (!layout) return false;
    return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function $560639d49e3c9a19$var$generate_layout({ frontmatter_layout: frontmatter_layout, layout_options: layout_options, layout_mode: layout_mode, filename: filename }) {
    let selected_layout;
    const error = {
        reason: ""
    };
    if (!layout_options || frontmatter_layout === false) return [
        false,
        false,
        false
    ];
    else if (layout_mode === "single") {
        selected_layout = layout_options.__mdsvex_default;
        if (frontmatter_layout) error.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
    } else if (frontmatter_layout) {
        selected_layout = layout_options[frontmatter_layout];
        if (!selected_layout) error.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
    } else selected_layout = $560639d49e3c9a19$var$map_layout_to_path(filename, layout_options);
    return [
        $560639d49e3c9a19$var$generate_layout_import(selected_layout),
        selected_layout !== undefined && selected_layout.components.length > 0 && selected_layout.components,
        error.reason ? error : false
    ];
}
function $560639d49e3c9a19$var$transform_hast({ layout: layout, layout_mode: layout_mode }) {
    return function transformer(tree, vFile) {
        // we need to keep { and } intact for svelte, so reverse the escaping in links and images
        // if anyone actually uses these characters for any other reason i'll probably just cry
        $560639d49e3c9a19$var$unistUtilVisit(tree, "element", (node)=>{
            if (node.tagName === "a" && node.properties && typeof node.properties.href === "string") node.properties.href = node.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
            if (node.tagName === "img" && node.properties && typeof node.properties.src === "string") node.properties.src = node.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
        });
        // the rest only applies to layouts and front matter
        // this  breaks position data
        // svelte preprocessors don't currently support sourcemaps
        // i'll fix this when they do
        //@ts-ignore
        if (!layout && !vFile.data.fm) return tree;
        $560639d49e3c9a19$var$unistUtilVisit(tree, "root", (node)=>{
            const { special: special, html: html, instance: instance, module: _module, css: css } = $560639d49e3c9a19$var$extract_parts(node.children);
            const { fm: metadata } = vFile.data;
            // Workaround for script and style tags in strings
            // https://github.com/sveltejs/svelte/issues/5292
            const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
            const fm = metadata && `export const metadata = ${stringified};${$560639d49e3c9a19$var$newline}` + `\tconst { ${Object.keys(metadata).join(", ")} } = metadata;`;
            const frontmatter_layout = metadata && metadata.layout;
            const [import_script, components, error] = $560639d49e3c9a19$var$generate_layout({
                frontmatter_layout: frontmatter_layout,
                layout_options: layout,
                layout_mode: layout_mode,
                //@ts-ignore
                filename: vFile.filename
            });
            if (error) vFile.messages.push(new $560639d49e3c9a19$var$vfileMessage(error.reason));
            if (components) for(let i = 0; i < components.length; i++)$560639d49e3c9a19$var$unistUtilVisit(tree, "element", (node)=>{
                if (node.tagName === components[i]) node.tagName = `Components.${components[i]}`;
            });
            // add the layout if we are using one, reusing the existing script if one exists
            if (import_script && !instance[0]) instance.push({
                type: "raw",
                value: `${$560639d49e3c9a19$var$newline}<script>${$560639d49e3c9a19$var$newline}\t${import_script}${$560639d49e3c9a19$var$newline}</script>${$560639d49e3c9a19$var$newline}`
            });
            else if (import_script) instance[0].value = instance[0].value.replace($560639d49e3c9a19$var$RE_SCRIPT, `$1${$560639d49e3c9a19$var$newline}\t${import_script}`);
            // inject the frontmatter into the module script if there is any, reusing the existing module script if one exists
            if (!_module[0] && fm) _module.push({
                type: "raw",
                value: `<script context="module">${$560639d49e3c9a19$var$newline}\t${fm}${$560639d49e3c9a19$var$newline}</script>`
            });
            else if (fm) // @ts-ignore
            _module[0].value = _module[0].value.replace($560639d49e3c9a19$var$RE_MODULE_SCRIPT, `$1${$560639d49e3c9a19$var$newline}\t${fm}`);
            // smoosh it all together in an order that makes sense,
            // if using a layout we only wrap the html and nothing else
            //@ts-ignore
            node.children = [
                //@ts-ignore
                ..._module,
                //@ts-ignore
                {
                    type: "raw",
                    value: _module[0] ? $560639d49e3c9a19$var$newline : ""
                },
                //@ts-ignore
                ...instance,
                //@ts-ignore
                {
                    type: "raw",
                    value: instance[0] ? $560639d49e3c9a19$var$newline : ""
                },
                //@ts-ignore
                ...css,
                //@ts-ignore
                {
                    type: "raw",
                    value: css[0] ? $560639d49e3c9a19$var$newline : ""
                },
                //@ts-ignore
                ...special,
                //@ts-ignore
                {
                    type: "raw",
                    value: special[0] ? $560639d49e3c9a19$var$newline : ""
                },
                {
                    //@ts-ignore
                    type: "raw",
                    value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
                },
                //@ts-ignore
                {
                    type: "raw",
                    value: $560639d49e3c9a19$var$newline
                },
                //@ts-ignore
                ...html,
                //@ts-ignore
                {
                    type: "raw",
                    value: $560639d49e3c9a19$var$newline
                },
                //@ts-ignore
                {
                    type: "raw",
                    value: import_script ? "</Layout_MDSVEX_DEFAULT>" : ""
                }
            ];
        });
    };
}
// highlighting stuff
// { [lang]: { path, deps: pointer to key } }
const $560639d49e3c9a19$var$langs = {};
let $560639d49e3c9a19$var$Prism;
const $560639d49e3c9a19$var$make_path = (base_path, id)=>base_path.replace("{id}", id);
// we need to get all language metadata
// also track if they depend on other languages so we can autoload without breaking
// i don't actually know what the require key means but it sounds important
function $560639d49e3c9a19$var$get_lang_info(name, lang_meta, base_path) {
    const _lang_meta = {
        name: name,
        path: `prismjs/${$560639d49e3c9a19$var$make_path(base_path, name)}`,
        deps: new Set()
    };
    const aliases = new Set();
    // TODO: DRY this up, it is literally identical
    if (lang_meta.require) {
        if (Array.isArray(lang_meta.require)) lang_meta.require.forEach((id)=>_lang_meta.deps.add(id));
        else _lang_meta.deps.add(lang_meta.require);
    }
    if (lang_meta.peerDependencies) {
        if (Array.isArray(lang_meta.peerDependencies)) lang_meta.peerDependencies.forEach((id)=>_lang_meta.deps.add(id));
        else _lang_meta.deps.add(lang_meta.peerDependencies);
    }
    if (lang_meta.alias) {
        if (Array.isArray(lang_meta.alias)) lang_meta.alias.forEach((id)=>aliases.add(id));
        else aliases.add(lang_meta.alias);
    }
    return [
        {
            ..._lang_meta,
            aliases: aliases
        },
        aliases
    ];
}

// workaround for ts weirdness - intersection types work better with interfaces vs object literals
function $560639d49e3c9a19$var$load_language_metadata() {
    if (!process.browser) {
        const { meta: meta, ...languages } = (parcelRequire("4bc8D")).languages;
        for(const lang in languages){
            const [lang_info, aliases] = $560639d49e3c9a19$var$get_lang_info(lang, languages[lang], meta.path);
            $560639d49e3c9a19$var$langs[lang] = lang_info;
            aliases.forEach((_n)=>{
                $560639d49e3c9a19$var$langs[_n] = $560639d49e3c9a19$var$langs[lang];
            });
        }
        const svelte_meta = {
            name: "svelte",
            aliases: new Set([
                "sv"
            ]),
            path: "prism-svelte",
            deps: new Set([
                "javscript",
                "css"
            ])
        };
        $560639d49e3c9a19$var$langs.svelte = svelte_meta;
        $560639d49e3c9a19$var$langs.sv = svelte_meta;
    }
}
function $560639d49e3c9a19$var$load_language(lang) {
    if (!process.browser) {
        if (!$560639d49e3c9a19$var$langs[lang]) return;
        $560639d49e3c9a19$var$langs[lang].deps.forEach((name)=>$560639d49e3c9a19$var$load_language(name));
        require($560639d49e3c9a19$var$langs[lang].path);
    }
}
function $560639d49e3c9a19$var$highlight_blocks({ highlighter: highlight_fn, alias: alias } = {}) {
    if (highlight_fn && !process.browser) {
        $560639d49e3c9a19$var$load_language_metadata();
        if (alias) for(const lang in alias)$560639d49e3c9a19$var$langs[lang] = $560639d49e3c9a19$var$langs[alias[lang]];
    }
    return async function(tree) {
        if (highlight_fn) {
            const nodes = [];
            $560639d49e3c9a19$var$unistUtilVisit(tree, "code", (node)=>{
                nodes.push(node);
            });
            await Promise.all(nodes.map(async (node)=>{
                node.type = "html";
                node.value = await highlight_fn(node.value, node.lang, node.meta);
            }));
        }
    };
}
// escape curlies, backtick, \t, \r, \n to avoid breaking output of {@html `here`} in .svelte
const $560639d49e3c9a19$export$92ff52ce4f9996ed = (str)=>str.replace(/[{}`]/g, //@ts-ignore
    (c)=>({
            "{": "&#123;",
            "}": "&#125;",
            "`": "&#96;"
        })[c]).replace(/\\([trn])/g, "&#92;$1");

const $560639d49e3c9a19$var$code_highlight = (code, lang)=>{
    const normalised_lang = $560639d49e3c9a19$var$_optionalChain([
        lang,
        "optionalAccess",
        (_)=>_.toLowerCase,
        "call",
        (_2)=>_2()
    ]);
    if (!process.browser) {
        let _lang = !!normalised_lang && $560639d49e3c9a19$var$langs[normalised_lang];
        if (!$560639d49e3c9a19$var$Prism) $560639d49e3c9a19$var$Prism = (parcelRequire("4wAom"));
        if (_lang && !$560639d49e3c9a19$var$Prism.languages[_lang.name]) $560639d49e3c9a19$var$load_language(_lang.name);
        if (!_lang && normalised_lang && $560639d49e3c9a19$var$Prism.languages[normalised_lang]) {
            $560639d49e3c9a19$var$langs[normalised_lang] = {
                name: lang
            };
            _lang = $560639d49e3c9a19$var$langs[normalised_lang];
        }
        const highlighted = $560639d49e3c9a19$export$92ff52ce4f9996ed(_lang ? $560639d49e3c9a19$var$Prism.highlight(code, $560639d49e3c9a19$var$Prism.languages[_lang.name], _lang.name) : $560639d49e3c9a19$var$escapeHtml_1(code));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
    } else {
        const highlighted = $560639d49e3c9a19$export$92ff52ce4f9996ed($560639d49e3c9a19$var$escapeHtml_1(code));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
    }
};
function $560639d49e3c9a19$var$stringify(options = {}) {
    this.Compiler = compiler;
    function compiler(tree) {
        return $560639d49e3c9a19$var$prettyhtmlHastToHtml(tree, options);
    }
}
const $560639d49e3c9a19$var$apply_plugins = (plugins, parser)=>{
    plugins.forEach((plugin)=>{
        if (Array.isArray(plugin)) {
            if (plugin[1] && plugin[1]) parser.use(plugin[0], plugin[1]);
            else parser.use(plugin[0]);
        } else parser.use(plugin);
    });
    return parser;
};
function $560639d49e3c9a19$var$transform({ remarkPlugins: remarkPlugins = [], rehypePlugins: rehypePlugins = [], frontmatter: frontmatter, smartypants: smartypants, layout: layout, layout_mode: layout_mode, highlight: highlight } = {
    layout_mode: "single"
}) {
    const fm_opts = frontmatter ? frontmatter : {
        parse: $560639d49e3c9a19$var$default_frontmatter,
        type: "yaml",
        marker: "-"
    };
    const toMDAST = $560639d49e3c9a19$var$unified_1$1().use($560639d49e3c9a19$var$remarkParse).use($560639d49e3c9a19$var$mdsvex_parser).use($560639d49e3c9a19$var$remarkExternalLinks, {
        target: false,
        rel: [
            "nofollow"
        ]
    }).use($560639d49e3c9a19$var$escape_code, {
        blocks: !!highlight
    }).use($560639d49e3c9a19$var$remarkFrontmatter, [
        {
            type: fm_opts.type,
            marker: fm_opts.marker
        }
    ]).use($560639d49e3c9a19$var$parse_frontmatter, {
        parse: fm_opts.parse,
        type: fm_opts.type
    });
    if (smartypants) toMDAST.use($560639d49e3c9a19$var$smartypants_transformer, typeof smartypants === "boolean" ? {} : smartypants);
    $560639d49e3c9a19$var$apply_plugins(remarkPlugins, toMDAST).use($560639d49e3c9a19$var$highlight_blocks, highlight || {});
    const toHAST = toMDAST.use($560639d49e3c9a19$var$remarkRehype, {
        // @ts-ignore
        allowDangerousHtml: true,
        allowDangerousCharacters: true
    }).use($560639d49e3c9a19$var$transform_hast, {
        layout: layout,
        layout_mode: layout_mode
    });
    $560639d49e3c9a19$var$apply_plugins(rehypePlugins, toHAST);
    const processor = toHAST.use($560639d49e3c9a19$var$stringify, {
        allowDangerousHtml: true,
        allowDangerousCharacters: true
    });
    return processor;
}
const $560639d49e3c9a19$var$defaults = {
    remarkPlugins: [],
    rehypePlugins: [],
    smartypants: true,
    extension: ".svx",
    highlight: {
        highlighter: $560639d49e3c9a19$var$code_highlight
    }
};
function $560639d49e3c9a19$var$to_posix(_path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
    if (isExtendedLengthPath || hasNonAscii) return _path;
    return _path.replace(/\\/g, "/");
}
function $560639d49e3c9a19$var$resolve_layout(layout_path) {
    try {
        return $560639d49e3c9a19$var$to_posix(undefined(layout_path));
    } catch (e) {
        try {
            const _path = (0, $4S4dR$join)(process.cwd(), layout_path);
            return $560639d49e3c9a19$var$to_posix(undefined(_path));
        } catch (e) {
            throw new Error(`The layout path you provided couldn't be found at either ${layout_path} or ${(0, $4S4dR$join)(process.cwd(), layout_path)}. Please double-check it and try again.`);
        }
    }
}
// handle custom components
function $560639d49e3c9a19$var$process_layouts(layouts) {
    const _layouts = layouts;
    for(const key in _layouts){
        const layout = (0, $4S4dR$fs).readFileSync(_layouts[key].path, {
            encoding: "utf8"
        });
        let ast;
        try {
            ast = (0, $49260c17099cae5e$exports.parse)(layout);
        } catch (e) {
            throw new Error(e.toString() + `\n	at ${_layouts[key].path}`);
        }
        if (ast.module) {
            const component_exports = ast.module.content.body.filter((node)=>node.type === "ExportNamedDeclaration");
            if (component_exports.length) {
                _layouts[key].components = [];
                for(let i = 0; i < component_exports.length; i++){
                    if (component_exports[i].specifiers && component_exports[i].specifiers.length) for(let j = 0; j < component_exports[i].specifiers.length; j++)_layouts[key].components.push(component_exports[i].specifiers[j].exported.name);
                    else if (component_exports[i].declaration.declarations) {
                        //@ts-ignore
                        const declarations = component_exports[i].declaration.declarations;
                        for(let j = 0; j < declarations.length; j++)_layouts[key].components.push(declarations[j].id.name);
                    } else if (component_exports[i].declaration) _layouts[key].components.push(//@ts-ignore
                    component_exports[i].declaration.id.name);
                }
            }
        }
    }
    return _layouts;
}
/**
 * The svelte preprocessor for use with svelte.preprocess
 *
 * **options** - An options object with the following properties, all are optional.
 *
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 *
 */ const $560639d49e3c9a19$export$d61cf7a1924293cc = (options = $560639d49e3c9a19$var$defaults)=>{
    const { remarkPlugins: remarkPlugins = [], rehypePlugins: rehypePlugins = [], smartypants: smartypants = true, extension: extension = ".svx", extensions: extensions, layout: layout = false, highlight: highlight = {
        highlighter: $560639d49e3c9a19$var$code_highlight
    }, frontmatter: frontmatter } = options;
    //@ts-ignore
    if (options.layouts) throw new Error(`mdsvex: "layouts" is not a valid option. Did you mean "layout"?`);
    const unknown_opts = [];
    const known_opts = [
        "filename",
        "remarkPlugins",
        "rehypePlugins",
        "smartypants",
        "extension",
        "extensions",
        "layout",
        "highlight",
        "frontmatter"
    ];
    for(const opt in options)if (!known_opts.includes(opt)) unknown_opts.push(opt);
    if (unknown_opts.length) console.warn(`mdsvex: Received unknown options: ${unknown_opts.join(", ")}. Valid options are: ${known_opts.join(", ")}.`);
    let _layout = {};
    let layout_mode = "single";
    if (typeof layout === "string") _layout.__mdsvex_default = {
        path: $560639d49e3c9a19$var$resolve_layout(layout),
        components: []
    };
    else if (typeof layout === "object") {
        layout_mode = "named";
        for(const name in layout)_layout[name] = {
            path: $560639d49e3c9a19$var$resolve_layout(layout[name]),
            components: []
        };
    }
    if (highlight && highlight.highlighter === undefined) highlight.highlighter = $560639d49e3c9a19$var$code_highlight;
    _layout = $560639d49e3c9a19$var$process_layouts(_layout);
    const parser = $560639d49e3c9a19$var$transform({
        remarkPlugins: remarkPlugins,
        rehypePlugins: rehypePlugins,
        smartypants: smartypants,
        layout: _layout,
        layout_mode: layout_mode,
        highlight: highlight,
        frontmatter: frontmatter
    });
    return {
        markup: async ({ content: content, filename: filename })=>{
            const extensionsParts = (extensions || [
                extension
            ]).map((ext)=>ext.split(".").pop());
            if (!extensionsParts.includes(filename.split(".").pop())) return;
            const parsed = await parser.process({
                contents: content,
                filename: filename
            });
            return {
                code: parsed.contents,
                data: parsed.data,
                map: ""
            };
        }
    };
};
/**
 * The standalone compile function.
 *
 * - **source** - the source code to convert.
 * - **options** - An options object with the following properties, all are optional.
 *
 * - `filename` - The filename of the generated file
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 */ const $560639d49e3c9a19$export$ef7acd7185315e22 = (source, opts)=>$560639d49e3c9a19$export$d61cf7a1924293cc(opts).markup({
        content: source,
        filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
    });


var $365749e2073871b1$exports = {};
var $bc540824f1c98218$exports = {};

var $4wAom = parcelRequire("4wAom");
var $34b7c77508ea8b01$exports = {};
$34b7c77508ea8b01$exports = {
    // Case insensitive
    // If you are changing this, update the inlined version in api/status/[...route]/extractQueries.server.js
    supportedLangs: [
        "JavaScript",
        "HTML",
        "CSS",
        "SQL",
        "Python",
        "TypeScript",
        "Java",
        "Bash",
        "CSharp",
        "C++",
        "PHP",
        "C",
        "PowerShell",
        "Go",
        "Rust",
        "Kotlin",
        "Dart",
        "Ruby",
        "R",
        "MATLAB",
        "DAX",
        "JSON",
        "YAML",
        "Markdown",
        "Code",
        "Svelte",
        "Shell"
    ].map((r)=>r.toLowerCase())
};


var $bc540824f1c98218$require$supportedLangs = $34b7c77508ea8b01$exports.supportedLangs;
/**
 * @returns {Set<string>}
 */ const $bc540824f1c98218$var$getPrismLangs = function() {
    let prismLangs = new Set();
    $bc540824f1c98218$require$supportedLangs.forEach((supportedLanguage)=>{
        prismLangs.add(supportedLanguage);
        if (supportedLanguage in $4wAom.languages) {
            const languageComponent = $4wAom.languages[supportedLanguage];
            if (languageComponent.alias) {
                if (Array.isArray(languageComponent.alias)) languageComponent.alias.forEach((a)=>prismLangs.add(a));
                else prismLangs.add(languageComponent.alias);
            }
        }
    });
    return prismLangs;
};
$bc540824f1c98218$exports = $bc540824f1c98218$var$getPrismLangs;


/**
 *
 * @param {string} code
 * @param {string} lang
 * @param {string | undefined} meta
 * @returns
 */ function $365749e2073871b1$var$highlighter(code, lang, meta) {
    code = code.replace(/'/g, "&apos;");
    code = code.replace(/"/g, "&quot;");
    // Replace curly braces or Svelte will try to evaluate as a JS expression
    code = code.replace(/{/g, "&lbrace;").replace(/}/g, "&rbrace;");
    if (lang?.toLowerCase() === "sql" && meta || !$bc540824f1c98218$exports().has(lang?.toLowerCase() ?? "")) {
        const queryId = lang?.toLowerCase() === "sql" && meta ? meta : lang;
        return `
        {#if ${queryId} }
            <QueryViewer
                queryID = "${queryId ?? "untitled"}"
                queryResult = {${queryId ?? "untitled"}}
            /> 
        {/if}
        `;
    }
    // Ensure that "real" code blocks are rendered not run as queries
    return `<CodeBlock source="${code}" copyToClipboard=true />`;
}
$365749e2073871b1$exports = {
    highlighter: $365749e2073871b1$var$highlighter
};


var $3fd82c6737eb24ad$require$highlighter = $365749e2073871b1$exports.highlighter;
var $7d9f7d1f69c18b39$exports = {};
/**
 * @type {import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ const $7d9f7d1f69c18b39$var$addScriptTags = {
    markup ({ content: content, filename: filename }) {
        if (filename.endsWith(".md")) {
            if (!content.match(/\<script(.*)\>/)) return {
                code: '<script context="module"> </script><script> </script>' + content
            };
            if (!content.match(/\<script(.*)context\=\"module\"(.*)\>/)) return {
                code: '<script context="module"> </script>' + content
            };
            if (!content.match(/\<script\>/)) return {
                code: "<script> </script>" + content
            };
        }
    }
};
$7d9f7d1f69c18b39$exports = $7d9f7d1f69c18b39$var$addScriptTags;


var $bb8aaf4d81463a1b$exports = {};
var $8f0b7f8489fbb30d$exports = {};
var $0515c28000a54e5a$exports = {};
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ /* global define */ (function($) {
    "use strict";
    /**
   * Add integers, wrapping at 2^32.
   * This uses 16-bit operations internally to work around bugs in interpreters.
   *
   * @param {number} x First integer
   * @param {number} y Second integer
   * @returns {number} Sum
   */ function safeAdd(x, y) {
        var lsw = (x & 0xffff) + (y & 0xffff);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 0xffff;
    }
    /**
   * Bitwise rotate a 32-bit number to the left.
   *
   * @param {number} num 32-bit number
   * @param {number} cnt Rotation count
   * @returns {number} Rotated number
   */ function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} q q
   * @param {number} a a
   * @param {number} b b
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5ff(a, b, c, d, x, s, t) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5gg(a, b, c, d, x, s, t) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    /**
   * Calculate the MD5 of an array of little-endian words, and a bit length.
   *
   * @param {Array} x Array of little-endian words
   * @param {number} len Bit length
   * @returns {Array<number>} MD5 Array
   */ function binlMD5(x, len) {
        /* append padding */ x[len >> 5] |= 0x80 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for(i = 0; i < x.length; i += 16){
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;
            a = md5ff(a, b, c, d, x[i], 7, -680876936);
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5gg(b, c, d, a, x[i], 20, -373897302);
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5hh(d, a, b, c, x[i], 11, -358537222);
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5ii(a, b, c, d, x[i], 6, -198630844);
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safeAdd(a, olda);
            b = safeAdd(b, oldb);
            c = safeAdd(c, oldc);
            d = safeAdd(d, oldd);
        }
        return [
            a,
            b,
            c,
            d
        ];
    }
    /**
   * Convert an array of little-endian words to a string
   *
   * @param {Array<number>} input MD5 Array
   * @returns {string} MD5 string
   */ function binl2rstr(input) {
        var i;
        var output = "";
        var length32 = input.length * 32;
        for(i = 0; i < length32; i += 8)output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);
        return output;
    }
    /**
   * Convert a raw string to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   *
   * @param {string} input Raw input string
   * @returns {Array<number>} Array of little-endian words
   */ function rstr2binl(input) {
        var i;
        var output = [];
        output[(input.length >> 2) - 1] = undefined;
        for(i = 0; i < output.length; i += 1)output[i] = 0;
        var length8 = input.length * 8;
        for(i = 0; i < length8; i += 8)output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
        return output;
    }
    /**
   * Calculate the MD5 of a raw string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */ function rstrMD5(s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
    }
    /**
   * Calculates the HMAC-MD5 of a key and some data (raw strings)
   *
   * @param {string} key HMAC key
   * @param {string} data Raw input string
   * @returns {string} Raw MD5 string
   */ function rstrHMACMD5(key, data) {
        var i;
        var bkey = rstr2binl(key);
        var ipad = [];
        var opad = [];
        var hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) bkey = binlMD5(bkey, key.length * 8);
        for(i = 0; i < 16; i += 1){
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5c5c5c5c;
        }
        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binlMD5(opad.concat(hash), 640));
    }
    /**
   * Convert a raw string to a hex string
   *
   * @param {string} input Raw input string
   * @returns {string} Hex encoded string
   */ function rstr2hex(input) {
        var hexTab = "0123456789abcdef";
        var output = "";
        var x;
        var i;
        for(i = 0; i < input.length; i += 1){
            x = input.charCodeAt(i);
            output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);
        }
        return output;
    }
    /**
   * Encode a string as UTF-8
   *
   * @param {string} input Input string
   * @returns {string} UTF8 string
   */ function str2rstrUTF8(input) {
        return unescape(encodeURIComponent(input));
    }
    /**
   * Encodes input string as raw MD5 string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */ function rawMD5(s) {
        return rstrMD5(str2rstrUTF8(s));
    }
    /**
   * Encodes input string as Hex encoded string
   *
   * @param {string} s Input string
   * @returns {string} Hex encoded string
   */ function hexMD5(s) {
        return rstr2hex(rawMD5(s));
    }
    /**
   * Calculates the raw HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */ function rawHMACMD5(k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
    }
    /**
   * Calculates the Hex encoded HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */ function hexHMACMD5(k, d) {
        return rstr2hex(rawHMACMD5(k, d));
    }
    /**
   * Calculates MD5 value for a given string.
   * If a key is provided, calculates the HMAC-MD5 value.
   * Returns a Hex encoded string unless the raw argument is given.
   *
   * @param {string} string Input string
   * @param {string} [key] HMAC key
   * @param {boolean} [raw] Raw output switch
   * @returns {string} MD5 output
   */ function md5(string, key, raw) {
        if (!key) {
            if (!raw) return hexMD5(string);
            return rawMD5(string);
        }
        if (!raw) return hexHMACMD5(key, string);
        return rawHMACMD5(key, string);
    }
    if (typeof define === "function" && define.amd) define(function() {
        return md5;
    });
    else if (0, $0515c28000a54e5a$exports) $0515c28000a54e5a$exports = md5;
    else $.md5 = md5;
})($0515c28000a54e5a$exports);


$8f0b7f8489fbb30d$exports = {
    /**
	 * Generates a unique (but consistent) hash for a route
	 * @param {string} filename
	 * @example /src/pages/+page.md /src/pages/my-route/+page.md
	 * @returns string
	 */ getRouteHash: (filename)=>{
        const isIndex = filename.split("/src/pages")[1] === "/+page.md";
        if (isIndex) return $0515c28000a54e5a$exports("/");
        let route = filename.split("/src/pages")?.[1].replace(".md", "").replace(/\/\+page/g, "");
        if (!route) throw new Error(`Failed to generate route hash for ${filename} (${JSON.stringify({
            isIndex: isIndex
        })})`);
        return $0515c28000a54e5a$exports(route);
    }
};


var $bb8aaf4d81463a1b$require$getRouteHash = $8f0b7f8489fbb30d$exports.getRouteHash;
var $3bc517d55346f2bb$exports = {};
var $7f6f6807a3a8644e$exports = {};
"use strict";
var $df3ba5e804f3b490$exports = {};
"use strict";
$df3ba5e804f3b490$exports = $df3ba5e804f3b490$var$bail;
function $df3ba5e804f3b490$var$bail(err) {
    if (err) throw err;
}



var $9POxA = parcelRequire("9POxA");
var $5f4474664cf1d724$exports = {};
"use strict";
var $5f4474664cf1d724$var$hasOwn = Object.prototype.hasOwnProperty;
var $5f4474664cf1d724$var$toStr = Object.prototype.toString;
var $5f4474664cf1d724$var$defineProperty = Object.defineProperty;
var $5f4474664cf1d724$var$gOPD = Object.getOwnPropertyDescriptor;
var $5f4474664cf1d724$var$isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") return Array.isArray(arr);
    return $5f4474664cf1d724$var$toStr.call(arr) === "[object Array]";
};
var $5f4474664cf1d724$var$isPlainObject = function isPlainObject(obj) {
    if (!obj || $5f4474664cf1d724$var$toStr.call(obj) !== "[object Object]") return false;
    var hasOwnConstructor = $5f4474664cf1d724$var$hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $5f4474664cf1d724$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for(key in obj);
    return typeof key === "undefined" || $5f4474664cf1d724$var$hasOwn.call(obj, key);
};
// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var $5f4474664cf1d724$var$setProperty = function setProperty(target, options) {
    if ($5f4474664cf1d724$var$defineProperty && options.name === "__proto__") $5f4474664cf1d724$var$defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
    });
    else target[options.name] = options.newValue;
};
// Return undefined instead of __proto__ if '__proto__' is not an own property
var $5f4474664cf1d724$var$getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
        if (!$5f4474664cf1d724$var$hasOwn.call(obj, name)) return void 0;
        else if ($5f4474664cf1d724$var$gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return $5f4474664cf1d724$var$gOPD(obj, name).value;
    }
    return obj[name];
};
$5f4474664cf1d724$exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
    for(; i < length; ++i){
        options = arguments[i];
        // Only deal with non-null/undefined values
        if (options != null) // Extend the base object
        for(name in options){
            src = $5f4474664cf1d724$var$getProperty(target, name);
            copy = $5f4474664cf1d724$var$getProperty(options, name);
            // Prevent never-ending loop
            if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && ($5f4474664cf1d724$var$isPlainObject(copy) || (copyIsArray = $5f4474664cf1d724$var$isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && $5f4474664cf1d724$var$isArray(src) ? src : [];
                    } else clone = src && $5f4474664cf1d724$var$isPlainObject(src) ? src : {};
                    // Never move original objects, clone them
                    $5f4474664cf1d724$var$setProperty(target, {
                        name: name,
                        newValue: extend(deep, clone, copy)
                    });
                // Don't bring in undefined values
                } else if (typeof copy !== "undefined") $5f4474664cf1d724$var$setProperty(target, {
                    name: name,
                    newValue: copy
                });
            }
        }
    }
    // Return the modified object
    return target;
};


var $b2243982bfcc40b1$exports = {};
"use strict";
$b2243982bfcc40b1$exports = (value)=>{
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};


var $d42d0c51804cd466$exports = {};
"use strict";
var $31c5a40faaf91428$exports = {};
"use strict";
var $31c5a40faaf91428$var$slice = [].slice;
$31c5a40faaf91428$exports = $31c5a40faaf91428$var$wrap;
// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function $31c5a40faaf91428$var$wrap(fn, callback) {
    var invoked;
    return wrapped;
    function wrapped() {
        var params = $31c5a40faaf91428$var$slice.call(arguments, 0);
        var callback = fn.length > params.length;
        var result;
        if (callback) params.push(done);
        try {
            result = fn.apply(null, params);
        } catch (error) {
            // Well, this is quite the pickle.
            // `fn` received a callback and invoked it (thus continuing the pipeline),
            // but later also threw an error.
            // We’re not about to restart the pipeline again, so the only thing left
            // to do is to throw the thing instead.
            if (callback && invoked) throw error;
            return done(error);
        }
        if (!callback) {
            if (result && typeof result.then === "function") result.then(then, done);
            else if (result instanceof Error) done(result);
            else then(result);
        }
    }
    // Invoke `next`, only once.
    function done() {
        if (!invoked) {
            invoked = true;
            callback.apply(null, arguments);
        }
    }
    // Invoke `done` with one value.
    // Tracks if an error is passed, too.
    function then(value) {
        done(null, value);
    }
}


$d42d0c51804cd466$exports = $d42d0c51804cd466$var$trough;
$d42d0c51804cd466$var$trough.wrap = $31c5a40faaf91428$exports;
var $d42d0c51804cd466$var$slice = [].slice;
// Create new middleware.
function $d42d0c51804cd466$var$trough() {
    var fns = [];
    var middleware = {};
    middleware.run = run;
    middleware.use = use;
    return middleware;
    // Run `fns`.  Last argument must be a completion handler.
    function run() {
        var index = -1;
        var input = $d42d0c51804cd466$var$slice.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") throw new Error("Expected function as last argument, not " + done);
        next.apply(null, [
            null
        ].concat(input));
        // Run the next `fn`, if any.
        function next(err) {
            var fn = fns[++index];
            var params = $d42d0c51804cd466$var$slice.call(arguments, 0);
            var values = params.slice(1);
            var length = input.length;
            var pos = -1;
            if (err) {
                done(err);
                return;
            }
            // Copy non-nully input into values.
            while(++pos < length)if (values[pos] === null || values[pos] === undefined) values[pos] = input[pos];
            input = values;
            // Next or done.
            if (fn) $31c5a40faaf91428$exports(fn, next).apply(null, input);
            else done.apply(null, [
                null
            ].concat(input));
        }
    }
    // Add `fn` to the list.
    function use(fn) {
        if (typeof fn !== "function") throw new Error("Expected `fn` to be a function, not " + fn);
        fns.push(fn);
        return middleware;
    }
}


var $10b7bc44255075d9$exports = {};
"use strict";

$10b7bc44255075d9$exports = (parcelRequire("i3bOO"));


// Expose a frozen processor.
$7f6f6807a3a8644e$exports = $7f6f6807a3a8644e$var$unified().freeze();
var $7f6f6807a3a8644e$var$slice = [].slice;
var $7f6f6807a3a8644e$var$own = {}.hasOwnProperty;
// Process pipeline.
var $7f6f6807a3a8644e$var$pipeline = $d42d0c51804cd466$exports().use($7f6f6807a3a8644e$var$pipelineParse).use($7f6f6807a3a8644e$var$pipelineRun).use($7f6f6807a3a8644e$var$pipelineStringify);
function $7f6f6807a3a8644e$var$pipelineParse(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $7f6f6807a3a8644e$var$pipelineRun(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $7f6f6807a3a8644e$var$pipelineStringify(p, ctx) {
    var result = p.stringify(ctx.tree, ctx.file);
    var file = ctx.file;
    if (result === undefined || result === null) ;
    else if (typeof result === "string" || $9POxA(result)) file.contents = result;
    else file.result = result;
}
// Function to create the first processor.
function $7f6f6807a3a8644e$var$unified() {
    var attachers = [];
    var transformers = $d42d0c51804cd466$exports();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $7f6f6807a3a8644e$var$unified();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($5f4474664cf1d724$exports(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $7f6f6807a3a8644e$var$assertUnfrozen("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $7f6f6807a3a8644e$var$own.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $7f6f6807a3a8644e$var$assertUnfrozen("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $7f6f6807a3a8644e$var$assertUnfrozen("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $5f4474664cf1d724$exports(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $5f4474664cf1d724$exports(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($b2243982bfcc40b1$exports(entry[1]) && $b2243982bfcc40b1$exports(value)) value = $5f4474664cf1d724$exports(entry[1], value);
                entry[1] = value;
            } else attachers.push($7f6f6807a3a8644e$var$slice.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $10b7bc44255075d9$exports(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $7f6f6807a3a8644e$var$assertParser("parse", Parser);
        if ($7f6f6807a3a8644e$var$newable(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $7f6f6807a3a8644e$var$assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $10b7bc44255075d9$exports(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $7f6f6807a3a8644e$var$assertDone("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $df3ba5e804f3b490$exports(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $10b7bc44255075d9$exports(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $7f6f6807a3a8644e$var$assertCompiler("stringify", Compiler);
        $7f6f6807a3a8644e$var$assertNode(node);
        if ($7f6f6807a3a8644e$var$newable(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process(doc, cb) {
        freeze();
        $7f6f6807a3a8644e$var$assertParser("process", processor.Parser);
        $7f6f6807a3a8644e$var$assertCompiler("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $10b7bc44255075d9$exports(doc);
            $7f6f6807a3a8644e$var$pipeline.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $7f6f6807a3a8644e$var$assertParser("processSync", processor.Parser);
        $7f6f6807a3a8644e$var$assertCompiler("processSync", processor.Compiler);
        file = $10b7bc44255075d9$exports(doc);
        process(file, done);
        $7f6f6807a3a8644e$var$assertDone("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $df3ba5e804f3b490$exports(err);
        }
    }
}
// Check if `value` is a constructor.
function $7f6f6807a3a8644e$var$newable(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($7f6f6807a3a8644e$var$keys(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $7f6f6807a3a8644e$var$keys(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $7f6f6807a3a8644e$var$assertParser(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $7f6f6807a3a8644e$var$assertCompiler(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $7f6f6807a3a8644e$var$assertUnfrozen(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $7f6f6807a3a8644e$var$assertNode(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $7f6f6807a3a8644e$var$assertDone(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}


var $4ecf9a54af9f01ab$exports = {};
"use strict";
var $16758458ef599f83$exports = {};
"use strict";

var $gqx3p = parcelRequire("gqx3p");
var $73e3fac3938c8b64$exports = {};


try {
    var $73e3fac3938c8b64$var$util = $73e3fac3938c8b64$import$1706da53f7e85fa1;
    /* istanbul ignore next */ if (typeof $73e3fac3938c8b64$var$util.inherits !== "function") throw "";
    $73e3fac3938c8b64$exports = $73e3fac3938c8b64$var$util.inherits;
} catch (e) {
    /* istanbul ignore next */ $73e3fac3938c8b64$exports = (parcelRequire("cSDDS"));
}


$16758458ef599f83$exports = $16758458ef599f83$var$unherit;
// Create a custom constructor which can be modified without affecting the
// original class.
function $16758458ef599f83$var$unherit(Super) {
    var result;
    var key;
    var value;
    $73e3fac3938c8b64$exports(Of, Super);
    $73e3fac3938c8b64$exports(From, Of);
    // Clone values.
    result = Of.prototype;
    for(key in result){
        value = result[key];
        if (value && typeof value === "object") result[key] = "concat" in value ? value.concat() : $gqx3p(value);
    }
    return Of;
    // Constructor accepting a single argument, which itself is an `arguments`
    // object.
    function From(parameters) {
        return Super.apply(this, parameters);
    }
    // Constructor accepting variadic arguments.
    function Of() {
        if (!(this instanceof Of)) return new From(arguments);
        return Super.apply(this, arguments);
    }
}



var $gqx3p = parcelRequire("gqx3p");
var $ed2921c87997049c$exports = {};
"use strict";

var $gqx3p = parcelRequire("gqx3p");
var $aec8e6fcf2d07ca0$exports = {};
"use strict";
$aec8e6fcf2d07ca0$exports = $aec8e6fcf2d07ca0$var$factory;
// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function $aec8e6fcf2d07ca0$var$factory(key, state, ctx) {
    return enter;
    function enter() {
        var context = ctx || this;
        var current = context[key];
        context[key] = !state;
        return exit;
        function exit() {
            context[key] = current;
        }
    }
}


var $cd6373c8f2c4afd5$exports = {};
"use strict";
$cd6373c8f2c4afd5$exports = $cd6373c8f2c4afd5$var$factory;
function $cd6373c8f2c4afd5$var$factory(file) {
    var value = String(file);
    var indices = [];
    var search = /\r?\n|\r/g;
    while(search.exec(value))indices.push(search.lastIndex);
    indices.push(value.length + 1);
    return {
        toPoint: offsetToPoint,
        toPosition: offsetToPoint,
        toOffset: pointToOffset
    };
    // Get the line and column-based `point` for `offset` in the bound indices.
    function offsetToPoint(offset) {
        var index = -1;
        if (offset > -1 && offset < indices[indices.length - 1]) while(++index < indices.length){
            if (indices[index] > offset) return {
                line: index + 1,
                column: offset - (indices[index - 1] || 0) + 1,
                offset: offset
            };
        }
        return {};
    }
    // Get the `offset` for a line and column-based `point` in the bound
    // indices.
    function pointToOffset(point) {
        var line = point && point.line;
        var column = point && point.column;
        var offset;
        if (!isNaN(line) && !isNaN(column) && line - 1 in indices) offset = (indices[line - 2] || 0) + column - 1 || 0;
        return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
    }
}


var $2a69ad6a0b7ae99b$exports = {};
"use strict";
$2a69ad6a0b7ae99b$exports = $2a69ad6a0b7ae99b$var$factory;
var $2a69ad6a0b7ae99b$var$backslash = "\\";
// Factory to de-escape a value, based on a list at `key` in `ctx`.
function $2a69ad6a0b7ae99b$var$factory(ctx, key) {
    return unescape;
    // De-escape a string using the expression at `key` in `ctx`.
    function unescape(value) {
        var previous = 0;
        var index = value.indexOf($2a69ad6a0b7ae99b$var$backslash);
        var escape = ctx[key];
        var queue = [];
        var character;
        while(index !== -1){
            queue.push(value.slice(previous, index));
            previous = index + 1;
            character = value.charAt(previous);
            // If the following character is not a valid escape, add the slash.
            if (!character || escape.indexOf(character) === -1) queue.push($2a69ad6a0b7ae99b$var$backslash);
            index = value.indexOf($2a69ad6a0b7ae99b$var$backslash, previous + 1);
        }
        queue.push(value.slice(previous));
        return queue.join("");
    }
}


var $d2ac610520580292$exports = {};
"use strict";

var $gqx3p = parcelRequire("gqx3p");

var $3qZkh = parcelRequire("3qZkh");
$d2ac610520580292$exports = $d2ac610520580292$var$factory;
// Factory to create an entity decoder.
function $d2ac610520580292$var$factory(ctx) {
    decoder.raw = decodeRaw;
    return decoder;
    // Normalize `position` to add an `indent`.
    function normalize(position) {
        var offsets = ctx.offset;
        var line = position.line;
        var result = [];
        while(++line){
            if (!(line in offsets)) break;
            result.push((offsets[line] || 0) + 1);
        }
        return {
            start: position,
            indent: result
        };
    }
    // Decode `value` (at `position`) into text-nodes.
    function decoder(value, position, handler) {
        $3qZkh(value, {
            position: normalize(position),
            warning: handleWarning,
            text: handler,
            reference: handler,
            textContext: ctx,
            referenceContext: ctx
        });
    }
    // Decode `value` (at `position`) into a string.
    function decodeRaw(value, position, options) {
        return $3qZkh(value, $gqx3p(options, {
            position: normalize(position),
            warning: handleWarning
        }));
    }
    // Handle a warning.
    // See <https://github.com/wooorm/parse-entities> for the warnings.
    function handleWarning(reason, position, code) {
        if (code !== 3) ctx.file.message(reason, position);
    }
}


var $a79271e383b04b47$exports = {};
"use strict";
$a79271e383b04b47$exports = $a79271e383b04b47$var$factory;
// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
function $a79271e383b04b47$var$factory(type) {
    return tokenize;
    // Tokenizer for a bound `type`.
    function tokenize(value, location) {
        var self = this;
        var offset = self.offset;
        var tokens = [];
        var methods = self[type + "Methods"];
        var tokenizers = self[type + "Tokenizers"];
        var line = location.line;
        var column = location.column;
        var index;
        var length;
        var method;
        var name;
        var matched;
        var valueLength;
        // Trim white space only lines.
        if (!value) return tokens;
        // Expose on `eat`.
        eat.now = now;
        eat.file = self.file;
        // Sync initial offset.
        updatePosition("");
        // Iterate over `value`, and iterate over all tokenizers.  When one eats
        // something, re-iterate with the remaining value.  If no tokenizer eats,
        // something failed (should not happen) and an exception is thrown.
        while(value){
            index = -1;
            length = methods.length;
            matched = false;
            while(++index < length){
                name = methods[index];
                method = tokenizers[name];
                // Previously, we had constructs such as footnotes and YAML that used
                // these properties.
                // Those are now external (plus there are userland extensions), that may
                // still use them.
                if (method && /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) && /* istanbul ignore next */ (!method.notInList || !self.inList) && /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {
                    valueLength = value.length;
                    method.apply(self, [
                        eat,
                        value
                    ]);
                    matched = valueLength !== value.length;
                    if (matched) break;
                }
            }
            /* istanbul ignore if */ if (!matched) self.file.fail(new Error("Infinite loop"), eat.now());
        }
        self.eof = now();
        return tokens;
        // Update line, column, and offset based on `value`.
        function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf("\n");
            while(index !== -1){
                line++;
                lastIndex = index;
                index = subvalue.indexOf("\n", index + 1);
            }
            if (lastIndex === -1) column += subvalue.length;
            else column = subvalue.length - lastIndex;
            if (line in offset) {
                if (lastIndex !== -1) column += offset[line];
                else if (column <= offset[line]) column = offset[line] + 1;
            }
        }
        // Get offset.  Called before the first character is eaten to retrieve the
        // range’s offsets.
        function getOffset() {
            var indentation = [];
            var pos = line + 1;
            // Done.  Called when the last character is eaten to retrieve the range’s
            // offsets.
            return function() {
                var last = line + 1;
                while(pos < last){
                    indentation.push((offset[pos] || 0) + 1);
                    pos++;
                }
                return indentation;
            };
        }
        // Get the current position.
        function now() {
            var pos = {
                line: line,
                column: column
            };
            pos.offset = self.toOffset(pos);
            return pos;
        }
        // Store position information for a node.
        function Position(start) {
            this.start = start;
            this.end = now();
        }
        // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
        // throw on new, incorrect rules.
        function validateEat(subvalue) {
            /* istanbul ignore if */ if (value.slice(0, subvalue.length) !== subvalue) // Capture stack-trace.
            self.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
        }
        // Mark position and patch `node.position`.
        function position() {
            var before = now();
            return update;
            // Add the position to a node.
            function update(node, indent) {
                var previous = node.position;
                var start = previous ? previous.start : before;
                var combined = [];
                var n = previous && previous.end.line;
                var l = before.line;
                node.position = new Position(start);
                // If there was already a `position`, this node was merged.  Fixing
                // `start` wasn’t hard, but the indent is different.  Especially
                // because some information, the indent between `n` and `l` wasn’t
                // tracked.  Luckily, that space is (should be?) empty, so we can
                // safely check for it now.
                if (previous && indent && previous.indent) {
                    combined = previous.indent;
                    if (n < l) {
                        while(++n < l)combined.push((offset[n] || 0) + 1);
                        combined.push(before.column);
                    }
                    indent = combined.concat(indent);
                }
                node.position.indent = indent || [];
                return node;
            }
        }
        // Add `node` to `parent`s children or to `tokens`.  Performs merges where
        // possible.
        function add(node, parent) {
            var children = parent ? parent.children : tokens;
            var previous = children[children.length - 1];
            var fn;
            if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $a79271e383b04b47$var$mergeable(previous) && $a79271e383b04b47$var$mergeable(node)) {
                fn = node.type === "text" ? $a79271e383b04b47$var$mergeText : $a79271e383b04b47$var$mergeBlockquote;
                node = fn.call(self, previous, node);
            }
            if (node !== previous) children.push(node);
            if (self.atStart && tokens.length !== 0) self.exitStart();
            return node;
        }
        // Remove `subvalue` from `value`.  `subvalue` must be at the start of
        // `value`.
        function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();
            validateEat(subvalue);
            apply.reset = reset;
            reset.test = test;
            apply.test = test;
            value = value.slice(subvalue.length);
            updatePosition(subvalue);
            indent = indent();
            return apply;
            // Add the given arguments, add `position` to the returned node, and
            // return the node.
            function apply(node, parent) {
                return pos(add(pos(node), parent), indent);
            }
            // Functions just like apply, but resets the content: the line and
            // column are reversed, and the eaten value is re-added.   This is
            // useful for nodes with a single type of content, such as lists and
            // tables.  See `apply` above for what parameters are expected.
            function reset() {
                var node = apply.apply(null, arguments);
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return node;
            }
            // Test the position, after eating, and reverse to a not-eaten state.
            function test() {
                var result = pos({});
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return result.position;
            }
        }
    }
}
// Check whether a node is mergeable with adjacent nodes.
function $a79271e383b04b47$var$mergeable(node) {
    var start;
    var end;
    if (node.type !== "text" || !node.position) return true;
    start = node.position.start;
    end = node.position.end;
    // Only merge nodes which occupy the same size as their `value`.
    return start.line !== end.line || end.column - start.column === node.value.length;
}
// Merge two text nodes: `node` into `prev`.
function $a79271e383b04b47$var$mergeText(previous, node) {
    previous.value += node.value;
    return previous;
}
// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
function $a79271e383b04b47$var$mergeBlockquote(previous, node) {
    if (this.options.commonmark || this.options.gfm) return node;
    previous.children = previous.children.concat(node.children);
    return previous;
}


$ed2921c87997049c$exports = $ed2921c87997049c$var$Parser;
function $ed2921c87997049c$var$Parser(doc, file) {
    this.file = file;
    this.offset = {};
    this.options = $gqx3p(this.options);
    this.setOptions({});
    this.inList = false;
    this.inBlock = false;
    this.inLink = false;
    this.atStart = true;
    this.toOffset = $cd6373c8f2c4afd5$exports(file).toOffset;
    this.unescape = $2a69ad6a0b7ae99b$exports(this, "escape");
    this.decode = $d2ac610520580292$exports(this);
}
var $ed2921c87997049c$var$proto = $ed2921c87997049c$var$Parser.prototype;

// Expose core.
$ed2921c87997049c$var$proto.setOptions = (parcelRequire("fh61I"));

$ed2921c87997049c$var$proto.parse = (parcelRequire("jPzk9"));

// Expose `defaults`.
$ed2921c87997049c$var$proto.options = (parcelRequire("c0y3C"));
// Enter and exit helpers.
$ed2921c87997049c$var$proto.exitStart = $aec8e6fcf2d07ca0$exports("atStart", true);
$ed2921c87997049c$var$proto.enterList = $aec8e6fcf2d07ca0$exports("inList", false);
$ed2921c87997049c$var$proto.enterLink = $aec8e6fcf2d07ca0$exports("inLink", false);
$ed2921c87997049c$var$proto.enterBlock = $aec8e6fcf2d07ca0$exports("inBlock", false);
// Nodes that can interupt a paragraph:
//
// ```markdown
// A paragraph, followed by a thematic break.
// ___
// ```
//
// In the above example, the thematic break “interupts” the paragraph.
$ed2921c87997049c$var$proto.interruptParagraph = [
    [
        "thematicBreak"
    ],
    [
        "list"
    ],
    [
        "atxHeading"
    ],
    [
        "fencedCode"
    ],
    [
        "blockquote"
    ],
    [
        "html"
    ],
    [
        "setextHeading",
        {
            commonmark: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a list:
//
// ```markdown
// - One
// ___
// ```
//
// In the above example, the thematic break “interupts” the list.
$ed2921c87997049c$var$proto.interruptList = [
    [
        "atxHeading",
        {
            pedantic: false
        }
    ],
    [
        "fencedCode",
        {
            pedantic: false
        }
    ],
    [
        "thematicBreak",
        {
            pedantic: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a blockquote:
//
// ```markdown
// > A paragraph.
// ___
// ```
//
// In the above example, the thematic break “interupts” the blockquote.
$ed2921c87997049c$var$proto.interruptBlockquote = [
    [
        "indentedCode",
        {
            commonmark: true
        }
    ],
    [
        "fencedCode",
        {
            commonmark: true
        }
    ],
    [
        "atxHeading",
        {
            commonmark: true
        }
    ],
    [
        "setextHeading",
        {
            commonmark: true
        }
    ],
    [
        "thematicBreak",
        {
            commonmark: true
        }
    ],
    [
        "html",
        {
            commonmark: true
        }
    ],
    [
        "list",
        {
            commonmark: true
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];












// Handlers.
$ed2921c87997049c$var$proto.blockTokenizers = {
    blankLine: (parcelRequire("6MCKT")),
    indentedCode: (parcelRequire("eRBEg")),
    fencedCode: (parcelRequire("1dZOZ")),
    blockquote: (parcelRequire("1lYit")),
    atxHeading: (parcelRequire("dbuo7")),
    thematicBreak: (parcelRequire("etWp6")),
    list: (parcelRequire("2nv9J")),
    setextHeading: (parcelRequire("igoS1")),
    html: (parcelRequire("5mJ60")),
    definition: (parcelRequire("iUyeb")),
    table: (parcelRequire("jvhub")),
    paragraph: (parcelRequire("fkexf"))
};













$ed2921c87997049c$var$proto.inlineTokenizers = {
    escape: (parcelRequire("jGxnv")),
    autoLink: (parcelRequire("aoJGq")),
    url: (parcelRequire("9HIzs")),
    email: (parcelRequire("dps5A")),
    html: (parcelRequire("6NCFJ")),
    link: (parcelRequire("8jyKl")),
    reference: (parcelRequire("4wSVw")),
    strong: (parcelRequire("icpkQ")),
    emphasis: (parcelRequire("3P2AS")),
    deletion: (parcelRequire("jUYRO")),
    code: (parcelRequire("ahmx7")),
    break: (parcelRequire("9AmxP")),
    text: (parcelRequire("I2hrQ"))
};
// Expose precedence.
$ed2921c87997049c$var$proto.blockMethods = $ed2921c87997049c$var$keys($ed2921c87997049c$var$proto.blockTokenizers);
$ed2921c87997049c$var$proto.inlineMethods = $ed2921c87997049c$var$keys($ed2921c87997049c$var$proto.inlineTokenizers);
// Tokenizers.
$ed2921c87997049c$var$proto.tokenizeBlock = $a79271e383b04b47$exports("block");
$ed2921c87997049c$var$proto.tokenizeInline = $a79271e383b04b47$exports("inline");
$ed2921c87997049c$var$proto.tokenizeFactory = $a79271e383b04b47$exports;
// Get all keys in `value`.
function $ed2921c87997049c$var$keys(value) {
    var result = [];
    var key;
    for(key in value)result.push(key);
    return result;
}


$4ecf9a54af9f01ab$exports = $4ecf9a54af9f01ab$var$parse;
$4ecf9a54af9f01ab$var$parse.Parser = $ed2921c87997049c$exports;
function $4ecf9a54af9f01ab$var$parse(options) {
    var settings = this.data("settings");
    var Local = $16758458ef599f83$exports($ed2921c87997049c$exports);
    Local.prototype.options = $gqx3p(Local.prototype.options, settings, options);
    this.Parser = Local;
}



var $5cnuX = parcelRequire("5cnuX");



var $ljm8s = parcelRequire("ljm8s");
var $3bc517d55346f2bb$require$parseFrontmatter = $ljm8s.parseFrontmatter;
var $1b8cd49791e763b0$exports = {};
"use strict";

var $2WRWK = parcelRequire("2WRWK");
var $4210d187e864d94b$exports = {};
"use strict";


var $e15a6bce02e95efb$exports = {};
"use strict";
$e15a6bce02e95efb$exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


const { env: $4210d187e864d94b$var$env } = process;
let $4210d187e864d94b$var$forceColor;
if ($e15a6bce02e95efb$exports("no-color") || $e15a6bce02e95efb$exports("no-colors") || $e15a6bce02e95efb$exports("color=false") || $e15a6bce02e95efb$exports("color=never")) $4210d187e864d94b$var$forceColor = 0;
else if ($e15a6bce02e95efb$exports("color") || $e15a6bce02e95efb$exports("colors") || $e15a6bce02e95efb$exports("color=true") || $e15a6bce02e95efb$exports("color=always")) $4210d187e864d94b$var$forceColor = 1;
if ("FORCE_COLOR" in $4210d187e864d94b$var$env) {
    if ($4210d187e864d94b$var$env.FORCE_COLOR === "true") $4210d187e864d94b$var$forceColor = 1;
    else if ($4210d187e864d94b$var$env.FORCE_COLOR === "false") $4210d187e864d94b$var$forceColor = 0;
    else $4210d187e864d94b$var$forceColor = $4210d187e864d94b$var$env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt($4210d187e864d94b$var$env.FORCE_COLOR, 10), 3);
}
function $4210d187e864d94b$var$translateLevel(level) {
    if (level === 0) return false;
    return {
        level: level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function $4210d187e864d94b$var$supportsColor(haveStream, streamIsTTY) {
    if ($4210d187e864d94b$var$forceColor === 0) return 0;
    if ($e15a6bce02e95efb$exports("color=16m") || $e15a6bce02e95efb$exports("color=full") || $e15a6bce02e95efb$exports("color=truecolor")) return 3;
    if ($e15a6bce02e95efb$exports("color=256")) return 2;
    if (haveStream && !streamIsTTY && $4210d187e864d94b$var$forceColor === undefined) return 0;
    const min = $4210d187e864d94b$var$forceColor || 0;
    if ($4210d187e864d94b$var$env.TERM === "dumb") return min;
    if (process.platform === "win32") {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = $4S4dR$release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
        return 1;
    }
    if ("CI" in $4210d187e864d94b$var$env) {
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE"
        ].some((sign)=>sign in $4210d187e864d94b$var$env) || $4210d187e864d94b$var$env.CI_NAME === "codeship") return 1;
        return min;
    }
    if ("TEAMCITY_VERSION" in $4210d187e864d94b$var$env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test($4210d187e864d94b$var$env.TEAMCITY_VERSION) ? 1 : 0;
    if ($4210d187e864d94b$var$env.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in $4210d187e864d94b$var$env) {
        const version = parseInt(($4210d187e864d94b$var$env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch($4210d187e864d94b$var$env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test($4210d187e864d94b$var$env.TERM)) return 2;
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test($4210d187e864d94b$var$env.TERM)) return 1;
    if ("COLORTERM" in $4210d187e864d94b$var$env) return 1;
    return min;
}
function $4210d187e864d94b$var$getSupportLevel(stream) {
    const level = $4210d187e864d94b$var$supportsColor(stream, stream && stream.isTTY);
    return $4210d187e864d94b$var$translateLevel(level);
}
$4210d187e864d94b$exports = {
    supportsColor: $4210d187e864d94b$var$getSupportLevel,
    stdout: $4210d187e864d94b$var$translateLevel($4210d187e864d94b$var$supportsColor(true, $4S4dR$isatty(1))),
    stderr: $4210d187e864d94b$var$translateLevel($4210d187e864d94b$var$supportsColor(true, $4S4dR$isatty(2)))
};


var $1b8cd49791e763b0$require$stdoutColor = $4210d187e864d94b$exports.stdout;
var $1b8cd49791e763b0$require$stderrColor = $4210d187e864d94b$exports.stderr;
var $a8b17ba7c3520953$exports = {};
"use strict";
const $a8b17ba7c3520953$var$stringReplaceAll = (string, substring, replacer)=>{
    let index = string.indexOf(substring);
    if (index === -1) return string;
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
};
const $a8b17ba7c3520953$var$stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{
    let endIndex = 0;
    let returnValue = "";
    do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
    }while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
};
$a8b17ba7c3520953$exports = {
    stringReplaceAll: $a8b17ba7c3520953$var$stringReplaceAll,
    stringEncaseCRLFWithFirstIndex: $a8b17ba7c3520953$var$stringEncaseCRLFWithFirstIndex
};


var $1b8cd49791e763b0$require$stringReplaceAll = $a8b17ba7c3520953$exports.stringReplaceAll;
var $1b8cd49791e763b0$require$stringEncaseCRLFWithFirstIndex = $a8b17ba7c3520953$exports.stringEncaseCRLFWithFirstIndex;
const { isArray: $1b8cd49791e763b0$var$isArray } = Array;
// `supportsColor.level` → `ansiStyles.color[name]` mapping
const $1b8cd49791e763b0$var$levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
];
const $1b8cd49791e763b0$var$styles = Object.create(null);
const $1b8cd49791e763b0$var$applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
    // Detect level if not set manually
    const colorLevel = $1b8cd49791e763b0$require$stdoutColor ? $1b8cd49791e763b0$require$stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class $1b8cd49791e763b0$var$ChalkClass {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return $1b8cd49791e763b0$var$chalkFactory(options);
    }
}
const $1b8cd49791e763b0$var$chalkFactory = (options)=>{
    const chalk = {};
    $1b8cd49791e763b0$var$applyOptions(chalk, options);
    chalk.template = (...arguments_)=>$1b8cd49791e763b0$var$chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, $1b8cd49791e763b0$var$Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = ()=>{
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk.template.Instance = $1b8cd49791e763b0$var$ChalkClass;
    return chalk.template;
};
function $1b8cd49791e763b0$var$Chalk(options) {
    return $1b8cd49791e763b0$var$chalkFactory(options);
}
for (const [styleName, style] of Object.entries($2WRWK))$1b8cd49791e763b0$var$styles[styleName] = {
    get () {
        const builder = $1b8cd49791e763b0$var$createBuilder(this, $1b8cd49791e763b0$var$createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {
            value: builder
        });
        return builder;
    }
};
$1b8cd49791e763b0$var$styles.visible = {
    get () {
        const builder = $1b8cd49791e763b0$var$createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {
            value: builder
        });
        return builder;
    }
};
const $1b8cd49791e763b0$var$usedModels = [
    "rgb",
    "hex",
    "keyword",
    "hsl",
    "hsv",
    "hwb",
    "ansi",
    "ansi256"
];
for (const model of $1b8cd49791e763b0$var$usedModels)$1b8cd49791e763b0$var$styles[model] = {
    get () {
        const { level: level } = this;
        return function(...arguments_) {
            const styler = $1b8cd49791e763b0$var$createStyler($2WRWK.color[$1b8cd49791e763b0$var$levelMapping[level]][model](...arguments_), $2WRWK.color.close, this._styler);
            return $1b8cd49791e763b0$var$createBuilder(this, styler, this._isEmpty);
        };
    }
};
for (const model of $1b8cd49791e763b0$var$usedModels){
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    $1b8cd49791e763b0$var$styles[bgModel] = {
        get () {
            const { level: level } = this;
            return function(...arguments_) {
                const styler = $1b8cd49791e763b0$var$createStyler($2WRWK.bgColor[$1b8cd49791e763b0$var$levelMapping[level]][model](...arguments_), $2WRWK.bgColor.close, this._styler);
                return $1b8cd49791e763b0$var$createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
const $1b8cd49791e763b0$var$proto = Object.defineProperties(()=>{}, {
    ...$1b8cd49791e763b0$var$styles,
    level: {
        enumerable: true,
        get () {
            return this._generator.level;
        },
        set (level) {
            this._generator.level = level;
        }
    }
});
const $1b8cd49791e763b0$var$createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open: open,
        close: close,
        openAll: openAll,
        closeAll: closeAll,
        parent: parent
    };
};
const $1b8cd49791e763b0$var$createBuilder = (self, _styler, _isEmpty)=>{
    const builder = (...arguments_)=>{
        if ($1b8cd49791e763b0$var$isArray(arguments_[0]) && $1b8cd49791e763b0$var$isArray(arguments_[0].raw)) // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
        return $1b8cd49791e763b0$var$applyStyle(builder, $1b8cd49791e763b0$var$chalkTag(builder, ...arguments_));
        // Single argument is hot path, implicit coercion is faster than anything
        // eslint-disable-next-line no-implicit-coercion
        return $1b8cd49791e763b0$var$applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, $1b8cd49791e763b0$var$proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
};
const $1b8cd49791e763b0$var$applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) return self._isEmpty ? "" : string;
    let styler = self._styler;
    if (styler === undefined) return string;
    const { openAll: openAll, closeAll: closeAll } = styler;
    if (string.indexOf("\x1b") !== -1) while(styler !== undefined){
        // Replace any instances already present with a re-opening code
        // otherwise only the part of the string until said closing code
        // will be colored, and the rest will simply be 'plain'.
        string = $1b8cd49791e763b0$require$stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) string = $1b8cd49791e763b0$require$stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    return openAll + string + closeAll;
};
let $1b8cd49791e763b0$var$template;

const $1b8cd49791e763b0$var$chalkTag = (chalk, ...strings)=>{
    const [firstString] = strings;
    if (!$1b8cd49791e763b0$var$isArray(firstString) || !$1b8cd49791e763b0$var$isArray(firstString.raw)) // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(" ");
    const arguments_ = strings.slice(1);
    const parts = [
        firstString.raw[0]
    ];
    for(let i = 1; i < firstString.length; i++)parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    if ($1b8cd49791e763b0$var$template === undefined) $1b8cd49791e763b0$var$template = (parcelRequire("gn0Qn"));
    return $1b8cd49791e763b0$var$template(chalk, parts.join(""));
};
Object.defineProperties($1b8cd49791e763b0$var$Chalk.prototype, $1b8cd49791e763b0$var$styles);
const $1b8cd49791e763b0$var$chalk = $1b8cd49791e763b0$var$Chalk(); // eslint-disable-line new-cap
$1b8cd49791e763b0$var$chalk.supportsColor = $1b8cd49791e763b0$require$stdoutColor;
$1b8cd49791e763b0$var$chalk.stderr = $1b8cd49791e763b0$var$Chalk({
    level: $1b8cd49791e763b0$require$stderrColor ? $1b8cd49791e763b0$require$stderrColor.level : 0
}); // eslint-disable-line new-cap
$1b8cd49791e763b0$var$chalk.stderr.supportsColor = $1b8cd49791e763b0$require$stderrColor;
$1b8cd49791e763b0$exports = $1b8cd49791e763b0$var$chalk;


/** @typedef {{id: string, compileError: string, compiledQueryString: string, inputQueryString: string, compiled: boolean, inline: boolean}} Query */ const $3bc517d55346f2bb$var$warnedExternalQueries = {};
/**
 *
 * @param {string} externalQuery
 * @param {string} id
 * @returns {Query}
 */ const $3bc517d55346f2bb$var$readFileToQuery = (externalQuery, id)=>{
    try {
        const content = $4S4dR$readFileSync(`./queries/${externalQuery}`).toString().trim();
        return {
            id: id.toLowerCase(),
            compiledQueryString: content,
            inputQueryString: content,
            compiled: false,
            inline: false
        };
    } catch  {
        console.warn(`Failed to load sql file ${externalQuery}`);
    }
};
// Unified parser step to ignore indented code blocks.
// Adapted from the mdsvex source, here: https://github.com/pngwn/MDsveX/blob/master/packages/mdsvex/src/parsers/index.ts
// Discussion & background here:  https://github.com/evidence-dev/evidence/issues/286
const $3bc517d55346f2bb$var$ignoreIndentedCode = function() {
    const Parser = this.Parser;
    const block_tokenizers = Parser.prototype.blockTokenizers;
    block_tokenizers.indentedCode = ()=>true;
};
/**
 * @param {string} content File content
 * @param {string} filename File name
 * @returns {Query[]}
 */ const $3bc517d55346f2bb$var$extractExternalQueries = (content, filename)=>{
    const frontmatter = $3bc517d55346f2bb$require$parseFrontmatter(content);
    if (!frontmatter) return [];
    if (!frontmatter.queries) return [];
    if (!Array.isArray(frontmatter.queries)) {
        console.warn(`Malformed frontmatter found in ${filename}. Unable to extract external queries.`);
        return [];
    }
    /**
	 *
	 * @param {string} externalQuery
	 * @returns {boolean}
	 */ const validateExternalQuery = (externalQuery)=>{
        if (!externalQuery.endsWith(".sql")) {
            if (!$3bc517d55346f2bb$var$warnedExternalQueries[externalQuery]) {
                $3bc517d55346f2bb$var$warnedExternalQueries[externalQuery] = true;
                console.warn($1b8cd49791e763b0$exports.bold.red(`! ${externalQuery}`) + $1b8cd49791e763b0$exports.gray(" does not appear to be a .sql file, and will not be loaded"));
            }
            return false;
        }
        return true;
    };
    /**
	 * @type Query[]
	 */ return frontmatter.queries.map((externalQuery)=>{
        if (typeof externalQuery === "string") {
            if (!validateExternalQuery(externalQuery)) return false;
            const id = externalQuery.split(".sql")[0].replace("/", "_").replace("\\", "_");
            return $3bc517d55346f2bb$var$readFileToQuery(externalQuery, id);
        } else if (typeof externalQuery === "object") {
            const usedKey = Object.keys(externalQuery)?.[0] ?? "";
            const value = externalQuery[usedKey];
            // Note; this is to be obseleted, as the import syntax evolves, but for now only one key should be used.
            if (Object.keys(externalQuery).length > 1) console.warn(`ExternalQuery object has more than one key, this may lead to unintended behavior. Only ${usedKey}: ${value} will be imported.`);
            if (!validateExternalQuery(value)) return false;
            return $3bc517d55346f2bb$var$readFileToQuery(value, usedKey);
        }
    }).filter(Boolean); // filter out queries that returned false;
};
/**
 * @param {string} content Raw File Content
 * @returns {Query[]}
 */ const $3bc517d55346f2bb$var$extractInlineQueries = (content)=>{
    let queries = [];
    let tree = $7f6f6807a3a8644e$exports().use($4ecf9a54af9f01ab$exports).use($3bc517d55346f2bb$var$ignoreIndentedCode).parse(content);
    const prismLangs = $bc540824f1c98218$exports();
    $5cnuX(tree, "code", function(node) {
        let id = node.lang ?? "untitled";
        if (id.toLowerCase() === "sql" && node.meta) id = node.meta;
        if (!prismLangs.has(id.toLowerCase()) && id.toLowerCase() !== "plaintext") {
            // Prevent prism code blocks from being interpreted as queries
            let compiledQueryString = node.value.trim(); // refs get compiled and sent to db orchestrator
            let inputQueryString = compiledQueryString; // original, as written
            let compiled = false; // default flag, switched to true if query is compiled
            queries.push({
                id: id,
                compiledQueryString: compiledQueryString,
                inputQueryString: inputQueryString,
                compiled: compiled,
                inline: true
            });
        }
    });
    return queries;
};
const $3bc517d55346f2bb$var$strictBuild = process.env.VITE_BUILD_STRICT === "true";
const $3bc517d55346f2bb$var$circularRefErrorMsg = "Compiler error: circular reference";
/**
 * @param {string} filename
 * @returns {Query[]}
 */ const $3bc517d55346f2bb$var$extractQueries = (content)=>{
    const queries = [];
    queries.push(...$3bc517d55346f2bb$var$extractExternalQueries(content));
    queries.push(...$3bc517d55346f2bb$var$extractInlineQueries(content));
    // Handle query chaining:
    const maxIterations = 15;
    const queryIds = new Set(queries.map((d)=>d.id));
    const interpolated_variables = new Set();
    for(let i = 0; i <= maxIterations; i++)queries.forEach((query)=>{
        const startTemplateInterpolation = /[^\\](\$\{)/g;
        const validTemplateInterpolation = /[^\\]\$\{((?:.|\s)+?)\}/g;
        /*
				This is a somewhat naive way of looking for invalid template strings
				It currently tests for ${} and ${ cases, but is unable to detect } cases
			*/ const hasTemplates = startTemplateInterpolation.exec(query.inputQueryString);
        const hasValidTemplates = validTemplateInterpolation.exec(query.inputQueryString);
        if (hasTemplates?.length !== hasValidTemplates?.length) {
            if (query.inputQueryString.includes("${}")) query.compileError = "Query contains an empty template literal (${})";
            else query.compileError = "Query contains invalid template literal (unmatched ${ and }";
            return;
        }
        const references = query.compiledQueryString.match(/\${.*?\}/gi);
        if (references && references.some((d)=>!interpolated_variables.has(d))) references.forEach((reference)=>{
            try {
                const referencedQueryID = reference.replace("${", "").replace("}", "").trim();
                if (!queryIds.has(referencedQueryID)) interpolated_variables.add(reference);
                else if (i >= maxIterations) throw new Error($3bc517d55346f2bb$var$circularRefErrorMsg);
                else {
                    const referencedQuery = queries.find((d)=>d.id === referencedQueryID);
                    if (!query.inline && referencedQuery.inline) throw new Error(`Cannot reference inline query from SQL File. (Referenced ${referencedQueryID})`);
                    const queryString = `(${referencedQuery.compiledQueryString})`;
                    query.compiledQueryString = query.compiledQueryString.replace(reference, queryString);
                    query.compiled = true;
                }
            } catch (_e) {
                // if error is unknown use default circular ref. error
                const e = _e.message === undefined || _e.message === null ? Error($3bc517d55346f2bb$var$circularRefErrorMsg) : _e;
                query.compileError = e.message;
                query.compiledQueryString = e.message;
                // if build is strict and we detect an error, force a failure
                if ($3bc517d55346f2bb$var$strictBuild) throw new Error(e.message);
            }
        });
    });
    return queries;
};
/**
 *
 * @param {string} content File Content
 *
 * @param {string} content File Content
 * @returns {string[]}
 */ const $3bc517d55346f2bb$var$getQueryIds = (content)=>{
    return $3bc517d55346f2bb$var$extractQueries(content).map((q)=>q.id);
};
$3bc517d55346f2bb$exports = {
    extractQueries: $3bc517d55346f2bb$var$extractQueries,
    getQueryIds: $3bc517d55346f2bb$var$getQueryIds
};


var $bb8aaf4d81463a1b$require$extractQueries = $3bc517d55346f2bb$exports.extractQueries;

var $bb8aaf4d81463a1b$require$highlighter = $365749e2073871b1$exports.highlighter;

var $5xH1P = parcelRequire("5xH1P");
var $bb8aaf4d81463a1b$require$containsFrontmatter = $5xH1P.containsFrontmatter;
// prettier obliterates the formatting of queryDeclarations
// prettier-ignore
/**
 *
 * @param {string} filename
 * @param {boolean} componentDevelopmentMode
 * @param {Record<string, import('./extract-queries/extract-queries.cjs').Query>} duckdbQueries
 * @returns
 */ const $bb8aaf4d81463a1b$var$createDefaultProps = function(filename, componentDevelopmentMode, duckdbQueries = {}) {
    const routeH = $bb8aaf4d81463a1b$require$getRouteHash(filename);
    let queryDeclarations = "";
    if (Object.keys(duckdbQueries).length > 0) {
        const IS_VALID_QUERY = /^([a-zA-Z_$][a-zA-Z0-9d_$]*)$/;
        const validIds = Object.keys(duckdbQueries).filter((query)=>IS_VALID_QUERY.test(query) && !duckdbQueries[query].compileError);
        // prerendered queries: stuff without ${}
        // reactive queries: stuff with ${}
        const IS_REACTIVE_QUERY = /\${.*?}/s;
        const reactiveIds = validIds.filter((id)=>IS_REACTIVE_QUERY.test(duckdbQueries[id].compiledQueryString));
        // input queries: reactive with ${inputs...} in it
        const IS_INPUT_QUERY = /\${\s*inputs\s*\..*?}/s;
        const input_ids = reactiveIds.filter((id)=>IS_INPUT_QUERY.test(duckdbQueries[id].compiledQueryString));
        const errQueries = Object.values(duckdbQueries).filter((q)=>q.compileError).map((q)=>`const ${q.id} = QueryStore.create(\`${q.compiledQueryString.replaceAll("$", "\\$")}\`, undefined, "${q.id}", { initialError: new Error(\`${q.compileError.replaceAll("$", "\\$")}\`)})`);
        const queryStoreDeclarations = validIds.map((id)=>{
            /*
				"What the heck is happening here":
					_${id}_initial_query:
						Copy of the query as it is written in the source markdown file
						It is interpolated with the initial values of any variables _at mount time_
						and does not change after that

						This variable _must_ be declared; then assigned "reactively" to make sure it can reference the user's variables,
						as it pushes the reactive assignment to the bottom of the file (after the user's scripts have run)
						
						We use the if to make sure it is only reactive once, and still acts as a "constant"


					_${id}_current_query:
						Copy of the query with the variables reactively interpolated - this is what will
						actually be executed against the database

						
					_${id}_changed:
						Helper variable to check if current is same as initial

					
					We care about all of this because we want to provide the initialData from SSR when the query is unchanged,
					but we need to ensure that if the query changes, it re-executes. When constructing the QueryStore below,
					we hinge on the change to pass intiailData (or not).
			*/ return `
				$: _${id}_query_text = \`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
				$: _${id}_has_unresolved = __checkForUnsetInputs\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;

				if (import.meta?.hot) {
					import.meta.hot.on("evidence:queryChange", ({queryId, content}) => {
						let errors = []
						if (!queryId) errors.push("Malformed event: Missing queryId")
						if (!content) errors.push("Malformed event: Missing content")
						if (errors.length) {
							console.warn("Failed to update query on serverside change!", errors.join("\\n"))
							return
						}

						if (queryId === "${id}") {
							_${id}_query_text = content
						}
						
					})
				}

				// Initial Query
				let _${id}_initial_query;
				$: if(!_${id}_initial_query) _${id}_initial_query = _${id}_query_text;
				onMount(() => _${id}_initial_query = _${id}_query_text);
		
				// Current Query
				$: _${id}_current_query = _${id}_query_text;
				
				// Query has changed
				$: _${id}_changed = browser ? _${id}_current_query !== _${id}_initial_query : false;
				
				// Actual Query Execution
				let _${id};

				const _${id}_reactivity_manager = () => {
					const update = () => {
						let initialData, initialError;

						try {
							if (_${id}_changed || __has_hmr_run) {
								// Query changed after page load, we have no prerendered results
								initialData = undefined
								initialError = undefined
							} else if (data.${id}) {
								// Data is coming from SSR
								if (data.${id} instanceof Error) {
									throw data.${id}
								} else {
									initialData = data.${id}
								}
							} else {
								// We are currently prerendering
								initialData = profile(__db.query, _${id}_query_text, { query_name: '${id}' })
							}
						} catch (e) {
							if (!browser) {
								// If building in strict mode; we should fail, this query broke
								if (import.meta.env.VITE_BUILD_STRICT) throw e;
							}
							initialData = []
							initialError = e
						}

						const query_store = QueryStore.create(
							_${id}_query_text,
							queryFunc,
							'${id}',
							{
								scoreNotifier,
								initialData,
								initialError,
								noResolve: _${id}_has_unresolved
							}
						);
						
						let fetch_maybepromise = undefined
						if (!query_store.loaded) {
							fetch_maybepromise = query_store.fetch();
						}

						// if we have initial data, execute the query anyways in the background, ignoring results
						// this helps fetch some parquet which can speed up future queries
						if (initialData) {
							query_store.backgroundFetch();
						}

						if (_${id}) {
							// Query has already been created
							// Fetch the data and then replace
							
							if (fetch_maybepromise instanceof Promise) {
								fetch_maybepromise.then(() => (_${id} = query_store));
							} else {
								_${id} = query_store;
							}
						} else {
							_${id} = query_store;
						}
					};
		
					update();
		
					const debounced = debounce(update, 500);
		
					return () => {
						if (_mounted) {
							debounced();
						} else {
							update();
						}
					}
				}
		
				let _${id}_debounced_updater;
				// make sure svelte knows debounced updater is dependent on query text
				$: if (typeof _${id}_debounced_updater === 'undefined') {
                    _${id}_query_text;
                    _${id}_debounced_updater = _${id}_reactivity_manager();
                };
				
				// rerun if query text changes, prevent initial run to stop unnecessary update
				let _${id}_debounced_once = false;
				$: if (_${id}_debounced_once) {
					_${id}_query_text;
					_${id}_debounced_updater();
				} else {
					_${id}_debounced_once = true;
				}

				// rerun if data changes during dev mode, likely source HMR, prevent initial for same reason as above
				let _${id}_hmr_once = false;
				$: if (dev) {
					if (_${id}_hmr_once) {
						data;
						_${id}_debounced_updater();
					} else {
						_${id}_hmr_once = true;
					}
				}
			`;
        });
        /* 
			reactivity doesn't happen on the server, so we need to manually subscribe to the inputs store
			and update the queries when the inputs change
		*/ const input_query_stores = `
		if (!browser) {
			onDestroy(inputs_store.subscribe((inputs) => {
				${input_ids.map((id)=>`
				${id} = get(QueryStore.create(
						\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`,
						queryFunc,
						'${id}',
						{}
					));
				`).join("\n")}
			}));
		}
		`;
        const all_query_stores = validIds.map((id)=>`$: ${id} = $_${id};`);
        queryDeclarations += `
		${errQueries.join("\n")}
		${queryStoreDeclarations.join("\n")}
		${input_query_stores}
		${all_query_stores.join("\n")}
		`;
    }
    let defaultProps = `
        import { page } from '$app/stores';
        import { pageHasQueries, routeHash, toasts } from '@evidence-dev/component-utilities/stores';
        import { setContext, getContext, beforeUpdate, onDestroy, onMount } from 'svelte';
		import { writable, get } from 'svelte/store';
        
        // Functions
        import { fmt } from '@evidence-dev/component-utilities/formatting';

		import { CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY, INPUTS_CONTEXT_KEY } from '@evidence-dev/component-utilities/globalContexts';		
        
        let props;
        export { props as data }; // little hack to make the data name not overlap
        let { data = {}, customFormattingSettings, __db, inputs } = props;
        $: ({ data = {}, customFormattingSettings, __db } = props);

        $routeHash = '${routeH}';

		${""}
		let inputs_store = writable(inputs);
		setContext(INPUTS_CONTEXT_KEY, inputs_store);
		onDestroy(inputs_store.subscribe((value) => inputs = value));

        $: pageHasQueries.set(Object.keys(data).length > 0);

        setContext(CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY, {
            getCustomFormats: () => {
                return customFormattingSettings.customFormats || [];
            }
        });

		import { browser, dev } from "$app/environment";
		import { profile } from '@evidence-dev/component-utilities/profile';
		import debounce from 'debounce';
		import { QueryStore } from '@evidence-dev/query-store';
		import { setQueryFunction } from '@evidence-dev/component-utilities/buildQuery';

		const queryFunc = (query, query_name) => profile(__db.query, query, { query_name });
		setQueryFunction(queryFunc);

		const scoreNotifier = !dev? () => {} : (info) => {
			toasts.add({
				id: Math.random(),
				title: info.id,
				message: \`Results estimated to use \${
					Intl.NumberFormat().format(info.score / (1024 * 1024))
				}mb of memory, performance may be impacted\`,
				status: 'warning'
			}, 5000);
		};

		const activeQueries = QueryStore.activeQueries;

		let loadingQueriesToast = 0;
		$: if ($activeQueries.size > 0) {
			clearTimeout(loadingQueriesToast);
			loadingQueriesToast = setTimeout(() => {
				toasts.add({
					id: 'LoadingToast',
					title: '',
					message: 'Loading...',
					status: 'info'
				}, 2 ** 31 - 1);
			}, 1000);
		} else {
			clearTimeout(loadingQueriesToast);
			toasts.dismiss('LoadingToast');
		}

		let __has_hmr_run = false
	    if (import.meta?.hot) {
	        import.meta.hot.on("vite:afterUpdate", () => {
				__has_hmr_run = true
				QueryStore.emptyCache() // All bets are off
			})
	    }
		
		let params = $page.params;
		$: params = $page.params;

		function __checkForUnsetInputs(strings, ...args) {
			if (args.some(a => a?.__unset)) {
				return true
			} else {
				return false
			}
		}
		
		let _mounted = false;
		onMount(() => (_mounted = true));

        ${queryDeclarations}
    `;
    return defaultProps;
};
/**
 * @type {(componentDevelopmentMode: boolean) => import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ const $bb8aaf4d81463a1b$var$processQueries = (componentDevelopmentMode)=>{
    /**
	 * @type {Record<string, Record<string, import("./extract-queries/extract-queries.cjs").Query>>}
	 */ const dynamicQueries = {};
    return {
        markup ({ content: content, filename: filename }) {
            if (filename.endsWith(".md")) {
                let fileQueries = $bb8aaf4d81463a1b$require$extractQueries(content);
                dynamicQueries[$bb8aaf4d81463a1b$require$getRouteHash(filename)] = fileQueries.reduce((acc, q)=>{
                    acc[q.id] = q;
                    return acc;
                }, {});
                const externalQueryViews = "\n\n\n" + fileQueries.filter((q)=>!q.inline).map((q)=>{
                    return $bb8aaf4d81463a1b$require$highlighter(q.compiledQueryString, q.id.toLowerCase());
                }).join("\n");
                // Page contains frontmatter
                const frontmatter = $bb8aaf4d81463a1b$require$containsFrontmatter(content);
                if (frontmatter) {
                    const contentWithoutFrontmatter = content.substring(frontmatter.length + 6);
                    const output = `---\n${frontmatter}\n---` + externalQueryViews + contentWithoutFrontmatter;
                    return {
                        code: output
                    };
                }
                return {
                    code: externalQueryViews + content
                };
            }
        },
        script ({ content: content, filename: filename, attributes: attributes }) {
            if (filename.endsWith(".md")) {
                if (attributes.context != "module") {
                    const duckdbQueries = dynamicQueries[$bb8aaf4d81463a1b$require$getRouteHash(filename)];
                    return {
                        code: $bb8aaf4d81463a1b$var$createDefaultProps(filename, componentDevelopmentMode, duckdbQueries) + content
                    };
                }
            }
        }
    };
};
$bb8aaf4d81463a1b$exports = $bb8aaf4d81463a1b$var$processQueries;


var $283f418c0f57366a$exports = {};
var $eb0fced0eff13ef9$exports = {};

$parcel$export($eb0fced0eff13ef9$exports, "matches", () => $3c8bc001a91ed78a$export$de994efd351b291c);
$parcel$export($eb0fced0eff13ef9$exports, "select", () => $3c8bc001a91ed78a$export$2e6c959c16ff56b8);
$parcel$export($eb0fced0eff13ef9$exports, "selectAll", () => $3c8bc001a91ed78a$export$90aca4adda6ff0f5);
/**
 * @typedef {import('./lib/types.js').Space} Space
 */ /**
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Space} Space
 * @typedef {import('./types.js').SelectState} SelectState
 */ /**
 * @typedef {import('./lib/util/info.js').Info} Info
 * @typedef {import('./lib/util/schema.js').Schema} Schema
 */ /**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 */ /**
 * @typedef {import('./info.js').Info} Info
 * @typedef {Record<string, Info>} Properties
 * @typedef {Record<string, string>} Normal
 */ class $94de3ff8ae2a59d0$export$19342e026b58ebb7 {
    /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */ constructor(property, normal, space){
        this.property = property;
        this.normal = normal;
        if (space) this.space = space;
    }
}
/** @type {Properties} */ $94de3ff8ae2a59d0$export$19342e026b58ebb7.prototype.property = {};
/** @type {Normal} */ $94de3ff8ae2a59d0$export$19342e026b58ebb7.prototype.normal = {};
/** @type {string|null} */ $94de3ff8ae2a59d0$export$19342e026b58ebb7.prototype.space = null;


function $9bb6a41dd9e96c7c$export$4950aa0f605343fb(definitions, space) {
    /** @type {Properties} */ const property = {};
    /** @type {Normal} */ const normal = {};
    let index = -1;
    while(++index < definitions.length){
        Object.assign(property, definitions[index].property);
        Object.assign(normal, definitions[index].normal);
    }
    return new (0, $94de3ff8ae2a59d0$export$19342e026b58ebb7)(property, normal, space);
}


/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 *
 * @typedef {Record<string, string>} Attributes
 *
 * @typedef {Object} Definition
 * @property {Record<string, number|null>} properties
 * @property {(attributes: Attributes, property: string) => string} transform
 * @property {string} [space]
 * @property {Attributes} [attributes]
 * @property {Array<string>} [mustUseProperty]
 */ /**
 * @param {string} value
 * @returns {string}
 */ function $980e993c25f15b87$export$a3295358bff77e(value) {
    return value.toLowerCase();
}



class $e79e41024153ca29$export$c4868e4a24d48fad {
    /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */ constructor(property, attribute){
        /** @type {string} */ this.property = property;
        /** @type {string} */ this.attribute = attribute;
    }
}
/** @type {string|null} */ $e79e41024153ca29$export$c4868e4a24d48fad.prototype.space = null;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.boolean = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.booleanish = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.overloadedBoolean = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.number = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.commaSeparated = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.spaceSeparated = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.commaOrSpaceSeparated = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.mustUseProperty = false;
$e79e41024153ca29$export$c4868e4a24d48fad.prototype.defined = false;


var $23ccbfab2b5e2567$exports = {};

$parcel$export($23ccbfab2b5e2567$exports, "boolean", () => $23ccbfab2b5e2567$export$4a21f16c33752377);
$parcel$export($23ccbfab2b5e2567$exports, "booleanish", () => $23ccbfab2b5e2567$export$55e9e1fbc638dc8f);
$parcel$export($23ccbfab2b5e2567$exports, "overloadedBoolean", () => $23ccbfab2b5e2567$export$242ac3d3042558aa);
$parcel$export($23ccbfab2b5e2567$exports, "number", () => $23ccbfab2b5e2567$export$98e628dec113755e);
$parcel$export($23ccbfab2b5e2567$exports, "spaceSeparated", () => $23ccbfab2b5e2567$export$ab8645c862eb5a3e);
$parcel$export($23ccbfab2b5e2567$exports, "commaSeparated", () => $23ccbfab2b5e2567$export$9c8d678629b3d3);
$parcel$export($23ccbfab2b5e2567$exports, "commaOrSpaceSeparated", () => $23ccbfab2b5e2567$export$2ad25cfebf36cacd);
let $23ccbfab2b5e2567$var$powers = 0;
const $23ccbfab2b5e2567$export$4a21f16c33752377 = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$55e9e1fbc638dc8f = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$242ac3d3042558aa = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$98e628dec113755e = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$ab8645c862eb5a3e = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$9c8d678629b3d3 = $23ccbfab2b5e2567$var$increment();
const $23ccbfab2b5e2567$export$2ad25cfebf36cacd = $23ccbfab2b5e2567$var$increment();
function $23ccbfab2b5e2567$var$increment() {
    return 2 ** ++$23ccbfab2b5e2567$var$powers;
}


/** @type {Array<keyof types>} */ // @ts-expect-error: hush.
const $564f267885156f07$var$checks = Object.keys($23ccbfab2b5e2567$exports);
class $564f267885156f07$export$ea6b9f0064e88c9b extends (0, $e79e41024153ca29$export$c4868e4a24d48fad) {
    /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */ constructor(property, attribute, mask, space){
        let index = -1;
        super(property, attribute);
        $564f267885156f07$var$mark(this, "space", space);
        if (typeof mask === "number") while(++index < $564f267885156f07$var$checks.length){
            const check = $564f267885156f07$var$checks[index];
            $564f267885156f07$var$mark(this, $564f267885156f07$var$checks[index], (mask & $23ccbfab2b5e2567$exports[check]) === $23ccbfab2b5e2567$exports[check]);
        }
    }
}
$564f267885156f07$export$ea6b9f0064e88c9b.prototype.defined = true;
/**
 * @param {DefinedInfo} values
 * @param {string} key
 * @param {unknown} value
 */ function $564f267885156f07$var$mark(values, key, value) {
    if (value) // @ts-expect-error: assume `value` matches the expected value of `key`.
    values[key] = value;
}


const $a923e85a30ab9a9e$var$own = {}.hasOwnProperty;
function $a923e85a30ab9a9e$export$185802fd694ee1f5(definition) {
    /** @type {Properties} */ const property = {};
    /** @type {Normal} */ const normal = {};
    /** @type {string} */ let prop;
    for(prop in definition.properties)if ($a923e85a30ab9a9e$var$own.call(definition.properties, prop)) {
        const value = definition.properties[prop];
        const info = new (0, $564f267885156f07$export$ea6b9f0064e88c9b)(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);
        if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) info.mustUseProperty = true;
        property[prop] = info;
        normal[(0, $980e993c25f15b87$export$a3295358bff77e)(prop)] = prop;
        normal[(0, $980e993c25f15b87$export$a3295358bff77e)(info.attribute)] = prop;
    }
    return new (0, $94de3ff8ae2a59d0$export$19342e026b58ebb7)(property, normal, definition.space);
}


const $ceb366ce7ed27563$export$2bd1230ec7600845 = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    space: "xlink",
    transform (_, prop) {
        return "xlink:" + prop.slice(5).toLowerCase();
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
});



const $8f588845f7d636b7$export$f2913fe8983302e = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    space: "xml",
    transform (_, prop) {
        return "xml:" + prop.slice(3).toLowerCase();
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});



/**
 * @param {Record<string, string>} attributes
 * @param {string} attribute
 * @returns {string}
 */ function $a895da6a591ce535$export$5b10b3bc32d7efbc(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
}


function $e7f7136ae3b2ec96$export$32b9e4cec9c208e1(attributes, property) {
    return (0, $a895da6a591ce535$export$5b10b3bc32d7efbc)(attributes, property.toLowerCase());
}


const $e75654d3dbd1b16e$export$e20c24a128671213 = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: (0, $e7f7136ae3b2ec96$export$32b9e4cec9c208e1),
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
});




const $aa8ca69aa86d27a4$export$4d2d26490572750a = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    transform (_, prop) {
        return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaAutoComplete: null,
        ariaBusy: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaChecked: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaColCount: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaColIndex: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaColSpan: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaControls: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaCurrent: null,
        ariaDescribedBy: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaDetails: null,
        ariaDisabled: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaDropEffect: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaErrorMessage: null,
        ariaExpanded: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaFlowTo: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaGrabbed: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaHasPopup: null,
        ariaHidden: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaLevel: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaLive: null,
        ariaModal: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaMultiLine: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaMultiSelectable: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaOrientation: null,
        ariaOwns: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaPlaceholder: null,
        ariaPosInSet: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaPressed: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaReadOnly: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaRelevant: null,
        ariaRequired: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaRoleDescription: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        ariaRowCount: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaRowIndex: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaRowSpan: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaSelected: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        ariaSetSize: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaSort: null,
        ariaValueMax: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaValueMin: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaValueNow: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        ariaValueText: null,
        role: null
    }
});





const $69772c807f2dc588$export$c0bb0b647f701bb5 = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: (0, $e7f7136ae3b2ec96$export$32b9e4cec9c208e1),
    mustUseProperty: [
        "checked",
        "multiple",
        "muted",
        "selected"
    ],
    properties: {
        // Standard Properties.
        abbr: null,
        accept: (0, $23ccbfab2b5e2567$export$9c8d678629b3d3),
        acceptCharset: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        accessKey: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        action: null,
        allow: null,
        allowFullScreen: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        allowPaymentRequest: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        allowUserMedia: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        alt: null,
        as: null,
        async: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        autoCapitalize: null,
        autoComplete: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        autoFocus: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        autoPlay: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        blocking: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        capture: null,
        charSet: null,
        checked: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        cite: null,
        className: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        cols: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        colSpan: null,
        content: null,
        contentEditable: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        controls: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        controlsList: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        coords: (0, $23ccbfab2b5e2567$export$98e628dec113755e) | (0, $23ccbfab2b5e2567$export$9c8d678629b3d3),
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        defer: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        dir: null,
        dirName: null,
        disabled: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        download: (0, $23ccbfab2b5e2567$export$242ac3d3042558aa),
        draggable: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        formTarget: null,
        headers: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        height: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        hidden: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        high: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        href: null,
        hrefLang: null,
        htmlFor: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        httpEquiv: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        inputMode: null,
        integrity: null,
        is: null,
        isMap: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        itemId: null,
        itemProp: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        itemRef: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        itemScope: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        itemType: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        low: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        manifest: null,
        max: null,
        maxLength: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        media: null,
        method: null,
        min: null,
        minLength: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        multiple: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        muted: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        name: null,
        nonce: null,
        noModule: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        noValidate: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        optimum: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        pattern: null,
        ping: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        placeholder: null,
        playsInline: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        referrerPolicy: null,
        rel: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        required: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        reversed: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        rows: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        rowSpan: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        sandbox: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        scope: null,
        scoped: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        seamless: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        selected: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        shadowRootDelegatesFocus: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        shadowRootMode: null,
        shape: null,
        size: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        sizes: null,
        slot: null,
        span: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        spellCheck: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        step: null,
        style: null,
        tabIndex: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        useMap: null,
        value: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        width: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        aLink: null,
        archive: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        axis: null,
        background: null,
        bgColor: null,
        border: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        borderColor: null,
        bottomMargin: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        declare: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        leftMargin: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        marginWidth: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        noResize: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        noHref: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        noShade: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        noWrap: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        rules: null,
        scheme: null,
        scrolling: (0, $23ccbfab2b5e2567$export$55e9e1fbc638dc8f),
        standby: null,
        summary: null,
        text: null,
        topMargin: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        disableRemotePlayback: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        prefix: null,
        property: null,
        results: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        security: null,
        unselectable: null
    }
});





const $564c50696fca7eb5$export$7ed1367e7fa1ad68 = (0, $a923e85a30ab9a9e$export$185802fd694ee1f5)({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: (0, $a895da6a591ce535$export$5b10b3bc32d7efbc),
    properties: {
        about: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        accentHeight: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        amplitude: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        arabicForm: null,
        ascent: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        attributeName: null,
        attributeType: null,
        azimuth: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        by: null,
        calcMode: null,
        capHeight: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        className: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        diffuseConstant: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        direction: null,
        display: null,
        dur: null,
        divisor: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        dominantBaseline: null,
        download: (0, $23ccbfab2b5e2567$export$4a21f16c33752377),
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        enableBackground: null,
        end: null,
        event: null,
        exponent: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: (0, $23ccbfab2b5e2567$export$9c8d678629b3d3),
        g2: (0, $23ccbfab2b5e2567$export$9c8d678629b3d3),
        glyphName: (0, $23ccbfab2b5e2567$export$9c8d678629b3d3),
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        horizOriginX: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        horizOriginY: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        id: null,
        ideographic: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        k: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        k1: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        k2: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        k3: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        k4: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        kernelMatrix: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        overlineThickness: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: (0, $23ccbfab2b5e2567$export$ab8645c862eb5a3e),
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        pointsAtY: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        pointsAtZ: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        rev: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        requiredFeatures: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        requiredFonts: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        requiredFormats: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        specularExponent: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        strikethroughThickness: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        string: null,
        stroke: null,
        strokeDashArray: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        strokeOpacity: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        strokeWidth: null,
        style: null,
        surfaceScale: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        tabIndex: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        tableValues: null,
        target: null,
        targetX: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        targetY: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: (0, $23ccbfab2b5e2567$export$2ad25cfebf36cacd),
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        underlineThickness: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        values: null,
        vAlphabetic: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        vMathematical: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        vectorEffect: null,
        vHanging: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        vIdeographic: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        version: null,
        vertAdvY: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        vertOriginX: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        vertOriginY: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: (0, $23ccbfab2b5e2567$export$98e628dec113755e),
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
});


/**
 * @typedef {import('./util/schema.js').Schema} Schema
 */ 


const $fc4ee6ce5278f0ba$var$valid = /^data[-\w.:]+$/i;
const $fc4ee6ce5278f0ba$var$dash = /-[a-z]/g;
const $fc4ee6ce5278f0ba$var$cap = /[A-Z]/g;
function $fc4ee6ce5278f0ba$export$71aa6c912b956294(schema, value) {
    const normal = (0, $980e993c25f15b87$export$a3295358bff77e)(value);
    let prop = value;
    let Type = (0, $e79e41024153ca29$export$c4868e4a24d48fad);
    if (normal in schema.normal) return schema.property[schema.normal[normal]];
    if (normal.length > 4 && normal.slice(0, 4) === "data" && $fc4ee6ce5278f0ba$var$valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === "-") {
            // Turn it into a property.
            const rest = value.slice(5).replace($fc4ee6ce5278f0ba$var$dash, $fc4ee6ce5278f0ba$var$camelcase);
            prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
        } else {
            // Turn it into an attribute.
            const rest = value.slice(4);
            if (!$fc4ee6ce5278f0ba$var$dash.test(rest)) {
                let dashes = rest.replace($fc4ee6ce5278f0ba$var$cap, $fc4ee6ce5278f0ba$var$kebab);
                if (dashes.charAt(0) !== "-") dashes = "-" + dashes;
                value = "data" + dashes;
            }
        }
        Type = (0, $564f267885156f07$export$ea6b9f0064e88c9b);
    }
    return new Type(prop, value);
}
/**
 * @param {string} $0
 * @returns {string}
 */ function $fc4ee6ce5278f0ba$var$kebab($0) {
    return "-" + $0.toLowerCase();
}
/**
 * @param {string} $0
 * @returns {string}
 */ function $fc4ee6ce5278f0ba$var$camelcase($0) {
    return $0.charAt(1).toUpperCase();
}




const $7798a5acf5615526$export$c0bb0b647f701bb5 = (0, $9bb6a41dd9e96c7c$export$4950aa0f605343fb)([
    (0, $8f588845f7d636b7$export$f2913fe8983302e),
    (0, $ceb366ce7ed27563$export$2bd1230ec7600845),
    (0, $e75654d3dbd1b16e$export$e20c24a128671213),
    (0, $aa8ca69aa86d27a4$export$4d2d26490572750a),
    (0, $69772c807f2dc588$export$c0bb0b647f701bb5)
], "html");
const $7798a5acf5615526$export$7ed1367e7fa1ad68 = (0, $9bb6a41dd9e96c7c$export$4950aa0f605343fb)([
    (0, $8f588845f7d636b7$export$f2913fe8983302e),
    (0, $ceb366ce7ed27563$export$2bd1230ec7600845),
    (0, $e75654d3dbd1b16e$export$e20c24a128671213),
    (0, $aa8ca69aa86d27a4$export$4d2d26490572750a),
    (0, $564c50696fca7eb5$export$7ed1367e7fa1ad68)
], "svg");


/**
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').RuleSet} RuleSet
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Selectors} Selectors
 *
 * @typedef Nest
 *   Rule sets by nesting.
 * @property {Array<RuleSet> | undefined} descendant
 *   `a b`
 * @property {Array<RuleSet> | undefined} directChild
 *   `a > b`
 * @property {Array<RuleSet> | undefined} adjacentSibling
 *   `a + b`
 * @property {Array<RuleSet> | undefined} generalSibling
 *   `a ~ b`
 *
 * @typedef Counts
 *   Info on elements in a parent.
 * @property {number} count
 *   Number of elements.
 * @property {Map<string, number>} types
 *   Number of elements by tag name.
 */ /**
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').ElementChild} ElementChild
 * @typedef {import('./types.js').Direction} Direction
 * @typedef {import('unist-util-visit/complex-types.js').Visitor<ElementChild>} Visitor
 */ const $4d7f0cfb8aa82529$var$rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
const $4d7f0cfb8aa82529$var$ltrRange = "A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
/* eslint-disable no-misleading-character-class */ const $4d7f0cfb8aa82529$var$rtl = new RegExp("^[^" + $4d7f0cfb8aa82529$var$ltrRange + "]*[" + $4d7f0cfb8aa82529$var$rtlRange + "]");
const $4d7f0cfb8aa82529$var$ltr = new RegExp("^[^" + $4d7f0cfb8aa82529$var$rtlRange + "]*[" + $4d7f0cfb8aa82529$var$ltrRange + "]");
function $4d7f0cfb8aa82529$export$9fddb9d0dd7d8a54(value) {
    const source = String(value || "");
    return $4d7f0cfb8aa82529$var$rtl.test(source) ? "rtl" : $4d7f0cfb8aa82529$var$ltr.test(source) ? "ltr" : "neutral";
}


/**
 * @fileoverview
 *   Get the plain-text value of a hast node.
 * @longdescription
 *   ## Use
 *
 *   ```js
 *   import {h} from 'hastscript'
 *   import {toString} from 'hast-util-to-string'
 *
 *   toString(h('p', 'Alpha'))
 *   //=> 'Alpha'
 *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))
 *   //=> 'Bold and italic.'
 *   ```
 *
 *   ## API
 *
 *   ### `toString(node)`
 *
 *   Transform a node to a string.
 */ /**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 * @typedef {Root|Root['children'][number]} Node
 */ /**
 * Get the plain-text value of a hast node.
 *
 * @param {Node} node
 * @returns {string}
 */ function $3906261811062ae3$export$f84e8e69fd4488a5(node) {
    // “The concatenation of data of all the Text node descendants of the context
    // object, in tree order.”
    if ("children" in node) return $3906261811062ae3$var$all(node);
    // “Context object’s data.”
    return "value" in node ? node.value : "";
}
/**
 * @param {Node} node
 * @returns {string}
 */ function $3906261811062ae3$var$one(node) {
    if (node.type === "text") return node.value;
    return "children" in node ? $3906261811062ae3$var$all(node) : "";
}
/**
 * @param {Root|Element} node
 * @returns {string}
 */ function $3906261811062ae3$var$all(node) {
    let index = -1;
    /** @type {string[]} */ const result = [];
    while(++index < node.children.length)result[index] = $3906261811062ae3$var$one(node.children[index]);
    return result.join("");
}



/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */ /**
 * @typedef {boolean | 'skip'} Action
 *   Union of the action types.
 *
 * @typedef {number} Index
 *   Move to the sibling at `index` next (after node itself is completely
 *   traversed).
 *
 *   Useful if mutating the tree, such as removing the node the visitor is
 *   currently on, or any of its previous siblings.
 *   Results less than 0 or greater than or equal to `children.length` stop
 *   traversing the parent.
 *
 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
 *   List with one or two values, the first an action, the second an index.
 *
 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
 *   Any value that can be returned from a visitor.
 */ /**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform the parent of node (the last of `ancestors`).
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of an ancestor still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Array<Ancestor>} ancestors
 *   Ancestors of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */ /**
 * @template {Node} [Tree=Node]
 *   Tree type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor
 *   Build a typed `Visitor` function from a tree and a test.
 *
 *   It will infer which values are passed as `node` and which as `parents`.
 */ /**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */ /**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */ /**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */ /**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */ /**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */ const $f39978d975233efe$export$226b3eccf92c9ed9 = /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */ /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */ // eslint-disable-next-line max-params
function is(node, test, index, parent, context) {
    const check = $f39978d975233efe$export$9c68d69a4c5bbcf9(test);
    if (index !== undefined && index !== null && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) throw new Error("Expected positive finite index");
    if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) throw new Error("Expected parent node");
    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) throw new Error("Expected both parent and index");
    // @ts-expect-error Looks like a node.
    return node && node.type && typeof node.type === "string" ? Boolean(check.call(context, node, index, parent)) : false;
};
const $f39978d975233efe$export$9c68d69a4c5bbcf9 = /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */ /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */ function(test) {
    if (test === undefined || test === null) return $f39978d975233efe$var$ok;
    if (typeof test === "string") return $f39978d975233efe$var$typeFactory(test);
    if (typeof test === "object") return Array.isArray(test) ? $f39978d975233efe$var$anyFactory(test) : $f39978d975233efe$var$propsFactory(test);
    if (typeof test === "function") return $f39978d975233efe$var$castFactory(test);
    throw new Error("Expected function, string, or object as test");
};
/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */ function $f39978d975233efe$var$anyFactory(tests) {
    /** @type {Array<AssertAnything>} */ const checks = [];
    let index = -1;
    while(++index < tests.length)checks[index] = $f39978d975233efe$export$9c68d69a4c5bbcf9(tests[index]);
    return $f39978d975233efe$var$castFactory(any);
    /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function any(...parameters) {
        let index = -1;
        while(++index < checks.length){
            if (checks[index].call(this, ...parameters)) return true;
        }
        return false;
    }
}
/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */ function $f39978d975233efe$var$propsFactory(check) {
    return $f39978d975233efe$var$castFactory(all);
    /**
   * @param {Node} node
   * @returns {boolean}
   */ function all(node) {
        /** @type {string} */ let key;
        for(key in check){
            // @ts-expect-error: hush, it sure works as an index.
            if (node[key] !== check[key]) return false;
        }
        return true;
    }
}
/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */ function $f39978d975233efe$var$typeFactory(check) {
    return $f39978d975233efe$var$castFactory(type);
    /**
   * @param {Node} node
   */ function type(node) {
        return node && node.type === check;
    }
}
/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */ function $f39978d975233efe$var$castFactory(check) {
    return assertion;
    /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function assertion(node, ...parameters) {
        return Boolean(node && typeof node === "object" && "type" in node && // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters)));
    }
}
function $f39978d975233efe$var$ok() {
    return true;
}


/**
 * @param {string} d
 * @returns {string}
 */ function $f29933faf25f3a8a$export$35e9368ef982300f(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}


const $db76ae54c0965a56$export$f4d8133c446fe484 = true;
const $db76ae54c0965a56$export$7f100f842f565dc9 = false;
const $db76ae54c0965a56$export$8773f85c2fb2c116 = "skip";
const $db76ae54c0965a56$export$70008a21eb6de899 = /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */ /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */ function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
    }
    const is = (0, $f39978d975233efe$export$9c68d69a4c5bbcf9)(test);
    const step = reverse ? -1 : 1;
    factory(tree, undefined, [])();
    /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */ function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */ // @ts-expect-error: hush
        const value = node && typeof node === "object" ? node : {};
        if (typeof value.type === "string") {
            const name = // `hast`
            typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            Object.defineProperty(visit, "name", {
                value: "node (" + (0, $f29933faf25f3a8a$export$35e9368ef982300f)(node.type + (name ? "<" + name + ">" : "")) + ")"
            });
        }
        return visit;
        function visit() {
            /** @type {ActionTuple} */ let result = [];
            /** @type {ActionTuple} */ let subresult;
            /** @type {number} */ let offset;
            /** @type {Array<Parent>} */ let grandparents;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $db76ae54c0965a56$var$toResult(visitor(node, parents));
                if (result[0] === $db76ae54c0965a56$export$7f100f842f565dc9) return result;
            }
            // @ts-expect-error looks like a parent.
            if (node.children && result[0] !== $db76ae54c0965a56$export$8773f85c2fb2c116) {
                // @ts-expect-error looks like a parent.
                offset = (reverse ? node.children.length : -1) + step;
                // @ts-expect-error looks like a parent.
                grandparents = parents.concat(node);
                // @ts-expect-error looks like a parent.
                while(offset > -1 && offset < node.children.length){
                    // @ts-expect-error looks like a parent.
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $db76ae54c0965a56$export$7f100f842f565dc9) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
};
/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */ function $db76ae54c0965a56$var$toResult(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === "number") return [
        $db76ae54c0965a56$export$f4d8133c446fe484,
        value
    ];
    return [
        value
    ];
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */ /**
 * Check if `Child` can be a child of `Ancestor`.
 *
 * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns
 * `never`.
 *
 * @template {Node} Ancestor
 *   Node type.
 * @template {Node} Child
 *   Node type.
 * @typedef {(
 *   Ancestor extends Parent
 *     ? Child extends Ancestor['children'][number]
 *       ? Ancestor
 *       : never
 *     : never
 * )} ParentsOf
 */ /**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform `parent`.
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of `parent` still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Visited extends Node ? number | null : never} index
 *   Index of `node` in `parent`.
 * @param {Ancestor extends Node ? Ancestor | null : never} parent
 *   Parent of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */ /**
 * Build a typed `Visitor` function from a node and all possible parents.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Visited
 *   Node type.
 * @template {Parent} Ancestor
 *   Parent type.
 * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch
 */ /**
 * Build a typed `Visitor` function from a list of descendants and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Descendant
 *   Node type.
 * @template {Test} Check
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromMatch<
 *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,
 *     Extract<Descendant, Parent>
 *   >
 * )} BuildVisitorFromDescendants
 */ /**
 * Build a typed `Visitor` function from a tree and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} [Tree=Node]
 *   Node type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromDescendants<
 *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,
 *     Check
 *   >
 * )} BuildVisitor
 */ 
const $289d4c6ee6457b3d$export$bf638b60ea8b89b7 = /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */ /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */ function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    (0, $db76ae54c0965a56$export$70008a21eb6de899)(tree, test, overload, reverse);
    /**
       * @param {Node} node
       * @param {Array<Parent>} parents
       */ function overload(node, parents) {
        const parent = parents[parents.length - 1];
        return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
    }
};


function $e904230d8788bdad$export$b6a91203b6b36f(state, node) {
    const schema = state.schema;
    const language = state.language;
    const currentDirection = state.direction;
    const editableOrEditingHost = state.editableOrEditingHost;
    /** @type {Direction | undefined} */ let dirInferred;
    if (node.type === "element" && node.properties) {
        const lang = node.properties.xmlLang || node.properties.lang;
        const type = node.properties.type || "text";
        const dir = $e904230d8788bdad$var$dirProperty(node);
        if (lang !== undefined && lang !== null) state.language = String(lang);
        if (schema && schema.space === "html") {
            if (node.properties.contentEditable === "true") state.editableOrEditingHost = true;
            if (node.tagName === "svg") state.schema = (0, $7798a5acf5615526$export$7ed1367e7fa1ad68);
            // See: <https://html.spec.whatwg.org/#the-directionality>.
            // Explicit `[dir=rtl]`.
            if (dir === "rtl") dirInferred = dir;
            else if (// Explicit `[dir=ltr]`.
            dir === "ltr" || // HTML with an invalid or no `[dir]`.
            dir !== "auto" && node.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
            dir !== "auto" && node.tagName === "input" && type === "tel") dirInferred = "ltr";
            else if (dir === "auto" || node.tagName === "bdi") {
                if (node.tagName === "textarea") // Check contents of `<textarea>`.
                dirInferred = $e904230d8788bdad$var$dirBidi((0, $3906261811062ae3$export$f84e8e69fd4488a5)(node));
                else if (node.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) // Check value of `<input>`.
                dirInferred = node.properties.value ? $e904230d8788bdad$var$dirBidi(node.properties.value) : "ltr";
                else // Check text nodes in `node`.
                (0, $289d4c6ee6457b3d$export$bf638b60ea8b89b7)(node, inferDirectionality);
            }
            if (dirInferred) state.direction = dirInferred;
        } else if (state.editableOrEditingHost) state.editableOrEditingHost = false;
    }
    return reset;
    function reset() {
        state.schema = schema;
        state.language = language;
        state.direction = currentDirection;
        state.editableOrEditingHost = editableOrEditingHost;
    }
    /** @type {Visitor} */ function inferDirectionality(child) {
        if (child.type === "text") {
            dirInferred = $e904230d8788bdad$var$dirBidi(child.value);
            return dirInferred ? (0, $db76ae54c0965a56$export$7f100f842f565dc9) : undefined;
        }
        if (child !== node && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || $e904230d8788bdad$var$dirProperty(child))) return 0, $db76ae54c0965a56$export$8773f85c2fb2c116;
    }
}
/**
 * @param {string} value
 * @returns {Direction | undefined}
 */ function $e904230d8788bdad$var$dirBidi(value) {
    const result = (0, $4d7f0cfb8aa82529$export$9fddb9d0dd7d8a54)(value);
    return result === "neutral" ? undefined : result;
}
/**
 * @param {ElementChild} node
 * @returns {Direction | undefined}
 */ function $e904230d8788bdad$var$dirProperty(node) {
    const value = node.type === "element" && node.properties && typeof node.properties.dir === "string" ? node.properties.dir.toLowerCase() : undefined;
    return value === "auto" || value === "ltr" || value === "rtl" ? value : undefined;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 */ /**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RuleAttr} RuleAttr
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Schema} Schema
 * @typedef {import('./types.js').Info} Info
 * @typedef {import('./types.js').PropertyValue} PropertyValue
 */ /**
 * @typedef Options
 *   Configuration for `stringify`.
 * @property {boolean} [padLeft=true]
 *   Whether to pad a space before a token.
 * @property {boolean} [padRight=false]
 *   Whether to pad a space after a token.
 */ /**
 * @typedef {Options} StringifyOptions
 *   Please use `StringifyOptions` instead.
 */ /**
 * Parse comma-separated tokens to an array.
 *
 * @param {string} value
 *   Comma-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */ function $0c63d871a212e575$export$98e6a39c04603d36(value) {
    /** @type {Array<string>} */ const tokens = [];
    const input = String(value || "");
    let index = input.indexOf(",");
    let start = 0;
    /** @type {boolean} */ let end = false;
    while(!end){
        if (index === -1) {
            index = input.length;
            end = true;
        }
        const token = input.slice(start, index).trim();
        if (token || !end) tokens.push(token);
        start = index + 1;
        index = input.indexOf(",", start);
    }
    return tokens;
}
function $0c63d871a212e575$export$fac44ee5b035f737(values, options) {
    const settings = options || {};
    // Ensure the last empty entry is seen.
    const input = values[values.length - 1] === "" ? [
        ...values,
        ""
    ] : values;
    return input.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
}


/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Content} Content
 */ /**
 * @typedef {Root | Content} Node
 */ const $987364a2ac7dd705$var$own = {}.hasOwnProperty;
function $987364a2ac7dd705$export$bf9617eaf5d2451(node, field) {
    const value = typeof field === "string" && $987364a2ac7dd705$var$isNode(node) && node.type === "element" && node.properties && $987364a2ac7dd705$var$own.call(node.properties, field) && node.properties[field];
    return value !== null && value !== undefined && value !== false;
}
/**
 * @param {unknown} value
 * @returns {value is Node}
 */ function $987364a2ac7dd705$var$isNode(value) {
    return Boolean(value && typeof value === "object" && "type" in value);
}



/**
 * Parse space-separated tokens to an array of strings.
 *
 * @param {string} value
 *   Space-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */ function $d4dc163a2878d994$export$98e6a39c04603d36(value) {
    const input = String(value || "").trim();
    return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function $d4dc163a2878d994$export$fac44ee5b035f737(values) {
    return values.join(" ").trim();
}


/**
 * @callback Handler
 *   Handle a value, with a certain ID field set to a certain value.
 *   The ID field is passed to `zwitch`, and it’s value is this function’s
 *   place on the `handlers` record.
 * @param {...any} parameters
 *   Arbitrary parameters passed to the zwitch.
 *   The first will be an object with a certain ID field set to a certain value.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback UnknownHandler
 *   Handle values that do have a certain ID field, but it’s set to a value
 *   that is not listed in the `handlers` record.
 * @param {unknown} value
 *   An object with a certain ID field set to an unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback InvalidHandler
 *   Handle values that do not have a certain ID field.
 * @param {unknown} value
 *   Any unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {void|null|undefined|never}
 *   This should crash or return nothing.
 */ /**
 * @template {InvalidHandler} [Invalid=InvalidHandler]
 * @template {UnknownHandler} [Unknown=UnknownHandler]
 * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]
 * @typedef Options
 *   Configuration (required).
 * @property {Invalid} [invalid]
 *   Handler to use for invalid values.
 * @property {Unknown} [unknown]
 *   Handler to use for unknown values.
 * @property {Handlers} [handlers]
 *   Handlers to use.
 */ const $4515cf84e19a07d6$var$own = {}.hasOwnProperty;
function $4515cf84e19a07d6$export$d6a12bfbbedf6185(key, options) {
    const settings = options || {};
    /**
   * Handle one value.
   *
   * Based on the bound `key`, a respective handler will be called.
   * If `value` is not an object, or doesn’t have a `key` property, the special
   * “invalid” handler will be called.
   * If `value` has an unknown `key`, the special “unknown” handler will be
   * called.
   *
   * All arguments, and the context object, are passed through to the handler,
   * and it’s result is returned.
   *
   * @this {unknown}
   *   Any context object.
   * @param {unknown} [value]
   *   Any value.
   * @param {...unknown} parameters
   *   Arbitrary parameters passed to the zwitch.
   * @property {Handler} invalid
   *   Handle for values that do not have a certain ID field.
   * @property {Handler} unknown
   *   Handle values that do have a certain ID field, but it’s set to a value
   *   that is not listed in the `handlers` record.
   * @property {Handlers} handlers
   *   Record of handlers.
   * @returns {unknown}
   *   Anything.
   */ function one(value, ...parameters) {
        /** @type {Handler|undefined} */ let fn = one.invalid;
        const handlers = one.handlers;
        if (value && $4515cf84e19a07d6$var$own.call(value, key)) {
            // @ts-expect-error Indexable.
            const id = String(value[key]);
            // @ts-expect-error Indexable.
            fn = $4515cf84e19a07d6$var$own.call(handlers, id) ? handlers[id] : one.unknown;
        }
        if (fn) return fn.call(this, value, ...parameters);
    }
    one.handlers = settings.handlers || {};
    one.invalid = settings.invalid;
    one.unknown = settings.unknown;
    // @ts-expect-error: matches!
    return one;
}


/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */ const $f1fd158f99fe7ac5$var$handle = (0, $4515cf84e19a07d6$export$d6a12bfbbedf6185)("operator", {
    unknown: $f1fd158f99fe7ac5$var$unknownOperator,
    // @ts-expect-error: hush.
    invalid: $f1fd158f99fe7ac5$var$exists,
    handlers: {
        "=": $f1fd158f99fe7ac5$var$exact,
        "~=": $f1fd158f99fe7ac5$var$spaceSeparatedList,
        "|=": $f1fd158f99fe7ac5$var$exactOrPrefix,
        "^=": $f1fd158f99fe7ac5$var$begins,
        "$=": $f1fd158f99fe7ac5$var$ends,
        "*=": $f1fd158f99fe7ac5$var$contains
    }
});
function $f1fd158f99fe7ac5$export$af4b9a83f4b00434(query, element, schema) {
    const attrs = query.attrs;
    let index = -1;
    while(++index < attrs.length){
        if (!$f1fd158f99fe7ac5$var$handle(attrs[index], element, (0, $fc4ee6ce5278f0ba$export$71aa6c912b956294)(schema, attrs[index].name))) return false;
    }
    return true;
}
/**
 * Check whether an attribute exists.
 *
 * `[attr]`
 *
 * @param {RuleAttr} _
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$exists(_, element, info) {
    return (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property);
}
/**
 * Check whether an attribute has an exact value.
 *
 * `[attr=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$exact(query, element, info) {
    return Boolean((0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && element.properties && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info) === query.value);
}
/**
 * Check whether an attribute, interpreted as a space-separated list, contains
 * a value.
 *
 * `[attr~=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$spaceSeparatedList(query, element, info) {
    const value = element.properties && element.properties[info.property];
    return(// If this is a space-separated list, and the query is contained in it, return
    // true.
    !info.commaSeparated && value && typeof value === "object" && query.value && value.includes(query.value) || // For all other values (including comma-separated lists), return whether this
    // is an exact match.
    (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && $f1fd158f99fe7ac5$var$normalizeValue(value, info) === query.value);
}
/**
 * Check whether an attribute has a substring as either the exact value or a
 * prefix.
 *
 * `[attr|=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$exactOrPrefix(query, element, info) {
    const value = $f1fd158f99fe7ac5$var$normalizeValue(element.properties && element.properties[info.property], info);
    return Boolean((0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === "-"));
}
/**
 * Check whether an attribute has a substring as its start.
 *
 * `[attr^=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$begins(query, element, info) {
    return Boolean((0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);
}
/**
 * Check whether an attribute has a substring as its end.
 *
 * `[attr$=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$ends(query, element, info) {
    return Boolean((0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);
}
/**
 * Check whether an attribute contains a substring.
 *
 * `[attr*=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $f1fd158f99fe7ac5$var$contains(query, element, info) {
    return Boolean((0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).includes(query.value));
}
// Shouldn’t be called, Parser throws an error instead.
/**
 * @param {unknown} query
 * @returns {never}
 */ /* c8 ignore next 4 */ function $f1fd158f99fe7ac5$var$unknownOperator(query) {
    // @ts-expect-error: `operator` guaranteed.
    throw new Error("Unknown operator `" + query.operator + "`");
}
/**
 * Stringify a hast value back to its HTML form.
 *
 * @param {PropertyValue} value
 * @param {Info} info
 * @returns {string}
 */ function $f1fd158f99fe7ac5$var$normalizeValue(value, info) {
    if (typeof value === "boolean") return info.attribute;
    if (Array.isArray(value)) return (info.commaSeparated ? (0, $0c63d871a212e575$export$fac44ee5b035f737) : (0, $d4dc163a2878d994$export$fac44ee5b035f737))(value);
    return String(value);
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has all class names.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $4e560857536fc474$export$2913c0c0b5623090(query, element) {
    /** @type {readonly string[]} */ // @ts-expect-error Assume array.
    const value = element.properties.className || [];
    let index = -1;
    if (query.classNames) while(++index < query.classNames.length){
        if (!value.includes(query.classNames[index])) return false;
    }
    return true;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has an ID.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $fda01db12207d90d$export$d560c7e4a29451c2(query, element) {
    return Boolean(element.properties && element.properties.id === query.id);
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has a tag name.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $3bcd2419cb986896$export$a8ff84c12d48cfa6(query, element) {
    return query.tagName === "*" || query.tagName === element.tagName;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').ElementChild} ElementChild
 */ /**
 * See <https://tools.ietf.org/html/rfc4647#section-3.1>
 * for more info on the algorithms.
 */ /**
 * @typedef {string} Tag
 *   BCP-47 tag.
 * @typedef {Array<Tag>} Tags
 *   List of BCP-47 tags.
 * @typedef {string} Range
 *   RFC 4647 range.
 * @typedef {Array<Range>} Ranges
 *   List of RFC 4647 range.
 *
 * @callback Check
 *   An internal check.
 * @param {Tag} tag
 *   BCP-47 tag.
 * @param {Range} range
 *   RFC 4647 range.
 * @returns {boolean}
 *   Whether the range matches the tag.
 *
 * @typedef {FilterOrLookup<true>} Filter
 *   Filter: yields all tags that match a range.
 * @typedef {FilterOrLookup<false>} Lookup
 *   Lookup: yields the best tag that matches a range.
 */ /**
 * @template {boolean} IsFilter
 *   Whether to filter or perform a lookup.
 * @callback FilterOrLookup
 *   A check.
 * @param {Tag|Tags} tags
 *   One or more BCP-47 tags.
 * @param {Range|Ranges|undefined} [ranges='*']
 *   One or more RFC 4647 ranges.
 * @returns {IsFilter extends true ? Tags : Tag|undefined}
 *   Result.
 */ /**
 * Factory to perform a filter or a lookup.
 *
 * This factory creates a function that accepts a list of tags and a list of
 * ranges, and contains logic to exit early for lookups.
 * `check` just has to deal with one tag and one range.
 * This match function iterates over ranges, and for each range,
 * iterates over tags.
 * That way, earlier ranges matching any tag have precedence over later ranges.
 *
 * @template {boolean} IsFilter
 * @param {Check} check
 *   A check.
 * @param {IsFilter} filter
 *   Whether to filter or perform a lookup.
 * @returns {FilterOrLookup<IsFilter>}
 *   Filter or lookup.
 */ function $09d8790eeaaaa3c4$var$factory(check, filter) {
    /**
   * @param {Tag|Tags} tags
   *   One or more BCP-47 tags.
   * @param {Range|Ranges|undefined} [ranges='*']
   *   One or more RFC 4647 ranges.
   * @returns {IsFilter extends true ? Tags : Tag|undefined}
   *   Result.
   */ return function(tags, ranges) {
        let left = $09d8790eeaaaa3c4$var$cast(tags, "tag");
        const right = $09d8790eeaaaa3c4$var$cast(ranges === null || ranges === undefined ? "*" : ranges, "range");
        /** @type {Tags} */ const matches = [];
        let rightIndex = -1;
        while(++rightIndex < right.length){
            const range = right[rightIndex].toLowerCase();
            // Ignore wildcards in lookup mode.
            if (!filter && range === "*") continue;
            let leftIndex = -1;
            /** @type {Tags} */ const next = [];
            while(++leftIndex < left.length)if (check(left[leftIndex].toLowerCase(), range)) {
                // Exit if this is a lookup and we have a match.
                if (!filter) return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ left[leftIndex];
                matches.push(left[leftIndex]);
            } else next.push(left[leftIndex]);
            left = next;
        }
        // If this is a filter, return the list.  If it’s a lookup, we didn’t find
        // a match, so return `undefined`.
        return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ filter ? matches : undefined;
    };
}
const $09d8790eeaaaa3c4$export$454d02d943c45292 = $09d8790eeaaaa3c4$var$factory(function(tag, range) {
    return range === "*" || tag === range || tag.includes(range + "-");
}, true);
const $09d8790eeaaaa3c4$export$d216e65da1a9aa7e = $09d8790eeaaaa3c4$var$factory(function(tag, range) {
    // 3.3.2.1
    const left = tag.split("-");
    const right = range.split("-");
    let leftIndex = 0;
    let rightIndex = 0;
    // 3.3.2.2
    if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) return false;
    leftIndex++;
    rightIndex++;
    // 3.3.2.3
    while(rightIndex < right.length){
        // 3.3.2.3.A
        if (right[rightIndex] === "*") {
            rightIndex++;
            continue;
        }
        // 3.3.2.3.B
        if (!left[leftIndex]) return false;
        // 3.3.2.3.C
        if (left[leftIndex] === right[rightIndex]) {
            leftIndex++;
            rightIndex++;
            continue;
        }
        // 3.3.2.3.D
        if (left[leftIndex].length === 1) return false;
        // 3.3.2.3.E
        leftIndex++;
    }
    // 3.3.2.4
    return true;
}, true);
const $09d8790eeaaaa3c4$export$dfc7155ac0343b8 = $09d8790eeaaaa3c4$var$factory(function(tag, range) {
    let right = range;
    /* eslint-disable-next-line no-constant-condition */ while(true){
        if (right === "*" || tag === right) return true;
        let index = right.lastIndexOf("-");
        if (index < 0) return false;
        if (right.charAt(index - 2) === "-") index -= 2;
        right = right.slice(0, index);
    }
}, false);
/**
 * Validate tags or ranges, and cast them to arrays.
 *
 * @param {string|Array<string>} values
 * @param {string} name
 * @returns {Array<string>}
 */ function $09d8790eeaaaa3c4$var$cast(values, name) {
    const value = values && typeof values === "string" ? [
        values
    ] : values;
    if (!value || typeof value !== "object" || !("length" in value)) throw new Error("Invalid " + name + " `" + value + "`, expected non-empty string");
    return value;
}




/**
 * Check if the given value is *inter-element whitespace*.
 *
 * @param {unknown} thing
 *   Thing to check (typically `Node` or `string`).
 * @returns {boolean}
 *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
 *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
 *   (`\r`), or form feed (`\f`).
 *   If a node is passed it must be a `Text` node, whose `value` field is
 *   checked.
 */ function $e944ab25bc9b5b93$export$7af1228ff777d175(thing) {
    /** @type {string} */ const value = // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
    // HTML whitespace expression.
    // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
    return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}


// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
const $f78a485a6b780c6e$var$whitespace = new Set([
    9,
    10,
    12,
    13,
    32
]);
const $f78a485a6b780c6e$var$ZERO = "0".charCodeAt(0);
const $f78a485a6b780c6e$var$NINE = "9".charCodeAt(0);
function $f78a485a6b780c6e$export$98e6a39c04603d36(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") return [
        2,
        0
    ];
    else if (formula === "odd") return [
        2,
        1
    ];
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    let idx = 0;
    let a = 0;
    let sign = readSign();
    let number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        } else sign = number = 0;
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
    return [
        a,
        sign * number
    ];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") idx++;
        return 1;
    }
    function readNumber() {
        const start = idx;
        let value = 0;
        while(idx < formula.length && formula.charCodeAt(idx) >= $f78a485a6b780c6e$var$ZERO && formula.charCodeAt(idx) <= $f78a485a6b780c6e$var$NINE){
            value = value * 10 + (formula.charCodeAt(idx) - $f78a485a6b780c6e$var$ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while(idx < formula.length && $f78a485a6b780c6e$var$whitespace.has(formula.charCodeAt(idx)))idx++;
    }
}


var $547415ca9abfdbdd$exports = {};
$547415ca9abfdbdd$exports = {
    trueFunc: function trueFunc() {
        return true;
    },
    falseFunc: function falseFunc() {
        return false;
    }
};


function $2623cd3fb43a925b$export$ef7acd7185315e22(parsed) {
    const a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    const b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */ if (b < 0 && a <= 0) return (0, (/*@__PURE__*/$parcel$interopDefault($547415ca9abfdbdd$exports))).falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1) return (index)=>index <= b;
    if (a === 0) return (index)=>index === b;
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1) return b < 0 ? (0, (/*@__PURE__*/$parcel$interopDefault($547415ca9abfdbdd$exports))).trueFunc : (index)=>index >= b;
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */ const absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    const bMod = (b % absA + absA) % absA;
    return a > 1 ? (index)=>index >= b && index % absA === bMod : (index)=>index <= b && index % absA === bMod;
}
function $2623cd3fb43a925b$export$80d376111cc09ad7(parsed) {
    const a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    let b = parsed[1] - 1;
    let n = 0;
    // Make sure to always return an increasing sequence
    if (a < 0) {
        const aPos = -a;
        // Get `b mod a`
        const minValue = (b % aPos + aPos) % aPos;
        return ()=>{
            const val = minValue + aPos * n++;
            return val > b ? null : val;
        };
    }
    if (a === 0) return b < 0 ? ()=>null : ()=>n++ === 0 ? b : null;
    if (b < 0) b += a * Math.ceil(-b / a);
    return ()=>a * n++ + b;
}


function $314464ea2a7d3765$export$2e2bcd8739ae039(formula) {
    return (0, $2623cd3fb43a925b$export$ef7acd7185315e22)((0, $f78a485a6b780c6e$export$98e6a39c04603d36)(formula));
}
function $314464ea2a7d3765$export$49bb65c2ea163039(formula) {
    return (0, $2623cd3fb43a925b$export$80d376111cc09ad7)((0, $f78a485a6b780c6e$export$98e6a39c04603d36)(formula));
}




/** @type {import('nth-check').default} */ // @ts-expect-error
const $32779e344bb57507$var$nthCheck = (0, $314464ea2a7d3765$export$2e2bcd8739ae039).default || (0, $314464ea2a7d3765$export$2e2bcd8739ae039);
/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */ const $32779e344bb57507$var$handle = (0, $4515cf84e19a07d6$export$d6a12bfbbedf6185)("name", {
    unknown: $32779e344bb57507$var$unknownPseudo,
    invalid: $32779e344bb57507$var$invalidPseudo,
    handlers: {
        any: $32779e344bb57507$var$matches,
        "any-link": $32779e344bb57507$var$anyLink,
        blank: $32779e344bb57507$var$blank,
        checked: $32779e344bb57507$var$checked,
        dir: $32779e344bb57507$var$dir,
        disabled: $32779e344bb57507$var$disabled,
        empty: $32779e344bb57507$var$empty,
        enabled: $32779e344bb57507$var$enabled,
        "first-child": $32779e344bb57507$var$firstChild,
        "first-of-type": $32779e344bb57507$var$firstOfType,
        has: $32779e344bb57507$var$has,
        lang: $32779e344bb57507$var$lang,
        "last-child": $32779e344bb57507$var$lastChild,
        "last-of-type": $32779e344bb57507$var$lastOfType,
        matches: $32779e344bb57507$var$matches,
        not: $32779e344bb57507$var$not,
        "nth-child": $32779e344bb57507$var$nthChild,
        "nth-last-child": $32779e344bb57507$var$nthLastChild,
        "nth-of-type": $32779e344bb57507$var$nthOfType,
        "nth-last-of-type": $32779e344bb57507$var$nthLastOfType,
        "only-child": $32779e344bb57507$var$onlyChild,
        "only-of-type": $32779e344bb57507$var$onlyOfType,
        optional: $32779e344bb57507$var$optional,
        "read-only": $32779e344bb57507$var$readOnly,
        "read-write": $32779e344bb57507$var$readWrite,
        required: $32779e344bb57507$var$required,
        root: $32779e344bb57507$var$root,
        scope: $32779e344bb57507$var$scope
    }
});
$32779e344bb57507$export$4a40d01fa098dd92.needsIndex = [
    "any",
    "first-child",
    "first-of-type",
    "last-child",
    "last-of-type",
    "matches",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-of-type",
    "nth-last-of-type",
    "only-child",
    "only-of-type"
];
function $32779e344bb57507$export$4a40d01fa098dd92(query, element, index, parent, state) {
    const pseudos = query.pseudos;
    let offset = -1;
    while(++offset < pseudos.length){
        if (!$32779e344bb57507$var$handle(pseudos[offset], element, index, parent, state)) return false;
    }
    return true;
}
/**
 * Check whether an element matches an `:any-link` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$anyLink(_, element) {
    return (element.tagName === "a" || element.tagName === "area" || element.tagName === "link") && (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "href");
}
/**
 * Check whether an element matches a `:blank` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$blank(_, element) {
    return !$32779e344bb57507$var$someChildren(element, check);
    /**
   * @param {ElementChild} child
   * @returns {boolean}
   */ function check(child) {
        return child.type === "element" || child.type === "text" && !(0, $e944ab25bc9b5b93$export$7af1228ff777d175)(child);
    }
}
/**
 * Check whether an element matches a `:checked` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$checked(_, element) {
    if (element.tagName === "input" || element.tagName === "menuitem") return Boolean(element.properties && (element.properties.type === "checkbox" || element.properties.type === "radio") && (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "checked"));
    if (element.tagName === "option") return (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "selected");
    return false;
}
/**
 * Check whether an element matches a `:dir()` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$dir(query, _1, _2, _3, state) {
    return state.direction === query.value;
}
/**
 * Check whether an element matches a `:disabled` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$disabled(_, element) {
    return (element.tagName === "button" || element.tagName === "input" || element.tagName === "select" || element.tagName === "textarea" || element.tagName === "optgroup" || element.tagName === "option" || element.tagName === "menuitem" || element.tagName === "fieldset") && (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "disabled");
}
/**
 * Check whether an element matches an `:empty` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$empty(_, element) {
    return !$32779e344bb57507$var$someChildren(element, check);
    /**
   * @param {ElementChild} child
   * @returns {boolean}
   */ function check(child) {
        return child.type === "element" || child.type === "text";
    }
}
/**
 * Check whether an element matches an `:enabled` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$enabled(query, element) {
    return !$32779e344bb57507$var$disabled(query, element);
}
/**
 * Check whether an element matches a `:first-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$firstChild(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return state.elementIndex === 0;
}
/**
 * Check whether an element matches a `:first-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$firstOfType(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return state.typeIndex === 0;
}
/**
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$has(query, element, _1, _2, state) {
    /** @type {SelectState} */ const childState = {
        ...state,
        // Not found yet.
        found: false,
        // Do walk deep.
        shallow: false,
        // One result is enough.
        one: true,
        scopeElements: [
            element
        ],
        results: [],
        rootQuery: (0, $daa884ef28a3b3e1$export$9141434d8c079e66)(query.value)
    };
    (0, $daa884ef28a3b3e1$export$588732934346abbf)(childState, {
        type: "root",
        children: element.children
    });
    return childState.results.length > 0;
}
/**
 * Check whether an element matches a `:lang()` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$lang(query, _1, _2, _3, state) {
    return state.language !== "" && state.language !== undefined && // @ts-expect-error never `selectors`.
    (0, $09d8790eeaaaa3c4$export$d216e65da1a9aa7e)(state.language, (0, $0c63d871a212e575$export$98e6a39c04603d36)(query.value)).length > 0;
}
/**
 * Check whether an element matches a `:last-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$lastChild(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);
}
/**
 * Check whether an element matches a `:last-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$lastOfType(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
/**
 * Check whether an element `:matches` further selectors.
 *
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} _
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$matches(query, element, _, parent, state) {
    /** @type {SelectState} */ const childState = {
        ...state,
        // Not found yet.
        found: false,
        // Do walk deep.
        shallow: false,
        // One result is enough.
        one: true,
        scopeElements: [
            element
        ],
        results: [],
        rootQuery: (0, $daa884ef28a3b3e1$export$9141434d8c079e66)(query.value)
    };
    (0, $daa884ef28a3b3e1$export$588732934346abbf)(childState, element);
    return childState.results[0] === element;
}
/**
 * Check whether an element does `:not` match further selectors.
 *
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$not(query, element, index, parent, state) {
    return !$32779e344bb57507$var$matches(query, element, index, parent, state);
}
/**
 * Check whether an element matches an `:nth-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$nthChild(query, _1, _2, _3, state) {
    const fn = $32779e344bb57507$var$getCachedNthCheck(query);
    $32779e344bb57507$var$assertDeep(state, query);
    return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
/**
 * Check whether an element matches an `:nth-last-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$nthLastChild(query, _1, _2, _3, state) {
    const fn = $32779e344bb57507$var$getCachedNthCheck(query);
    $32779e344bb57507$var$assertDeep(state, query);
    return Boolean(typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1));
}
/**
 * Check whether an element matches a `:nth-last-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$nthLastOfType(query, _1, _2, _3, state) {
    const fn = $32779e344bb57507$var$getCachedNthCheck(query);
    $32779e344bb57507$var$assertDeep(state, query);
    return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
/**
 * Check whether an element matches an `:nth-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$nthOfType(query, _1, _2, _3, state) {
    const fn = $32779e344bb57507$var$getCachedNthCheck(query);
    $32779e344bb57507$var$assertDeep(state, query);
    return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
/**
 * Check whether an element matches an `:only-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$onlyChild(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return state.elementCount === 1;
}
/**
 * Check whether an element matches an `:only-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$onlyOfType(query, _1, _2, _3, state) {
    $32779e344bb57507$var$assertDeep(state, query);
    return state.typeCount === 1;
}
/**
 * Check whether an element matches an `:optional` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$optional(query, element) {
    return !$32779e344bb57507$var$required(query, element);
}
/**
 * Check whether an element matches a `:read-only` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$readOnly(query, element, index, parent, state) {
    return !$32779e344bb57507$var$readWrite(query, element, index, parent, state);
}
/**
 * Check whether an element matches a `:read-write` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$readWrite(_, element, _1, _2, state) {
    return element.tagName === "input" || element.tagName === "textarea" ? !(0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "readOnly") && !(0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "disabled") : Boolean(state.editableOrEditingHost);
}
/**
 * Check whether an element matches a `:required` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $32779e344bb57507$var$required(_, element) {
    return (element.tagName === "input" || element.tagName === "textarea" || element.tagName === "select") && (0, $987364a2ac7dd705$export$bf9617eaf5d2451)(element, "required");
}
/**
 * Check whether an element matches a `:root` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$root(_, element, _1, parent, state) {
    return Boolean((!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element.tagName === "html" || element.tagName === "svg"));
}
/**
 * Check whether an element matches a `:scope` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $32779e344bb57507$var$scope(_, element, _1, _2, state) {
    return state.scopeElements.includes(element);
}
// Shouldn’t be called, parser gives correct data.
/* c8 ignore next 3 */ function $32779e344bb57507$var$invalidPseudo() {
    throw new Error("Invalid pseudo-selector");
}
/**
 * @param {unknown} query
 * @returns {never}
 */ function $32779e344bb57507$var$unknownPseudo(query) {
    // @ts-expect-error: indexable.
    if (query.name) // @ts-expect-error: indexable.
    throw new Error("Unknown pseudo-selector `" + query.name + "`");
    throw new Error("Unexpected pseudo-element or empty pseudo-class");
}
/**
 * Check children.
 *
 * @param {Element} element
 * @param {(child: ElementChild) => boolean} check
 * @returns {boolean}
 */ function $32779e344bb57507$var$someChildren(element, check) {
    const children = element.children;
    let index = -1;
    while(++index < children.length){
        if (check(children[index])) return true;
    }
    return false;
}
/**
 * @param {SelectState} state
 * @param {RulePseudo} query
 */ function $32779e344bb57507$var$assertDeep(state, query) {
    if (state.shallow) throw new Error("Cannot use `:" + query.name + "` without parent");
}
/**
 * @param {RulePseudo} query
 * @returns {(value: number) => boolean}
 */ function $32779e344bb57507$var$getCachedNthCheck(query) {
    /** @type {(value: number) => boolean} */ // @ts-expect-error: cache.
    let fn = query._cachedFn;
    if (!fn) {
        // @ts-expect-error: always string.
        fn = $32779e344bb57507$var$nthCheck(query.value);
        // @ts-expect-error: cache.
        query._cachedFn = fn;
    }
    return fn;
}


function $3dcbe92ace153305$export$e0969da9b8fb378d(query, element, index, parent, state) {
    return Boolean((!query.tagName || (0, $3bcd2419cb986896$export$a8ff84c12d48cfa6)(query, element)) && (!query.classNames || (0, $4e560857536fc474$export$2913c0c0b5623090)(query, element)) && (!query.id || (0, $fda01db12207d90d$export$d560c7e4a29451c2)(query, element)) && (!query.attrs || (0, $f1fd158f99fe7ac5$export$af4b9a83f4b00434)(query, element, state.schema)) && (!query.pseudos || (0, $32779e344bb57507$export$4a40d01fa098dd92)(query, element, index, parent, state)));
}


/** @type {Array<never>} */ const $daa884ef28a3b3e1$var$empty = [];
function $daa884ef28a3b3e1$export$9141434d8c079e66(query) {
    if (query === null) return {
        type: "selectors",
        selectors: []
    };
    if (query.type === "ruleSet") return {
        type: "selectors",
        selectors: [
            query
        ]
    };
    return query;
}
function $daa884ef28a3b3e1$export$588732934346abbf(state, tree) {
    if (tree) $daa884ef28a3b3e1$var$one(state, [], tree, undefined, undefined);
}
/**
 * Check a node.
 *
 * @param {SelectState} state
 * @param {Array<RuleSet>} currentRules
 * @param {Node} node
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @returns {Nest}
 */ function $daa884ef28a3b3e1$var$one(state, currentRules, node, index, parent) {
    /** @type {Nest} */ let nestResult = {
        directChild: undefined,
        descendant: undefined,
        adjacentSibling: undefined,
        generalSibling: undefined
    };
    const exit = (0, $e904230d8788bdad$export$b6a91203b6b36f)(state, node);
    if (node.type === "element") nestResult = $daa884ef28a3b3e1$var$applySelectors(state, // Try the root rules for this element too.
    $daa884ef28a3b3e1$var$combine(currentRules, state.rootQuery.selectors), node, index, parent);
    // If this is a parent, and we want to delve into them, and we haven’t found
    // our single result yet.
    if ("children" in node && !state.shallow && !(state.one && state.found)) $daa884ef28a3b3e1$var$all(state, nestResult, node);
    exit();
    return nestResult;
}
/**
 * Check a node.
 *
 * @param {SelectState} state
 * @param {Nest} nest
 * @param {Parent} node
 * @returns {void}
 */ function $daa884ef28a3b3e1$var$all(state, nest, node) {
    const fromParent = $daa884ef28a3b3e1$var$combine(nest.descendant, nest.directChild);
    /** @type {Array<RuleSet> | undefined} */ let fromSibling;
    let index = -1;
    /**
   * Total counts.
   * @type {Counts}
   */ const total = {
        count: 0,
        types: new Map()
    };
    /**
   * Counts of previous siblings.
   * @type {Counts}
   */ const before = {
        count: 0,
        types: new Map()
    };
    while(++index < node.children.length)$daa884ef28a3b3e1$var$count(total, node.children[index]);
    index = -1;
    while(++index < node.children.length){
        const child = node.children[index];
        // Uppercase to prevent prototype polution, injecting `constructor` or so.
        // Normalize because HTML is insensitive.
        const name = child.type === "element" ? child.tagName.toUpperCase() : undefined;
        // Before counting further elements:
        state.elementIndex = before.count;
        state.typeIndex = name ? before.types.get(name) || 0 : 0;
        // After counting all elements.
        state.elementCount = total.count;
        state.typeCount = name ? total.types.get(name) : 0;
        // Only apply if this is a parent, this should be an element, but we check
        // for parents so that we delve into custom nodes too.
        if ("children" in child) {
            const forSibling = $daa884ef28a3b3e1$var$combine(fromParent, fromSibling);
            const nest = $daa884ef28a3b3e1$var$one(state, forSibling, node.children[index], index, node);
            fromSibling = $daa884ef28a3b3e1$var$combine(nest.generalSibling, nest.adjacentSibling);
        }
        // We found one thing, and one is enough.
        if (state.one && state.found) break;
        $daa884ef28a3b3e1$var$count(before, node.children[index]);
    }
}
/**
 * Apply selectors to an element.
 *
 * @param {SelectState} state
 *   Current state.
 * @param {Array<RuleSet>} rules
 *   Rules to apply.
 * @param {Element} node
 *   Element to apply rules to.
 * @param {number | undefined} index
 *   Index of node in parent.
 * @param {Parent | undefined} parent
 *   Parent of node.
 * @returns {Nest}
 *   Further rules.
 */ function $daa884ef28a3b3e1$var$applySelectors(state, rules, node, index, parent) {
    /** @type {Nest} */ const nestResult = {
        directChild: undefined,
        descendant: undefined,
        adjacentSibling: undefined,
        generalSibling: undefined
    };
    let selectorIndex = -1;
    while(++selectorIndex < rules.length){
        const ruleSet = rules[selectorIndex];
        // We found one thing, and one is enough.
        if (state.one && state.found) break;
        // When shallow, we don’t allow nested rules.
        // Idea: we could allow a stack of parents?
        // Might get quite complex though.
        if (state.shallow && ruleSet.rule.rule) throw new Error("Expected selector without nesting");
        // If this rule matches:
        if ((0, $3dcbe92ace153305$export$e0969da9b8fb378d)(ruleSet.rule, node, index, parent, state)) {
            const nest = ruleSet.rule.rule;
            // Are there more?
            if (nest) {
                /** @type {RuleSet} */ const rule = {
                    type: "ruleSet",
                    rule: nest
                };
                /** @type {keyof Nest} */ const label = nest.nestingOperator === "+" ? "adjacentSibling" : nest.nestingOperator === "~" ? "generalSibling" : nest.nestingOperator === ">" ? "directChild" : "descendant";
                $daa884ef28a3b3e1$var$add(nestResult, label, rule);
            } else {
                // We have a match!
                state.found = true;
                if (!state.results.includes(node)) state.results.push(node);
            }
        }
        // Descendant.
        if (ruleSet.rule.nestingOperator === null) $daa884ef28a3b3e1$var$add(nestResult, "descendant", ruleSet);
        else if (ruleSet.rule.nestingOperator === "~") $daa884ef28a3b3e1$var$add(nestResult, "generalSibling", ruleSet);
    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).
    }
    return nestResult;
}
/**
 * Combine two lists, if needed.
 *
 * This is optimized to create as few lists as possible.
 *
 * @param {Array<RuleSet> | undefined} left
 * @param {Array<RuleSet> | undefined} right
 * @returns {Array<RuleSet>}
 */ function $daa884ef28a3b3e1$var$combine(left, right) {
    return left && right && left.length > 0 && right.length > 0 ? [
        ...left,
        ...right
    ] : left && left.length > 0 ? left : right && right.length > 0 ? right : $daa884ef28a3b3e1$var$empty;
}
/**
 * Add a rule to a nesting map.
 *
 * @param {Nest} nest
 * @param {keyof Nest} field
 * @param {RuleSet} rule
 */ function $daa884ef28a3b3e1$var$add(nest, field, rule) {
    const list = nest[field];
    if (list) list.push(rule);
    else nest[field] = [
        rule
    ];
}
/**
 * Count a node.
 *
 * @param {Counts} counts
 *   Counts.
 * @param {Node} node
 *   Node (we’re looking for elements).
 * @returns {void}
 *   Nothing.
 */ function $daa884ef28a3b3e1$var$count(counts, node) {
    if (node.type === "element") {
        // Uppercase to prevent prototype polution, injecting `constructor` or so.
        // Normalize because HTML is insensitive.
        const name = node.tagName.toUpperCase();
        const count = (counts.types.get(name) || 0) + 1;
        counts.count++;
        counts.types.set(name, count);
    }
}


/**
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').RuleSet} RuleSet
 */ var $79ed8fe42e9b8cf0$exports = {};
"use strict";
Object.defineProperty($79ed8fe42e9b8cf0$exports, "__esModule", {
    value: true
});
var $617dad7234ad1cf3$exports = {};
"use strict";
Object.defineProperty($617dad7234ad1cf3$exports, "__esModule", {
    value: true
});
var $92e3dae750c8c1f1$exports = {};
"use strict";
Object.defineProperty($92e3dae750c8c1f1$exports, "__esModule", {
    value: true
});
function $92e3dae750c8c1f1$var$isIdentStart(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_";
}
$92e3dae750c8c1f1$exports.isIdentStart = $92e3dae750c8c1f1$var$isIdentStart;
function $92e3dae750c8c1f1$var$isIdent(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_";
}
$92e3dae750c8c1f1$exports.isIdent = $92e3dae750c8c1f1$var$isIdent;
function $92e3dae750c8c1f1$var$isHex(c) {
    return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
$92e3dae750c8c1f1$exports.isHex = $92e3dae750c8c1f1$var$isHex;
function $92e3dae750c8c1f1$var$escapeIdentifier(s) {
    var len = s.length;
    var result = "";
    var i = 0;
    while(i < len){
        var chr = s.charAt(i);
        if ($92e3dae750c8c1f1$exports.identSpecialChars[chr]) result += "\\" + chr;
        else if (!(chr === "_" || chr === "-" || chr >= "A" && chr <= "Z" || chr >= "a" && chr <= "z" || i !== 0 && chr >= "0" && chr <= "9")) {
            var charCode = chr.charCodeAt(0);
            if ((charCode & 0xF800) === 0xD800) {
                var extraCharCode = s.charCodeAt(i++);
                if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) throw Error("UCS-2(decode): illegal sequence");
                charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
            }
            result += "\\" + charCode.toString(16) + " ";
        } else result += chr;
        i++;
    }
    return result;
}
$92e3dae750c8c1f1$exports.escapeIdentifier = $92e3dae750c8c1f1$var$escapeIdentifier;
function $92e3dae750c8c1f1$var$escapeStr(s) {
    var len = s.length;
    var result = "";
    var i = 0;
    var replacement;
    while(i < len){
        var chr = s.charAt(i);
        if (chr === '"') chr = '\\"';
        else if (chr === "\\") chr = "\\\\";
        else if ((replacement = $92e3dae750c8c1f1$exports.strReplacementsRev[chr]) !== undefined) chr = replacement;
        result += chr;
        i++;
    }
    return '"' + result + '"';
}
$92e3dae750c8c1f1$exports.escapeStr = $92e3dae750c8c1f1$var$escapeStr;
$92e3dae750c8c1f1$exports.identSpecialChars = {
    "!": true,
    '"': true,
    "#": true,
    "$": true,
    "%": true,
    "&": true,
    "'": true,
    "(": true,
    ")": true,
    "*": true,
    "+": true,
    ",": true,
    ".": true,
    "/": true,
    ";": true,
    "<": true,
    "=": true,
    ">": true,
    "?": true,
    "@": true,
    "[": true,
    "\\": true,
    "]": true,
    "^": true,
    "`": true,
    "{": true,
    "|": true,
    "}": true,
    "~": true
};
$92e3dae750c8c1f1$exports.strReplacementsRev = {
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\f": "\\f",
    "\v": "\\v"
};
$92e3dae750c8c1f1$exports.singleQuoteEscapeChars = {
    n: "\n",
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    "'": "'"
};
$92e3dae750c8c1f1$exports.doubleQuotesEscapeChars = {
    n: "\n",
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    '"': '"'
};


function $617dad7234ad1cf3$var$parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
    var l = str.length;
    var chr = "";
    function getStr(quote, escapeTable) {
        var result = "";
        pos++;
        chr = str.charAt(pos);
        while(pos < l){
            if (chr === quote) {
                pos++;
                return result;
            } else if (chr === "\\") {
                pos++;
                chr = str.charAt(pos);
                var esc = void 0;
                if (chr === quote) result += quote;
                else if ((esc = escapeTable[chr]) !== undefined) result += esc;
                else if ($92e3dae750c8c1f1$exports.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while($92e3dae750c8c1f1$exports.isHex(chr)){
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === " ") {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                } else result += chr;
            } else result += chr;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function getIdent() {
        var result = "";
        chr = str.charAt(pos);
        while(pos < l){
            if ($92e3dae750c8c1f1$exports.isIdent(chr)) result += chr;
            else if (chr === "\\") {
                pos++;
                if (pos >= l) throw Error("Expected symbol but end of file reached.");
                chr = str.charAt(pos);
                if ($92e3dae750c8c1f1$exports.identSpecialChars[chr]) result += chr;
                else if ($92e3dae750c8c1f1$exports.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while($92e3dae750c8c1f1$exports.isHex(chr)){
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === " ") {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                } else result += chr;
            } else return result;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function skipWhitespace() {
        chr = str.charAt(pos);
        var result = false;
        while(chr === " " || chr === "	" || chr === "\n" || chr === "\r" || chr === "\f"){
            result = true;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function parse() {
        var res = parseSelector();
        if (pos < l) throw Error('Rule expected but "' + str.charAt(pos) + '" found.');
        return res;
    }
    function parseSelector() {
        var selector = parseSingleSelector();
        if (!selector) return null;
        var res = selector;
        chr = str.charAt(pos);
        while(chr === ","){
            pos++;
            skipWhitespace();
            if (res.type !== "selectors") res = {
                type: "selectors",
                selectors: [
                    selector
                ]
            };
            selector = parseSingleSelector();
            if (!selector) throw Error('Rule expected after ",".');
            res.selectors.push(selector);
        }
        return res;
    }
    function parseSingleSelector() {
        skipWhitespace();
        var selector = {
            type: "ruleSet"
        };
        var rule = parseRule();
        if (!rule) return null;
        var currentRule = selector;
        while(rule){
            rule.type = "rule";
            currentRule.rule = rule;
            currentRule = rule;
            skipWhitespace();
            chr = str.charAt(pos);
            if (pos >= l || chr === "," || chr === ")") break;
            if (ruleNestingOperators[chr]) {
                var op = chr;
                pos++;
                skipWhitespace();
                rule = parseRule();
                if (!rule) throw Error('Rule expected after "' + op + '".');
                rule.nestingOperator = op;
            } else {
                rule = parseRule();
                if (rule) rule.nestingOperator = null;
            }
        }
        return selector;
    }
    // @ts-ignore no-overlap
    function parseRule() {
        var rule = null;
        while(pos < l){
            chr = str.charAt(pos);
            if (chr === "*") {
                pos++;
                (rule = rule || {}).tagName = "*";
            } else if ($92e3dae750c8c1f1$exports.isIdentStart(chr) || chr === "\\") (rule = rule || {}).tagName = getIdent();
            else if (chr === ".") {
                pos++;
                rule = rule || {};
                (rule.classNames = rule.classNames || []).push(getIdent());
            } else if (chr === "#") {
                pos++;
                (rule = rule || {}).id = getIdent();
            } else if (chr === "[") {
                pos++;
                skipWhitespace();
                var attr = {
                    name: getIdent()
                };
                skipWhitespace();
                // @ts-ignore
                if (chr === "]") pos++;
                else {
                    var operator = "";
                    if (attrEqualityMods[chr]) {
                        operator = chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (pos >= l) throw Error('Expected "=" but end of file reached.');
                    if (chr !== "=") throw Error('Expected "=" but "' + chr + '" found.');
                    attr.operator = operator + "=";
                    pos++;
                    skipWhitespace();
                    var attrValue = "";
                    attr.valueType = "string";
                    // @ts-ignore
                    if (chr === '"') attrValue = getStr('"', $92e3dae750c8c1f1$exports.doubleQuotesEscapeChars);
                    else if (chr === "'") attrValue = getStr("'", $92e3dae750c8c1f1$exports.singleQuoteEscapeChars);
                    else if (substitutesEnabled && chr === "$") {
                        pos++;
                        attrValue = getIdent();
                        attr.valueType = "substitute";
                    } else {
                        while(pos < l){
                            if (chr === "]") break;
                            attrValue += chr;
                            pos++;
                            chr = str.charAt(pos);
                        }
                        attrValue = attrValue.trim();
                    }
                    skipWhitespace();
                    if (pos >= l) throw Error('Expected "]" but end of file reached.');
                    if (chr !== "]") throw Error('Expected "]" but "' + chr + '" found.');
                    pos++;
                    attr.value = attrValue;
                }
                rule = rule || {};
                (rule.attrs = rule.attrs || []).push(attr);
            } else if (chr === ":") {
                pos++;
                var pseudoName = getIdent();
                var pseudo = {
                    name: pseudoName
                };
                // @ts-ignore
                if (chr === "(") {
                    pos++;
                    var value = "";
                    skipWhitespace();
                    if (pseudos[pseudoName] === "selector") {
                        pseudo.valueType = "selector";
                        value = parseSelector();
                    } else {
                        pseudo.valueType = pseudos[pseudoName] || "string";
                        // @ts-ignore
                        if (chr === '"') value = getStr('"', $92e3dae750c8c1f1$exports.doubleQuotesEscapeChars);
                        else if (chr === "'") value = getStr("'", $92e3dae750c8c1f1$exports.singleQuoteEscapeChars);
                        else if (substitutesEnabled && chr === "$") {
                            pos++;
                            value = getIdent();
                            pseudo.valueType = "substitute";
                        } else {
                            while(pos < l){
                                if (chr === ")") break;
                                value += chr;
                                pos++;
                                chr = str.charAt(pos);
                            }
                            value = value.trim();
                        }
                        skipWhitespace();
                    }
                    if (pos >= l) throw Error('Expected ")" but end of file reached.');
                    if (chr !== ")") throw Error('Expected ")" but "' + chr + '" found.');
                    pos++;
                    pseudo.value = value;
                }
                rule = rule || {};
                (rule.pseudos = rule.pseudos || []).push(pseudo);
            } else break;
        }
        return rule;
    }
    return parse();
}
$617dad7234ad1cf3$exports.parseCssSelector = $617dad7234ad1cf3$var$parseCssSelector;


var $f5d92bef1bc337ec$exports = {};
"use strict";
Object.defineProperty($f5d92bef1bc337ec$exports, "__esModule", {
    value: true
});

function $f5d92bef1bc337ec$var$renderEntity(entity) {
    var res = "";
    switch(entity.type){
        case "ruleSet":
            var currentEntity = entity.rule;
            var parts = [];
            while(currentEntity){
                if (currentEntity.nestingOperator) parts.push(currentEntity.nestingOperator);
                parts.push($f5d92bef1bc337ec$var$renderEntity(currentEntity));
                currentEntity = currentEntity.rule;
            }
            res = parts.join(" ");
            break;
        case "selectors":
            res = entity.selectors.map($f5d92bef1bc337ec$var$renderEntity).join(", ");
            break;
        case "rule":
            if (entity.tagName) {
                if (entity.tagName === "*") res = "*";
                else res = $92e3dae750c8c1f1$exports.escapeIdentifier(entity.tagName);
            }
            if (entity.id) res += "#" + $92e3dae750c8c1f1$exports.escapeIdentifier(entity.id);
            if (entity.classNames) res += entity.classNames.map(function(cn) {
                return "." + $92e3dae750c8c1f1$exports.escapeIdentifier(cn);
            }).join("");
            if (entity.attrs) res += entity.attrs.map(function(attr) {
                if ("operator" in attr) {
                    if (attr.valueType === "substitute") return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + attr.operator + "$" + attr.value + "]";
                    else return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + attr.operator + $92e3dae750c8c1f1$exports.escapeStr(attr.value) + "]";
                } else return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + "]";
            }).join("");
            if (entity.pseudos) res += entity.pseudos.map(function(pseudo) {
                if (pseudo.valueType) {
                    if (pseudo.valueType === "selector") return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + $f5d92bef1bc337ec$var$renderEntity(pseudo.value) + ")";
                    else if (pseudo.valueType === "substitute") return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "($" + pseudo.value + ")";
                    else if (pseudo.valueType === "numeric") return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + pseudo.value + ")";
                    else return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.value) + ")";
                } else return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name);
            }).join("");
            break;
        default:
            throw Error('Unknown entity type: "' + entity.type + '".');
    }
    return res;
}
$f5d92bef1bc337ec$exports.renderEntity = $f5d92bef1bc337ec$var$renderEntity;


var $79ed8fe42e9b8cf0$var$CssSelectorParser = /** @class */ function() {
    function CssSelectorParser() {
        this.pseudos = {};
        this.attrEqualityMods = {};
        this.ruleNestingOperators = {};
        this.substitutesEnabled = false;
    }
    CssSelectorParser.prototype.registerSelectorPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++){
            var pseudo = pseudos_1[_a];
            this.pseudos[pseudo] = "selector";
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterSelectorPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++){
            var pseudo = pseudos_2[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNumericPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++){
            var pseudo = pseudos_3[_a];
            this.pseudos[pseudo] = "numeric";
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNumericPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++){
            var pseudo = pseudos_4[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNestingOperators = function() {
        var operators = [];
        for(var _i = 0; _i < arguments.length; _i++)operators[_i] = arguments[_i];
        for(var _a = 0, operators_1 = operators; _a < operators_1.length; _a++){
            var operator = operators_1[_a];
            this.ruleNestingOperators[operator] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNestingOperators = function() {
        var operators = [];
        for(var _i = 0; _i < arguments.length; _i++)operators[_i] = arguments[_i];
        for(var _a = 0, operators_2 = operators; _a < operators_2.length; _a++){
            var operator = operators_2[_a];
            delete this.ruleNestingOperators[operator];
        }
        return this;
    };
    CssSelectorParser.prototype.registerAttrEqualityMods = function() {
        var mods = [];
        for(var _i = 0; _i < arguments.length; _i++)mods[_i] = arguments[_i];
        for(var _a = 0, mods_1 = mods; _a < mods_1.length; _a++){
            var mod = mods_1[_a];
            this.attrEqualityMods[mod] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterAttrEqualityMods = function() {
        var mods = [];
        for(var _i = 0; _i < arguments.length; _i++)mods[_i] = arguments[_i];
        for(var _a = 0, mods_2 = mods; _a < mods_2.length; _a++){
            var mod = mods_2[_a];
            delete this.attrEqualityMods[mod];
        }
        return this;
    };
    CssSelectorParser.prototype.enableSubstitutes = function() {
        this.substitutesEnabled = true;
        return this;
    };
    CssSelectorParser.prototype.disableSubstitutes = function() {
        this.substitutesEnabled = false;
        return this;
    };
    CssSelectorParser.prototype.parse = function(str) {
        return $617dad7234ad1cf3$exports.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    };
    CssSelectorParser.prototype.render = function(path) {
        return $f5d92bef1bc337ec$exports.renderEntity(path).trim();
    };
    return CssSelectorParser;
}();
$79ed8fe42e9b8cf0$exports.CssSelectorParser = $79ed8fe42e9b8cf0$var$CssSelectorParser;


const $1313968c046283b7$var$parser = new (0, $79ed8fe42e9b8cf0$exports.CssSelectorParser)();
$1313968c046283b7$var$parser.registerAttrEqualityMods("~", "|", "^", "$", "*");
$1313968c046283b7$var$parser.registerSelectorPseudos("any", "matches", "not", "has");
$1313968c046283b7$var$parser.registerNestingOperators(">", "+", "~");
function $1313968c046283b7$export$98e6a39c04603d36(selector) {
    if (typeof selector !== "string") throw new TypeError("Expected `string` as selector, not `" + selector + "`");
    return $1313968c046283b7$var$parser.parse(selector);
}


function $3c8bc001a91ed78a$export$de994efd351b291c(selector, node, space) {
    const state = $3c8bc001a91ed78a$var$createState(selector, node, space);
    state.one = true;
    state.shallow = true;
    (0, $daa884ef28a3b3e1$export$588732934346abbf)(state, node || undefined);
    return state.results.length > 0;
}
function $3c8bc001a91ed78a$export$2e6c959c16ff56b8(selector, tree, space) {
    const state = $3c8bc001a91ed78a$var$createState(selector, tree, space);
    state.one = true;
    (0, $daa884ef28a3b3e1$export$588732934346abbf)(state, tree || undefined);
    // To do in major: return `undefined` instead.
    return state.results[0] || null;
}
function $3c8bc001a91ed78a$export$90aca4adda6ff0f5(selector, tree, space) {
    const state = $3c8bc001a91ed78a$var$createState(selector, tree, space);
    (0, $daa884ef28a3b3e1$export$588732934346abbf)(state, tree || undefined);
    return state.results;
}
/**
 * @param {string} selector
 *   Tree to search.
 * @param {Node | null | undefined} [tree]
 *   Tree to search.
 * @param {Space | null | undefined} [space='html']
 *   Name of namespace (`'svg'` or `'html'`).
 * @returns {SelectState} SelectState
 */ function $3c8bc001a91ed78a$var$createState(selector, tree, space) {
    return {
        // State of the query.
        rootQuery: (0, $daa884ef28a3b3e1$export$9141434d8c079e66)((0, $1313968c046283b7$export$98e6a39c04603d36)(selector)),
        results: [],
        // @ts-expect-error assume elements.
        scopeElements: tree ? tree.type === "root" ? tree.children : [
            tree
        ] : [],
        one: false,
        shallow: false,
        found: false,
        // State in the tree.
        schema: space === "svg" ? (0, $7798a5acf5615526$export$7ed1367e7fa1ad68) : (0, $7798a5acf5615526$export$c0bb0b647f701bb5),
        language: undefined,
        direction: "ltr",
        editableOrEditingHost: false,
        typeIndex: undefined,
        elementIndex: undefined,
        typeCount: undefined,
        elementCount: undefined
    };
}




const { selectAll: $283f418c0f57366a$var$selectAll } = $eb0fced0eff13ef9$exports;
$283f418c0f57366a$exports = (additions)=>{
    const adders = Object.entries(additions).map($283f418c0f57366a$var$adder);
    return (node)=>adders.forEach((a)=>a(node));
};
const $283f418c0f57366a$var$adder = ([selector, className])=>{
    const writer = $283f418c0f57366a$var$write(className);
    return (node)=>$283f418c0f57366a$var$selectAll(selector, node).forEach(writer);
};
const $283f418c0f57366a$var$write = (className)=>{
    return ({ properties: properties })=>{
        if (!properties.className) properties.className = className;
        else properties.className += ` ${className}`;
    };
};


var $01baaa270549c889$exports = {};
/**
 * @type {(componentDevelopmentMode: boolean) => import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ 
$01baaa270549c889$exports = ()=>{
    /**
	 * This ensures that we don't read ./handle-og.svelte more than once
	 * @type {string}
	 */ let handleOgContent;
    return {
        markup: ({ content: content, filename: filename })=>{
            if (typeof filename === "undefined") return;
            if (!filename.endsWith("+page.md")) return;
            if (!handleOgContent) handleOgContent = (parcelRequire("6PNpJ"));
            return {
                code: handleOgContent + content
            };
        },
        script: ({ content: content, filename: filename, attributes: attributes })=>{
            if (typeof filename === "undefined") return;
            if (attributes.context !== "module") return;
            if (!filename.endsWith("+page.md")) return;
            if (!content.includes("export const metadata =")) // There is no frontmatter, and we want to make sure that it as at least defined.
            // Technically this won't _break_ things, just spam the logs with a vite warning.
            return {
                code: content + ";const metadata = undefined;"
            };
            else // exporting makes tailwind break HMR
            return {
                code: content.replace("export const metadata =", "const metadata =")
            };
        }
    };
};


var $b3bc6995532c53ea$exports = {};


/**
 * @param {string} originalString
 * @returns {string}
 */ function $b3bc6995532c53ea$var$injectPartials(originalString) {
    const r = /\{@partial\s+"(.*?)"\s*\}/g;
    for (const match of originalString.matchAll(r) ?? []){
        const filename = match[1];
        // There is an error with parcel that prevents the use of the "path" library.
        const content = $4S4dR$readFileSync(`./partials/${filename}`).toString();
        originalString = originalString.replace(match[0], content);
    }
    return originalString;
}
$b3bc6995532c53ea$exports = {
    markup: ({ content: content, filename: filename })=>{
        if (typeof filename === "undefined") return;
        if (!filename.endsWith("+page.md")) return;
        return {
            code: $b3bc6995532c53ea$var$injectPartials(content)
        };
    },
    injectPartials: $b3bc6995532c53ea$var$injectPartials
};


$3fd82c6737eb24ad$exports = function evidencePreprocess(componentDevelopmentMode = false) {
    return [
        $b3bc6995532c53ea$exports,
        $bb8aaf4d81463a1b$exports(componentDevelopmentMode),
        $560639d49e3c9a19$export$d61cf7a1924293cc({
            extensions: [
                ".md"
            ],
            smartypants: {
                quotes: false,
                ellipses: true,
                backticks: true,
                dashes: "oldschool"
            },
            highlight: {
                highlighter: $3fd82c6737eb24ad$require$highlighter
            },
            rehypePlugins: [
                [
                    $283f418c0f57366a$exports,
                    {
                        "*": "markdown"
                    }
                ]
            ]
        }),
        // Add both script tags to all markdown files, if they are missing
        $7d9f7d1f69c18b39$exports,
        $01baaa270549c889$exports()
    ];
};

$3fd82c6737eb24ad$exports.parseFrontmatter = (parcelRequire("ljm8s")).parseFrontmatter;

$3fd82c6737eb24ad$exports.extractQueries = $3bc517d55346f2bb$exports.extractQueries;
$3fd82c6737eb24ad$exports.getQueryIds = $3bc517d55346f2bb$exports.getQueryIds;
$3fd82c6737eb24ad$exports.injectPartials = $b3bc6995532c53ea$exports.injectPartials;


export {$3fd82c6737eb24ad$exports as default};
