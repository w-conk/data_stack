/* tslint:disable */
/* eslint-disable */
/**
* Read a Parquet file into Arrow data using the [`arrow2`](https://crates.io/crates/arrow2) and
* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.
*
* This returns an Arrow table in WebAssembly memory. To transfer the Arrow table to JavaScript
* memory you have two options:
*
* - (Easier): Call {@linkcode Table.intoIPCStream} to construct a buffer that can be parsed with
*   Arrow JS's `tableFromIPC` function.
* - (More performant but bleeding edge): Call {@linkcode Table.intoFFI} to construct a data
*   representation that can be parsed zero-copy from WebAssembly with
*   [arrow-js-ffi](https://github.com/kylebarron/arrow-js-ffi).
*
* Example:
*
* ```js
* import { tableFromIPC } from "apache-arrow";
* // Edit the `parquet-wasm` import as necessary
* import { readParquet } from "parquet-wasm/node/arrow2";
*
* const resp = await fetch("https://example.com/file.parquet");
* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());
* const arrowWasmTable = readParquet(parquetUint8Array);
* const arrowTable = tableFromIPC(arrowWasmTable.intoIPCStream());
* ```
*
* @param parquet_file Uint8Array containing Parquet data
* @param {Uint8Array} parquet_file
* @returns {Table}
*/
export function readParquet(parquet_file: Uint8Array): Table;
/**
* Read metadata from a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and
* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.
*
* Example:
*
* ```js
* // Edit the `parquet-wasm` import as necessary
* import { readMetadata } from "parquet-wasm/node/arrow2";
*
* const resp = await fetch("https://example.com/file.parquet");
* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());
* const parquetFileMetaData = readMetadata(parquetUint8Array);
* ```
*
* @param parquet_file Uint8Array containing Parquet data
* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.
* @param {Uint8Array} parquet_file
* @returns {FileMetaData}
*/
export function readMetadata(parquet_file: Uint8Array): FileMetaData;
/**
* Read a single row group from a Parquet file into Arrow data using the
* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)
* Rust crates.
*
* This returns an Arrow record batch in WebAssembly memory. To transfer the Arrow record batch to
* JavaScript memory you have two options:
*
* - (Easier): Call {@linkcode RecordBatch.intoIPCStream} to construct a buffer that can be parsed
*   with Arrow JS's `tableFromIPC` function.
* - (More performant but bleeding edge): Call {@linkcode RecordBatch.intoFFI} to construct a data
*   representation that can be parsed zero-copy from WebAssembly with
*   [arrow-js-ffi](https://github.com/kylebarron/arrow-js-ffi).
*
* Example:
*
* ```js
* import { tableFromIPC } from "apache-arrow";
* // Edit the `parquet-wasm` import as necessary
* import { readRowGroup, readMetadata } from "parquet-wasm/node/arrow2";
*
* const resp = await fetch("https://example.com/file.parquet");
* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());
* const parquetFileMetaData = readMetadata(parquetUint8Array);
*
* const arrowSchema = parquetFileMetaData.arrowSchema();
* // Read only the first row group
* const parquetRowGroupMeta = parquetFileMetaData.rowGroup(0);
*
* // Read only the first row group
* const arrowWasmBatch = readRowGroup(
*   parquetUint8Array,
*   arrowSchema,
*   parquetRowGroupMeta
* );
* const arrowJsTable = tableFromIPC(arrowWasmBatch.intoIPCStream());
* // This table will only have one batch
* const arrowJsRecordBatch = arrowJsTable.batches[0];
* ```
*
* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}
*
* @param parquet_file Uint8Array containing Parquet data
* @param schema Use {@linkcode FileMetaData.arrowSchema} to create.
* @param meta {@linkcode RowGroupMetaData} from a call to {@linkcode readMetadata}
* @param {Uint8Array} parquet_file
* @param {ArrowSchema} schema
* @param {RowGroupMetaData} meta
* @returns {RecordBatch}
*/
export function readRowGroup(parquet_file: Uint8Array, schema: ArrowSchema, meta: RowGroupMetaData): RecordBatch;
/**
* Asynchronously read metadata from a Parquet file using the
* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)
* Rust crates.
*
* For now, this requires knowing the content length of the file, but hopefully this will be
* relaxed in the future. If you don't know the contentLength of the file, this will perform a
* HEAD request to do so.
*
* Example:
*
* ```js
* // Edit the `parquet-wasm` import as necessary
* import { readMetadataAsync } from "parquet-wasm";
*
* const parquetFileMetaData = await readMetadataAsync(url, contentLength);
* ```
*
* @param url String location of remote Parquet file containing Parquet data
* @param content_length Number content length of file in bytes
* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.
* @param {string} url
* @param {number | undefined} content_length
* @returns {Promise<FileMetaData>}
*/
export function readMetadataAsync(url: string, content_length?: number): Promise<FileMetaData>;
/**
* Asynchronously read a single row group from a Parquet file into Arrow data using the
* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)
* Rust crates.
*
* Example:
*
* ```ts
* import * as arrowJs from "apache-arrow";
* // Edit the `parquet-wasm` import as necessary
* import {
*   readRowGroupAsync,
*   readMetadataAsync,
*   RecordBatch,
* } from "parquet-wasm/node/arrow2";
*
* const url = "https://example.com/file.parquet";
* const headResp = await fetch(url, { method: "HEAD" });
* const length = parseInt(headResp.headers.get("Content-Length"));
*
* const parquetFileMetaData = await readMetadataAsync(url, length);
* const arrowSchema = parquetFileMetaData.arrowSchema();
*
* // Read all batches from the file in parallel
* const promises: Promise<RecordBatch>[] = [];
* for (let i = 0; i < parquetFileMetaData.numRowGroups(); i++) {
*   const rowGroupMeta = parquetFileMetaData.rowGroup(i);
*   const rowGroupPromise = readRowGroupAsync(url, rowGroupMeta, arrowSchema);
*   promises.push(rowGroupPromise);
* }
*
* // Collect the per-batch requests
* const wasmRecordBatchChunks = await Promise.all(promises);
*
* // Parse the wasm record batches into JS record batches
* const jsRecordBatchChunks: arrowJs.RecordBatch[] = [];
* for (const wasmRecordBatch of wasmRecordBatchChunks) {
*   const arrowJsTable = arrowJs.tableFromIPC(wasmRecordBatch.intoIPCStream());
*   // This should never throw
*   if (arrowJsTable.batches.length > 1) throw new Error();
*   const arrowJsRecordBatch = arrowJsTable.batches[0];
*   jsRecordBatchChunks.push(arrowJsRecordBatch);
* }
*
* // Concatenate the JS record batches into a table
* const jsTable = new arrowJs.Table(recordBatchChunks);
* ```
*
* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}
*
* @param url String location of remote Parquet file containing Parquet data
* @param schema Use {@linkcode FileMetaData.arrowSchema} to create.
* @param meta {@linkcode RowGroupMetaData} from a call to {@linkcode readMetadataAsync}
* @param {string} url
* @param {RowGroupMetaData} row_group_meta
* @param {ArrowSchema} arrow_schema
* @returns {Promise<RecordBatch>}
*/
export function readRowGroupAsync(url: string, row_group_meta: RowGroupMetaData, arrow_schema: ArrowSchema): Promise<RecordBatch>;
/**
* Write Arrow data to a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and
* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.
*
* For example, to create a Parquet file with Snappy compression:
*
* ```js
* import { tableToIPC } from "apache-arrow";
* // Edit the `parquet-wasm` import as necessary
* import {
*   Table,
*   WriterPropertiesBuilder,
*   Compression,
*   writeParquet,
* } from "parquet-wasm/node/arrow2";
*
* // Given an existing arrow JS table under `table`
* const wasmTable = Table.fromIPCStream(tableToIPC(table, "stream"));
* const writerProperties = new WriterPropertiesBuilder()
*   .setCompression(Compression.SNAPPY)
*   .build();
* const parquetUint8Array = writeParquet(wasmTable, writerProperties);
* ```
*
* If `writerProperties` is not provided or is `null`, the default writer properties will be used.
* This is equivalent to `new WriterPropertiesBuilder().build()`.
*
* @param table A {@linkcode Table} representation in WebAssembly memory.
* @param writer_properties (optional) Configuration for writing to Parquet. Use the {@linkcode
*   WriterPropertiesBuilder} to build a writing configuration, then call `.build()` to create an
*   immutable writer properties to pass in here.
* @returns Uint8Array containing written Parquet data.
* @param {Table} table
* @param {WriterProperties | undefined} writer_properties
* @returns {Uint8Array}
*/
export function writeParquet(table: Table, writer_properties?: WriterProperties): Uint8Array;
/**
* @param {string} url
* @returns {Promise<ReadableStream>}
*/
export function readParquetStream(url: string): Promise<ReadableStream>;
/**
* Returns a handle to this wasm instance's `WebAssembly.Memory`
* @returns {any}
*/
export function wasmMemory(): any;
/**
* Returns a handle to this wasm instance's `WebAssembly.Table` which is the indirect function
* table used by Rust
* @returns {any}
*/
export function _functionTable(): any;
/**
* Supported compression algorithms.
*
* Codecs added in format version X.Y can be read by readers based on X.Y and later.
* Codec support may vary between readers based on the format version and
* libraries available at runtime.
*/
export enum Compression {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  BROTLI = 3,
/**
* @deprecated as of Parquet 2.9.0.
* Switch to LZ4_RAW
*/
  LZ4 = 4,
  ZSTD = 5,
  LZ4_RAW = 6,
}
/**
* Encodings supported by Parquet.
* Not all encodings are valid for all types. These enums are also used to specify the
* encoding of definition and repetition levels.
*/
export enum Encoding {
/**
* Default byte encoding.
* - BOOLEAN - 1 bit per value, 0 is false; 1 is true.
* - INT32 - 4 bytes per value, stored as little-endian.
* - INT64 - 8 bytes per value, stored as little-endian.
* - FLOAT - 4 bytes per value, stored as little-endian.
* - DOUBLE - 8 bytes per value, stored as little-endian.
* - BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
* - FIXED_LEN_BYTE_ARRAY - just the bytes are stored.
*/
  PLAIN = 0,
/**
* **Deprecated** dictionary encoding.
*
* The values in the dictionary are encoded using PLAIN encoding.
* Since it is deprecated, RLE_DICTIONARY encoding is used for a data page, and
* PLAIN encoding is used for dictionary page.
*/
  PLAIN_DICTIONARY = 1,
/**
* Group packed run length encoding.
*
* Usable for definition/repetition levels encoding and boolean values.
*/
  RLE = 2,
/**
* Bit packed encoding.
*
* This can only be used if the data has a known max width.
* Usable for definition/repetition levels encoding.
*/
  BIT_PACKED = 3,
/**
* Delta encoding for integers, either INT32 or INT64.
*
* Works best on sorted data.
*/
  DELTA_BINARY_PACKED = 4,
/**
* Encoding for byte arrays to separate the length values and the data.
*
* The lengths are encoded using DELTA_BINARY_PACKED encoding.
*/
  DELTA_LENGTH_BYTE_ARRAY = 5,
/**
* Incremental encoding for byte arrays.
*
* Prefix lengths are encoded using DELTA_BINARY_PACKED encoding.
* Suffixes are stored using DELTA_LENGTH_BYTE_ARRAY encoding.
*/
  DELTA_BYTE_ARRAY = 6,
/**
* Dictionary encoding.
*
* The ids are encoded using the RLE encoding.
*/
  RLE_DICTIONARY = 7,
/**
* Encoding for floating-point data.
*
* K byte-streams are created where K is the size in bytes of the data type.
* The individual bytes of an FP value are scattered to the corresponding stream and
* the streams are concatenated.
* This itself does not reduce the size of the data but can lead to better compression
* afterwards.
*/
  BYTE_STREAM_SPLIT = 8,
}
/**
* The Parquet version to use when writing
*/
export enum WriterVersion {
  V1 = 0,
  V2 = 1,
}
/**
* Arrow Schema representing a Parquet file.
*/
export class ArrowSchema {
  free(): void;
/**
* Clone this struct in wasm memory.
* @returns {ArrowSchema}
*/
  copy(): ArrowSchema;
}
/**
* Metadata for a column chunk.
*/
export class ColumnChunkMetaData {
  free(): void;
/**
* File where the column chunk is stored.
*
* If not set, assumed to belong to the same file as the metadata.
* This path is relative to the current file.
* @returns {string | undefined}
*/
  filePath(): string | undefined;
/**
* Byte offset in `file_path()`.
* @returns {bigint}
*/
  fileOffset(): bigint;
/**
* @returns {string}
*/
  pathInSchema(): string;
/**
* @returns {boolean}
*/
  statistics_exist(): boolean;
/**
* @returns {any}
*/
  getStatisticsMinValue(): any;
/**
* @returns {any}
*/
  getStatisticsMaxValue(): any;
/**
* @returns {any}
*/
  getStatisticsNullCount(): any;
/**
* Total number of values in this column chunk. Note that this is not necessarily the number
* of rows. E.g. the (nested) array `[[1, 2], [3]]` has 2 rows and 3 values.
* @returns {bigint}
*/
  numValues(): bigint;
/**
* Returns the total compressed data size of this column chunk.
* @returns {bigint}
*/
  compressedSize(): bigint;
/**
* Returns the total uncompressed data size of this column chunk.
* @returns {bigint}
*/
  uncompressedSize(): bigint;
/**
* Returns the offset for the column data.
* @returns {bigint}
*/
  dataPageOffset(): bigint;
/**
* Returns `true` if this column chunk contains a index page, `false` otherwise.
* @returns {boolean}
*/
  hasIndexPage(): boolean;
/**
* Returns the offset for the index page.
* @returns {bigint | undefined}
*/
  indexPageOffset(): bigint | undefined;
/**
* Returns the offset for the dictionary page, if any.
* @returns {bigint | undefined}
*/
  dictionaryPageOffset(): bigint | undefined;
/**
* Returns the number of encodings for this column
* @returns {number}
*/
  numColumnEncodings(): number;
/**
* Returns the offset and length in bytes of the column chunk within the file
* @returns {BigUint64Array}
*/
  byteRange(): BigUint64Array;
}
/**
* The set of supported logical types in this crate.
*/
export class DataType {
  free(): void;
}
/**
* A representation of an Arrow RecordBatch in WebAssembly memory exposed as FFI-compatible
* structs through the Arrow C Data Interface.
*/
export class FFIRecordBatch {
  free(): void;
/**
* Access the pointer to the
* [`ArrowArray`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)
* struct. This can be viewed or copied (without serialization) to an Arrow JS `RecordBatch` by
* using [`arrow-js-ffi`](https://github.com/kylebarron/arrow-js-ffi). You can access the
* [`WebAssembly.Memory`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)
* instance by using {@linkcode wasmMemory}.
*
* **Example**:
*
* ```ts
* import { parseRecordBatch } from "arrow-js-ffi";
*
* const wasmRecordBatch: FFIRecordBatch = ...
* const wasmMemory: WebAssembly.Memory = wasmMemory();
*
* // Pass `true` to copy arrays across the boundary instead of creating views.
* const jsRecordBatch = parseRecordBatch(
*   wasmMemory.buffer,
*   wasmRecordBatch.arrayAddr(),
*   wasmRecordBatch.schemaAddr(),
*   true
* );
* ```
* @returns {number}
*/
  arrayAddr(): number;
/**
* Access the pointer to the
* [`ArrowSchema`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)
* struct. This can be viewed or copied (without serialization) to an Arrow JS `Field` by
* using [`arrow-js-ffi`](https://github.com/kylebarron/arrow-js-ffi). You can access the
* [`WebAssembly.Memory`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)
* instance by using {@linkcode wasmMemory}.
*
* **Example**:
*
* ```ts
* import { parseRecordBatch } from "arrow-js-ffi";
*
* const wasmRecordBatch: FFIRecordBatch = ...
* const wasmMemory: WebAssembly.Memory = wasmMemory();
*
* // Pass `true` to copy arrays across the boundary instead of creating views.
* const jsRecordBatch = parseRecordBatch(
*   wasmMemory.buffer,
*   wasmRecordBatch.arrayAddr(),
*   wasmRecordBatch.schemaAddr(),
*   true
* );
* ```
* @returns {number}
*/
  schemaAddr(): number;
}
/**
* A representation of an Arrow Table in WebAssembly memory exposed as FFI-compatible
* structs through the Arrow C Data Interface.
*/
export class FFITable {
  free(): void;
/**
* Get the total number of record batches in the table
* @returns {number}
*/
  numBatches(): number;
/**
* Get the pointer to one ArrowSchema FFI struct
* @returns {number}
*/
  schemaAddr(): number;
/**
* Get the pointer to one ArrowArray FFI struct for a given chunk index and column index
*
* Access the pointer to one
* [`ArrowArray`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)
* struct representing one of the internal `RecordBatch`es. This can be viewed or copied (without serialization) to an Arrow JS `RecordBatch` by
* using [`arrow-js-ffi`](https://github.com/kylebarron/arrow-js-ffi). You can access the
* [`WebAssembly.Memory`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory)
* instance by using {@linkcode wasmMemory}.
*
* **Example**:
*
* ```ts
* import * as arrow from "apache-arrow";
* import { parseRecordBatch } from "arrow-js-ffi";
*
* const wasmTable: FFITable = ...
* const wasmMemory: WebAssembly.Memory = wasmMemory();
*
* const jsBatches: arrow.RecordBatch[] = []
* for (let i = 0; i < wasmTable.numBatches(); i++) {
*   // Pass `true` to copy arrays across the boundary instead of creating views.
*   const jsRecordBatch = parseRecordBatch(
*     wasmMemory.buffer,
*     wasmTable.arrayAddr(i),
*     wasmTable.schemaAddr(),
*     true
*   );
*   jsBatches.push(jsRecordBatch);
* }
* const jsTable = new arrow.Table(jsBatches);
* ```
*
* @param chunk number The chunk index to use
* @returns number pointer to an ArrowArray FFI struct in Wasm memory
* @param {number} chunk
* @returns {number}
*/
  arrayAddr(chunk: number): number;
/**
*/
  drop(): void;
}
/**
*/
export class FFIVector {
  free(): void;
/**
* @returns {number}
*/
  array_addr(): number;
/**
* @returns {number}
*/
  field_addr(): number;
}
/**
* Metadata for a Parquet file.
*/
export class FileMetaData {
  free(): void;
/**
* Clone this struct in wasm memory.
* @returns {FileMetaData}
*/
  copy(): FileMetaData;
/**
* Version of this file.
* @returns {number}
*/
  version(): number;
/**
* number of rows in the file.
* @returns {number}
*/
  numRows(): number;
/**
* String message for application that wrote this file.
* @returns {string | undefined}
*/
  createdBy(): string | undefined;
/**
* Number of row groups in the file
* @returns {number}
*/
  numRowGroups(): number;
/**
* Returns a single RowGroupMetaData by index
* @param {number} i
* @returns {RowGroupMetaData}
*/
  rowGroup(i: number): RowGroupMetaData;
/**
* @returns {SchemaDescriptor}
*/
  schema(): SchemaDescriptor;
/**
* @returns {any}
*/
  keyValueMetadata(): any;
/**
* @returns {ArrowSchema}
*/
  arrowSchema(): ArrowSchema;
}
/**
*/
export class IntoUnderlyingByteSource {
  free(): void;
/**
* @param {any} controller
*/
  start(controller: any): void;
/**
* @param {any} controller
* @returns {Promise<any>}
*/
  pull(controller: any): Promise<any>;
/**
*/
  cancel(): void;
/**
*/
  readonly autoAllocateChunkSize: number;
/**
*/
  readonly type: string;
}
/**
*/
export class IntoUnderlyingSink {
  free(): void;
/**
* @param {any} chunk
* @returns {Promise<any>}
*/
  write(chunk: any): Promise<any>;
/**
* @returns {Promise<any>}
*/
  close(): Promise<any>;
/**
* @param {any} reason
* @returns {Promise<any>}
*/
  abort(reason: any): Promise<any>;
}
/**
*/
export class IntoUnderlyingSource {
  free(): void;
/**
* @param {any} controller
* @returns {Promise<any>}
*/
  pull(controller: any): Promise<any>;
/**
*/
  cancel(): void;
}
/**
* Raw options for [`pipeTo()`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/pipeTo).
*/
export class PipeOptions {
  free(): void;
/**
*/
  readonly preventAbort: boolean;
/**
*/
  readonly preventCancel: boolean;
/**
*/
  readonly preventClose: boolean;
/**
*/
  readonly signal: AbortSignal | undefined;
}
/**
*/
export class QueuingStrategy {
  free(): void;
/**
*/
  readonly highWaterMark: number;
}
/**
* Raw options for [`getReader()`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/getReader).
*/
export class ReadableStreamGetReaderOptions {
  free(): void;
/**
*/
  readonly mode: any;
}
/**
* A group of columns of equal length in WebAssembly memory with an associated {@linkcode Schema}.
*/
export class RecordBatch {
  free(): void;
/**
* Get a column's vector by index.
* @param {number} index
* @returns {Vector | undefined}
*/
  column(index: number): Vector | undefined;
/**
* Get a column's vector by name
* @param {string} name
* @returns {Vector | undefined}
*/
  column_by_name(name: string): Vector | undefined;
/**
* Export this RecordBatch to FFI structs according to the Arrow C Data Interface.
*
* This method **does not consume** the RecordBatch, so you must remember to call {@linkcode
* RecordBatch.free} to release the resources. The underlying arrays are reference counted, so
* this method does not copy data, it only prevents the data from being released.
* @returns {FFIRecordBatch}
*/
  toFFI(): FFIRecordBatch;
/**
* Export this RecordBatch to FFI structs according to the Arrow C Data Interface.
*
* This method **does consume** the RecordBatch, so the original RecordBatch will be
* inaccessible after this call. You must still call {@linkcode FFIRecordBatch.free} after
* you've finished using the FFI table.
* @returns {FFIRecordBatch}
*/
  intoFFI(): FFIRecordBatch;
/**
* Consume this RecordBatch and convert to an Arrow IPC Stream buffer
* @returns {Uint8Array}
*/
  intoIPCStream(): Uint8Array;
/**
* The number of columns in this RecordBatch
*/
  readonly numColumns: number;
/**
* The number of rows in this RecordBatch
*/
  readonly numRows: number;
/**
* The {@linkcode Schema} of this RecordBatch.
*/
  readonly schema: Schema;
}
/**
* Metadata for a row group.
*/
export class RowGroupMetaData {
  free(): void;
/**
* Number of rows in this row group.
* @returns {number}
*/
  numRows(): number;
/**
* Number of columns in this row group.
* @returns {number}
*/
  numColumns(): number;
/**
* Returns a single column chunk metadata by index
* @param {number} i
* @returns {ColumnChunkMetaData}
*/
  column(i: number): ColumnChunkMetaData;
/**
* Total byte size of all uncompressed column data in this row group.
* @returns {number}
*/
  totalByteSize(): number;
/**
* Total size of all compressed column data in this row group.
* @returns {number}
*/
  compressedSize(): number;
}
/**
* A named collection of types that defines the column names and types in a RecordBatch or Table
* data structure.
*
* A Schema can also contain extra user-defined metadata either at the Table or Column level.
* Column-level metadata is often used to define [extension
* types](https://arrow.apache.org/docs/format/Columnar.html#extension-types).
*/
export class Schema {
  free(): void;
}
/**
* A schema descriptor. This encapsulates the top-level schemas for all the columns,
* as well as all descriptors for all the primitive columns.
*/
export class SchemaDescriptor {
  free(): void;
/**
* The schemas' name.
* @returns {string}
*/
  name(): string;
/**
* The number of columns in the schema
* @returns {number}
*/
  numColumns(): number;
/**
* The number of fields in the schema
* @returns {number}
*/
  numFields(): number;
}
/**
* A Table in WebAssembly memory conforming to the Apache Arrow spec.
*
* A Table consists of one or more {@linkcode RecordBatch} objects plus a {@linkcode Schema} that
* each RecordBatch conforms to.
*/
export class Table {
  free(): void;
/**
* Access a RecordBatch from the Table by index.
*
* @param index The positional index of the RecordBatch to retrieve.
* @returns a RecordBatch or `null` if out of range.
* @param {number} index
* @returns {RecordBatch | undefined}
*/
  recordBatch(index: number): RecordBatch | undefined;
/**
* Export this Table to FFI structs according to the Arrow C Data Interface.
*
* This method **does not consume** the Table, so you must remember to call {@linkcode
* Table.free} to release the resources. The underlying arrays are reference counted, so
* this method does not copy data, it only prevents the data from being released.
* @returns {FFITable}
*/
  toFFI(): FFITable;
/**
* Export this Table to FFI structs according to the Arrow C Data Interface.
*
* This method **does consume** the Table, so the original Table will be
* inaccessible after this call. You must still call {@linkcode FFITable.free} after
* you've finished using the FFITable.
* @returns {FFITable}
*/
  intoFFI(): FFITable;
/**
* Consume this table and convert to an Arrow IPC Stream buffer
* @returns {Uint8Array}
*/
  intoIPCStream(): Uint8Array;
/**
* Create a table from an Arrow IPC File buffer
* @param {Uint8Array} buf
* @returns {Table}
*/
  static fromIPCFile(buf: Uint8Array): Table;
/**
* Create a table from an Arrow IPC Stream buffer
* @param {Uint8Array} buf
* @returns {Table}
*/
  static fromIPCStream(buf: Uint8Array): Table;
/**
* The number of batches in the Table
*/
  readonly numBatches: number;
/**
* Access the Table's {@linkcode Schema}.
*/
  readonly schema: Schema;
}
/**
* An Arrow vector of unknown type that is guaranteed to have contiguous memory (i.e. cannot be
* chunked).
*/
export class Vector {
  free(): void;
/**
* The data type of this vector
* @returns {DataType}
*/
  data_type(): DataType;
}
/**
* Immutable struct to hold writing configuration for `writeParquet2`.
*
* Use {@linkcode WriterPropertiesBuilder} to create a configuration, then call {@linkcode
* WriterPropertiesBuilder.build} to create an instance of `WriterProperties`.
*/
export class WriterProperties {
  free(): void;
}
/**
* Builder to create a writing configuration for `writeParquet2`
*
* Call {@linkcode build} on the finished builder to create an immputable {@linkcode WriterProperties} to pass to `writeParquet2`
*/
export class WriterPropertiesBuilder {
  free(): void;
/**
* Returns default state of the builder.
*/
  constructor();
/**
* Finalizes the configuration and returns immutable writer properties struct.
* @returns {WriterProperties}
*/
  build(): WriterProperties;
/**
* Sets writer version.
* @param {number} value
* @returns {WriterPropertiesBuilder}
*/
  setWriterVersion(value: number): WriterPropertiesBuilder;
/**
* Sets encoding for any column.
*
* If dictionary is not enabled, this is treated as a primary encoding for all
* columns. In case when dictionary is enabled for any column, this value is
* considered to be a fallback encoding for that column.
*
* Panics if user tries to set dictionary encoding here, regardless of dictionary
* encoding flag being set.
* @param {number} value
* @returns {WriterPropertiesBuilder}
*/
  setEncoding(value: number): WriterPropertiesBuilder;
/**
* Sets compression codec for any column.
* @param {number} value
* @returns {WriterPropertiesBuilder}
*/
  setCompression(value: number): WriterPropertiesBuilder;
/**
* Sets flag to enable/disable statistics for any column.
* @param {boolean} value
* @returns {WriterPropertiesBuilder}
*/
  setStatisticsEnabled(value: boolean): WriterPropertiesBuilder;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly readParquet: (a: number, b: number, c: number) => void;
  readonly readMetadata: (a: number, b: number, c: number) => void;
  readonly readRowGroup: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly readMetadataAsync: (a: number, b: number, c: number, d: number) => number;
  readonly readRowGroupAsync: (a: number, b: number, c: number, d: number) => number;
  readonly writeParquet: (a: number, b: number, c: number) => void;
  readonly readParquetStream: (a: number, b: number) => number;
  readonly __wbg_writerproperties_free: (a: number) => void;
  readonly writerpropertiesbuilder_new: () => number;
  readonly writerpropertiesbuilder_build: (a: number) => number;
  readonly writerpropertiesbuilder_setWriterVersion: (a: number, b: number) => number;
  readonly writerpropertiesbuilder_setEncoding: (a: number, b: number) => number;
  readonly writerpropertiesbuilder_setCompression: (a: number, b: number) => number;
  readonly writerpropertiesbuilder_setStatisticsEnabled: (a: number, b: number) => number;
  readonly __wbg_writerpropertiesbuilder_free: (a: number) => void;
  readonly __wbg_filemetadata_free: (a: number) => void;
  readonly filemetadata_copy: (a: number) => number;
  readonly filemetadata_version: (a: number) => number;
  readonly filemetadata_numRows: (a: number) => number;
  readonly filemetadata_createdBy: (a: number, b: number) => void;
  readonly filemetadata_numRowGroups: (a: number) => number;
  readonly filemetadata_rowGroup: (a: number, b: number) => number;
  readonly filemetadata_schema: (a: number) => number;
  readonly filemetadata_keyValueMetadata: (a: number, b: number) => void;
  readonly filemetadata_arrowSchema: (a: number, b: number) => void;
  readonly __wbg_rowgroupmetadata_free: (a: number) => void;
  readonly rowgroupmetadata_numRows: (a: number) => number;
  readonly rowgroupmetadata_numColumns: (a: number) => number;
  readonly rowgroupmetadata_column: (a: number, b: number) => number;
  readonly rowgroupmetadata_totalByteSize: (a: number) => number;
  readonly rowgroupmetadata_compressedSize: (a: number) => number;
  readonly __wbg_columnchunkmetadata_free: (a: number) => void;
  readonly columnchunkmetadata_filePath: (a: number, b: number) => void;
  readonly columnchunkmetadata_fileOffset: (a: number) => number;
  readonly columnchunkmetadata_pathInSchema: (a: number, b: number) => void;
  readonly columnchunkmetadata_statistics_exist: (a: number, b: number) => void;
  readonly columnchunkmetadata_getStatisticsMinValue: (a: number, b: number) => void;
  readonly columnchunkmetadata_getStatisticsMaxValue: (a: number, b: number) => void;
  readonly columnchunkmetadata_getStatisticsNullCount: (a: number, b: number) => void;
  readonly columnchunkmetadata_numValues: (a: number) => number;
  readonly columnchunkmetadata_compressedSize: (a: number) => number;
  readonly columnchunkmetadata_uncompressedSize: (a: number) => number;
  readonly columnchunkmetadata_dataPageOffset: (a: number) => number;
  readonly columnchunkmetadata_hasIndexPage: (a: number) => number;
  readonly columnchunkmetadata_indexPageOffset: (a: number, b: number) => void;
  readonly columnchunkmetadata_dictionaryPageOffset: (a: number, b: number) => void;
  readonly columnchunkmetadata_numColumnEncodings: (a: number) => number;
  readonly columnchunkmetadata_byteRange: (a: number, b: number) => void;
  readonly __wbg_schemadescriptor_free: (a: number) => void;
  readonly schemadescriptor_name: (a: number, b: number) => void;
  readonly schemadescriptor_numColumns: (a: number) => number;
  readonly schemadescriptor_numFields: (a: number) => number;
  readonly __wbg_arrowschema_free: (a: number) => void;
  readonly arrowschema_copy: (a: number) => number;
  readonly __wbg_readablestreamgetreaderoptions_free: (a: number) => void;
  readonly readablestreamgetreaderoptions_mode: (a: number) => number;
  readonly __wbg_pipeoptions_free: (a: number) => void;
  readonly pipeoptions_preventClose: (a: number) => number;
  readonly pipeoptions_preventCancel: (a: number) => number;
  readonly pipeoptions_preventAbort: (a: number) => number;
  readonly pipeoptions_signal: (a: number) => number;
  readonly __wbg_queuingstrategy_free: (a: number) => void;
  readonly queuingstrategy_highWaterMark: (a: number) => number;
  readonly __wbg_intounderlyingsink_free: (a: number) => void;
  readonly intounderlyingsink_write: (a: number, b: number) => number;
  readonly intounderlyingsink_close: (a: number) => number;
  readonly intounderlyingsink_abort: (a: number, b: number) => number;
  readonly __wbg_intounderlyingbytesource_free: (a: number) => void;
  readonly intounderlyingbytesource_type: (a: number, b: number) => void;
  readonly intounderlyingbytesource_autoAllocateChunkSize: (a: number) => number;
  readonly intounderlyingbytesource_start: (a: number, b: number) => void;
  readonly intounderlyingbytesource_pull: (a: number, b: number) => number;
  readonly intounderlyingbytesource_cancel: (a: number) => void;
  readonly __wbg_intounderlyingsource_free: (a: number) => void;
  readonly intounderlyingsource_pull: (a: number, b: number) => number;
  readonly intounderlyingsource_cancel: (a: number) => void;
  readonly __wbg_recordbatch_free: (a: number) => void;
  readonly recordbatch_numRows: (a: number) => number;
  readonly recordbatch_numColumns: (a: number) => number;
  readonly recordbatch_schema: (a: number) => number;
  readonly recordbatch_column: (a: number, b: number) => number;
  readonly recordbatch_column_by_name: (a: number, b: number, c: number) => number;
  readonly recordbatch_toFFI: (a: number, b: number) => void;
  readonly recordbatch_intoFFI: (a: number, b: number) => void;
  readonly recordbatch_intoIPCStream: (a: number, b: number) => void;
  readonly __wbg_ffirecordbatch_free: (a: number) => void;
  readonly ffirecordbatch_arrayAddr: (a: number) => number;
  readonly ffirecordbatch_schemaAddr: (a: number) => number;
  readonly __wbg_ffivector_free: (a: number) => void;
  readonly ffivector_array_addr: (a: number) => number;
  readonly ffivector_field_addr: (a: number) => number;
  readonly __wbg_datatype_free: (a: number) => void;
  readonly __wbg_schema_free: (a: number) => void;
  readonly wasmMemory: () => number;
  readonly _functionTable: () => number;
  readonly __wbg_table_free: (a: number) => void;
  readonly table_schema: (a: number) => number;
  readonly table_recordBatch: (a: number, b: number) => number;
  readonly table_numBatches: (a: number) => number;
  readonly table_toFFI: (a: number, b: number) => void;
  readonly table_intoFFI: (a: number, b: number) => void;
  readonly table_intoIPCStream: (a: number, b: number) => void;
  readonly table_fromIPCFile: (a: number, b: number, c: number) => void;
  readonly table_fromIPCStream: (a: number, b: number, c: number) => void;
  readonly __wbg_ffitable_free: (a: number) => void;
  readonly ffitable_numBatches: (a: number) => number;
  readonly ffitable_schemaAddr: (a: number) => number;
  readonly ffitable_arrayAddr: (a: number, b: number) => number;
  readonly ffitable_drop: (a: number) => void;
  readonly __wbg_vector_free: (a: number) => void;
  readonly vector_data_type: (a: number) => number;
  readonly rust_zstd_wasm_shim_malloc: (a: number) => number;
  readonly rust_zstd_wasm_shim_calloc: (a: number, b: number) => number;
  readonly rust_zstd_wasm_shim_free: (a: number) => void;
  readonly rust_zstd_wasm_shim_memcpy: (a: number, b: number, c: number) => number;
  readonly rust_zstd_wasm_shim_memmove: (a: number, b: number, c: number) => number;
  readonly rust_zstd_wasm_shim_memset: (a: number, b: number, c: number) => number;
  readonly BrotliDecoderCreateInstance: (a: number, b: number, c: number) => number;
  readonly BrotliDecoderSetParameter: (a: number, b: number, c: number) => void;
  readonly BrotliDecoderDecompress: (a: number, b: number, c: number, d: number) => number;
  readonly BrotliDecoderDecompressStream: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly BrotliDecoderDecompressStreaming: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly BrotliDecoderDecompressWithReturnInfo: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly BrotliDecoderDecompressPrealloc: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number) => void;
  readonly BrotliDecoderMallocU8: (a: number, b: number) => number;
  readonly BrotliDecoderFreeU8: (a: number, b: number, c: number) => void;
  readonly BrotliDecoderMallocUsize: (a: number, b: number) => number;
  readonly BrotliDecoderFreeUsize: (a: number, b: number, c: number) => void;
  readonly BrotliDecoderDestroyInstance: (a: number) => void;
  readonly BrotliDecoderVersion: () => number;
  readonly CBrotliDecoderErrorString: (a: number) => number;
  readonly BrotliDecoderErrorString: (a: number) => number;
  readonly CBrotliDecoderHasMoreOutput: (a: number) => number;
  readonly BrotliDecoderHasMoreOutput: (a: number) => number;
  readonly CBrotliDecoderTakeOutput: (a: number, b: number) => number;
  readonly BrotliDecoderTakeOutput: (a: number, b: number) => number;
  readonly CBrotliDecoderIsUsed: (a: number) => number;
  readonly BrotliDecoderIsUsed: (a: number) => number;
  readonly CBrotliDecoderIsFinished: (a: number) => number;
  readonly BrotliDecoderIsFinished: (a: number) => number;
  readonly CBrotliDecoderGetErrorCode: (a: number) => number;
  readonly BrotliDecoderGetErrorCode: (a: number) => number;
  readonly CBrotliDecoderGetErrorString: (a: number) => number;
  readonly BrotliDecoderGetErrorString: (a: number) => number;
  readonly BrotliEncoderCreateInstance: (a: number, b: number, c: number) => number;
  readonly BrotliEncoderSetParameter: (a: number, b: number, c: number) => number;
  readonly BrotliEncoderDestroyInstance: (a: number) => void;
  readonly BrotliEncoderIsFinished: (a: number) => number;
  readonly BrotliEncoderHasMoreOutput: (a: number) => number;
  readonly BrotliEncoderSetCustomDictionary: (a: number, b: number, c: number) => void;
  readonly BrotliEncoderTakeOutput: (a: number, b: number) => number;
  readonly BrotliEncoderVersion: () => number;
  readonly BrotliEncoderMaxCompressedSize: (a: number) => number;
  readonly BrotliEncoderCompress: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => number;
  readonly BrotliEncoderCompressStreaming: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly BrotliEncoderCompressStream: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => number;
  readonly BrotliEncoderMallocU8: (a: number, b: number) => number;
  readonly BrotliEncoderFreeU8: (a: number, b: number, c: number) => void;
  readonly BrotliEncoderMallocUsize: (a: number, b: number) => number;
  readonly BrotliEncoderFreeUsize: (a: number, b: number, c: number) => void;
  readonly BrotliEncoderMaxCompressedSizeMulti: (a: number, b: number) => number;
  readonly BrotliEncoderCompressMulti: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number) => number;
  readonly BrotliEncoderCreateWorkPool: (a: number, b: number, c: number, d: number) => number;
  readonly BrotliEncoderDestroyWorkPool: (a: number) => void;
  readonly BrotliEncoderCompressWorkPool: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number) => number;
  readonly BroccoliCreateInstance: (a: number) => void;
  readonly BroccoliCreateInstanceWithWindowSize: (a: number, b: number) => void;
  readonly BroccoliDestroyInstance: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number, q: number, r: number, s: number, t: number, u: number, v: number, w: number, x: number, y: number, z: number, a1: number, b1: number, c1: number, d1: number, e1: number, f1: number, g1: number, h1: number, i1: number, j1: number, k1: number, l1: number, m1: number, n1: number, o1: number, p1: number, q1: number, r1: number, s1: number, t1: number, u1: number, v1: number, w1: number, x1: number, y1: number, z1: number, a2: number, b2: number, c2: number, d2: number, e2: number, f2: number, g2: number, h2: number, i2: number, j2: number, k2: number, l2: number, m2: number, n2: number, o2: number, p2: number, q2: number, r2: number, s2: number, t2: number, u2: number, v2: number, w2: number, x2: number, y2: number, z2: number, a3: number, b3: number, c3: number, d3: number, e3: number, f3: number, g3: number, h3: number, i3: number, j3: number, k3: number, l3: number, m3: number, n3: number, o3: number, p3: number, q3: number, r3: number, s3: number, t3: number, u3: number, v3: number, w3: number, x3: number, y3: number, z3: number, a4: number, b4: number, c4: number, d4: number, e4: number, f4: number, g4: number, h4: number, i4: number, j4: number, k4: number, l4: number, m4: number, n4: number, o4: number, p4: number, q4: number) => void;
  readonly BroccoliNewBrotliFile: (a: number) => void;
  readonly BroccoliConcatStream: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly BroccoliConcatStreaming: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly BroccoliConcatFinish: (a: number, b: number, c: number) => number;
  readonly BroccoliConcatFinished: (a: number, b: number, c: number) => number;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h896648893be04d51: (a: number, b: number, c: number) => void;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly wasm_bindgen__convert__closures__invoke2_mut__h02232cd008ae4dfe: (a: number, b: number, c: number, d: number) => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;
